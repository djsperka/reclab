' $Log$
' Revision 1.13  2008/05/06 18:23:50  devel
' Fix bug when playing tone stim - first stim was tone, all others were noise. Sound2 trial completion code is now "F" to distinguish from regular "E" trials. PlaySound routine no longer uses ind argument - instead uses global gTrialListIndex%
'
' Revision 1.12  2008-04-29 17:42:05  devel
' File naming cleaned up. Modified to prevent final trial of a stim set from being background. Begin (unfinished!!!) creation and writing of resultant data files.
'
' Revision 1.11  2008-04-16 18:25:16  devel
' Reading noise files now. Clean up error handling in noise file load, init.
'
' Revision 1.10  2008-04-08 18:54:28  devel
' Clean up dialog wording. Fix up naming of timeout and max time vars.
'
' Revision 1.9  2008-04-02 18:10:26  devel
' Now ready for testing. Still need to deal with file naming. Dialog params saved and restored.
'
' Revision 1.8  2008-03-26 17:17:08  devel
' Incorporate random list for noise files. Add selection of dir and mask for noise files.
'
' Revision 1.7  2008-03-18 19:49:39  devel
' Incorporate sound gen and playing. Add triggering (still must debug), configurable debug mode, etc.
'
' Revision 1.6  2008-03-13 19:19:45  devel
' Incorporate sound generation procs in gensound.s2s
'
' Revision 1.5  2008-03-11 19:28:42  devel
' Integrate trial list generator script, triallistgen.s2s
'
' Revision 1.4  2008-03-06 20:08:42  devel
' Fix bugs in state logic. Still in testing. Need sound() funcs and PrepareTrials algorithm.
'
' Revision 1.3  2008-03-05 00:15:32  devel
' Added a working idle function. Still more work needed, but we're getting close.
'
' Revision 1.2  2008-02-29 19:35:48  devel
' Add toolbar and sampling funcs. Still need FileNew() and Idle() funcs.
'
' Revision 1.1  2008-02-28 21:40:15  devel
' Initial add of this script.
'


#include "filesystemvars.s2s"
#include "tdt.s2s"
#include "recfuncs.s2s"
#include "triallistgen.s2s"
#include "gensound.s2s"

var spcDebug% := 1;

'-------- global vars --------------------------------------------------------
const gspcPI := 3.141592653589793;
const gspcTTMaxSpeakers% := 100;
const gspcMaxTrials%        := 100;         ' Maximum number of trials per speaker.
var gspcTTSpeakers%[gspcTTMaxSpeakers%];    ' speaker numbers - each is considered a trial type. Can have duplicates. 
var gspcTTSpikeCounts%[gspcTTMaxSpeakers%][gspcMaxTrials%]; ' spike counts for completed trials on each trial type
var gspcTTSpikeRate[gspcTTMaxSpeakers%][gspcMaxTrials%];    ' spike rates for completed trials on each trial type
var gspcTTSpikeRateMean[gspcTTMaxSpeakers%];' mean spike rate for each trial type
var gspcTTSpikeRateStd[gspcTTMaxSpeakers%]; ' std dev for above. 
var gspcTTAtten[gspcTTMaxSpeakers%];        ' atten to use for each speaker number in g_spcTTSpeakers%[]
var gspcTTIndexBackground%;                 ' index into TT arrays which is the background speaker/atten pair. 
var gspcTrialCount% := 0;                   ' overall trial counter - each trial gets a number!
var gspcNTrialTypes% := 0;
var gwindowData%;
var gwindowXY%;
const gtrialListMin% := 3;                             ' min size of the trial list
const gtrialListMax% := 7;
var gtrialList%[gtrialListMax%];       ' The trial list is a list of speakers to use in a series
var gtrialListFilenames$[gtrialListMax%];   ' When noise chosen, these are filenames of noise files used
var gntrialList%;
var gtrialListIndex%;

'-------- global vars RE: xy plot
var gspcUnitX[16];
var gspcUnitY[16];

'-------- global vars RE: sound -------------------------------------------------
const gDAC0Key$        := "A";
const gDAC0%         := 0;
const gspcSoundSize%    := 33333;
const gspcSampleLengthSec := 0.2;
var gspcDAC0Rate     := 166666.6666667;
var gspcSoundVolts[gspcSoundSize%];
var gspcSoundDAC%[gspcSoundSize%];          ' 16 bit ints; -32768 to 32767. Should start/stop at 0!!!
var gspcToneCopiedToPlayWaveArea% := 0;

'-------- space1g configuration dialog ---------------------------------------

var spcOutputRoot$          := "output";        ' root filename for output file
var spcNoise%               := 1;
var spcNoiseDir$            := "c:/reclab/space1g";
var spcNoiseMask$           := "noise*.bin";
var spcTone%                := 0;
var spcFreq%                := 20000;
var spcTrialTypesFileSelection% := 0;
var spcTrialTypesFile$      := "";
var spcTrialTypesFileList$[100];
var spcNTrialsPerStim%      := 0;
var spcBlockSize%           := 2;
var spcMinDelay             := 0.5;
var spcVarDelay             := 0.5;
var spcMaxLvrDownTime       := 10.0;
var spcLvrDownTimeout       := 2.0;
var spcFalsePositiveTimeout := 2.0;
var spcInterStimInterval    := 1.0;
var spcMaxLvrUpTime         := 2.0;
var spcLvrUpTimeout         := 2.0;
var spcFreeRewardCheck%     := 0;
var spcFreeRewardSize%      := 50;
var spcLongRewardCheck%     := 0;
var spcLongRewardSize%      := 100;


const spcdlgRoot%       := 1;
const spcdlgNoise%      := 2;
const spcdlgNoiseDir%   := 3;
const spcdlgNoiseMask%  := 4;
const spcdlgTone%       := 5;
const spcdlgFreq%       := 6;
const spcdlgTTSelection%:= 7;
const spcdlgNTrials%    := 8;
const spcdlgBlockSize%  := 9;
const spcdlgMinDelay%   := 10;
const spcdlgVarDelay%   := 11;
'const spcdlgMaxLvrDownTime%     := 12;
'const spcdlgLvrDownTimeout%     := 13;
const spcdlgInterStimInterval%  := 12;
const spcdlgMaxLvrUpTime%       := 13;
const spcdlgLvrUpTimeout%       := 14;
const spcdlgFalsePositiveTimeout% := 15;
const spcdlgFreeRewardCheck% := 16;
const spcdlgFreeRewardSize% := 17;
const spcdlgLongRewardCheck% := 18;
const spcdlgLongRewardSize% := 19;
const spcdlgDebug% := 20;


proc Space1gScriptDialogSaveParams()
	var stmp$;
	var key$;

	key$:="Reclab\\Space1g";
	Profile(key$, "OutputRoot", spcOutputRoot$);
	Profile(key$, "NoiseCheck", spcNoise%);
	Profile(key$, "NoiseDir", spcNoiseDir$);
	Profile(key$, "NoiseMask", spcNoiseMask$);
	Profile(key$, "ToneCheck", spcTone%);
	Profile(key$, "ToneFreq", spcFreq%);
    Profile(key$, "TrialTypesFileSelection", spcTrialTypesFileSelection%);
	Profile(key$, "NTrialsPerStim", spcNTrialsPerStim%);
	Profile(key$, "StimBlockSize", spcBlockSize%);
    Profile(key$, "MinDelay", str$(spcMinDelay));
    Profile(key$, "VarDelay", str$(spcVarDelay));
    Profile(key$, "MaxLvrDownTime", str$(spcMaxLvrDownTime));
    Profile(key$, "LvrDownTimeout", str$(spcLvrDownTimeout));
    Profile(key$, "InterStimInterval", str$(spcInterStimInterval));
    Profile(key$, "MaxLvrUpTime", str$(spcMaxLvrUpTime));
    Profile(key$, "LvrUpTimeout", str$(spcLvrUpTimeout));
    Profile(key$, "FalsePositiveTimeout", str$(spcFalsePositiveTimeout));
	Profile(key$, "FreeRewardCheck", spcFreeRewardCheck%);
	Profile(key$, "FreeRewardSize", spcFreeRewardSize%);
	Profile(key$, "LongRewardCheck", spcLongRewardCheck%);
	Profile(key$, "LongRewardSize", spcLongRewardSize%);
	Profile(key$, "DebugCheck", spcDebug%);

	return;
end

proc Space1gScriptDialogGetParams()
	var stmp$;
	var key$;

    key$:="Reclab\\Space1g";
	Profile(key$, "OutputRoot", spcOutputRoot$, spcOutputRoot$);
	Profile(key$, "NoiseCheck", spcNoise%, spcNoise%);
	Profile(key$, "NoiseDir", spcNoiseDir$, spcNoiseDir$);
	Profile(key$, "NoiseMask", spcNoiseMask$, spcNoiseMask$);
	Profile(key$, "ToneCheck", spcTone%, spcTone%);
	Profile(key$, "ToneFreq", spcFreq%, spcFreq%);
    Profile(key$, "TrialTypesFileSelection", spcTrialTypesFileSelection%, spcTrialTypesFileSelection%);
	Profile(key$, "NTrialsPerStim", spcNTrialsPerStim%, spcNTrialsPerStim%);
	Profile(key$, "StimBlockSize", spcBlockSize%, spcBlockSize%);
    Profile(key$, "MinDelay", str$(spcMinDelay), stmp$);
    spcMinDelay := val(stmp$);
    Profile(key$, "VarDelay", str$(spcVarDelay), stmp$);
    spcVarDelay := val(stmp$);
    Profile(key$, "MaxLvrDownTime", str$(spcMaxLvrDownTime), stmp$);
    spcMaxLvrDownTime := val(stmp$);
    Profile(key$, "LvrDownTimeout", str$(spcLvrDownTimeout), stmp$);
    spcLvrDownTimeout := val(stmp$);
    Profile(key$, "InterStimInterval", str$(spcInterStimInterval), stmp$);
    spcInterStimInterval := val(stmp$);
    Profile(key$, "MaxLvrUpTime", str$(spcMaxLvrUpTime), stmp$);
    spcMaxLvrUpTime := val(stmp$);
    Profile(key$, "LvrUpTimeout", str$(spcLvrUpTimeout), stmp$);
    spcLvrUpTimeout := val(stmp$);
    Profile(key$, "FalsePositiveTimeout", str$(spcFalsePositiveTimeout), stmp$);
    spcFalsePositiveTimeout := val(stmp$);
	Profile(key$, "FreeRewardCheck", spcFreeRewardCheck%, spcFreeRewardCheck%);
	Profile(key$, "FreeRewardSize", spcFreeRewardSize%, spcFreeRewardSize%);
	Profile(key$, "LongRewardCheck", spcLongRewardCheck%, spcLongRewardCheck%);
	Profile(key$, "LongRewardSize", spcLongRewardSize%, spcLongRewardSize%);
	Profile(key$, "DebugCheck", spcDebug%, spcDebug%);
	return;
end



func Space1gDlgChanged%(item%)
    var status% := 1;
    var value%;


    docase 
    case item% = spcdlgNoise% then
    
        ' Get value, toggle it, and set the toggled value in Tone checkbox. 
    
        value% := DlgValue(spcdlgNoise%);
        DlgValue(spcdlgTone%, 1-value%);
        
    case item% = spcdlgTone% then

        ' Get value, toggle it, and set the toggled value in Noise checkbox. 
    
        value% := DlgValue(spcdlgTone%);
        DlgValue(spcdlgNoise%, 1-value%);
    
    endcase

    ' enable or disable frequency box as needed
    DlgEnable(DlgValue(spcdlgTone%), spcdlgFreq%);
    DlgEnable(DlgValue(spcdlgNoise%), spcdlgNoiseDir%);
    DlgEnable(DlgValue(spcdlgNoise%), spcdlgNoiseMask%);
    DlgEnable(DlgValue(spcdlgFreeRewardCheck%), spcdlgFreeRewardSize%);
    DlgEnable(DlgValue(spcdlgLongRewardCheck%), spcdlgLongRewardSize%);
        
    
    return status%
end



func Space1gScriptDialog%()
    var i%;
    var status% := 0;
    var sFileCount% := 0;
    var sFileMask$ := "spc*.txt";
    var pathTemp$;
    
    ' Fetch parameters from registry
    
    Space1gScriptDialogGetParams();

    ' Get file list for trial types. If no files are found in stim$ matching the mask, 
    ' show a message and quit. 
    FilePathSet(stim$);
    sFileCount% := FileList(spcTrialTypesFileList$, -1, sFileMask$);
    if sFileCount% = 0 then
        Message("There are no files in dir %s matching the mask %s", stim$, sFileMask$);
        return 0;   ' will look as if user hit Cancel
    endif
    
    ' Generate the dialog
    
	DlgCreate("Space1g Parameters", 25, 10);
    DlgString(spcdlgRoot%, "Output file root|Base name of output file, e.g. a022098a", 32, "a-zA-Z0-9_-");
    DlgCheck(spcdlgNoise%, "Noise");
    DlgString(spcdlgNoiseDir%, "Noise file dir:", 255, "a-zA-Z0-9_-:/\\.");
    DlgString(spcdlgNoiseMask%, "Noise file mask:", 255, "a-zA-Z0-9_-*?.");
    DlgCheck(spcdlgTone%, "Tone");
    DlgInteger(spcdlgFreq%, "Frequency(Hz)", 1, 100000);
    DlgList(spcdlgTTSelection%, "Stim set:", spcTrialTypesFileList$, sFileCount%);
    DlgInteger(spcdlgNTrials%, "# trials per stim", 1, 20, 0, 0, 1);
    DlgInteger(spcdlgBlockSize%, "block size", 1, 5, 0, 0, 1);
    DlgReal(spcdlgMinDelay%, "Min delay(s)", 0.0, 5.0);
    DlgReal(spcdlgVarDelay%, "Var delay(s)", 0.0, 5.0);
'    DlgReal(spcdlgMaxLvrDownTime%, "Max lvr down time(s)", 0.0, 120.0);
'    DlgReal(spcdlgLvrDownTimeout%, "Lvr down timeout(s)", 0.0, 120.0);
    DlgReal(spcdlgInterStimInterval%, "ISI(s)", 0.0, 5.0);
    DlgReal(spcdlgMaxLvrUpTime%, "Max lvr up time(s)", 0.0, 120.0);
    DlgReal(spcdlgLvrUpTimeout%, "Lvr up timeout(s)", 0.0, 120.0);
    DlgReal(spcdlgFalsePositiveTimeout%, "False positive timeout(s)", 0.0, 5.0);
    DlgCheck(spcdlgFreeRewardCheck%, "Training reward?");
    DlgInteger(spcdlgFreeRewardSize%, "Training reward size", 5, 500, 0, 0, 10);
    DlgCheck(spcdlgLongRewardCheck%, "Long reward?");
    DlgInteger(spcdlgLongRewardSize%, "Long reward size", 5, 500, 0, 0, 10);
    DlgCheck(spcdlgDebug%, "Debug?");

    DlgButton(1, "OK", Space1gCheckOK%);
    DlgButton(0, "Cancel");
    DlgAllow(0, 0, Space1gDlgChanged%);

    ' Show the dialog. 

	i%:=DlgShow(spcOutputRoot$, spcNoise%, spcNoiseDir$, spcNoiseMask$, spcTone%, 
                spcFreq%, spcTrialTypesFileSelection%, spcNTrialsPerStim%, spcBlocksize%, 
                spcMinDelay, spcVarDelay, 
'                spcMaxLvrDownTime, spcLvrDownTimeout, 
                spcInterStimInterval, 
                spcMaxLvrUpTime, spcLvrUpTimeout, spcFalsePositiveTimeout, 
                spcFreeRewardCheck%, spcFreeRewardSize%, spcLongRewardCheck%, spcLongRewardSize%, 
                spcDebug%);

    ' If user hit OK then save parameters (and return 1). 

	if i% = 1 then
        Space1gScriptDialogSaveParams();
        status% := 1;
    else
        status% := 0;
    endif
    
    ' If debug was set, then turn on debugging for supporting scripts
    if spcDebug% = 1 then
        gensoundSetDebug(spcDebug%);
    endif

	return status%;
end;



func Space1gCheckOK%()
    var status% := 0;
    var o$;
    var dummy$;
    var i1%;
    var i2%;

    ' Verify that output root is not null
    o$ := DlgValue$(spcdlgRoot%);
    if len(o$) = 0 then
        Message("Please enter an output root.");
        status% := 1;
    endif

    ' See if output file(s) already exist. 
    
    FilePathSet(data$);
    if FileList(dummy$, -1, o$ + ".*")>0 then
        Message("Data files with this name (" + o$ + ") already exist.\nTry another name.");
        status% := 1;
    endif

    ' Check that spcNTrialsPerStim% is a multiple of spcBlockSize%
    i1% := DlgValue(spcdlgNTrials%);
    i2% := DlgValue(spcdlgBlockSize%);
    if i1% mod i2% <> 0 then
        Message("NTrialsPerStim must be a multiple of block size!");
        status% := 1;
    endif

    ' Now open and load trial types file.
    
    i1% := DlgValue(spcdlgTTSelection%);
    spcTrialTypesFile$ := spcTrialTypesFileList$[i1%];
    FilePathSet(stim$);    
    if LoadTrialTypes%(spcTrialTypesFile$) <= 0 then
        Message("Cannot load trial types file " + spcTrialTypesFile$);
        status% := 1;
    endif
    PrintLog("Loaded %d trial types from %s\n", gspcNTrialTypes%, spcTrialTypesFile$);


    ' If noise is selected, init the random noise selection and ensure there are enough files
    if DlgValue(spcdlgNoise%) = 1 then
        var ntemp%;
        spcNoiseDir$ := DlgValue$(spcdlgNoiseDir%);
        spcNoiseMask$ := DlgValue$(spcdlgNoiseMask%);
        gensoundSetDebug(1);
        ntemp% := gensoundInitRandomList%(spcNoiseDir$, spcNoiseMask$);
        if ntemp% = 0 then
            Message("No noise files found in dir " + spcNoiseDir$ + " using mask " + spcNoiseMask$);
            status% := 1;
        else
            if ntemp% < (spcNTrialsPerStim%*gspcNTrialTypes%) then
                if Query("Found just " + str$(ntemp%) + " noise files in dir " + spcNoiseDir$ + " using mask " + 
                        spcNoiseMask$ + ". With " + str$(spcNTrialsPerStim%) + " trials per stim, and with " + 
                        str$(gspcNTrialTypes%) + " trial types loaded from " + spcTrialTypesFile$ + " there will be repeats. Continue?") = 0 then
                    status% := 1;
                endif
            endif
        endif
    endif
    
    return status%;
end


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' LoadTrialTypes%() - open and read trial types file. 
' Expecting format with two numbers per line:
' spk atten
' where spk is speaker number and atten is attenuation
' The last entry is treated as background in the online analysis!!! It doesn't matter what speaker it is. 
' Lines that start with "#" are ignored. Blank lines are ignored too. 
' Will load array g_spcTTSpeakers%[g_spcTTMaxSpeakers%] and g_spcTTAtten[g_spcTTMaxSpeakers%], 
' and will set spcNTrialTypes% to be the number of speaker/atten pairs read. 

func LoadTrialTypes%(sTTFile$)
    var handle;
    var line$;
    var count% := 0;
    
    ' open file
    handle := FileOpen(sTTFile$, 8, 0);
    if handle = 0 then
        PrintLog("Cannot open trial types file " + sTTFile$ + "\n");
        return -1;
    endif
    
    ' Now read a line at a time, discard any that begin with #
    while Read(line$)>=0 do
        ' is it a comment?
        if InStr(line$, "#") <> 1 then
            if (ReadStr(line$, gspcTTSpeakers%[count%], gspcTTAtten[count%]) = 2) then
                count% := count% + 1;
            endif
        endif
    wend
    gspcNTrialTypes% := count%;
    gspcTTIndexBackground% := count%-1;
    
    FileClose();
  
    return count%;
end


''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' PrepareTrials%()
'
' Prepares a list of trials to run and copies data to DAC PlayWave areas if needed. 
' The list may be from 3-7 trials long. When user has chosen TONE, there's just
' one sound. When NOISE is selected, we allocate gtrialListMax% areas. 
' TODO: There is a limit to how much memory can be allocated to the PlayWave areas. 
' Should check this and return an error!?!
' Returns 0 when all trials are done. Otherwise return nonzero value.

func PrepareTrials%()

    var i%;
    var nread%:= 0;
    var file$;
    var swapIndex% := -1;

    ' Get the trial list, then check if we're done. If so, return now, don't do the 
    ' rest of the stuff here since there's nothing to do. 
    gntrialList% := tlgGetTrialList%(gtrialList%[]);
    if gntrialList% = 0 then
        return gntrialList%;
    endif
    
    ' Check that the last trial in the list is NOT the background trial index. If it is, then 
    ' swap it with one of the other non-background trial indices.

    if gtrialList%[gntrialList%-1] = gspcNTrialTypes%-1 then
    
        PrintLog("Last trial in list is background. Fixing...\n");
        
        ' GREGG: should this start at 0 or 1? Is it OK for the first trial to be background? 
        while i%<gntrialList%-2 and swapIndex% < 0 do
            if gtrialList%[i%] <> gtrialList%[gntrialList%-1] then
                swapIndex% := i%;
            endif
            i% := i%+1;
        wend
        
        ' Should never happen, but if that loop failed I'm just gonna quit. 
        ' The only way that could happen would be if the trial list generator sent back a 
        ' list consisting of nothing but the background index. As long as we request 
        ' lists with a min length > 1 that shouldn't happen, since the trial list 
        ' generator doesn't allow repeated indices. 
        if swapIndex% < 0 then
            Message("Trial list error!");
            halt;
        endif

        ' Now swap the indices and move on. 
        i% := gtrialList%[gntrialList%-1];
        gtrialList%[gntrialList%-1] := gtrialList%[swapIndex%];
        gtrialList%[swapIndex%] := i%;
        

        PrintLog("Swapped trials to fix. Trial indices: ");
        for i% := 0 to gntrialList%-1 do
            PrintLog("%d", gtrialList%[i%]);
            if i% < gntrialList%-1 then
                PrintLog(",");
            endif
        next
        PrintLog("\n");
    endif

    if spcDebug% = 1 then
        PrintLog("TrialList ");
        for i% := 0 to gntrialList%-1 do
            PrintLog(str$(gtrialList%[i%]) + " ");
        next
        PrintLog("\n");
    endif

    docase
    case spcTone% = 1 then

        ' Only need to copy tone once
        if gspcToneCopiedToPlayWaveArea% = 0 then
        
            gensoundTone(gspcSoundDAC%[], gspcSoundSize%, spcFreq%, gspcDAC0Rate);
            PlayWaveCopy(GetPlayWaveKey$(0), gspcSoundDAC%[]);
            gspcToneCopiedToPlayWaveArea% := 1;

        endif
        
    case spcNoise% = 1 then
    
        ' Load noise for each of the trials
        for i% := 0 to gntrialList%-1 do
            ArrConst(gspcSoundDAC%[], 0);
            nread% := gensoundRandomFromList%(gspcSoundDAC%[], gspcSoundSize%, gtrialListFilenames$[i%]);
            if spcDebug% = 1 then
                PrintLog("gensoundRandomFromList returned file$ := " + gtrialListFilenames$[i%] + "\n");
            endif
            if (nread% <= 0) then
                Message("Error loading random sounds. Check log.");
                halt;
            endif
            if (nread% < gspcSoundSize%) then
                PrintLog("WARNING: Sound file " + gtrialListFilenames$[i%] + " has " + str$(nread%) + " samples. Expecting " + str$(gspcSoundSize%) + "\n");
            endif    
            PlayWaveCopy(GetPlayWaveKey$(i%), gspcSoundDAC%[]);

        next        
    endcase


    return gntrialList%;

end


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' InitializePlayWaveAreas - add play wave areas for sounds. 
' If TONE was chosen (spcTone% = 1) then we need just one area = "A".
' If NOISE was chosen (spcNoise% = 1) then we need to allocate gtriallistMax%
' areas "A", "B", ....

Proc InitializePlayWaveAreas()
    var st;
    var i%;
    if spcTone% = 1 then
    
        st := PlayWaveAdd(GetPlayWaveKey$(0), GetPlayWaveKey$(0), gDAC0%, gspcDAC0Rate, gspcSoundSize%);
        if st < 0 then
            Message("Error in PlayWaveAdd for area " + GetPlayWaveKey$(0));
            halt;
        else
            PlayWaveTrigger(GetPlayWaveKey$(0), 1);
        endif

    else
    
        for i% := 0 to gtrialListMax% do
        
            st := PlayWaveAdd(GetPlayWaveKey$(i%), GetPlayWaveKey$(i%), gDAC0%, gspcDAC0Rate, gspcSoundSize%);
            if st < 0 then
                Message("Error in PlayWaveAdd for area " + GetPlayWaveKey$(i%));
                halt;
            else
                PlayWaveTrigger(GetPlayWaveKey$(i%), 1);
            endif        
        
        next

    endif

end


func GetPlayWaveKey$(index%)

    return Chr$(Asc(gDAC0Key$)+index%);
    
end


' PlaySound plays the sound for the trial number in gTrialListIndex.
' If this is the repeated-last-index (if gtrialListIndex% = gntrialList%)
' then play gntrialList%-1 sound - that makes the repeat happen.

Proc PlaySound()
    var spk%[1];
    var atten;
    var s$;
    var playInd%;

    ' Determine what sound index to play. 
    playInd% := gtrialListIndex%;
    if gtrialListIndex% = gntrialList% then
        playInd% := gntrialList%-1;
    endif

    ' Increment trial counter
    gspcTrialCount% := gspcTrialCount% + 1;

    ' Set speaker and atten
    recSpeaker%(gspcTTSpeakers%[gtrialList%[playInd%]]);

    atten := gspcTTAtten[gtrialList%[playInd%]] + 0.5*Floor(Rand(3, 0));
    recAtten%(atten);
    spk%[0] := gtrialList%[playInd%];


    ' Send sample key for the play wave area. The play wave areas are triggered, so this 
    ' command alone will NOT play the sound - the SampleKey("T") triggers it. 

    if spcTone% then
        SampleKey(GetPlayWaveKey$(0));
        ' saved string format speaker%,atten,frequency%
        s$ := Print$("S,%d,%d,%d,%.1f,%d", gspcTrialCount%, gtrialList%[playInd%], gspcTTSpeakers%[gtrialList%[playInd%]], atten, spcFreq%);
        SampleText(s$, -1);
    else
        SampleKey(GetPlayWaveKey$(playInd%));
        ' saved string format speaker%,atten,soundfilename
        s$ := Print$("S,%d,%d,%d,%.1f,%s", gspcTrialCount%, gtrialList%[playInd%], gspcTTSpeakers%[gtrialList%[playInd%]], atten, gtrialListFilenames$[playInd%]);
        SampleText(s$, -1);
    endif
    SampleKey("T");
    
end


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' CreateSampleConfiguration - prepare toolbar buttons. Note that the idle processing function 
' (ToolbarSet(0, blah, blah)) is not set here. That's done when the user hits the start 
' button.
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

var DAC0Channel% := 1;          ' DAC0 output should be tee'd and input to ADC port 6
var Trode1Channel% := 11;       ' First electrode. Don't use channel numbers above this
                                ' for anything other than electrodes!
var TrigChannel% := 2;
var xychanMean%;
var xychanMeanPlus%;
var xychanMeanMinus%;
var xychanBkgd%;
var xychanBkgdPlus%;
var xychanBkgdMinus%;
var xychanLines%;

proc CreateSampleConfiguration()

	var index;
    var r;

    ' Initialize sampling settings
    
'	SampleClear();
	SampleAutoComment(0);
	SampleAutoCommit(30);
    SampleAutoFile(0);
    SampleAutoName$("space000");

    ' Event channel 0 is for sound triggers
    SampleEvent(TrigChannel%, 0, 2, 10);
    SampleTitle$(TrigChannel%, "Trigger");


    ' Text marks
    SampleTextMark(64);

    ' DAC0 (sound output) -> record this channel? It will inflate the file sizes......

    if spcDebug% = 1 then
        SampleWaveform(DAC0Channel%, 6, 50000);
        SampleTitle$(DAC0Channel%, "DAC0");
    endif
    

	' Electrode
    
	SampleWaveMark(Trode1Channel%, 0, 100, 34, 15, 28000); ' chan, port, event rate, points, pre-trigger, rate
	SampleTitle$(Trode1Channel%, "Trode 1"); 

    ' Set optimise mode (do this last). Settings specific to Power1401 625 (that's the "5"). 
    ' The second arg groups channels with same ideal rates together so they all get same 
    ' actual rate. That means multiple electrodes (if used) will all get same actual rate, 
    ' assuming you use same ideal rate (in SampleWavemark()). 
    
    SampleSequencer(script$ + "space1g.pls");
	SampleOptimise(2, 1, 5, 2, 50);  
    SampleMode(1);
end




proc InitializeWindows()
    var i%;
    var ang;

    ' Since we are opening files here, set the path. 
    FilePathSet(data$, 1, 1);

    ' Open text files for output. In the old "space1g", these were the "ecode_file" and the 
    ' "bak_file". 
'    gEcodeFile% := FileOpen()zzzzzzzzzzzzzzzzzzzzzzzzzzz

    ' Open xy window for radar plot. Initialize arrays for that plot as well. 
    gwindowXY% := FileNew(12);
	Window(0, 50, 50, 100); 
	View(gwindowXY%).WindowVisible(1);
    xychanMean% := XYSetChan(0, -16, 0, 2, 8);
    xychanMeanPlus% := XYSetChan(0, -16, 0, 2, 7);
    xychanMeanMinus% := XYSetChan(0, -16, 0, 2, 7);
    xychanBkgd% := XYSetChan(0, -16, 0, 2, 0);
    xychanBkgdPlus% := XYSetChan(0, -16, 0, 2, 5);
    xychanBkgdMinus% := XYSetChan(0, -16, 0, 2, 5);
    xychanLines% := XYSetChan(0, -32, 0, 2, 20);

    for i%:=0 to 15 do
        ang := -gspcPI/8*(5+i%);
        gspcUnitX[i%] := cos(ang);
        gspcUnitY[i%] := sin(ang);
    next
    
	'Open the data sampling window
	gwindowData% := FileNew(0,4);
	Window(0, 0, 100, 50); 
	View(gwindowData%).WindowVisible(1);

end;


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' InitilizeToolbar - prepare toolbar buttons. Note that the idle processing function 
' (ToolbarSet(0, blah, blah)) is not set here. That's done when the user hits the start 
' button.
'

const tbStart%  := 1;
const tbStop%   := 2;
const tbPause%  := 3;
const tbResume% := 4;
const tbReward% := 5;

proc InitializeToolbar()

	View(App(8)).WindowVisible(0);	'Hide the standard sample bar
	ToolbarVisible(1);
	ToolbarSet(tbStart%, "Start", Start%);
	ToolbarSet(tbStop%, "Stop", Stop%);
	ToolbarSet(tbPause%, "Pause", Pause%);
	ToolbarSet(tbResume%, "Resume", Resume%);
	ToolbarSet(tbReward%, "Reward", Reward%);

    ' Explicitly set enabled state of things...
    ToolbarEnable(tbStart%, 1);
    ToolbarEnable(tbStop%, 0);
    ToolbarEnable(tbPause%, 0);
    ToolbarEnable(tbResume%, 0);
    ToolbarEnable(tbReward%, 1);

end;


var fPaused%    := 0;
var fStarted%   := 0;

func Start%()
    fStarted% := 1;

    ' Disable start button, enable stop and pause
    
    ToolbarEnable(tbStart%, 0);
    ToolbarEnable(tbStop%, 1);
    ToolbarEnable(tbPause%, 1);
    
    ' Oh yeah, start the sampling. 
    
    SampleStart();

    ' Set idle function
    ToolbarSet(0, "", IdleLoop%);
    
    ' Tell the world about it. 
    
    ToolbarText("Sampling started.");
    return 1;
end

func Stop%()
    PrintLog("Stop called\n");
    
    ' Stop sampling....

    if SampleStatus() <> -1 then
        SampleStop();
        FilePathSet(data$);
        FileSaveAs(spcOutputRoot$ + ".smr", -1);
    endif
    
    ' Returning zero from here any ToolbarSet() functions causes the 
    ' Toolbar() function to return.
    return 0;
end

func Pause%()
    PrintLog("Pause called\n");
    fPaused% := 1;
    ToolbarEnable(tbResume%, 1);
    ToolbarEnable(tbPause%, 0);
    return 1;
end

func Resume%()
    fPaused% := 0;
    ToolbarEnable(tbResume%, 0);
    ToolbarEnable(tbPause%, 1);
    return 1;
end

func Reward%()
    ' TODO: Add reward func here!
    return 1;
end


' UpdateOnlineAnalysis(tUpTo)
' Look for trials completed in the period tOnlineLast - tUpTo

var tOnlineLast := -1;

proc UpdateOnlineAnalysis(tUpTo)
    var begSpk% := -1;
    var begBak% := -1;
    var begInd% := -1;
    var begTime := -1;
    var begTrial% := 0;
    var endSpk% := -1;
    var endBak% := -1;
    var endTime := -1;
    var endTrial% := 0;
    var haveBeg% := 0;  ' state desc. 0(1) = looking for beginning (end) of trial. 
    var markers%[4];    ' not used, actually. 
    var markerStr$;     ' text in the text marker
    var s$;
    var trcount%;
    var spk%;
    var ind%;
    var att;
    var t;
    var tindex%;
    var i%;
    var arrx[16];
    var arry[16];
    var arrxl[32];
    var arryl[32];
    var maxrate := -99999;
    
    ' Look for text marks in the observation period
    t := NextTime(30, tOnlineLast, markers%[], markerStr$);
    while (t >= 0) do
        ' determine if this is a beginning or end marker
        if (InStr(markerStr$, "S")=1) then
            if ReadStr(Mid$(markerStr$, 3), trcount%, ind%, spk%) = 3 then 
                'PrintLog("Found start of trial " + str$(trcount%) + " ind, spk=" + str$(ind%) + "," + str$(spk%) + "\n");
                begTrial% := trcount%;
                begInd% := ind%;
                begSpk% := spk%;
                begTime := t;
            else 
                PrintLog("Error reading marker string at t=" + str$(t) + ": " + markerStr$ + "\n");
            endif
        endif

        if (InStr(markerStr$, "E")=1) then
            if ReadStr(Mid$(markerStr$, 3), trcount%) = 1 then 
                'PrintLog("Found end of trial " + str$(trcount%) + "\n");
                if trcount% = begTrial% then
                    endTime := t;
                    
                    ' Count up wavemarks
                    tindex% := tlgTrialIndexHowManyCompleted%(begInd%)-1;
                    gspcTTSpikeCounts%[begInd%][tindex%] := View(gwindowData%).Count(Trode1Channel%, begTime, endTime);   
                    gspcTTSpikeRate[begInd%][tindex%] := gspcTTSpikeCounts%[begInd%][tindex%]/gspcSampleLengthSec;
                    if (tindex% >= 1) then
                        ArrSum(gspcTTSpikeRate[begInd%][0:tindex%], gspcTTSpikeRateMean[begInd%], gspcTTSpikeRateStd[begInd%]);
                        'PrintLog("ind, spk=" + str$(begInd%) + "," + str$(begSpk%) + " rate+-std " + 
                        '        str$(gspcTTSpikeRate[begInd%]) + "+-" + str$(gspcTTSpikeRateStd[begInd%]) + "\n");
                    endif
                endif
            else 
                PrintLog("Error reading marker string at t=" + str$(t) + ": " + markerStr$ + "\n");
            endif
        endif
        
        if (InStr(markerStr$, "F")=1) then
            ' F marker indicates end of the repeat/last trial of a trialList. We don't include
            ' these spikes in the averages == space1g didn't, either. 
        endif
        
        tOnlineLast := t;
        t := NextTime(30, tOnlineLast, markers%[], markerStr$);
    wend
    
    ' Update plots. WARNING: Assuming that there are 16 speakers, and there is just one background trial type -- 
    ' and that the background is the last one. 
    
    ' rate. Get max rate while we're at it. 
    ArrConst(arrx, 0);
    ArrConst(arry, 0);
    for i% := 0 to 15 do
        arrx[i%] := gspcTTSpikeRateMean[i%] * gspcUnitX[i%];
        arry[i%] := gspcTTSpikeRateMean[i%] * gspcUnitY[i%];
        if abs(gspcTTSpikeRateMean[i%]) > maxrate then
            maxrate := abs(gspcTTSpikeRateMean[i%]);
        endif
    next
    View(gwindowXY%).XYAddData(xychanMean%, arrx, arry);
    
    ' rate+std
    ArrConst(arrx, 0);
    ArrConst(arry, 0);
    for i% := 0 to 15 do
        arrx[i%] := (gspcTTSpikeRateMean[i%] + gspcTTSpikeRateStd[i%]) * gspcUnitX[i%];
        arry[i%] := (gspcTTSpikeRateMean[i%] + gspcTTSpikeRateStd[i%]) * gspcUnitY[i%];
    next
    View(gwindowXY%).XYAddData(xychanMeanPlus%, arrx, arry);

    ' rate-std
    ArrConst(arrx, 0);
    ArrConst(arry, 0);
    for i% := 0 to 15 do
        arrx[i%] := (gspcTTSpikeRateMean[i%] - gspcTTSpikeRateStd[i%]) * gspcUnitX[i%];
        arry[i%] := (gspcTTSpikeRateMean[i%] - gspcTTSpikeRateStd[i%]) * gspcUnitY[i%];
    next
    View(gwindowXY%).XYAddData(xychanMeanMinus%, arrx, arry);

    ' bkgd
    ArrConst(arrx, 0);
    ArrConst(arry, 0);
    for i% := 0 to 15 do
        arrx[i%] := gspcTTSpikeRateMean[16] * gspcUnitX[i%];
        arry[i%] := gspcTTSpikeRateMean[16] * gspcUnitY[i%];
    next
    View(gwindowXY%).XYAddData(xychanBkgd%, arrx, arry);

    ' bkgd+std
    ArrConst(arrx, 0);
    ArrConst(arry, 0);
    for i% := 0 to 15 do
        arrx[i%] := (gspcTTSpikeRateMean[16] + gspcTTSpikeRateStd[16]) * gspcUnitX[i%];
        arry[i%] := (gspcTTSpikeRateMean[16] + gspcTTSpikeRateStd[16]) * gspcUnitY[i%];
    next
    View(gwindowXY%).XYAddData(xychanBkgdPlus%, arrx, arry);

    ' bkgd-std
    ArrConst(arrx, 0);
    ArrConst(arry, 0);
    for i% := 0 to 15 do
        arrx[i%] := (gspcTTSpikeRateMean[16] - gspcTTSpikeRateStd[16]) * gspcUnitX[i%];
        arry[i%] := (gspcTTSpikeRateMean[16] - gspcTTSpikeRateStd[16]) * gspcUnitY[i%];
    next
    View(gwindowXY%).XYAddData(xychanBkgdMinus%, arrx, arry);

    ' lines
    ArrConst(arrxl, 0);
    ArrConst(arryl, 0);
    for i% := 0 to 15 do
        arrxl[i%*2+1] := maxrate * 1.25 * gspcUnitX[i%];
        arryl[i%*2+1] := maxrate * 1.25 * gspcUnitY[i%];
    next
    View(gwindowXY%).XYAddData(xychanLines%, arrxl, arryl);
    
end


' States
const stateStart%               := 0;
const statePrepareTrials%       := 1;
const stateWaitLvrDown%         := 2;
const stateLvrDownTimeout%      := 3;
const stateDelayInterval%       := 4;
const statePlaySound%           := 5;
const stateWaitSoundDone%       := 6;
const stateWaitISI%             := 7;
const statePlaySound2%          := 8;
const stateFreeReward%          := 9;
const stateWaitLvrUp%           := 10;
const stateLvrUpReward%         := 11;
const stateFalsePositive%       := 12;
const stateLvrUpTimeout%        := 13;
const statePlaySoundWait%       := 14;
const statePlaySound2Wait%      := 15;
const stateDone%                := 20;

var tNow:=0;		' latest time for which there are values recorded. Used in IdleLoop%
var tLast:=-1;		' last time we checked for a trigger. 
var iState%:=stateStart%;		' present state
var tStateStart:=-1;	' time that present state started. Used to measure wait time, fixation time, etc. 
var delayIntervalTime;  ' time to delay before a set of trials are started 

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' 
' ChangeStateTo
' 
' Call this function on exit from a state. The var stateTo% should be the state to enter
' on the next call to the loop function. 
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

proc LogStatus(stateName$, msg$)
    if spcDebug% = 1 then
        PrintLog("S:    " + stateName$ + "  Tstart: " + str$(tStateStart) + " " + msg$ + "\n");
    endif
end


proc ChangeStateTo(stateTo%)
	iState% := stateTo%;
    tStateStart := MaxTime();
end;

func IdleLoop%()
    var status% := 1;
	var iStatus% := 1;	' this is return value. value of 1 (0) continues (stops) processing
    var stmp%;
    var strtmp$;
	tNow := MaxTime();

	' What state are we in? 
	docase 

	
		case iState% = stateStart% then

            LogStatus("Start", "Preparing trials");
            ChangeStateTo(statePrepareTrials%);
            
        case iState% = statePrepareTrials% then
        
            ' prepare values for the next trial.
            ' this is the point where the expt can be paused. Operator can hit the pause
            ' button anytime, but the actual pause will not happen until here. 
            gtrialListIndex% := 0;
            if fPaused% = 0 then

                if PrepareTrials%() = 0 then
                    LogStatus("PrepareTrials", "All done!");
                    ChangeStateTo(stateDone%);
                else
                    LogStatus("PrepareTrials", str$(gntrialList%) + " trials selected.");
                    ChangeStateTo(stateWaitLvrDown%);
                endif

            endif
            
        case iState% = stateWaitLvrDown% then
            var s%;
            LogStatus("WaitLvrDown", "Blink/Wait.");
            s% := recBlinkUntilLeverDown%(.5, spcMaxLvrDownTime);

            docase
                case s% = 1 then
                    delayIntervalTime := spcMinDelay + Rand(spcVarDelay, 0);
                    LogStatus("WaitLvrDown", "Delay interval=" + str$(delayIntervalTime) + " s.");
                    ChangeStateTo(stateDelayInterval%);
                case s% = 0 then
                    LogStatus("WaitLvrDown", "Timeout waiting for lever down.");
                    ChangeStateTo(stateLvrDownTimeout%);
                else
                    Message("Error in recBlinkUntilLeverDown!");
                    ChangeStateTo(stateDone%);
                    status% := 0;
            endcase
            
        case iState% = stateLvrDownTimeout% then
        
            if tNow - tStateStart > spcLvrDownTimeout then
                LogStatus("LvrDownTimeout", "Timeout period done.");
                ChangeStateTo(statePrepareTrials%);
            endif
            
        case iState% = stateDelayInterval% then
        
            if tNow - tStateStart >= delayIntervalTime then
                LogStatus("DelayInterval", "Delay done.");
                ChangeStateTo(statePlaySound%);
            endif

        case iState% = statePlaySound% then

            LogStatus("PlaySound", 
                      "SPK " + str$(gspcTTSpeakers%[gtrialList%[gtrialListIndex%]]) + 
                      "ATT " + str$(gspcTTAtten[gtrialList%[gtrialListIndex%]]) + "\n");
            PlaySound();
            ChangeStateTo(statePlaySoundWait%);
            
        case iState% = statePlaySoundWait% then
        
            if PlayWaveStatus$() = "" then
            
                ' Record completed trial here, and update online analysis. 
                strtmp$ := Print$("E,%d", gspcTrialCount%);
                SampleText(strtmp$, -1);
                tlgTrialIndexCompleted(gtrialList%[gtrialListIndex%]);
                UpdateOnlineAnalysis(tNow); ' Should really call this after tlgTrialIndexCompleted, since the 
                                            ' trial count is incremented there. 
                gtrialListIndex% += 1;
                ChangeStateTo(stateWaitISI%);
            endif
            
        case iState% = stateWaitISI% then
 
            ' Check that lever is still down.
            stmp% := recLeverDown%();
            if stmp% < 0 then
                PrintLog("ERROR in recLeverDown()!!!\n");
            endif
            
            if stmp% = 0 then
                LogStatus("WaitISI", "FAIL! Lever is up");
                ChangeStateTo(stateFalsePositive%);
            else
                if tNow - tStateStart > spcInterStimInterval then
                    LogStatus("WaitISI", "ISI done.");
                    
                    if gtrialListIndex% = gntrialList% then
                        ChangeStateTo(statePlaySound2%);
                    else
                        ChangeStateTo(statePlaySound%);
                    endif
                endif
            endif
            
        case iState% = statePlaySound2% then
        
            LogStatus("PlaySound2", 
                      "SPK " + str$(gspcTTSpeakers%[gtrialList%[gtrialListIndex%-1]]) + 
                      "ATT " + str$(gspcTTAtten[gtrialList%[gtrialListIndex%-1]]) + "\n");
            PlaySound();
            ChangeStateTo(statePlaySound2Wait%);
            
        case iState% = statePlaySound2Wait% then
        
            if PlayWaveStatus$() = "" then
                LogStatus("PlaySound2", "Sound done playing.");
                ' Record completed trial here, and update online analysis. 
                strtmp$ := Print$("F,%d", gspcTrialCount%);
                SampleText(strtmp$, -1);
                ChangeStateTo(stateFreeReward%);
            endif
            
        case iState% = stateFreeReward% then
        
            ' Are we giving free rewards? If we are, then do so, otherwise we just pass on through. 
            if spcFreeRewardCheck% = 1 then
                LogStatus("FreeReward", "Giving free reward size " + str$(spcFreeRewardSize%));
                tdtREWARD%(spcFreeRewardSize%);
            else
                LogStatus("FreeReward", "No free reward.");
            endif
            ChangeStateTo(stateWaitLvrUp%);
            
        case iState% = stateWaitLvrUp% then
        
            stmp% := recLeverDown%();
            if stmp% < 0 then
                PrintLog("ERROR in recLeverDown()!!!\n");
                ChangeStateTo(stateDone%);
            endif
            
            if stmp% = 0 then
                LogStatus("WaitLvrUp", "Lever is up");
                ChangeStateTo(stateLvrUpReward%);
            else
                if tNow - tStateStart > spcMaxLvrUpTime then
                    LogStatus("WaitLvrUp", "Lever not up - timed out!");
                    ChangeStateTo(stateLvrUpTimeout%);
                endif
            endif

        case iState% = stateLvrUpTimeout% then
        
            if tNow - tStateStart > spcLvrUpTimeout then
                LogStatus("LvrUpTimeout", "Timeout period done.");
                ChangeStateTo(statePrepareTrials%);
            endif
            
        case iState% = stateFalsePositive% then
        
            if tNow - tStateStart > spcFalsePositiveTimeout then
                LogStatus("FalsePositiveTimeout", "Timeout period done.");
                ChangeStateTo(statePrepareTrials%);
            endif
            
        case iState% = stateLvrUpReward% then
        
            if spcLongRewardCheck% = 1 then
                LogStatus("LvrUpReward", "(long)) Reward size=" + str$(spcLongRewardSize%));
                tdtREWARD%(spcLongRewardSize%);
            endif
            ChangeStateTo(statePrepareTrials%);
            
        case iState% = stateDone% then
        
            LogStatus("Done", "");
            Stop%();
            iStatus% := 0;
            
        else
        
            LogStatus("UNKNOWN STATE", "iState%=" + str$(iState%));
            Message("Unknown state (%d)!", iState%);
            Stop%();
            iStatus% := 0;
            
    endcase
        

    return iStatus%;
end


'==========================   Start script here ===========================================================




' Check if sampling is happening. If not, quit. 
' Alt: Create sampling config here. 

'if SampleStatus() <> 2 then
'    Message("Sampling must be started before script is run!!!");
'    halt;
'endif


' Do TDT initializations

if recInitTDT%() < 0 then
    halt;
endif


' Open dialog for expt parameters. 

if Space1gScriptDialog%() = 0 then
    halt;
endif


' initialize trial list generator

tlgInit(gspcNTrialTypes%, spcBlockSize%, spcNTrialsPerStim%/spcBlockSize%, gtrialListMin%, gtrialListMax%);

' Initialize PlayWave areas. The call to InitializePlayWaveAreas MUST
' come before the call to InitializeWindows -- that's where FileNew() is called. See Spike2
' docs for PlayWaveAdd(): PlayWaveAdd must be called before FileNew() for sampling window. 

InitializePlayWaveAreas();

' Setup sampling config and open windows

CreateSampleConfiguration();
InitializeWindows();

' Initialize toolbar. Once Toolbar is called the expt is controlled by the toolbar
' buttons. Toolbar() does not return until one of the toolbar functions returns 0 - Stop%()
' does that, as does IdleLoop%() when it reaches the end of all trials. 

InitializeToolbar();
Toolbar("Hit \"Start\" to begin sampling.", 0x3ff);
'Toolbar("Hit \"Start\" to begin sampling.", 0x3ff);



