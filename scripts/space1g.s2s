' $Log$
' Revision 1.4  2008/03/06 20:08:42  devel
' Fix bugs in state logic. Still in testing. Need sound() funcs and PrepareTrials algorithm.
'
' Revision 1.3  2008-03-05 00:15:32  devel
' Added a working idle function. Still more work needed, but we're getting close.
'
' Revision 1.2  2008-02-29 19:35:48  devel
' Add toolbar and sampling funcs. Still need FileNew() and Idle() funcs.
'
' Revision 1.1  2008-02-28 21:40:15  devel
' Initial add of this script.
'


#include "filesystemvars.s2s"
#include "tdt.s2s"
#include "recfuncs.s2s"
var spcDebug% := 1;

'-------- global vars --------------------------------------------------------
const gspcTTMaxSpeakers% := 100;
var gspcTTSpeakers%[gspcTTMaxSpeakers%];    ' speaker numbers - each is considered a trial type. Can have duplicates. 
var gspcTTAtten[gspcTTMaxSpeakers%];        ' atten to use for each speaker number in g_spcTTSpeakers%[]
var gspcTTTallies[gspcTTMaxSpeakers%];      ' running tally of the number of completed trials of each type
var gspcNTrialTypes% := 0;
var gwindowData%;
const gtrialListMin% := 3;                             ' min size of the trial list
const gtrialListMax% := 7;
var gtrialList[gtrialListMax%];       ' The trial list is a list of speakers to use in a series
var gntrialList%;
var gtrialListIndex%;

'-------- space1g configuration dialog ---------------------------------------

var spcOutputRoot$;                 ' root filename for output file
var spcNoise%               := 1;
var spcTone%                := 0;
var spcFreq%                := 20000;
var spcNTrialsPerStim%      := 0;
var spcMinDelay             := 0.5;
var spcVarDelay             := 0.5;
var spcInterStimInterval    := 1.0;
var spcMissTimeout          := 2.0;
var spcLeverTimeout         := 0.0;
var spcTrialTypesFile$      := "";
var spcBlockSize%           := 2;
var spcFreeRewardSize%      := 50;
var spcFreeRewardCheck%     := 0;
var spcLongRewardSize%      := 100;
var spcLongRewardCheck%     := 0;


const spcdlgRoot%       := 1;
const spcdlgNoise%      := 2;
const spcdlgTone%       := 3;
const spcdlgFreq%       := 4;
const spcdlgTTSelection%:= 5;
const spcdlgNTrials%    := 6;
const spcdlgBlockSize%  := 7;
const spcdlgMinDelay%   := 8;
const spcdlgVarDelay%   := 9;
const spcdlgInterStimInterval% := 10;
const spcdlgMissTimeout%:= 11;
const spcdlgLeverTimeout% := 12;
const spcdlgFreeRewardCheck% := 13;
const spcdlgFreeRewardSize% := 14;
const spcdlgLongRewardCheck% := 15;
const spcdlgLongRewardSize% := 16;


proc Space1gScriptDialogSaveParams()
    PrintLog("TODO: proc Space1gScriptDialogSaveParams()\n");
end

proc Space1gScriptDialogGetParams()
    PrintLog("TODO: proc Space1gScriptDialogGetParams()\n");
end


func Space1gDlgChanged%(item%)
    var status% := 1;
    var value%;


    docase 
    case item% = spcdlgNoise% then
    
        ' Get value, toggle it, and set the toggled value in Tone checkbox. 
    
        value% := DlgValue(spcdlgNoise%);
        DlgValue(spcdlgTone%, 1-value%);
        
    case item% = spcdlgTone% then

        ' Get value, toggle it, and set the toggled value in Noise checkbox. 
    
        value% := DlgValue(spcdlgTone%);
        DlgValue(spcdlgNoise%, 1-value%);
    
    endcase

    ' enable or disable frequency box as needed
    DlgEnable(DlgValue(spcdlgTone%), spcdlgFreq%);
    DlgEnable(DlgValue(spcdlgFreeRewardCheck%), spcdlgFreeRewardSize%);
    DlgEnable(DlgValue(spcdlgLongRewardCheck%), spcdlgLongRewardSize%);
        
    
    return status%
end


func Space1gCheckOK%()
    var status% := 0;
    var o$;

    ' Verify that output root is not null
    o$ := DlgValue$(spcdlgRoot%);
    if len(o$) = 0 then
        Message("Please enter an output root.");
        status% := 1;
    endif

    ' Check that spcNTrialsPerStim% is a multiple of spcBlockSize%
    if spcNTrialsPerStim% mod spcBlockSize% <> 0 then
        Message("NTrialsPerStim must be a multiple of block size!");
        status% := 1;
    endif

    ' TODO: Check that output file does not exist. 
    
    return status%;
end

func Space1gScriptDialog%()
    var i%;
    var status% := 0;
    var sFiles$[100];
    var sFileCount% := 0;
    var sFileMask$ := "spc*.txt";
    var iFileSelection% := 0;
    
    ' Fetch parameters from registry
    
    Space1gScriptDialogGetParams();

    ' Get file list for trial types. If no files are found in stim$ matching the mask, 
    ' show a message and quit. 
    FilePathSet(stim$);
    sFileCount% := FileList(sFiles$, -1, sFileMask$);
    if sFileCount% = 0 then
        Message("There are no files in dir %s matching the mask %s", stim$, sFileMask$);
        return 0;   ' will look as if user hit Cancel
    endif
    
    ' Generate the dialog
    
	DlgCreate("Space1g Parameters", 25, 10);
    DlgString(spcdlgRoot%, "Output file root|Base name of output file, e.g. a022098a", 32, "a-zA-Z0-9_-");
    DlgCheck(spcdlgNoise%, "Noise");
    DlgCheck(spcdlgTone%, "Tone");
    DlgInteger(spcdlgFreq%, "Frequency(Hz)", 1, 100000);
    DlgList(spcdlgTTSelection%, "Stim set:", sFiles$, sFileCount%);
    DlgInteger(spcdlgNTrials%, "# trials per stim", 1, 20, 0, 0, 1);
    DlgInteger(spcdlgBlockSize%, "block size", 1, 5, 0, 0, 1);
    DlgReal(spcdlgMinDelay%, "Min delay(s)", 0.0, 5.0);
    DlgReal(spcdlgVarDelay%, "Var delay(s)", 0.0, 5.0);
    DlgReal(spcdlgInterStimInterval%, "ISI(s)", 0.0, 5.0);
    DlgReal(spcdlgMissTimeout%, "Miss timeout(s)", 0.0, 5.0);
    DlgReal(spcdlgLeverTimeout%, "Lever timeout(s)", 0.0, 5.0);
    DlgCheck(spcdlgFreeRewardCheck%, "Free reward?");
    DlgInteger(spcdlgFreeRewardSize%, "Free reward size", 5, 500, 0, 0, 10);
    DlgCheck(spcdlgLongRewardCheck%, "Long reward?");
    DlgInteger(spcdlgLongRewardSize%, "Long reward size", 5, 500, 0, 0, 10);

    DlgButton(1, "OK", Space1gCheckOK%);
    DlgButton(0, "Cancel");
    DlgAllow(0, 0, Space1gDlgChanged%);

    ' Show the dialog. 

	i%:=DlgShow(spcOutputRoot$, spcNoise%, spcTone%, spcFreq%, iFileSelection%, spcNTrialsPerStim%, spcBlocksize%, 
                spcMinDelay, spcVarDelay, spcInterStimInterval, spcMissTimeout, spcLeverTimeout, 
                spcFreeRewardCheck%, spcFreeRewardSize%, spcLongRewardCheck%, spcLongRewardSize%);

    ' If user hit OK then save parameters (and return 1). 

	if i% = 1 then
        spcTrialTypesFile$ := sFiles$[iFileSelection%];
        Space1gScriptDialogSaveParams();
        status% := 1;
    else
        status% := 0;
    endif

	return status%;
end;


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' LoadTrialTypes%() - open and read trial types file. 
' Expecting format with two numbers per line:
' spk atten
' where spk is speaker number and atten is attenuation
' Will load array g_spcTTSpeakers%[g_spcTTMaxSpeakers%] and g_spcTTAtten[g_spcTTMaxSpeakers%], 
' and will set spcNTrialTypes% to be the number of speaker/atten pairs read. 

func LoadTrialTypes%(sTTFile$)
    var handle;
    var line$;
    var count% := 0;
    
    ' open file
    handle := FileOpen(sTTFile$, 8, 0);
    if handle = 0 then
        PrintLog("Cannot open trial types file " + sTTFile$ + "\n");
        return -1;
    endif
    
    ' Now read a line at a time, discard any that begin with #
    while Read(line$)>=0 do
        ' is it a comment?
        if InStr(line$, "#") <> 1 then
            if (ReadStr(line$, gspcTTSpeakers%[count%], gspcTTAtten[count%]) = 2) then
                count% := count% + 1;
            endif
        endif
    wend
    gspcNTrialTypes% := count%;
    
    FileClose();
  
    return count%;
end


''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' PrepareTrials%()
'
' Prepares a list of trials to run. The list may be from 3-7 trials long. 
' Returns 0 when all trials are done. Otherwise return nonzero value.

func PrepareTrials%()

    return 1;

end



'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' CreateSampleConfiguration - prepare toolbar buttons. Note that the idle processing function 
' (ToolbarSet(0, blah, blah)) is not set here. That's done when the user hits the start 
' button.
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

var DAC0Channel% := 1;          ' DAC0 output should be tee'd and input to ADC port 6
var Trode1Channel% := 11;       ' First electrode. Don't use channel numbers above this
                                ' for anything other than electrodes!

proc CreateSampleConfiguration()

	var index;

    ' Initialize sampling settings
    
	SampleClear();
	SampleAutoComment(0);
	SampleAutoCommit(60);

    ' DAC0 (sound output) -> record this channel? It will inflate the file sizes......
    

	' Electrode
    
	SampleWaveMark(Trode1Channel%, 0, 100, 34, 15, 28000); ' chan, port, event rate, points, pre-trigger, rate
	SampleTitle$(index, "Trode 1"); 

    ' Set optimise mode (do this last). Settings specific to Power1401 625 (that's the "5"). 
    ' The second arg groups channels with same ideal rates together so they all get same 
    ' actual rate. That means multiple electrodes (if used) will all get same actual rate, 
    ' assuming you use same ideal rate (in SampleWavemark()). 
    
	SampleOptimise(2, 1, 5, 2, 50);  
    SampleMode(1);
end




proc InitializeWindows()

	'Open the data sampling window
	gwindowData% := FileNew(0,4);
	Window(0, 0, 100, 50); 
	View(gwindowData%).WindowVisible(1);

end;


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' InitilizeToolbar - prepare toolbar buttons. Note that the idle processing function 
' (ToolbarSet(0, blah, blah)) is not set here. That's done when the user hits the start 
' button.
'

const tbStart%  := 1;
const tbStop%   := 2;
const tbPause%  := 3;
const tbResume% := 4;
const tbReward% := 5;

proc InitializeToolbar()

	View(App(8)).WindowVisible(0);	'Hide the standard sample bar
	ToolbarVisible(1);
	ToolbarSet(tbStart%, "Start", Start%);
	ToolbarSet(tbStop%, "Stop", Stop%);
	ToolbarSet(tbPause%, "Pause", Pause%);
	ToolbarSet(tbResume%, "Resume", Resume%);
	ToolbarSet(tbReward%, "Reward", Reward%);

    ' Explicitly set enabled state of things...
    ToolbarEnable(tbStart%, 1);
    ToolbarEnable(tbStop%, 0);
    ToolbarEnable(tbPause%, 0);
    ToolbarEnable(tbResume%, 0);
    ToolbarEnable(tbReward%, 1);

end;


var fPaused%    := 0;
var fStarted%   := 0;

func Start%()
    fStarted% := 1;

    ' Disable start button, enable stop and pause
    
    ToolbarEnable(tbStart%, 0);
    ToolbarEnable(tbStop%, 1);
    ToolbarEnable(tbPause%, 1);
    
    ' Oh yeah, start the sampling. 
    
    SampleStart();

    ' Set idle function
    ToolbarSet(0, "", IdleLoop%);
    
    ' Tell the world about it. 
    
    ToolbarText("Sampling started.");
    return 1;
end

func Stop%()
    
    ' Stop sampling....

    if SampleStatus() <> -1 then
        SampleStop();
    endif
    
    ' Returning zero from here any ToolbarSet() functions causes the 
    ' Toolbar() function to return.
    return 0;
end

func Pause%()
    fPaused% := 1;
    ToolbarEnable(tbResume%, 1);
    ToolbarEnable(tbPause%, 0);
    return 1;
end

func Resume%()
    fPaused% := 0;
    ToolbarEnable(tbResume%, 0);
    ToolbarEnable(tbPause%, 1);
    return 1;
end

func Reward%()
    ' TODO: Add reward func here!
    return 1;
end



' States
const stateStart%               := 0;
const statePrepareTrials%        := 1;
const stateWaitLvrDown%         := 2;
const stateDelayInterval%       := 3;
const statePlaySound%           := 4;
const stateWaitSoundDone%       := 5;
const stateWaitISI%             := 6;
const statePlaySound2%          := 7;
const stateFreeReward%          := 8;
const stateWaitLvrUp%           := 9;
const stateLvrUpReward%         := 10;
const stateMissTimeout%         := 11;
const stateLeverTimeout%        := 12;
const stateDone%                := 20;

var tNow:=0;		' latest time for which there are values recorded. Used in IdleLoop%
var tLast:=-1;		' last time we checked for a trigger. 
var iState%:=stateStart%;		' present state
var tStateStart:=-1;	' time that present state started. Used to measure wait time, fixation time, etc. 
var delayIntervalTime;  ' time to delay before a set of trials are started 

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' 
' ChangeStateTo
' 
' Call this function on exit from a state. The var stateTo% should be the state to enter
' on the next call to the loop function. 
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

proc LogStatus(stateName$, msg$)
    if spcDebug% = 1 then
        PrintLog("S:    " + stateName$ + "  Tstart: " + str$(tStateStart) + " " + msg$ + "\n");
    endif
end


proc ChangeStateTo(stateTo%)
	iState% := stateTo%;
    tStateStart := MaxTime();
end;

func IdleLoop%()
    var status% := 1;
	var iStatus% := 1;	' this is return value. value of 1 (0) continues (stops) processing
	tNow := MaxTime();

	' What state are we in? 
	docase 

	
		case iState% = stateStart% then

            LogStatus("Start", "Preparing trials");
            ChangeStateTo(statePrepareTrials%);
            
        case iState% = statePrepareTrials% then
        
            ' prepare values for the next trial.
            ' this is the point where the expt can be paused. Operator can hit the pause
            ' button anytime, but the actual pause will not happen until here. 
            if fPaused% = 0 then

                if PrepareTrials%() = 0 then
                    LogStatus("PrepareTrials", "All done!");
                    ChangeStateTo(stateDone%);
                else
                    LogStatus("PrepareTrials", "Trials selected.");
                    ChangeStateTo(stateWaitLvrDown%);
                endif

            endif
            
        case iState% = stateWaitLvrDown% then
            var s%;
            LogStatus("WaitLvrDown", "Blink/Wait.");
            s% := recBlinkUntilLeverDown%(.5, 10.0);

            docase
                case s% = 1 then
                    delayIntervalTime := spcMinDelay + Rand(spcVarDelay, 0);
                    LogStatus("WaitLvrDown", "Delay interval=" + str$(delayIntervalTime) + " s.");
                    ChangeStateTo(stateDelayInterval%);
                case s% = 0 then
                    LogStatus("WaitLvrDown", "Timeout waiting for lever down.");
                    ChangeStateTo(stateLeverTimeout%);
                else
                    Message("Error in recBlinkUntilLeverDown!");
                    ChangeStateTo(stateDone%);
                    status% := 0;
            endcase
            
        case iState% = stateLeverTimeout% then
        
            if tNow - tStateStart > spcMissTimeout then
                LogStatus("LeverTimeout", "Timeout period done.");
                ChangeStateTo(statePrepareTrials%);
            endif
            
        case iState% = stateDelayInterval% then
        
            if tNow - tStateStart >= delayIntervalTime then
                LogStatus("DelayInterval", "Delay done.");
                ChangeStateTo(statePlaySound%);
            endif

        case iState% = statePlaySound% then

            LogStatus("PlaySound", "");
            ChangeStateTo(stateWaitISI%);
            
        case iState% = stateWaitISI% then
        
            if tNow - tStateStart > spcInterStimInterval then
                LogStatus("WaitISI", "ISI done.");
                ChangeStateTo(statePlaySound2%);
            endif
            
        case iState% = statePlaySound2% then
        
            LogStatus("PlaySound2", "");
            ChangeStateTo(stateFreeReward%);
            
        case iState% = stateFreeReward% then
        
            ' Are we giving free rewards? If we are, then do so, otherwise we just pass on through. 
            if spcFreeRewardCheck% = 1 then
                LogStatus("FreeReward", "Giving free reward size " + str$(spcFreeRewardSize%));
                tdtREWARD%(spcFreeRewardSize%);
            else
                LogStatus("FreeReward", "No free reward.");
            endif
            ChangeStateTo(stateWaitLvrUp%);
            
        case iState% = stateWaitLvrUp% then
        
            var stmp%;
            stmp% := recLeverDown%();
            if stmp% < 0 then
                PrintLog("ERROR in recLeverDown()!!!\n");
            endif
            
            if stmp% = 0 then
                LogStatus("WaitLvrUp", "Lever is up");
                ChangeStateTo(stateLvrUpReward%);
            else
                if tNow - tStateStart > spcdlgLeverTimeout% then
                    LogStatus("WaitLvrUp", "Lever not up - timed out!");
                    ChangeStateTo(stateMissTimeout%);
                endif
            endif

        case iState% = stateMissTimeout% then
        
            if tNow - tStateStart > spcMissTimeout then
                LogStatus("MissTimeout", "Timeout period done.");
                ChangeStateTo(statePrepareTrials%);
            endif
            
        case iState% = stateLvrUpReward% then
        
            if spcLongRewardCheck% = 1 then
                LogStatus("LvrUpReward", "(long)) Reward size=" + str$(spcLongRewardSize%));
                tdtREWARD%(spcLongRewardSize%);
            endif
            ChangeStateTo(statePrepareTrials%);
            
        case iState% = stateDone% then
        
            LogStatus("Done", "");
            Stop%();
            iStatus% := 0;
            
        else
        
            LogStatus("UNKNOWN STATE", "iState%=" + str$(iState%));
            Message("Unknown state (%d)!", iState%);
            Stop%();
            iStatus% := 0;
            
    endcase
        

    return iStatus%;
end


'==========================   Start script here ===========================================================




' Check if sampling is happening. If not, quit. 
' Alt: Create sampling config here. 

'if SampleStatus() <> 2 then
'    Message("Sampling must be started before script is run!!!");
'    halt;
'endif


' Do TDT initializations

if recInitTDT%() < 0 then
    halt;
endif


' Open dialog for expt parameters. 

if Space1gScriptDialog%() = 0 then
    halt;
endif

' Now open and load trial types file.

if LoadTrialTypes%(spcTrialTypesFile$) <= 0 then
    Message("Cannot load trial types file " + spcTrialTypesFile$);
    halt;
endif
PrintLog("Loaded %d trial types from %s\n", gspcNTrialTypes%, spcTrialTypesFile$);

' Setup sampling config and open windows

CreateSampleConfiguration();
InitializeWindows();

' Initialize toolbar. Once Toolbar is called the expt is controlled by the toolbar
' buttons. Toolbar() does not return until one of the toolbar functions returns 0 - Stop%()
' does that, as does IdleLoop%() when it reaches the end of all trials. 

InitializeToolbar();
Toolbar("Hit \"Start\" to begin sampling.", 0x7);
'Toolbar("Hit \"Start\" to begin sampling.", 0x3ff);



