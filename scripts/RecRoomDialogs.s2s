'RecRoomDialogs.s2s
'This script is designed to pull out the dialog box stuff from RecRoom; the idea is to make it
'easier to find stuff in either script.  Hopefully it actually pans out that way.

'
'
'Begin Global Variables Part II
'================================================================================================

'Variables which will be used throughout the RecRoom Suite, but are defined here because their
'primary function is associated with the dialogs.  This will be A LOT of the variables.


'Dialog button variables and other dialog variables
var recExpSearchButton%:=2;         'Arbitrary button value for the Search experiment
var recExpCharButton%:=3;            'Etc.   
var recExpAMDiscButton%:=4;
var recExpCueingButton%:=5;
var recExpTimingRewardButton%:=6;
var recAMDiscAddExpButton%:=7;
var recAMDiscDeleteExpButton%:=8;
var recSelectStimFileButton%:=9;
var recSelectTrialsFileButton%:=10;
var recLeverJoystickButton%:=11;
var recExpJoyTrnButton%:=12; '*jao
var recExpSpaceDisButton%:=13; '*jao 
var recSpaceDisAddExpButton%:=14; 'more buttons!
var recSpaceDisDeleteExpButton%:=15;  'moar buttons!!
var recExpAudiogramButton%:=16;  'maori buttons!!!! 
var recExpStereoDisButton%:=17;   
var recExpStereoDisAddExpButton%:=18;
var recExpStereoDisDeleteExpButton%:=19;
var recCharAddExpLoadFRAButton%:=20;
var recCharDeleteExpLoadFRAButton%:=21;    
var recSelectStimDistractorFileButton%:=22;  
var recExpStereoDisGNGAddExpButton%:=23;
var recExpStereoDisGNGDeleteExpButton%:=24;
var recExpOneStimDiscrimButton%:=25;  
var recExpOneStimDiscrimAddExpButton%:=26;
var recExpOneStimDiscrimDeleteExpButton%:=27;   
var recExpLongToneButton%:=28;    
var recCharAddExpGenFRAButton%:=29;
var recCharDeleteExpGenFRAButton%:=30;
var recCharAddExpGenSigNoiseButton%:=31;
var recCharDeleteExpGenSigNoiseButton%:=32;   
var recCharAddExpLoadSigNoiseButton%:=33;
var recCharDeleteExpLoadSigNoiseButton%:=34;
var recCharAddExpLoadArbStimButton%:=35;
var recCharDeleteExpLoadArbStimButton%:=36;  
var recAMDiscReportExpButton%:=37;  'buttons to report experiment details
var recSpaceDisReportExpButton%:=38;
var recStereoDisReportExpButton%:=39;    
var recCharReportExpButton%:=40;
var recOneStimDiscrimReportExpButton%:=41;
var recExpOneStimDiscrimGNGAddExpButton%:=42;
var recExpOneStimDiscrimGNGDeleteExpButton%:=43; 
    

'Selection Dialog variables
var recExpSelectDialogAllowOK%;     'Does not allow the "OK" button to be pressed until an experiment is selected
var recSpeakerArrayIndex%;          'Allows selection of a speaker array via dialog list
var recSpeakerArrayIndex2%;         'Allows selection of another speaker array via dialog list (to assign which PA4 if there are two)    
var recShuffle%;                    'Allows shuffle of trial order
var recExpSelectSamplingRateIndex%; 'Index of drop-down to select sampling rate
var recExpSelectPlayRateIndex%;     'Index of drop-down to select audio playback rate

'Search Dialog variables
var recSearchStimType%;             'Integer index to experiment selection list
var recSearchToneFreq;              'Frequency of tone
var recSearchBPLowerLim;            'Lower frequency limit of bandpass noise
var recSearchBPUpperLim;             'Upper frequency limit of bandpass noise
var recSearchSpeakerSweepRepeats%;  'Number of repeats of noise per speaker for speaker sweeps
var recSearchToneSweepRepeats%;     'Number of repeats of tone sweeps
var recSearchToneSweepLowLim;       'Lower frequency limit of tone sweeps
var recSearchToneSweepUpperLim;     'Upper frequency limit of tone sweeps
'var recSearchToneSweepOctaveStep;   'Octave step of tone sweep
var recSearchToneSweepNSteps%;      'Number of steps in the tone sweep
const recSearchToneSweepMaxSteps%:=10;        'Max number of frequency steps in search tone sweep curve
var recSearchS1Speaker%;            'Speaker on which S1 plays, transferred to recS1Speaker% if Search is selected
var recSearchS2Speaker%;            'Speaker on which S2 plays, transferred to recS2Speaker% if Search is selected
var recSearchMinS1%;                'Minimum number of S1s, transferred to recMinS1% if Search is selected
var recSearchVarS1%;                'Variable number of S2s, transferred to recVarS1% if Search is selected
var recSearchPropCatch;             'Proportion of catch trials, transferred to recPropCatch if Search is selected
var recSearchdBLevel;               'Set dB level, transferred to recdBLevel if Search is selected
var recSearchActive%;               'Is experiment active or passive, transferred to recActive% if Search is selected
var recSearchFixLED%;               'Use fixation LED, transferred to recFixLED% if Search is selected
var recSearchFMStartFreq;           'Starting frequency for FM sweep
var recSearchFMEndFreq;             'Ending frequency for FM sweep    
var recSearchFMNumReverses%;        'Number of reverses for FM sweep   (0 = logarithmic sweep, 1-9  = sinusoidal reversing sweep)  
var recSearchFMDur;                 'Duration  in seconds for FM sweep (other search parameters have hard-coded durations)   
    
var recSearchDoPSTH%;               'Do we make a PSTH during search?  If so, we need to define lots of stuff   
var recSearchWMPorts%[4];           'Which wavemark PORTs do we want to use (up to 4), if value is -1, no port defined    
ArrConst(recSearchWMPorts%[],-1);   'Start with -1  
var recSearchPSTHWindow%;           'Pointer to the PSTH window - may not be needed?
var recSearchPSTHHandle%[4];        'Handles for PSTHs    
var HistTotal;                      'Duration of histogram overall
var HistPre:=0.4;                   'Duration of pre-stimulus histogram, in seconds
var HistPost:=0.4;                  'Duration of post-stimulus histogram, in seconds
var HistBinWidth:=0.005;            'Width of histogram bin, in seconds
var HistBins%;                      'Total number of bins in the histogram
var MarkerCode%[4];                 'Marker code for sample texts
MarkerCode%[0] := 1;                'For now, we only care about using this for "Sound", which allows us to use sampleTexts to get the start time of the sound
var PSTHBeginTime; 
    

'Characterization (FRA/Rate-Level/Space) Dialog variables
var recCharS1Speaker%;               'Preferred speaker (S1 stimulus location)
var recCharMinS1%;
var recCharVarS1%;    
var recRateLeveldBLow:=30;          'Lower bound of rate-level curve - must give a default value or program will crash with nothing in the registry
var recRateLeveldBHigh:=80;         'Higher bound of rate-level curve - must give a default value or program will crash with nothing in the registry
var recRateLevelNRepeats%:=12;      'number of repeats for rate-level experiment    
var recFRATonedBLow:=30;            'Lower dB bound of FRA - must give a default value or program will crash with nothing in the registry
var recFRATonedBHigh:=80;           'Higher dB bound of FRA - must give a default value or program will crash with nothing in the registry
var recFRAToneFreqLow:=1000;        'Lower frequency bound of FRA - must give a default value or program will crash with nothing in the registry
var recFRAToneFreqHigh:=20000;      'Higher frequency bound of FRA - must give a default value or program will crash with nothing in the registry
var recFRANRepeats%:=1;             'number of repeats for FRA    
var recSpaceS2dBLevel;                'dB level of S2 stimuli (space curve), should match a level in the Rate-Level Curve
var recSpaceNRepeats%;
var recS1AMnoiseReps%; 
const nMTFrates% := 11;
var MTFrates[nMTFrates%]; 
const recRateLeveldBNSteps%:=10;    'Number of dB steps in rate-level curve
const recFRAdBNSteps%:=10;          'Number of dB steps in FRA curve
const recFRAFreqNSteps%:=45;        'Number of frequency steps in FRA curve    
var recRateLeveldBList[recRateLeveldBNSteps%];       'List of dB steps in rate-level curve
var recFRAdBList[recFRAdBNSteps%];                   'List of dB steps in FRA curve
var recFRAFreqList[recFRAFreqNSteps%];               'List of frequency steps in FRA curve
var recSearchToneSweepFreqList[recSearchToneSweepMaxSteps%];     'List of frequency steps in search tone sweep curve    
var recRLList1$;                    'Text string, displays selected values
var recRLList2$;                    'Etc.
var recFRAdBList1$;
var recFRAdBList2$;
var recFRAFreqList1$;
var recFRAFreqList2$;
var recFRAFreqList3$;
var recFRAFreqList4$;
var recFRAFreqList5$;
'var recMTFfreqList$;
var recSearchToneSweepFreqList$;
var recRLList1%;                    'Dialog item #, allows update of text
var recRLList2%;                    'Etc.
var recFRAdBList1%;
var recFRAdBList2%;
var recFRAFreqList1%;
var recFRAFreqList2%;
var recFRAFreqList3%;
var recFRAFreqList4%;
var recFRAFreqList5%;
var recSearchToneSweepFreqList%;
var recFMSweepRepeats%;
var recFMSweepStart%;
var recFMSweepEnd%;
var recFMSweep%[2];
var recFMSweepDur1%;
var recFMSweepDur2%;
var recFMSweepDur3%;
var recFMSweepDur4%;
var recFMSweepDur5%;
var recFMSweepDur%[5];
var recCharActive% := 0;
var recBPnoiseReps%;
const nBPnoises% := 20;    
var recBPnoisesLOs%[nBPnoises%];
var recBPnoisesHIs%[nBPnoises%];
    
const recCharNumExps% := 40;      'The allowable number of defined experiments in Characterization, DO NOT CHANGE WITHOUT OVERHAUL OF GETPARAM, ETC. STUFF           
'These are the names of the various experiment definitions for Characterization; we need one for each type of experiment (5 types), as all are loaded when the dialog is called    
var recCharExpNameLoadFRA$[recCharNumExps%];       'Loaded FRA
var recCharExpNameLoadSigNoise$[recCharNumExps%];    'Loaded SigNoise    
var recCharExpNameGenFRA$[recCharNumExps%];       'Generated FRA
var recCharExpNameGenSigNoise$[recCharNumExps%];       'Generated SigNoise
var recCharExpNameLoadArbStim$[recCharNumExps%];    'Loaded arbitrary stimulus    
'These are the stim (or stim/cal) and trials file locations for the above experiments, a stim/cal file and a trial file for each type of experiment    
var recCharStimcalFileLoadFRA$[recCharNumExps%];   'Loaded FRA Stim/Cal file
var recCharTrialsFileLoadFRA$[recCharNumExps%];    'Loaded FRA Trials file
var recCharStimcalFileLoadSigNoise$[recCharNumExps%];    'Loaded SigNoise Stim/Cal file
var recCharTrialsFileLoadSigNoise$[recCharNumExps%];    'Loaded SigNoise Trials file
var recCharStimFileGenFRA$[recCharNumExps%];   'Generated FRA Stim file   
var recCharTrialsFileGenFRA$[recCharNumExps%];    'Generated FRA Trials file
var recCharStimFileGenSigNoise$[recCharNumExps%];   'Generated SigNoise Stim file 
var recCharTrialsFileGenSigNoise$[recCharNumExps%];    'Generated SigNoise Trials file
var recCharStimcalFileLoadArbStim$[recCharNumExps%];    'Loaded arbitrary stimulus Stim/Cal file
var recCharTrialsFileLoadArbStim$[recCharNumExps%];    'Loaded arbitrary stimulus Trials file
'These are the experiment indices for indexing the above variables, one per type of experiment
var recCharExpIndexLoadFRA%;
var recCharExpIndexLoadSigNoise%;    'loaded signoise        
var recCharExpIndexGenFRA%;           
var recCharExpIndexGenSigNoise%;
var recCharExpIndexLoadArbStim%;     'Arbitrary
var recCharExpPrefixLoadArbStim$[recCharNumExps%];    'Loaded arbitrary stimulus  
var recCharRepeatsPerStim% := 1;       'Number of repeats for each stimulus defined in the trials file, this value is currently not assigned by dialog, fixed at 1  
    
var recStereoDisRepeatsPerStim% := 1;  
var recStereoDisGNGRepeatsPerStim% := 1; 
var recStereoDisdB := 65;   'we may change the intended dB  
var recOneStimDiscrimRepeatsPerStim% := 1;  
var recOneStimDiscrimGNGRepeatsPerStim% := 1;
var recOneStimDiscrimdB := 65;   'we may change the intended dB     
var recCharText1%;    
var recCharText2%;  
var recCharText3%;
var recCharText4%;
var recCharText5%;    
var recCharLoadStim% := 1;
var recDur;     
    
'Long Tone Dialog variables
var recLongToneDuration;
var recLongToneFreq;
var recLongToneBPLow;
var recLongToneBPHigh;
var recLongToneType%;  '0 = tone, 1 = broadband noise, 2 = bandpass noise
var recLongToneSpeaker%;
var recLongToneNRepeats%;     
var recLongToneISI;   
var recLongToneSilentDur;
var recLongToneSilentPWASize := 24.9;  'Initialize silent PWA at 24.9 seconds (max length)
var recLongToneTargetdB;
var recLongToneRewardProb;
const nLongTones% := 5;  'four tones and a silence period
const LongDur0 := 0.1 + 0.020;  'add in 10-ms ramp on each side
const LongDur1 := 1 + 0.020;  'add in 10-ms ramp on each side
const LongDur2 := 10 + 0.020;  'add in 10-ms ramp on each side
var LongDur3 := 100 + 0.020;  'add in 10-ms ramp on each side
var LongDurs[nLongTones%];  'setting this in GenTrialsLongTones, so it's with the silent trial setting
var LongDursAllocate[nLongTones%];   'We need to allocate the PWAs at maximum size, then we can adjust the size of the silence (others?) later    
'var recLongToneCycleStartTime;
'var recLongToneCyclesRemaining%;    
    
'Audiogram dialog variables
var recAudiogramS1Speaker%;  
var recAudiogramToneFreqLow:=1000;   'Lower frequency bound of audiogram - must give a default value or program will crash with nothing in the registry
var recAudiogramToneFreqHigh:=20000; 'Higher frequency bound of audiogram - must give a default value or program will crash with nothing in the registry
var recAudiogramNFreqs%:=45;   'Max Number of frequencies in audiogram, unlike FRA this value can be smaller 
var recAudiogramFreqList[45];   'List of frequency steps in audiogram    
var recAudiogramFreqList1$;
var recAudiogramFreqList2$;
var recAudiogramFreqList3$;
var recAudiogramFreqList4$;
var recAudiogramFreqList5$;  
var recAudiogramFreqList1%;
var recAudiogramFreqList2%;
var recAudiogramFreqList3%;
var recAudiogramFreqList4%;
var recAudiogramFreqList5%;    
var recAudiogramNReversals%;
var recAudiogramOnlyLogReversals%;
var recAudiogramStartdB;
var recAudiogramInitialDirection%;  '1 = up, 0 = down
var recAudiogramInitialdBStep;
var recAudiogramLouderdBStep;
var recAudiogramQuieterdBStep;
'Audiogram logic variables    
var recAudiogramCurrentReversals%;     
var recAudiogramCurrentdB; 
var recAudiogramPreviousdB;
var recAudiogramStartNewTrial% := 1;  'on first presentation, do increment trial counter
var recAudiogramCurrentDirection%;  '1 = up, 0 = down
var recAudiogramIsInitialDirection% := 1;   'audiogram will start on the initial direction 
'var recAudiogramLastResult%;    '1 = last result hit, -1 = last result miss, 0 = no results yet    
    
    
    
    

'AM Discrimination Dialog variables
var recAMDiscS1Speaker%;            'Speaker on which S1 plays, transferred to recS1Speaker% if Search is selected
var recAMDiscMinS1%;                'Minimum number of S1s, transferred to recMinS1% if Search is selected
var recAMDiscVarS1%;                'Variable number of S2s, transferred to recVarS1% if Search is selected
var recAMDiscPropCatch;             'Proportion of catch trials, transferred to recPropCatch if Search is selected
var recAMDiscdBLevel;               'Set dB level, transferred to recdBLevel if Search is selected
var recAMDiscRepeatsPerStim%;       'Number of repeats for each stimulus defined in the trials file
var recAMDiscMatGenStim%;           'If 1, generate stimuli with matlab, if 0 read from disk
var recAMDiscText1%;                'Allows enable/disable (= black/grey) of text item 1
var recAMDiscText2%;                'Allows enable/disable (= black/grey) of text item 2
var recAMDiscText3%;                'Allows enable/disable (= black/grey) of text item 3
var recAMDiscText4%;                'Allows enable/disable (= black/grey) of text item 4 
var recAMDiscDoRove%;               'Do we rove?
var recAMDiscRovedB;                'How much do we rove?
var recSelectedStimFile$;           'Stim or stim/cal file selected in add/delete 
var recSelectedStimDistractorFile$;    
var recSelectedTrialsFile$;         'Trials file selected in add/delete
var recSelectedPrefix$;             'Prefix of the selected file, for now only used with ArbStim
const recAMDiscNumExps% := 40;      'The allowable number of defined experiments in AMDisc, DO NOT CHANGE WITHOUT OVERHAUL OF GETPARAM, ETC. STUFF
var recAMDiscExpNameLoad$[recAMDiscNumExps%];       'Experiment names, loading files
var recAMDiscStimcalNameLoad$[recAMDiscNumExps%];   'Stim/Cal file names, loading files
var recAMDiscTrialsNameLoad$[recAMDiscNumExps%];    'Trials file names, loading files
var recAMDiscExpNameGen$[recAMDiscNumExps%];        'Experiment names, generating stims
var recAMDiscStimcalNameGen$[recAMDiscNumExps%];    'Stim file names, generating stims
var recAMDiscTrialsNameGen$[recAMDiscNumExps%];     'Trials file names, generating stims
var recAMDiscExpIndexLoad%;         'Experiment index, for loading stims, helps us look up stimcal/trials files
var recAMDiscExpIndexGen%;          'Experiment index, for generating stims, etc.
var recTrialInitReward%;            'Give training reward for successful trial initiation *jao
var recAMDiscTrialInitReward%;      'Separate out training reward for AMDisc
var recTrialHoldReward%;            'Give training reward for successful trial hold through stimulus, without response
var recAMDiscTrialHoldReward%;      'Separate out training reward for AMDisc
var recAMDiscActive%;               'Holds AMDisc active 
    
    
'Space Discrimination Dialog variables (unused or reused vars are commented out)
'var recSpaceDisS1Speaker%;            'Speaker on which S1 plays, transferred to recS1Speaker% if Search is selected
var recSpaceDisMinS1%;                'Minimum number of S1s, transferred to recMinS1% if Search is selected
var recSpaceDisVarS1%;                'Variable number of S2s, transferred to recVarS1% if Search is selected
var recSpaceDisPropCatch;             'Proportion of catch trials, transferred to recPropCatch if Search is selected
var recSpaceDisdBLevel;               'Set dB level, transferred to recdBLevel if Search is selected
var recSpaceDisRepeatsPerStim%;       'Number of repeats for each stimulus defined in the trials file
var recSpaceDisMatGenStim%;           'If 1, generate stimuli with matlab, if 0 read from disk
var recSpaceDisText1%;                'Allows enable/disable (= black/grey) of text item 1
var recSpaceDisText2%;                'Allows enable/disable (= black/grey) of text item 2
var recSpaceDisDoRove%;               'Do we rove?
var recSpaceDisRovedB;                'How much do we rove?
'var recSelectedStimFile$;           'Stim or stim/cal file selected in add/delete 
'var recSelectedTrialsFile$;         'Trials file selected in add/delete
const recSpaceDisNumExps% := 40;      'The allowable number of defined experiments in AMDisc, DO NOT CHANGE WITHOUT OVERHAUL OF GETPARAM, ETC. STUFF
var recSpaceDisExpNameLoad$[recSpaceDisNumExps%];       'Experiment names, loading files
var recSpaceDisStimcalNameLoad$[recSpaceDisNumExps%];   'Stim/Cal file names, loading files
var recSpaceDisTrialsNameLoad$[recSpaceDisNumExps%];    'Trials file names, loading files
var recSpaceDisExpNameGen$[recSpaceDisNumExps%];       'Experiment names, generating stims
var recSpaceDisStimcalNameGen$[recSpaceDisNumExps%];   'Stim file names, generating stims
var recSpaceDisTrialsNameGen$[recSpaceDisNumExps%];    'Trials file names, generating stims
var recSpaceDisExpIndexLoad%;         'Experiment index, for loading stims, helps us look up stimcal/trials files
var recSpaceDisExpIndexGen%;          'Experiment index, for generating stims, etc.
var recSpaceDisTrialInitReward%;    'Separate out training reward for SpaceDisc
var recSpaceDisTrialHoldReward%;    'Separate out training reward for SpaceDisc    
var recSpaceDisActive%;             'Holds SpaceDis active     
    
    
'Stereo Distractor Dialog variables
const recStereoDisNumExps% := 40;
var recStereoDisExpNameLoad$[recStereoDisNumExps%];
var recStereoDisStimcalNameLoad$[recStereoDisNumExps%];
var recStereoDisStimcalDistractorNameLoad$[recStereoDisNumExps%];
var recStereoDisTrialsNameLoad$[recStereoDisNumExps%];
var recStereoDisExpIndexLoad%;
var recStereoDisExpNameGen$[recStereoDisNumExps%];
var recStereoDisStimNameGen$[recStereoDisNumExps%];
var recStereoDisTrialsNameGen$[recStereoDisNumExps%];
var recStereoDisExpIndexGen%;
var recStereoDisExpDoFC%;
var recStereoDisExpDoGen%;
var recStereoDisExpDoLoad%;    
const recStereoDisGNGNumExps% := 40;
var recStereoDisGNGExpNameLoad$[recStereoDisGNGNumExps%];
var recStereoDisGNGStimcalNameLoad$[recStereoDisGNGNumExps%];
var recStereoDisGNGStimcalDistractorNameLoad$[recStereoDisGNGNumExps%];
var recStereoDisGNGTrialsNameLoad$[recStereoDisGNGNumExps%];
var recStereoDisGNGExpIndexLoad%;  
var recStereoDisGNGExpNameGen$[recStereoDisGNGNumExps%];
var recStereoDisGNGStimNameGen$[recStereoDisGNGNumExps%];
var recStereoDisGNGTrialsNameGen$[recStereoDisGNGNumExps%];
var recStereoDisGNGExpIndexGen%;
var recStereoDisExpDoGNG%;   
var recStereoDisDoRove%;               'Do we rove?
var recStereoDisRovedB;                'How much do we rove? 
var recStereoDisActive%;               'Active task? 
var recStereoDisTrialInitReward%; 
var recStereoDisTrialHoldReward%;
    
    
'OneStimDiscrim Dialog variables
const recOneStimDiscrimNumExps% := 40;
var recOneStimDiscrimExpNameLoad$[recOneStimDiscrimNumExps%];
var recOneStimDiscrimStimcalNameLoad$[recOneStimDiscrimNumExps%];
var recOneStimDiscrimStimcalDistractorNameLoad$[recOneStimDiscrimNumExps%];
var recOneStimDiscrimTrialsNameLoad$[recOneStimDiscrimNumExps%];
var recOneStimDiscrimExpIndexLoad%;
var recOneStimDiscrimExpNameGen$[recOneStimDiscrimNumExps%];
var recOneStimDiscrimStimNameGen$[recOneStimDiscrimNumExps%];
var recOneStimDiscrimTrialsNameGen$[recOneStimDiscrimNumExps%]; 
var recOneStimDiscrimExpIndexGen%;

const recOneStimDiscrimGNGNumExps% := 40;
var recOneStimDiscrimGNGExpNameLoad$[recOneStimDiscrimGNGNumExps%];
var recOneStimDiscrimGNGStimcalNameLoad$[recOneStimDiscrimGNGNumExps%];
var recOneStimDiscrimGNGStimcalDistractorNameLoad$[recOneStimDiscrimGNGNumExps%];
var recOneStimDiscrimGNGTrialsNameLoad$[recOneStimDiscrimGNGNumExps%];
var recOneStimDiscrimGNGExpIndexLoad%;
var recOneStimDiscrimGNGExpNameGen$[recOneStimDiscrimGNGNumExps%];
var recOneStimDiscrimGNGStimNameGen$[recOneStimDiscrimGNGNumExps%];
var recOneStimDiscrimGNGTrialsNameGen$[recOneStimDiscrimGNGNumExps%]; 
var recOneStimDiscrimGNGExpIndexGen%;

var recOneStimDiscrimExpDoFC%;
var recOneStimDiscrimExpDoGen%;
var recOneStimDiscrimExpDoLoad%;       
var recOneStimDiscrimExpDoGNG%;
var recOneStimDiscrimDoRove%;               'Do we rove?
var recOneStimDiscrimRovedB;                'How much do we rove? 
var recOneStimDiscrimActive%;               'Active task? 
var recOneStimDiscrimTrialInitReward%; 
var recOneStimDiscrimTrialHoldReward%; 
var recOneStimDiscrimTarget1Ind%;
var recOneStimDiscrimVersusInd%;
var recOneStimDiscrimTarget2Ind%;
var recOneStimDiscrimValue;
var recOneStimDiscrimValue$;  'We are going to allow either a number OR a string here, so now we have to hold it as a string
var recOneStimDiscrimExptType%;
var recOneStimDiscrimExptLabel$;  'recOneStimDiscrimExptType$ can't be used, it's defined in the dialog
var recUpdateRewardByGap% := 0;   'This is listed under OneStimDiscrim because for now it can only be used in the Boilermaker context


'Generic
var recExpName$[recStereoDisNumExps%];  'All the NumExps are the same...if that changes, this will be more complicated.
var recStimcalName$[recStereoDisNumExps%];
var recStimcalDistractor$[recStereoDisNumExps%];  
var recTrialsName$[recStereoDisNumExps%];
    






'
'
'Begin Dialog/DialogChanged functions
'================================================================================================


'
'
'===== RecDebugDialog =====

'A dialog used during debugging which allows use to variously "shut off" Matlab/TDT/CED capabilities

func RecDebugDialog%()
    
    var i%;
    var status% := 0;
    var debugLoc$[3];
    
    debugLoc$[0] := "No Debug Logging";
    debugLoc$[1] := "Debug Logging, Rec Lab";
    debugLoc$[2] := "Debug Logging, Jeff in lobby";
    
    ' Fetch parameters from registry    
    RecDebugGetParams();   'RecDebugGetParams() is below 
    
    ' Before the registry value is established, the value of LongDur3 will be 100.02, fix this due to constraints on dialog
    if LongDur3 > 100 then
        LongDur3 := 100;
    endif
    
    ' Generate the dialog
    
    DlgCreate("Debug Dialog",0,0,52,11);
    DlgCheck(1, "Matlab is present");
    DlgCheck(2, "TDT is present");
    DlgCheck(3, "CED 1401 is present");
    DlgCheck(4, "Calibration file is present");
    DlgCheck(5, "Do Sound Recording");
    'DlgCheck(6, "Do Debug Logging");
    DlgList(6,30,debugLoc$[],3);
    DlgReal(7,"Duration of Longest Regular Stimulus (s)",0.5,recMaxStimLengthSec);
    DlgReal(8,"Duration of Longest Long Tone/Noise (s)",25,100);
    'DlgReal(7,"Stimulus play rate (Hz)",1000,100000);  'Note, NOT saving value to registry, must explicitly override 100kHz every time you override
    DlgCheck(9,"Use Memory-Lite Version, No Experiment Switching");
    
    ' Show the dialog. 
    i%:=DlgShow(recMatlabIsPresent%, recTDTIsPresent%, recCEDIsPresent%, recCalibIsPresent%, recSoundRecording%, recDebug%, recThisStimLengthSec, LongDur3, recUseLiteMemory%);
    
    ' If user hit OK then save parameters (and return 1). 
	if i% = 1 then
        RecDebugSaveParams();   'ReDebugSaveParams() is below
        'Adjust LongDur3 to have ramp outside of specified duration, as for LongDur0-2, must do this in dialog before creating transfer variable
        LongDur3 := LongDur3 + 0.020;
        if recMatlabIsPresent% = 0 then
            LogInfo("User reports no Matlab present.  Running in testing mode.  Bypassing all Matlab calls.");
        endif
        if recTDTIsPresent% = 0 then
            LogInfo("User reports no TDT present.  Running in testing mode.  Bypassing all TDT calls."); 
        endif
        if recCEDIsPresent% = 0 then
            LogInfo("User reports no 1401 present.  Running in testing mode.  Bypassing all 1401 calls.");
        endif
        status% := 1;
    else
        status% := 0;
    endif
    
	return status%;
   
end;

'===== End RecDebugDialog =====
'
'


'
'
'===== RecExpSelectDialog =====

'A dialog which allows the selection of experiments

func RecExpSelectDialog%()
    
    var i%;
    var j%;
    var status% := 0;  
    var spkArr$[5];
    var spkArr1$[3];
    var spkArr2$[3];
    var fsArr$[2];
    var fsPlayArr$[3];
    var levText$;
'    spkArr$[0] := "None";
'    spkArr$[1] := "15";
'    spkArr$[2] := "16";
'    spkArr$[3] := "StandAlone";
'    spkArr$[4] := "StdAlNoPA4";
    
    spkArr1$[0] := "None";
    spkArr1$[1] := "15";
    spkArr1$[2] := "16";
    
    spkArr2$[0] := "None";
    spkArr2$[1] := "StandAlone";
    spkArr2$[2] := "StdAlNoPA4";
    
    fsPlayArr$[0] := "100000";
    fsPlayArr$[1] := "48000";
    fsPlayArr$[2] := "44100";
    
    fsArr$[0] := "50000";  
    fsArr$[1] := "30000";
    
    RecExpSelectDialogGetParams();
    
    recExpSelectDialogAllowOK% := 0;  'Disable OK button to start, force selection of experiment
    
    'get the LeverJoystick parameters so we know whether the Joystick or Lever is initially selected
    RecLeverJoystickGetParams(); 
    docase    
    case recUseJoystick% = 0 then
        levText$ := "    Lever Selected     ";
    case recUseJoystick% = 1 then
        levText$ := "  Joystick Selected    ";
    case recUseJoystick% = 2 then
        levText$ := " Joystick (-X) Selected";
    case recUseJoystick% = 3 then
        levText$ := " Joystick (-Y) Selected";
    case recUseJoystick% = 4 then
        levText$ := "Joystick (-XY) Selected";
    endcase;

    'Just DO this, even if we're not using the joystick.  Because I want it to just work.
    GetJoystickDegreesInVoltage(joystickVoltageConversionFactor);
    
    'Set the GNG sandbox to -1 (don't check)
    recCheckGNGSandbox% := -1;
    
    ' Generate the dialog
    
    DlgCreate("Experiment Selection Dialog",0,0,52,20);
    
    DlgGroup("Experimental Details", 1,1,50,8);
    DlgString(1,"Monkey Name",10,"",17,2);  'currently no "legal" specified, meaning all characters OK
    DlgText("File suffix letter",32,2); DlgString(7,"|e.g., a,b,c,d...",2,"",46,2);  'currently no "legal" specified, meaning all characters OK; max 2chars
    DlgInteger(2,"Number of electrodes (0 for behavioral)",-1,21,0,3); 
    DlgCheck(3,"Add Electrode Filter?",2,4);
    DlgInteger(4,"Number of BAKs",0,2,0,5);
    DlgList(5,"Speaker array, first (left) PA4",spkArr1$[],10,0,6);
    DlgList(6,"Speaker array, second (right) PA4",spkArr2$[],10,0,7);
    
    DlgGroup("Experiments", 1,9,50,6);
    DlgButton(0,"         Quit         ");
    DlgButton(1,"          OK          ");
    DlgButton(recExpSearchButton%,    "              Search              ", RecExpSearchDialog%, 2, 10);
    DlgButton(recExpCharButton%,      "      Characterization      ",       RecExpCharDialog%, 2, 11);
    DlgButton(recExpAMDiscButton%,    "            AM Disc.           ",    RecExpAMDiscDialog%, 26, 10);
    DlgButton(recExpSpaceDisButton%,  "          Space Disc          ",     RecExpSpaceDisDialog%, 26, 11);
    DlgButton(recExpCueingButton%,    "             Cueing             ",   RecExpCueingDialog%, 26, 12);
    DlgButton(recExpJoyTrnButton%,    " Joy Train (no stimulus)  ",         RecJoyTrainDialog%, 2, 12); 'will go under FRA button '*jao
    DlgButton(recExpAudiogramButton%, "           Audiogram           ",    RecAudiogramDialog%, 2, 13);  
    DlgButton(recExpStereoDisButton%, "     Stereo Distractor     ",        RecExpStereoDisDialog%, 26, 13);
    DlgButton(recExpLongToneButton%,  "           Long Tone           ",    RecLongToneDialog%, 2, 14); 
    DlgButton(recExpOneStimDiscrimButton%,  "     One Stim Discrim     ",   RecExpOneStimDiscrimDialog%, 26, 14); 
    
    'DlgGroup("Change Timing/Reward Parameters", 1,13,50,2);
    DlgButton(recExpTimingRewardButton%, "   Timing/Reward    ", RecExpTimingRewardDialog%, 2, 8);
    DlgButton(recLeverJoystickButton%, levText$, RecExpLeverJoystickDialog%, 30, 8);
    
    DlgCheck(8,"Shuffle Stimuli",2,15);
    DlgCheck(9,"Turn Off Reward",2,16);
    DlgList(10,"Audio play rate (Hz)",fsPlayArr$[],10,0,17);
    DlgList(11,"Electrode sampling rate (Hz)",fsArr$[],11,0,18);
    
    
    DlgAllow(0xffff, 0, RecExpSelectDialogChanged%);
    
    ' Show the dialog. 
    i%:=DlgShow(recMonkPrefix$,recNElectrodes%,recAddFilter%,recNBAKs%,recSpeakerArrayIndex%,
    recSpeakerArrayIndex2%,blockTag$,recShuffle%,recTurnOffReward%,recExpSelectPlayRateIndex%,recExpSelectSamplingRateIndex%); 
    
    ' If user hit OK then save parameters (and return 1). 
	if i% = 1 then
        
        'Assign speaker number, old single PA4 version
'        docase
'        case recSpeakerArrayIndex% = 1 then
'            recNSpeakers% := 15;
'        case recSpeakerArrayIndex% = 2 then
'            recNSpeakers% := 16;
'        case recSpeakerArrayIndex% = 3 then
'            recNSpeakers% := 11;  %11-speaker array does not actually exist
'        endcase;
        
        'Assign audio playback rate
        docase
        case recExpSelectPlayRateIndex% = 0 then
            recPlayRateHzCurrent := 100000;
        case recExpSelectPlayRateIndex% = 1 then
            recPlayRateHzCurrent := 48000; 
        case recExpSelectPlayRateIndex% = 2 then
            recPlayRateHzCurrent := 44100;            
        endcase
            
        'Assign sampling rate
        docase
        case recExpSelectSamplingRateIndex% = 0 then
            recSamplingRateHzRequested := 50000;
        case recExpSelectSamplingRateIndex% = 1 then
            recSamplingRateHzRequested := 30000;            
        endcase
        
        'Assign speaker number and PA4 variables.  This is more complicated since the addition of a second PA4.
        'Speaker number has to be either 15 or 16, we do not have any scenarios which currently allow ONLY the
        'standalone speaker, nor any that allow two arrays, so recNSpeakers% applies to the main array, of which
        'there must be exactly one.
        '
        'Note that because there is only one PM1, there is little incentive to allow "array2" to be either the 15 or 16 array.
        'The PM1 is "hard" wired to what ends up being "array1" anyways.  Please note that the value in recSpeakerArrayIndex2%
        'has changed due to the 15/16 arrays being removed from the dialog.  This has repercussions for the "Param1" sampletext
        'written in RecGoNoGoEngine/WriteExpParamsSampleText() that were fixed and must be accounted for if this scheme is changed.
        
        'Removed ability to have the array on either output
'        docase
'        case recSpeakerArrayIndex% = 1 or recSpeakerArrayIndex2% = 1 then  'both cannot be 1 due to the DlgAllow function
'            recNSpeakers% := 15;
'        case recSpeakerArrayIndex% = 2 or recSpeakerArrayIndex2% = 2 then  'both cannot be 2 due to the DlgAllow function
'            recNSpeakers% := 16; 
'        endcase;
        
        docase
        case recSpeakerArrayIndex% = 1 then  
            recNSpeakers% := 15;
        case recSpeakerArrayIndex% = 2 then  
            recNSpeakers% := 16; 
        endcase;
        
        'Assign PA4 variables
'        docase
'        case recSpeakerArrayIndex% = 1 or recSpeakerArrayIndex% = 2 then
'            arrayPA4ID% := xlnFirstPA4%;
'        case recSpeakerArrayIndex2% = 1 or recSpeakerArrayIndex2% = 2 then
'            arrayPA4ID% := xlnSecondPA4%;
'        else
'            message("Whoa! There does not appear to be an array selected and you should not have gotten this far!");
'            view(recLog%).print("ERROR: Array not selected, quitting!\n");
'            halt;
'        endcase
'        
'        docase 
'        case recSpeakerArrayIndex% = 3 then
'            standalonePA4ID% := xlnFirstPA4%;
'        case recSpeakerArrayIndex2% = 3 then
'            standalonePA4ID% := xlnSecondPA4%;
'        else
'            standalonePA4ID% := -1;  'No standalone PA4
'        endcase
        
        'Assign PA4 variables
        docase
        case recSpeakerArrayIndex% = 1 or recSpeakerArrayIndex% = 2 then
            arrayPA4ID% := xlnFirstPA4%;
        else
            message("Whoa! There does not appear to be an array selected and you should not have gotten this far!");
            view(recLog%).print("ERROR: Array not selected, quitting!\n");
            halt;
        endcase
        
        docase 
        
        case recSpeakerArrayIndex2% = 1 then
            standalonePA4ID% := xlnSecondPA4%;
        else
            standalonePA4ID% := -1;  'No standalone PA4
        endcase
        
        'So now we have assigned recNSpeakers% to work as it always has, and two PA4IDs to be used when calling RecAttenByID%()
        
        RecExpSelectDialogSaveParams();
        
        
        'After saving parameters, zero out value of recAddFilter% if there are no electrodes
        if recNElectrodes% < 1 then
            recAddFilter% := 0;  'this may never be strictly necessary, but just in case
        endif
        
        
        'Note name of file in external log file
        view(recLog%).print("Current file is " + recMonkPrefix$ + "_"+ Date$(2,2,3,3,"-")+ blockTag$ + ".smrx\n");
        
        
        status% := 1;
    else
        status% := 0;
    endif
    
	return status%;
   
end;

'===== End RecExpSelectDialog =====
'
'




'
'
'===== RecExpSelectDialogChanged =====

' This function is initially called with a "0" input
func RecExpSelectDialogChanged%(item%) 
    var levText$;
    var speakersOK% := 0;
    
    'Identifying legal speaker setups
    'Basically, at least one must be an array, they can't both be arrays
    'This is no longer relevant since we are NOT allowing "swapping" of the arrays, the PM1 will always be connected to the first output
'    docase
'    case (DlgValue(4) = 1 or DlgValue(4) = 2) and (DlgValue(5) = 0 or DlgValue(5) = 3 or DlgValue(5) = 4) then
'        speakersOK% := 1;
'    case (DlgValue(5) = 1 or DlgValue(5) = 2) and (DlgValue(4) = 0 or DlgValue(4) = 3 or DlgValue(4) = 4) then
'        speakersOK% := 1;    
'    endcase
    'If a standalone is requested for the wrong experiment, the easiest thing to do is ignore it (but an error would be nice)
    
    docase
    case (DlgValue(4) = 1 or DlgValue(4) = 2) then
        speakersOK% := 1;
    case (DlgValue(5) = 1 or DlgValue(5) = 2) then
        speakersOK% := 1;    
    endcase
    
    'Disable two buttons, note that this allows the remainder of the infrastructure for these expts to remain intact
    'DlgEnable(0,-recExpStereoDisButton%);  'Almost certainly broken, see GenTrialsStereoDis%() for more details
    DlgEnable(0,-recExpCueingButton%);  'Never full implemented
    
    
    'Disable the electrode filter checkbox if there are no electrodes specified
    'Note that in the future we may make this more flexible than just a single filter
    if DlgValue(2) > 0 then
        DlgEnable(1,3);  'Enable electrode filter checkbox
    else
        DlgEnable(0,3);  'Disable electrode filter checkbox
    endif
    
    
    'This disables the "OK" button (though it will have different labels) until an experiment is selected
    'AND a file name is chosen AND a number of electrodes is entered AND the speaker array selection is legal
    
    'if recExpSelectDialogAllowOK% = 1 and len(DlgValue$(1)) > 0 and DlgValue(2) > -1 and DlgValue(3) > 0 then
    if recExpSelectDialogAllowOK% = 1 and len(DlgValue$(1)) > 0 and DlgValue(2) > -1 and speakersOK% = 1 then
        DlgEnable(1,-1);  'enable "OK" 
    else
        DlgEnable(0,-1);  'Otherwise disable "OK"
    endif;
    
    'change button text based on selected response device
    docase    
    case recUseJoystick% = 0 then
        levText$ := "    Lever Selected     ";
    case recUseJoystick% = 1 then
        levText$ := "  Joystick Selected    ";
    case recUseJoystick% = 2 then
        levText$ := " Joystick (-X) Selected";
    case recUseJoystick% = 3 then
        levText$ := " Joystick (-Y) Selected";
    case recUseJoystick% = 4 then
        levText$ := "Joystick (-XY) Selected";
    endcase;
    DlgValue$(-recLeverJoystickButton%, levText$);
    
    return 1;
end

'===== End RecExpSelectDialogChanged =====
'
'



'
'
'===== RecExpSearchDialog =====

'A dialog for the Search experiment

func RecExpSearchDialog%()
    
    var i%;
    var status% := 0;
    var inds%[10];
    var j%;
    for j% := 0 to 9 do
        inds%[j%] := j%;
    next;
    var fiveInts%[5];
    var fourInts%[4];
    
    const searchListLen% := 7;
    var searchList$[searchListLen%];
    searchList$[0] := "Tones";
    searchList$[1] := "Broadband Noise";
    searchList$[2] := "Bandpass Noise";
    searchList$[3] := "Clicks";
    searchList$[4] := "Tone Sweeps";
    searchList$[5] := "Speaker Sweep (BbN)";
    searchList$[6] := "FM Sweeps";
    
    ' Fetch parameters from registry    
    RecSearchGetParams();
    
    'Set fiveInts%[] from registry values
    fiveInts%[0] := recSearchToneSweepNSteps%;
    fiveInts%[1] := recSearchS1Speaker%;
    fiveInts%[2] := recSearchS2Speaker%;
    fiveInts%[3] := recSearchMinS1%;
    fiveInts%[4] := recSearchVarS1%;
    
    'Set fourInts%[] from registry values
    fourInts%[0] := recSearchWMPorts%[0];
    fourInts%[1] := recSearchWMPorts%[1];
    fourInts%[2] := recSearchWMPorts%[2];
    fourInts%[3] := recSearchWMPorts%[3];
    
    
    if recSearchStimType% = 4 then
        ' Initial calculation of dB steps for tone sweeps
        GetLogProgression(recSearchToneSweepLowLim, recSearchToneSweepUpperLim, recSearchToneSweepNSteps%-1, recSearchToneSweepFreqList[]); 
        'GetLinearProgression(recSearchToneSweepLowLim, recSearchToneSweepUpperLim, recSearchToneSweepNSteps%-1, recSearchToneSweepFreqList[]);        
        ' Followed by initial stringification
        recSearchToneSweepFreqList$ := StringifyProgression2$(recSearchToneSweepNSteps%, recSearchToneSweepFreqList[0:recSearchToneSweepNSteps%], inds%[],0);
    else
        recSearchToneSweepFreqList$ := ""; 'Start with empty text if not doing tone sweeps
    endif;
    

    ' Generate the dialog    
    DlgCreate("Search Dialog",0,0,92,21);
    
    DlgGroup("Stimulus Selection",1,1,90,8);
    DlgList(1,"Select Experiment",searchList$[],searchListLen%,19,2);  '19 is min width for this dialog
    
    DlgGroup("Tones",40,2,22,2);
    DlgReal(2,6,0.001,50000,55,3);  'Frequency
    DlgText("Frequency, Hz",41,3);
    
    DlgGroup("Band Pass Noise",40,4,22,3);
    DlgReal(3,6,0,49999,55,5);  'BP lower limit
    DlgText("Lower Limit, Hz",41,5);
    DlgReal(4,6,0.001,50000,55,6);  'BP upper limit
    DlgText("Upper Limit, Hz",41,6);
    
    DlgGroup("Speaker Sweep",2,3,37,2);
    DlgText("Repeats for speaker sweep:",3,4);
    DlgInteger(17,3,1,10,28,4);
    
    DlgGroup("FM Sweeps",2,5,37,3);
    DlgText("Start Freq, Hz",3,6);
    DlgReal(18,6,20,30000,16,6);
    DlgText("End Freq, Hz",3,7);
    DlgReal(19,6,20,30000,16,7);
    DlgText("# Reverses",23,6);
    DlgInteger(20,4,0,9,34,6);
    DlgText("Duration, s",23,7);
    DlgReal(21,4,0.1,10,34,7);
    

    DlgGroup("Tone Sweep",63,2,27,5);
    DlgInteger(5,6,1,100,83,3);  'Tone sweep repeats
    DlgText("Repeats of each tone",64,3);
    DlgReal(6,6,0.001,49999,83,4);  'Tone sweep low freq
    DlgText("Low Frequency, Hz",64,4);
    DlgReal(7,6,0.002,50000,83,5);  'Tone sweep high freq
    DlgText("High Frequency, Hz",64,5);
    DlgInteger(8,6,2,10,83,6);  'Tone sweep number of steps
    DlgText("Number of Steps",64,6);
    
    DlgText("Tone Sweep Steps:",2,8);
    recSearchToneSweepFreqList% := DlgText(recSearchToneSweepFreqList$,18,8,50);
    
    
    DlgGroup("Variables",1,10,90,6);
    DlgInteger(9,6,0,20,55,11);  'S1 speaker
    DlgText("S1 Speaker",41,11);
    DlgInteger(10,6,0,20,83,11);  'S2 speaker
    DlgText("S2 Speaker",64,11);
    
    ' djs 7/19/2018 Change min allowed value to 2 here. 
    ' Program logic converts this to an index, and tests the value of the stim index AFTER it has been incremented. 
    ' The test is equality, so if the var here is 1, the index is 0, and the first time the test is performed 
    ' (see RecGoNoGoEngine.s2s, line 1098)
    
    DlgInteger(11,6,2,19,55,12);  'Min S1
    DlgText("Minimum S1 Presentations",30,12);
    DlgInteger(12,6,0,19,55,13);  'Var S1
    DlgText("Variable S1 Presentations",30,13);
    DlgReal(13,6,0,1,55,14);  'Proportion of catch trials
    DlgText("Proportion of Catch Trials",30,14);
    DlgReal(14,6,0,100,83,13);  'dB level
    DlgText("dB Level",64,13);
    DlgCheck(15,"",54,15);  'Monkey does lever task
    DlgText("Monkey Does Lever Task",30,15);
    DlgCheck(16,"",82,15);  'Use Fixation LED
    DlgText("Use Fixation LED",64,15);
    
    
    DlgGroup("PSTH Settings",1,17,90,3);
    DlgCheck(22,"",20,18);  'Do PSTH
    DlgText("Make Search PSTH",2,18);
    DlgInteger(23,6,-1,31,55,18);  'WM port 1, do not confuse user with 0-based values here!
    DlgText("WaveMark Port 1",30,18);
    DlgInteger(24,6,-1,31,83,18);  'WM port 2 
    DlgText("WaveMark Port 2",64,18);
    DlgInteger(25,6,-1,31,55,19);  'WM port 3
    DlgText("WaveMark Port 3",30,19);
    DlgInteger(26,6,-1,31,83,19);  'WM port 4 
    DlgText("WaveMark Port 4",64,19);
    
    
    
    DlgAllow(0xffff, 0, RecExpSearchDialogChanged%);
    
    ' Show the dialog. 
    i%:=DlgShow(recSearchStimType%,recSearchToneFreq,recSearchBPLowerLim,recSearchBPUpperLim,recSearchToneSweepRepeats%,
                recSearchToneSweepLowLim,recSearchToneSweepUpperLim,fiveInts%[],recSearchPropCatch,recSearchdBLevel,
                recSearchActive%,recSearchFixLED%,recSearchSpeakerSweepRepeats%,recSearchFMStartFreq,
                recSearchFMEndFreq,recSearchFMNumReverses%,recSearchFMDur,recSearchDoPSTH%,fourInts%[]);
    
    
    ' If user hit OK then save parameters (and return 1). 
	if i% = 1 then 
        'Unpack fiveInts%[]
        recSearchToneSweepNSteps% := fiveInts%[0];
        recSearchS1Speaker% := fiveInts%[1];
        recSearchS2Speaker% := fiveInts%[2];
        recSearchMinS1% := fiveInts%[3];
        recSearchVarS1% := fiveInts%[4];
        
        'Unpack fourInts%[]
        recSearchWMPorts%[0] := fourInts%[0];
        recSearchWMPorts%[1] := fourInts%[1];
        recSearchWMPorts%[2] := fourInts%[2];
        recSearchWMPorts%[3] := fourInts%[3];
        
        RecSearchSaveParams();
        recExptText$ := searchList$[recSearchStimType%];  'this puts the stimulus type into the values which will be SampleText'ed
        recDoRove% := 0;  'Do not allow roving in search
        
        'Set the GNG sandbox to -1 (don't check, value isn't present in this dialog)
        recCheckGNGSandbox% := -1;
        
        
        if recSearchMinS1% + recSearchVarS1% <= recMaxStimPerTrial%-1 then
            'Reset dialog OK button text on Select dialog, and note which experiment to run
            DlgValue$(-1,"Run Search");
            'DlgEnable(1,3);  'make sure that the Nspeakers selection item is enabled on the main dialog - this is now # BAKs, so ??? -jj 11/4/21
            recExpToRun% := recExpSearchButton%;
            recExpSelectDialogAllowOK% := 1;  'Prepare to enable OK button
            recExpSelectDialogChanged%(-1);  'Enables "OK" button, -1 is sham input
        
            'assign Search-specific variables to experiment-wide variables (so we can keep separate defaults but only code once)
            recS1Speaker% := recSearchS1Speaker%;
            recS2Speaker% := recSearchS2Speaker%;
            recMinS1% := recSearchMinS1%;
            recVarS1% := recSearchVarS1%;
            recPropCatch := recSearchPropCatch;
            recDeltadBLevel := 65-recSearchdBLevel;
            recActive% := recSearchActive%;
            recFixLED% := recSearchFixLED%;
            if recSearchStimType% >= 4 then  'adjustment of values - if doing tone sweep or speaker sweep or FM sweep, do not have task
                recActive% := 0;
                recHitRewardmL := 0;  'don't allow rewards for tone sweep or speaker sweep
                recCRRewardmL := 0;
            endif;
            if recActive% = 0 then 'adjustment of values, if not active, don't have second speaker or catch trials
                recPropCatch := 0;
                recS2Speaker% := recS1Speaker%;
            endif;
            recMatGenStim% := 1; 'Always generate stimuli during Search
            
            'fill stimulus creation variables as if we had loaded a stimfile
            'do indices 0 and 1 because if the S2 is on a different speaker, it has to have a different calibration value, index 1 is the S2
            arrconst(recTrialStimDur[0:2],200);              'Stimulus duration, hard code to 200 for all except variable for FM sweeps
            arrconst(recTrialGenRampMS[0:2],2);          'Duration in ms of front/back ramp, ramp is 1-Cos^2
            'A bunch of stuff we're just not using in Search
            arrconst(recTrialGenIsSweep[0:2],0);        'A list of whether each element is an FM sweep, if 0 no sweep
            arrconst(recTrialGenAMFreqHz[0:2],0);        'A list of AM frequency values, if 0 no AM
            arrconst(recTrialGenAMDepthPct[0:2],0);      'A list of AM depth values in percent, if 0 no depth
            arrconst(recTrialGenAMPhaseDeg[0:2],0);      'A list of AM phases, 0 = AM starts low, 90 = AM starts middle and rising, 180 = AM starts high, 270 = AM starts middle, falling
            arrconst(recTrialGenTonePhaseDeg[0:2],0);    'A list of tone phases, 0 = tone starts middle, rising (sine phase), 90 = tone starts high (cosine phase), note different than AM phase, only used for tone, not noise
            arrconst(recTrialGenGauss%[0:2],1);          'If 1 create Gaussian noise, if 0 create uniform noise
            arrconst(recTrialGenSeed%[0:2],0);           'Seed for random number generator, 0 = unspecified, will make own random number
            docase
            case recSearchStimType% = 0 then 'for tones
                arrconst(recTrialGenLowpassHz[0:2],recSearchToneFreq);       'A list of lowpass values - if -1, no lowpass, same as highpass means tone
                arrconst(recTrialGenHighpassHz[0:2],recSearchToneFreq);      'Same as above, highpass
                printlog("Tone (%f Hz) selected from search dialog\n",recSearchToneFreq);
            case recSearchStimType% = 1 then 'for broadband noise
                arrconst(recTrialGenLowpassHz[0:2],-1);       'A list of lowpass values - if -1, no lowpass, same as highpass means tone
                arrconst(recTrialGenHighpassHz[0:2],-1);      'Same as above, highpass
                printlog("Broadband noise selected from search dialog\n");
            case recSearchStimType% = 2 then 'for bandpass noise
                printlog("Bandpass noise (%f - %f Hz) selected from search dialog\n",recSearchBPLowerLim,recSearchBPUpperLim);
                if recSearchBPLowerLim = 0 then  'reclab_panstim expects -1 for no limit
                    recSearchBPLowerLim := -1;
                endif;
                if recSearchBPUpperLim = 50000 then  'reclab_panstim expects -1 for no limit
                    recSearchBPUpperLim := -1;
                endif;
                arrconst(recTrialGenLowpassHz[0:2],recSearchBPLowerLim);       'A list of lowpass values - if -1, no lowpass, same as highpass means tone
                arrconst(recTrialGenHighpassHz[0:2],recSearchBPUpperLim);      'Same as above, highpass
            case recSearchStimType% = 3 then  'for clicks, we won't use anything, just leave a note
                printlog("Clicks selected from search dialog\n");
            case recSearchStimType% = 4 then  'for tone sweeps
                'arrconst(recTrialStimDur[0:recSearchToneSweepNSteps%],50);
                arrconst(recTrialStimDur[0:recSearchToneSweepNSteps%],200);
                'get the log progression with the new values
                GetLogProgression(recSearchToneSweepLowLim, recSearchToneSweepUpperLim, recSearchToneSweepNSteps%-1, recSearchToneSweepFreqList[]);            
                'GetLinearProgression(recSearchToneSweepLowLim, recSearchToneSweepUpperLim, recSearchToneSweepNSteps%-1, recSearchToneSweepFreqList[]);
                for j% := 0 to recSearchToneSweepNSteps%-1 do
                    recTrialGenLowpassHz[j%] := recSearchToneSweepFreqList[j%];
                    recTrialGenHighpassHz[j%] := recSearchToneSweepFreqList[j%];
                    recTrialGenRampMS[j%] := 2;
                next
                printlog("Tone Sweep selected from search dialog, %d repeats\n",recSearchToneSweepRepeats%); 'n repeats of each tone
                printlog("Tone Sweep Progression is %d Hz\n",recSearchToneSweepFreqList[0:recSearchToneSweepNSteps%]);
            case recSearchStimType% = 5 then 'for speaker sweeps (broadband noise)
                arrconst(recTrialGenLowpassHz[0:2],-1);       'A list of lowpass values - if -1, no lowpass, same as highpass means tone
                arrconst(recTrialGenHighpassHz[0:2],-1);      'Same as above, highpass
                printlog("Speaker sweep (Broadband noise) selected from search dialog %d repeats\n", recSearchSpeakerSweepRepeats%);   
            case recSearchStimType% = 6 then 'for FM tone sweeps
                arrconst(recTrialStimDur[0:2],recSearchFMDur*1000);  'put in duration, we expect ms
                var doFloatMath := recSearchFMNumReverses%;  'Have to put Int into Float to divide by 10 in next line
                arrconst(recTrialGenIsSweep[0:2],1+(doFloatMath/10));  'Decimal holds the number of reverses
                arrconst(recTrialGenLowpassHz[0:2],recSearchFMStartFreq);  'Put in start frequency
                arrconst(recTrialGenHighpassHz[0:2],recSearchFMEndFreq);  'Put in end frequency
                printlog("FM Sweeps (%f - %f Hz, %d reversals) selected from search dialog\n",recSearchFMStartFreq,recSearchFMEndFreq,recSearchFMNumReverses%);
            endcase
            
        else
            message("The number of variable + constant S1s is greater than the maximum allowed number (%d)",recMaxStimPerTrial%-1);
            DlgValue$(-1,"OK");
            recExpSelectDialogAllowOK% := 0;  'Prepare to disable OK button
            recExpSelectDialogChanged%(-1);  'Enables "OK" button, -1 is sham input
        endif;            
            
        'We might need to specify a number of trials here...I'm assuming yes.  Note that SEARCH runs until the
        'user stops it, but this may be difficult to implement in practice - it would require fresh round(s) of
        'trial list generation that don't happen for other experiment types.  Most likely the easiest way to do
        'this is just to make a huge number of trials that the user won't exhaust, like 10,000 or something.
        
        status% := 1;
    else
        status% := 1;
    endif
    
	return status%;
   
end;

'===== End RecExpSearchDialog =====
'
'




'
'
'===== RecExpSearchDialogChanged =====

' This function is initially called with a "0" input
func RecExpSearchDialogChanged%(item%) 
    var checkLeverTaskVariable% := 1;  'do we check the lever task variable?  By default, yes.
    var inds%[10];
    var j%;
    for j% := 0 to 9 do
        inds%[j%] := j%;
    next;
    
    docase
    case DlgValue(1) = 0 then  'Tones
        DlgEnable(1,2);  'Enable frequency
        DlgEnable(0,3);  'Disable bandpass noise
        DlgEnable(0,4);
        DlgEnable(0,5);  'Disable tone sweep
        DlgEnable(0,6); 
        DlgEnable(0,7);
        DlgEnable(0,8);
        DlgEnable(0,17); 'Disable speaker sweep
        DlgEnable(0,18); 'Disable FM sweep
        DlgEnable(0,19); 
        DlgEnable(0,20);
        DlgEnable(0,21);
        DlgEnable(1,10); 'Enable S2 speaker
        DlgEnable(1,13); 'Enable prop. catch trials
        DlgEnable(1,14); 'Enable dB level
        DlgEnable(1,15); 'Enable lever task
    case DlgValue(1) = 1 then  'Broadband noise
        DlgEnable(0,2);  'Disable frequency
        DlgEnable(0,3);  'Disable bandpass noise
        DlgEnable(0,4);
        DlgEnable(0,5);  'Disable tone sweep
        DlgEnable(0,6); 
        DlgEnable(0,7);
        DlgEnable(0,8);
        DlgEnable(0,17); 'Disable speaker sweep
        DlgEnable(0,18); 'Disable FM sweep
        DlgEnable(0,19); 
        DlgEnable(0,20);
        DlgEnable(0,21);
        DlgEnable(1,10); 'Enable S2 speaker
        DlgEnable(1,13); 'Enable prop. catch trials
        DlgEnable(1,14); 'Enable dB level
        DlgEnable(1,15); 'Enable lever task
    case DlgValue(1) = 2 then  'Band pass noise
        DlgEnable(0,2);  'Disable frequency
        DlgEnable(1,3);  'Enable bandpass noise
        DlgEnable(1,4);
        DlgEnable(0,5);  'Disable tone sweep
        DlgEnable(0,6); 
        DlgEnable(0,7);
        DlgEnable(0,8);
        DlgEnable(0,17); 'Disable speaker sweep
        DlgEnable(1,10); 'Enable S2 speaker
        DlgEnable(1,13); 'Enable prop. catch trials
        DlgEnable(1,14); 'Enable dB level
        DlgEnable(1,15); 'Enable lever task
    case DlgValue(1) = 3 then  'Clicks
        DlgEnable(0,2);  'Disable frequency
        DlgEnable(0,3);  'Disable bandpass noise
        DlgEnable(0,4);
        DlgEnable(0,5);  'Disable tone sweep
        DlgEnable(0,6); 
        DlgEnable(0,7);
        DlgEnable(0,8);
        DlgEnable(0,17); 'Disable speaker sweep
        DlgEnable(0,18); 'Disable FM sweep
        DlgEnable(0,19); 
        DlgEnable(0,20);
        DlgEnable(0,21);
        DlgEnable(1,10); 'Enable S2 speaker
        DlgEnable(1,13); 'Enable prop. catch trials
        DlgEnable(0,14); 'Disable dB level
        DlgEnable(1,15); 'Enable lever task        
    case DlgValue(1) = 4 then  'Tone Sweep
        DlgEnable(0,2);  'Disable frequency
        DlgEnable(0,3);  'Disable bandpass noise
        DlgEnable(0,4);
        DlgEnable(1,5);  'Enable tone sweep
        DlgEnable(1,6); 
        DlgEnable(1,7);
        DlgEnable(1,8);
        DlgEnable(0,17); 'Disable speaker sweep
        DlgEnable(0,18); 'Disable FM sweep
        DlgEnable(0,19); 
        DlgEnable(0,20);
        DlgEnable(0,21);
        DlgEnable(0,10); 'Disable S2 speaker
        DlgEnable(0,13); 'Disable prop. catch trials
        DlgEnable(1,14); 'Enable dB level
        DlgEnable(0,15); 'Disable lever task
        checkLeverTaskVariable% := 0;  'don't check lever task variable
    case DlgValue(1) = 5 then 'Speaker Sweep
        DlgEnable(0,2);  'Disable frequency
        DlgEnable(0,3);  'Disable bandpass noise
        DlgEnable(0,4);
        DlgEnable(0,5);  'Disable tone sweep
        DlgEnable(0,6); 
        DlgEnable(0,7);
        DlgEnable(0,8);
        DlgEnable(1,17); 'Enable speaker sweep
        DlgEnable(0,18); 'Disable FM sweep
        DlgEnable(0,19); 
        DlgEnable(0,20);
        DlgEnable(0,21);
        DlgEnable(0,10); 'Disable S2 speaker
        DlgEnable(0,13); 'Disable prop. catch trials
        DlgEnable(1,14); 'Enable dB level
        DlgEnable(0,15); 'Disable lever task 
        checkLeverTaskVariable% := 0;  'don't check lever task variable  
    case DlgValue(1) = 6 then 'FM Sweep
        DlgEnable(0,2);  'Disable frequency
        DlgEnable(0,3);  'Disable bandpass noise
        DlgEnable(0,4);
        DlgEnable(0,5);  'Disable tone sweep
        DlgEnable(0,6); 
        DlgEnable(0,7);
        DlgEnable(0,8);
        DlgEnable(0,17); 'Disable speaker sweep
        DlgEnable(1,18); 'Enable FM sweep
        DlgEnable(1,19); 
        DlgEnable(1,20);
        DlgEnable(1,21);
        DlgEnable(0,10); 'Disable S2 speaker
        DlgEnable(0,13); 'Disable prop. catch trials
        DlgEnable(1,14); 'Enable dB level
        DlgEnable(0,15); 'Disable lever task 
        checkLeverTaskVariable% := 0;  'don't check lever task variable         
    endcase;
    
    if checkLeverTaskVariable% = 1 then
        if DlgValue(15) = 0 then  'if no lever task
            DlgEnable(0,10); 'Disable S2 speaker
            DlgEnable(0,13); 'Disable prop. catch trials
        else
            DlgEnable(1,10); 'Enable S2 speaker
            DlgEnable(1,13); 'Enable prop. catch trials
        endif;
    endif;
    
    'update tone sweep numbers
    if item% = 1 or item% = 6 or item% = 7 or item% = 8 then
        if DlgValue(1) <> 4 then
            recSearchToneSweepFreqList$ := "";
            'Update GUI
            DlgValue$(recSearchToneSweepFreqList%,recSearchToneSweepFreqList$);
    else
        'TODO:check High and Low Freq values before calling GetLogProgression (or make sure there is a valid FreqList)
            GetLogProgression(DlgValue(6), DlgValue(7), DlgValue(8)-1, recSearchToneSweepFreqList[]);   
            'GetLinearProgression(DlgValue(6), DlgValue(7), DlgValue(8)-1, recSearchToneSweepFreqList[]);   
            recSearchToneSweepFreqList$ := StringifyProgression2$(DlgValue(8), recSearchToneSweepFreqList[0:DlgValue(8)], inds%[],0);
            'Update GUI
            DlgValue$(recSearchToneSweepFreqList%,recSearchToneSweepFreqList$);
        endif;
    endif;
    
    'Check PSTH values
    if recCurrentlySampling% > 0 then
        DlgEnable(0,22); 'Disable DoPSTH - if we are currently samling we gotta run with what's already set up
    else
        DlgEnable(1,22); 'Enable if sampling has not started yet - obviously to get a PSTH Search must be the first scenario
    endif;
    
    if DlgValue(22) = 0 or recCurrentlySampling% > 0 then
        DlgEnable(0,23); 'Disable WM ports
        DlgEnable(0,24);
        DlgEnable(0,25);
        DlgEnable(0,26);
    else
        DlgEnable(1,23); 'Enable WM ports
        DlgEnable(1,24);
        DlgEnable(1,25);
        DlgEnable(1,26);
    endif;
    
    return 1;
end

'===== End RecExpSearchDialogChanged =====
'
'



'
'
'===== RecExpCharDialog =====

'A dialog for the Characterization experiments

func RecExpCharDialog%()
    var eightInts%[8];
    var threeInts%[3];
    var fiveInts%[5];
    '    var astring$;
    var i%;
    var k%;
    var status% := 0;  
    var inds%[10];
    var checkOK% := 1;
    var j%;
    for j% := 0 to 9 do
        inds%[j%] := j%;
    next;
    
    var recCharDoLoad$[6];
    recCharDoLoad$[0] := "Use Dialog Values";
    recCharDoLoad$[1] := "Load FRA From Script";   'was load FRA/SigNoise
    recCharDoLoad$[2] := "Load SigNoise From Script";
    recCharDoLoad$[3] := "Generate FRA From Script";  'was in index 2
    recCharDoLoad$[4] := "Generate SigNoise From Script";  'was in index 3
    recCharDoLoad$[5] := "Load Arbitrary Stimuli";
    
    ' Fetch parameters from registry    
    RecCharDialogFRAGetParams();
    RecCharExpListLoadFRAGetParams(recCharExpNameLoadFRA$[],recCharStimcalFileLoadFRA$[],recCharTrialsFileLoadFRA$[]);
    RecCharExpListLoadSigNoiseGetParams(recCharExpNameLoadSigNoise$[],recCharStimcalFileLoadSigNoise$[],recCharTrialsFileLoadSigNoise$[]);
    RecCharExpListGenFRAGetParams(recCharExpNameGenFRA$[],recCharStimFileGenFRA$[],recCharTrialsFileGenFRA$[]);
    RecCharExpListGenSigNoiseGetParams(recCharExpNameGenSigNoise$[],recCharStimFileGenSigNoise$[],recCharTrialsFileGenSigNoise$[]);
    RecCharExpListLoadArbStimGetParams(recCharExpNameLoadArbStim$[],recCharStimcalFileLoadArbStim$[],recCharTrialsFileLoadArbStim$[],recCharExpPrefixLoadArbStim$[]);
    
    threeInts%[0] := recCharS1Speaker%;
    threeInts%[1] := recCharMinS1%;
    threeInts%[2] := recCharVarS1%;
    
    eightInts%[0] := recFMSweepRepeats%;
    eightInts%[1] := recFMSweepStart%;
    eightInts%[2] := recFMSweepEnd%;
    eightInts%[3] := recFMSweepDur1%;
    eightInts%[4] := recFMSweepDur2%;
    eightInts%[5] := recFMSweepDur3%;
    eightInts%[6] := recFMSweepDur4%;
    eightInts%[7] := recFMSweepDur5%;
    
    fiveInts%[0] := recCharExpIndexLoadFRA%;
    fiveInts%[1] := recCharExpIndexLoadSigNoise%;
    fiveInts%[2] := recCharExpIndexGenFRA%;
    fiveInts%[3] := recCharExpIndexGenSigNoise%;
    fiveInts%[4] := recCharExpIndexLoadArbStim%;
    

    ' Initial calculation of dB steps, Freq. steps
    GetLinearProgression(recRateLeveldBLow, recRateLeveldBHigh, recRateLeveldBNSteps%-1, recRateLeveldBList[]);
    GetLinearProgression(recFRATonedBLow, recFRATonedBHigh, recFRAdBNSteps%-1, recFRAdBList[]);
    GetLogProgression(recFRAToneFreqLow, recFRAToneFreqHigh, recFRAFreqNSteps%-1, recFRAFreqList[]);   
    ' Followed by initial stringification
    recRLList1$ := StringifyProgression2$(5, recRateLeveldBList[0:5], inds%[],1);
    recRLList2$ := StringifyProgression2$(5, recRateLeveldBList[5:5], inds%[],1);
    recFRAdBList1$ := StringifyProgression2$(5, recFRAdBList[0:5], inds%[],1);
    recFRAdBList2$ := StringifyProgression2$(5, recFRAdBList[5:5], inds%[],1);
    recFRAFreqList1$ := StringifyProgression2$(10, recFRAFreqList[0:10], inds%[],0);
    recFRAFreqList2$ := StringifyProgression2$(10, recFRAFreqList[10:10], inds%[],0);
    recFRAFreqList3$ := StringifyProgression2$(9, recFRAFreqList[20:9], inds%[],0);
    recFRAFreqList4$ := StringifyProgression2$(8, recFRAFreqList[29:8], inds%[],0);
    recFRAFreqList5$ := StringifyProgression2$(8, recFRAFreqList[37:8], inds%[],0);
    
    
    ' Generate the dialog    
    DlgCreate("Characterization Dialog",0,0,120,30);
    
    DlgGroup("S1 Stimuli",1,1,118,2);
    DlgInteger(1,6,1,16,22,2);
    DlgText("S1 (preferred) Speaker",2,2);
    DlgInteger(2,6,2,3,44,2);
    DlgText("Min S1 Stimuli",31,2);
    DlgInteger(3,6,0,5,66,2);
    DlgText("Var S1 Stimuli",53,2);
    
    
    DlgGroup("Noise (Rate-Level)",2,3,27,8);
    DlgInteger(4,6,1,50,22,4);  'Rate-Level, n repeats
    DlgText("# Noise repeats",3,4);
    DlgReal(5,6,0.001,100,22,6);  'Rate-Level, low dB
    DlgText("dB Level, Low",3,6);
    DlgReal(6,6,0.001,100,22,7);  'Rate-Level, high dB
    DlgText("dB Level, High",3,7);
    DlgText("List of Selected dB Levels:",3,8);
    recRLList1% := DlgText(recRLList1$,3,9,25);
    recRLList2% := DlgText(recRLList2$,3,10,25);
    
    DlgGroup("Tone Pips (FRA)",30,3,88,8);
    DlgInteger(7,6,1,5,47,4);  'Rate-Level, n repeats
    DlgText("# Tone repeats",31,4);
    DlgReal(8,6,0.001,100,47,6);  'FRA low dB
    DlgText("Lower Level, dB",31,6);
    DlgReal(9,6,0.001,50000,47,7);  'FRA high dB
    DlgText("Upper Level, dB",31,7);
    DlgText("List of Selected dB Levels:",31,8);
    recFRAdBList1% := DlgText(recFRAdBList1$,31,9,25);
    recFRAdBList2% := DlgText(recFRAdBList2$,31,10,25);
    DlgReal(10,6,0.001,50000,73,4);  'FRA low frequency
    DlgText("Lower Limit, Hz",59,4);
    DlgReal(11,6,0.001,50000,103,4);  'FRA high frequency
    DlgText("Upper Limit, Hz",89,4);
    DlgText("List of Selected Freqs (rounded to nearest Hz):",59,5);
    recFRAFreqList1% := DlgText(recFRAFreqList1$,59,6,58);  'must set width of text boxes or it is based on
    recFRAFreqList2% := DlgText(recFRAFreqList2$,59,7,58);  'original text and updates can cause some
    recFRAFreqList3% := DlgText(recFRAFreqList3$,59,8,58);  'values to be "invisible" - also done for dB
    recFRAFreqList4% := DlgText(recFRAFreqList4$,59,9,58);  'values above (tone and rate-level) but probably
    recFRAFreqList5% := DlgText(recFRAFreqList5$,59,10,58);  'not crucial there.
    
    DlgGroup("S1 FM Tones",2,11,116,3);
    DlgInteger(12,6,1,50,22,12);  'FM Tones, n repeats
    DlgText("# FM Tone repeats",3,12);
    DlgInteger(13,6,20,10000,47,12);  'FM Tone start
    DlgText("FM Tone Start Hz",31,12);
    DlgInteger(14,6,40,50000,72,12);  'FM Tone end
    DlgText("FM Tone End Hz",56,12);
    DlgText("FM Tone Durs ms",3,13);  'FM Tone durations - only one label
    DlgInteger(15,6,10,1000,22,13); 
    DlgInteger(16,6,10,1000,32,13);
    DlgInteger(17,6,10,1000,42,13);
    DlgInteger(18,6,10,1000,52,13);
    DlgInteger(19,6,10,1000,62,13);    

    DlgGroup("S1 AM Noise",2,14,116,2);
    DlgInteger(20,6,1,50,22,15);  'AM noise, n repeats
    DlgText("# AM Noise repeats",3,15);
    MTFrates[0] := 4;
    MTFrates[1] := 6;
    MTFrates[2] := 8;
    MTFrates[3] := 12;
    MTFrates[4] := 16;
    MTFrates[5] := 24;
    MTFrates[6] := 32;
    MTFrates[7] := 48;
    MTFrates[8] := 64;
    MTFrates[9] := 128;
    MTFrates[10] := 256;
'    astring$ := "MTFrates = "+ StringifyProgression2$(nMTFrates%,MTFrates[],inds%[],1);
    'DlgText(astring$,31,15); 
    DlgText("AM rates = 4,6,8,12,16,24,32,48,64,128,256",31,15); 'DlgText("AM rates = "+recMTFfreqList$,31,15); 'figure how to do this the correct way!!
    'printlog("MTFrates = %d\n", MTFrates[]);
    'printlog("length nMTFrates = %d\n", len(MTFrates[]));

    DlgGroup("S1 Bandpass Noise",2,16,116,2);
    DlgInteger(21,6,1,50,22,17);  'AM noise, n repeats
    DlgText("# BP Noise repeats",3,17);
    'DlgText("Bandpass noises blah blah blah",31,18); 

    DlgGroup("S2 Stimuli (Space)",1,18,118,2);
    DlgReal(22,6,0.001,100,26,19);  'S2 speaker dB level
    DlgText("S2 (FM and AM) dB level",3,19);
    DlgInteger(23,6,1,100,51,19);  'S2 # repeats (for Space tuning) - separate from rate-level!
    DlgText("# Space repeats",35,19);
    DlgCheck(24,"",89,21);  'Monkey does lever task
    DlgText("Monkey Does Lever Task",65,21);

    DlgAllow(0xffff, 0, RecExpCharDialogChanged%); 
    
    DlgGroup("Experiment Selection",1,22,120,7);
    DlgList(25,30,recCharDoLoad$[],6,3,23);
    DlgButton(recCharReportExpButton%, "  Experiment Details  ", RecCharReportExp%,58,23);  'needs actual function written
    
    DlgList(26,22,recCharExpNameLoadFRA$[],recCharNumExps%,34,24);
    recCharText1% := DlgText("Select Exp't (Load FRA)",2,24);
    DlgButton(recCharAddExpLoadFRAButton%, "  Add Experiment  ", RecCharAddExpLoadFRA%,58,24);
    DlgButton(recCharDeleteExpLoadFRAButton%, "Delete Experiment ", RecCharDeleteExpLoadFRA%,78,24);
    
    DlgList(27,22,recCharExpNameLoadSigNoise$[],recCharNumExps%,34,25);
    recCharText2% := DlgText("Select Exp't (Load SigNoise)",2,25);
    DlgButton(recCharAddExpLoadSigNoiseButton%, "  Add Experiment  ", RecCharAddExpLoadSigNoise%,58,25);
    DlgButton(recCharDeleteExpLoadSigNoiseButton%, "Delete Experiment ", RecCharDeleteExpLoadSigNoise%,78,25);
    
    DlgList(28,22,recCharExpNameGenFRA$[],recCharNumExps%,34,26);
    recCharText3% := DlgText("Select Exp't (Gen FRA)",2,26);
    DlgButton(recCharAddExpGenFRAButton%, "  Add Experiment  ", RecCharAddExpGenFRA%,58,26);
    DlgButton(recCharDeleteExpGenFRAButton%, "Delete Experiment ", RecCharDeleteExpGenFRA%,78,26);
    
    DlgList(29,22,recCharExpNameGenSigNoise$[],recCharNumExps%,34,27);
    recCharText4% := DlgText("Select Exp't (Gen SigNoise)",2,27);
    DlgButton(recCharAddExpGenSigNoiseButton%, "  Add Experiment  ", RecCharAddExpGenSigNoise%,58,27);
    DlgButton(recCharDeleteExpGenSigNoiseButton%, "Delete Experiment ", RecCharDeleteExpGenSigNoise%,78,27);
    
    DlgList(30,22,recCharExpNameLoadArbStim$[],recCharNumExps%,34,28);
    recCharText5% := DlgText("Select Exp't (Load Arbitrary Stimulus)",2,28);
    DlgButton(recCharAddExpLoadArbStimButton%, "  Add Experiment  ", RecCharAddExpLoadArbStim%,58,28);
    DlgButton(recCharDeleteExpLoadArbStimButton%, "Delete Experiment ", RecCharDeleteExpLoadArbStim%,78,28);
    

    DlgAllow(0xffff, 0, RecExpCharDialogChanged%); 
    
    ' Show the dialog. 
    i%:=DlgShow(threeInts%, 'S1 stimuli
                recRateLevelNRepeats%, recRateLeveldBLow, recRateLeveldBHigh, 'Noise (rate-level)
                recFRANRepeats%,recFRATonedBLow,recFRATonedBHigh,recFRAToneFreqLow,recFRAToneFreqHigh, 'Tone Pips (FRA)
                eightInts%,  'S1 FM tones
                recS1AMnoiseReps%,'S1 AM Noise
                recBPnoiseReps%, 'S1 Bandpass Noise
                recSpaceS2dBLevel, recSpaceNRepeats%, recCharActive%, 'S2 Stimuli (space)
                recCharLoadStim%,fiveInts%);'Stimulus Selection 

                'printlog("Value is %d\n", recCharExpIndexLoadFRA%);

                recCharS1Speaker% := threeInts%[0];
                recCharMinS1%     := threeInts%[1];
                recCharVarS1%     := threeInts%[2];
    
                recFMSweepRepeats% := eightInts%[0];
                recFMSweepStart%   := eightInts%[1];
                recFMSweepEnd%     := eightInts%[2];
                recFMSweepDur1%    := eightInts%[3];
                recFMSweepDur2%    := eightInts%[4];
                recFMSweepDur3%    := eightInts%[5];
                recFMSweepDur4%    := eightInts%[6];
                recFMSweepDur5%    := eightInts%[7];
    
                recCharExpIndexLoadFRA%      := fiveInts%[0];
                recCharExpIndexLoadSigNoise% := fiveInts%[1];
                recCharExpIndexGenFRA%       := fiveInts%[2];
                recCharExpIndexGenSigNoise%  := fiveInts%[3];
                recCharExpIndexLoadArbStim%  := fiveInts%[4];

    'make sure the dialog values are OK
    docase
    case recRateLeveldBLow = recRateLeveldBHigh then
        message("Low and High dB level for noise cannot be the same value!");
        checkOK% := 0;
    case recFRATonedBLow = recFRATonedBHigh then
        message("Low and High dB level for tone pips cannot be the same value!");
        checkOK% := 0;
    case recFRAToneFreqLow = recFRAToneFreqHigh then
        message("Low and High frequency for tone pips cannot be the same value!");
        checkOK% := 0;
    endcase
    
    ' If user hit OK then save parameters (and return 1). 
	if i% = 1 and checkOK% = 1 then
        ' Recalculate dB steps, Freq. steps based on dialog values
        GetLinearProgression(recRateLeveldBLow, recRateLeveldBHigh, recRateLeveldBNSteps%-1, recRateLeveldBList[]);
        GetLinearProgression(recFRATonedBLow, recFRATonedBHigh, recFRAdBNSteps%-1, recFRAdBList[]);
        GetLogProgression(recFRAToneFreqLow, recFRAToneFreqHigh, recFRAFreqNSteps%-1, recFRAFreqList[]); 
        'calculate BPnoise intervals
        recBPnoisesLOs%[0] := 400;
        recBPnoisesHIs%[0] := recBPnoisesLOs%[0]+recBPnoisesLOs%[0]/2;
        for k% := 1 to nBPnoises%-1 do
            recBPnoisesLOs%[k%] := recBPnoisesLOs%[k%-1]+recBPnoisesLOs%[k%-1]/4;
            recBPnoisesHIs%[k%] := recBPnoisesLOs%[k%]+recBPnoisesLOs%[k%]/2;
        next;
    
        'Save parameters
        RecCharDialogFRASaveParams();
        
        'Set the GNG sandbox to -1 (don't check, value isn't present in this dialog)
        recCheckGNGSandbox% := -1;
        
        'Reset dialog OK button text on Select dialog, and note which experiment to run
        DlgValue$(-1,"Run Char.");
        
        'There doesn't appear to be, at this time, a compelling reason to actually limit this
        'to the 16-speaker array.  Dominique is trying to run this, as a "practice" in the 
        'small booth which only has a 15-speaker array, and this appears to be causing all
        'sorts of problems when the 16-speaker array is assigned by force.  Since the code
        'that creates the FRA stimuli is flexible enough to use the number of speakers requested,
        'I **THINK** everything should be hunky-dory if we just let it run on the 15-speaker
        'array.  My suspicion is that since the 15-speaker array is not 360-degrees that it was
        'probably considered unsuitable for the FRA, and perhaps it still ought to be, but this
        'is just for "practice" and we should let it happen.  -jj 8/2/17
        'DlgValue(3,2);  'force NSpeakers to the 16-speaker array on the main dialog
        'DlgEnable(0,3); 'and don't let this value be changed
        
        recExpToRun% := recExpCharButton%; 
        recExpSelectDialogAllowOK% := 1;  'Prepare to enable OK button
        recExpSelectDialogChanged%(-1);  'Enables "OK" button, -1 is sham input
        recDoRove% := 0;  'Do not allow roving in characterization
        
        'assign Search-specific variables to experiment-wide variables (so we can keep separate defaults but only code once)
        recMinS1% := recCharMinS1%;
        recVarS1% := recCharVarS1%;
        recS1Speaker% := recCharS1Speaker%;
        recActive% := recCharActive%;
        recFixLED% := 1;
        if recCharLoadStim% = 1 or recCharLoadStim% = 2 or recCharLoadStim% = 5 then  'Always generate stimuli for FRA unless it's a load scenario 
                                                                                      '(0 is dialog gen, 1 is load FRA, 2 is load SigNoise, 3 is gen FRA, 4 is gen SigNoise, 5 is load ArbStim)
            recMatGenStim% := 0;
        else
            recMatGenStim% := 1;  
        endif;
        if recCharLoadStim% = 2 or recCharLoadStim% = 4 then
            recUse2PWAs% := 1;  'when doing SigNoise, use 2 PWAs
        else
            recUse2PWAs% := 0;  'is already 0, but let's be explicit
        endif;
        
        status% := 1;
    else
        status% := 1;
    endif
    
	return status%;
   
end;


'===== End RecExpCharDialog =====
'
'

'
'
'===== RecExpCharDialogChanged =====

' This function is initially called with a "0" input
func RecExpCharDialogChanged%(item%) 
    'Quickly build a list of indices that we need
    var inds%[10];
    var j%;
    for j% := 0 to 9 do
        inds%[j%] := j%;
    next;
    
    docase
    case item% = 2 or item% = 3 then  'Rate-level dB changed, update values
        'Update values in variables
        recRateLeveldBLow := DlgValue(2);
        recRateLeveldBHigh := DlgValue(3);
        'Recalculate linear progression, if values are not the same
        if recRateLeveldBLow <> recRateLeveldBHigh then
            GetLinearProgression(recRateLeveldBLow, recRateLeveldBHigh, recRateLeveldBNSteps%-1, recRateLeveldBList[]);
        endif;
        'Update strings
        recRLList1$ := StringifyProgression2$(5, recRateLeveldBList[0:5], inds%[],1);
        recRLList2$ := StringifyProgression2$(5, recRateLeveldBList[5:5], inds%[],1);
        'Update GUI
        DlgValue$(recRLList1%,recRLList1$);
        DlgValue$(recRLList2%,recRLList2$);
    case item% = 4 or item% = 5 then  'FRA tone dB changed, update values
        'Update values in variables
        recFRATonedBLow := DlgValue(4);
        recFRATonedBHigh := DlgValue(5);
        'Recalculate linear progression, if values are not the same
        if recFRATonedBLow <> recFRATonedBHigh then
            GetLinearProgression(recFRATonedBLow, recFRATonedBHigh, recFRAdBNSteps%-1, recFRAdBList[]);
        endif;
        'Update strings
        recFRAdBList1$ := StringifyProgression2$(5, recFRAdBList[0:5], inds%[],1);
        recFRAdBList2$ := StringifyProgression2$(5, recFRAdBList[5:5], inds%[],1);
        'Update GUI
        DlgValue$(recFRAdBList1%,recFRAdBList1$);
        DlgValue$(recFRAdBList2%,recFRAdBList2$);
    case item% = 6 or item% = 7 then  'FRA tone frequency changed, update values
        'Update values in variables
        recFRAToneFreqLow := DlgValue(6);
        recFRAToneFreqHigh := DlgValue(7);
        'Recalculate log progression
        if recFRAToneFreqLow <> recFRAToneFreqHigh then
            GetLogProgression(recFRAToneFreqLow, recFRAToneFreqHigh, recFRAFreqNSteps%-1, recFRAFreqList[]);
        endif;
        'Update strings
        recFRAFreqList1$ := StringifyProgression2$(10, recFRAFreqList[0:10], inds%[],0);
        recFRAFreqList2$ := StringifyProgression2$(10, recFRAFreqList[10:10], inds%[],0);
        recFRAFreqList3$ := StringifyProgression2$(9, recFRAFreqList[20:9], inds%[],0);
        recFRAFreqList4$ := StringifyProgression2$(8, recFRAFreqList[29:8], inds%[],0);
        recFRAFreqList5$ := StringifyProgression2$(8, recFRAFreqList[37:8], inds%[],0);
        'Update GUI
        DlgValue$(recFRAFreqList1%,recFRAFreqList1$);
        DlgValue$(recFRAFreqList2%,recFRAFreqList2$);
        DlgValue$(recFRAFreqList3%,recFRAFreqList3$);
        DlgValue$(recFRAFreqList4%,recFRAFreqList4$);
        DlgValue$(recFRAFreqList5%,recFRAFreqList5$);
'    case item% = 11 or item% = 12 or item% = 13 or item% = 22 then  'change number of S1 stimulus repeats
'        nS1% := (nTonePips%*recFRAdBNSteps%*recFRANRepeats%)+(recRateLevelNRepeats%*recRateLeveldBNSteps%)+(nFMSweeps%*recFMSweepRepeats%);  'that's number of tone pips in FRA plus number of noise bursts in rate-level function
'        printlog("nS1% = %d\n", nS1%);
'        nS2% := (recNSpeakers%-1)*recSpaceNRepeats%;  'that's number of noises at speakers not in the S1 position
'        printlog("nS2% = %d\n", nS2%);
        
    case item% = 0 or item% = 25 then  'on first open, or on changing expt type
        docase
        case DlgValue(25) = 0 then
            'Disable all load/gen versions
            DlgEnable(0,26);
            DlgEnable(0,-recCharAddExpLoadFRAButton%);
            DlgEnable(0,-recCharDeleteExpLoadFRAButton%);
            DlgEnable(0,27);
            DlgEnable(0,-recCharAddExpLoadSigNoiseButton%);
            DlgEnable(0,-recCharDeleteExpLoadSigNoiseButton%);
            DlgEnable(0,28);
            DlgEnable(0,-recCharAddExpGenFRAButton%);
            DlgEnable(0,-recCharDeleteExpGenFRAButton%);
            DlgEnable(0,29);
            DlgEnable(0,-recCharAddExpGenSigNoiseButton%);
            DlgEnable(0,-recCharDeleteExpGenSigNoiseButton%);
            DlgEnable(0,30);
            DlgEnable(0,-recCharAddExpLoadArbStimButton%);
            DlgEnable(0,-recCharDeleteExpLoadArbStimButton%);
            'Enable all the other values
            for j% := 1 to 23 do
                DlgEnable(1,j%);
            next

        case DlgValue(25) = 1 then
            'Enable load FRA version
            DlgEnable(1,26);
            DlgEnable(1,-recCharAddExpLoadFRAButton%);
            DlgEnable(1,-recCharDeleteExpLoadFRAButton%);
            'Disable other versions
            DlgEnable(0,27);
            DlgEnable(0,-recCharAddExpLoadSigNoiseButton%);
            DlgEnable(0,-recCharDeleteExpLoadSigNoiseButton%);
            DlgEnable(0,28);
            DlgEnable(0,-recCharAddExpGenFRAButton%);
            DlgEnable(0,-recCharDeleteExpGenFRAButton%);
            DlgEnable(0,29);
            DlgEnable(0,-recCharAddExpGenSigNoiseButton%);
            DlgEnable(0,-recCharDeleteExpGenSigNoiseButton%);
            DlgEnable(0,30);
            DlgEnable(0,-recCharAddExpLoadArbStimButton%);
            DlgEnable(0,-recCharDeleteExpLoadArbStimButton%);
            'Disable all the other values
            for j% := 1 to 23 do
                DlgEnable(0,j%);
            next
            
        case DlgValue(25) = 2 then
            'Enable load SigNoise version
            DlgEnable(1,27);
            DlgEnable(1,-recCharAddExpLoadSigNoiseButton%);
            DlgEnable(1,-recCharDeleteExpLoadSigNoiseButton%);
            'Disable other versions
            DlgEnable(0,26);
            DlgEnable(0,-recCharAddExpLoadFRAButton%);
            DlgEnable(0,-recCharDeleteExpLoadFRAButton%);
            DlgEnable(0,28);
            DlgEnable(0,-recCharAddExpGenFRAButton%);
            DlgEnable(0,-recCharDeleteExpGenFRAButton%);
            DlgEnable(0,29);
            DlgEnable(0,-recCharAddExpGenSigNoiseButton%);
            DlgEnable(0,-recCharDeleteExpGenSigNoiseButton%);
            DlgEnable(0,30);
            DlgEnable(0,-recCharAddExpLoadArbStimButton%);
            DlgEnable(0,-recCharDeleteExpLoadArbStimButton%);
            'Disable all the other values
            for j% := 1 to 23 do
                DlgEnable(0,j%);
            next
            
        case DlgValue(25) = 3 then
            'Enable generate FRA version
            DlgEnable(1,28);
            DlgEnable(1,-recCharAddExpGenFRAButton%);
            DlgEnable(1,-recCharDeleteExpGenFRAButton%);
            'Disable other versions
            DlgEnable(0,26);
            DlgEnable(0,-recCharAddExpLoadFRAButton%);
            DlgEnable(0,-recCharDeleteExpLoadFRAButton%);
            DlgEnable(0,27);
            DlgEnable(0,-recCharAddExpLoadSigNoiseButton%);
            DlgEnable(0,-recCharDeleteExpLoadSigNoiseButton%);
            DlgEnable(0,29);
            DlgEnable(0,-recCharAddExpGenSigNoiseButton%);
            DlgEnable(0,-recCharDeleteExpGenSigNoiseButton%);
            DlgEnable(0,30);
            DlgEnable(0,-recCharAddExpLoadArbStimButton%);
            DlgEnable(0,-recCharDeleteExpLoadArbStimButton%);
            'Disable all the other values
            for j% := 1 to 23 do
                DlgEnable(0,j%);
            next
            
        case DlgValue(25) = 4 then
            'Enable generate SigNoise version
            DlgEnable(1,29);
            DlgEnable(1,-recCharAddExpGenSigNoiseButton%);
            DlgEnable(1,-recCharDeleteExpGenSigNoiseButton%);
            'Disable other versions
            DlgEnable(0,26);
            DlgEnable(0,-recCharAddExpLoadFRAButton%);
            DlgEnable(0,-recCharDeleteExpLoadFRAButton%);
            DlgEnable(0,27);
            DlgEnable(0,-recCharAddExpLoadSigNoiseButton%);
            DlgEnable(0,-recCharDeleteExpLoadSigNoiseButton%);
            DlgEnable(0,28);
            DlgEnable(0,-recCharAddExpGenFRAButton%);
            DlgEnable(0,-recCharDeleteExpGenFRAButton%);
            DlgEnable(0,30);
            DlgEnable(0,-recCharAddExpLoadArbStimButton%);
            DlgEnable(0,-recCharDeleteExpLoadArbStimButton%);
            'Disable all the other values
            for j% := 1 to 23 do
                DlgEnable(0,j%);
            next            
            
        case DlgValue(25) = 5 then
            'Enable load ArbStim version
            DlgEnable(1,30);
            DlgEnable(1,-recCharAddExpLoadArbStimButton%);
            DlgEnable(1,-recCharDeleteExpLoadArbStimButton%);
            'Disable other versions
            DlgEnable(0,26);
            DlgEnable(0,-recCharAddExpLoadFRAButton%);
            DlgEnable(0,-recCharDeleteExpLoadFRAButton%);
            DlgEnable(0,27);
            DlgEnable(0,-recCharAddExpLoadSigNoiseButton%);
            DlgEnable(0,-recCharDeleteExpLoadSigNoiseButton%);
            DlgEnable(0,28);
            DlgEnable(0,-recCharAddExpGenFRAButton%);
            DlgEnable(0,-recCharDeleteExpGenFRAButton%);
            DlgEnable(0,29);
            DlgEnable(0,-recCharAddExpGenSigNoiseButton%);
            DlgEnable(0,-recCharDeleteExpGenSigNoiseButton%);
            'Disable all the other values
            for j% := 1 to 23 do
                DlgEnable(0,j%);
            next
            
        endcase
    endcase;
    
    return 1;
end

'===== End RecExpCharDialogChanged =====
'
'


'===== RecJoyTrainDialog ===== '*jao

func RecJoyTrainDialog%()
'**look at search dialog for important functional details!!!
    var i%; 'for DlgShow
    var status% := 0;
    var c1txt% := 3;
    var c1% := 35; 'not the smart way to do it..
    var initStr$[7];
    var s2% := 9;

    initStr$[0] := "Not Allowed";
    initStr$[1] := "Down";
    initStr$[2] := "Up";
    initStr$[3] := "Right";
    initStr$[4] := "Left";
    initStr$[5] := "X Axis";
    initStr$[6] := "Y Axis";

    ' Fetch parameters from registry    
    RecJoyTrainGetParams(); 'make this below!
    
    ' Generate the dialog
    DlgCreate("Joystick training dialog", 0,0, 50,16); '0,0=ctr of scrn; 50,16=size of dlg
    DlgCheck(1, "Give juice for hitting trial start window?");

    DlgGroup("Timing and Rewards",1,2,48,6); 'just text for now to tell ppl where to go to change things
    'i think i can actually set these here (basically copy from those dialogs and then assign those vars below
'    DlgText("Use Timing/Reward Dialog to set (can't do it here!):",2,3); 
       ' DlgText("* Hit Reward Duration,mL = amount of juice",3,4); 'msg: amount of juice --> update HIT REWARD in timing and reward dialog!
       ' DlgText("* Reward Increment on hits",3,5); 'msg: reward increment on hits --> update in Timing & Reward Dialog!
       ' DlgText("* Minimum Onset Delay = hold to get juice",3,6); 'msg: juice delay? --> Minimum onset delay in timing and reward dialog!
        DlgReal(2,4,0,3,c1%,3); DlgText("Hit Reward, mL",c1txt%,3); '#2=recHitRewardmL
        DlgReal(3,4,0,1,c1%,4); DlgText("Reward Increment on hits, mL",c1txt%,4); '#3=recHitRewardIncmL
        DlgReal(4,4,0,10,c1%,5); DlgText("Minimum Onset Delay, s",c1txt%,5); '#4=recMinOnsetDelay
        DlgText("* ??? to Increment Onset Delay",3,6);'**increment delay? --> set max delay (is there already a variable for this?)
        DlgText("* ??? to Set Max Onset Delay",3,7);'**increment delay? --> set max delay (is there already a variable for this?)

    DlgGroup("Joystick",1,s2%,48,6);
'    DlgText("Use Joystick/Lever Dialog to set (can't do it here!):",2,10); 
        'DlgText("* Trial Initiation Position",3,11); 'msg: set trial initiation position in Joystick Dialog!
        'DlgText("* Joystick Thresholds and Increments",3,12);  'msg: set joystick increments in Joystick Dialog --> joystick increments!
        DlgList(5,20,initStr$[],7,c1%-6,s2%+1); DlgText("Trial Initiation Position",c1txt%,s2%+1); 'recTrialInitPosition%
        DlgButton(2,"Joystick Thresholds",SetJoystickThresholdDialog%,2,s2%+2);
        DlgCheck(6,"Do Increments",2,s2%+3); 'recDoIncrements%
        DlgButton(3,"Joystick Increments",SetJoystickThresholdIncrementDialog%,2,s2%+4); 'recTrialResponsePosition1%
        DlgButton(4,"Joystick Limits",SetJoystickThresholdLimitDialog%,2,s2%+5); 'recTrialResponsePosition2%


    DlgAllow(0xffff, 0, RecExpJoyTrnDialogChanged%); 'no idea how this works, but i'm sure i need it!

    ' Show the dialog. 
    i%:=DlgShow(recDoJoyTrain%, recHitRewardmL, recHitRewardIncmL, recMinOnsetDelay, recTrialInitPosition%, recDoIncrements%); 'DlgCheck(1... ??

    ' If user checked box and hit OK then save parameters (and return 1). 
	if i% = 1 then
        RecJoyTrainSaveParams(); 'hmm... do i need to do this??
        'Reset dialog OK button text on Select dialog, and note which experiment to run
        DlgEnable(1,3);  'make sure that the Nspeakers selection item is enabled on the main dialog
        DlgValue$(-1,"Run JoyTrain"); 'to enable OK button? see also ~line 1156 in RecRoom (RecExpSearchDialog) 
        recExpToRun% := recExpJoyTrnButton%;
        recExpSelectDialogAllowOK% := 1;  'Prepare to enable OK button
        'recExpSelectDialogChanged%(-1);  'Enables "OK" button, -1 is sham input  - doesn't actually do anything -jj
        
        recFixLED% := 0;
        recActive% := 1;
        
        'Set the GNG sandbox to -1 (don't check, value isn't present in this dialog)
        recCheckGNGSandbox% := -1;
        
        'assign JoyTrain-specific variables to experiment-wide variables here????
        'see lines 1163-1170 in RecRoom (RecExpSearchDialog) for examples of this (i think)
    
        'trial generation??? --> RecRoom do while 
        
        'jj is unsure of something.  It certainly seems that the recDoJoyTrain% checkbox is meant to be checked.
        'It seems it shouldn't be a checkbox, I think we should just use recExpToRun% := recExpJoyTrnButton% and forget recDoJoyTrain% (which is only checked once in GNGEngine)
        'But I'm working on other stuff right now and this is not a priority to understand.
        'When RecLab needs to use/change this, at least this note will be here to get me started.
    
        status% := 1;
    else
        status% := 1;
    endif
    
	return status%;


end; 'end func
'end RecJoyTrainDialog '*jao

'===== RecJoyTrnDialogChanged ===== '*jao

func RecExpJoyTrnDialogChanged%(item%)
'this is where dialog functions are enabled for JoyTrain dialog
'i dont understand how input and call to this func

'i actually don't need this ... YET!

    return 1;


end;
'end RecExpJoyTrnDialogChanged%() '*jao



'===== RecLongToneDialog ===== '-jj
func RecLongToneDialog%()
    var i%; 'for DlgShow
    var status% := 0;
    var longType$[3];
    
    longType$[0] := "Tone";
    longType$[1] := "Broadband Noise";
    longType$[2] := "Bandpass Noise";
    
    
    ' Fetch parameters from registry    
    RecLongToneGetParams();
    
    ' Generate the dialog
    DlgCreate("Long Tone Dialog");
    DlgList(1,17,longType$[],3);
    DlgReal(2,"Tone Frequency (Hz)",20,40000);
    DlgReal(3,"Low Freq Cutoff (Hz)",1,30000);
    DlgReal(4,"High Freq Cutoff (Hz)",2,100000);
    DlgInteger(5,"Speaker",1,16);
    DlgInteger(6,"Number of repeats per tone",1,12);  'We have to restrict this to 8 because of maximum variable size allowed by CED (have to hold all the damn long noises!)  Heck, try 12 and see...
    DlgReal(7,"ISI, seconds",1,100);
    DlgReal(8,"Silence trial, seconds",10.1,24.9);  'We have to restrict this to be > 10 and < 25 to ensure that Matlab analysis works and is backcompatible. See treatment of DURS, approx. line 105-113 RecLongToneSingleCellAnalysis
    DlgReal(9,"Target dB",1,100);
    DlgReal(10,"Probability of reward",0,1);
    
    DlgAllow(0xffff, 0, RecLongToneDialogChanged%); 
    
    ' Show the dialog
    i% := DlgShow(recLongToneType%,recLongToneFreq,recLongToneBPLow,recLongToneBPHigh,recLongToneSpeaker%,recLongToneNRepeats%,recLongToneISI,recLongToneSilentDur,recLongToneTargetdB,recLongToneRewardProb);
  
    
    ' If user checked box and hit OK then save parameters (and return 1). 
	if i% = 1 then
        RecLongToneSaveParams();  
        
        if recLongToneType% = 1 then  'if we are doing broadband noise, set the values here so we don't have to "think" at the noise creation step
            recLongToneBPLow := -1;  'correct value for broadband noise
            recLongToneBPHigh := -1;
        endif;
        
        'Set the GNG sandbox to -1 (don't check, value isn't present in this dialog)
        recCheckGNGSandbox% := -1;
        
        'Reset dialog OK button text on Select dialog, and note which experiment to run
        DlgEnable(1,3);  'make sure that the Nspeakers selection item is enabled on the main dialog
        DlgValue$(-1,"Run Long Tone"); 'to enable OK button? see also ~line 1156 in RecRoom (RecExpSearchDialog) 
        recExpToRun% := recExpLongToneButton%;
        recExpSelectDialogAllowOK% := 1;  'Prepare to enable OK button
        recExpSelectDialogChanged%(-1);  'Enables "OK" button, -1 is sham input
        recDoRove% := 0;  'Do not allow roving in longtone
        recFixLED% := 0;  'Long tone goes through different pathway, but reset value anyway
        
        LongDurs[4] := recLongToneSilentDur;  'update this value once we have 
        
        status% := 1;
    else
        status% := 1;
    endif
    
	return status%;
    
end



func RecLongToneDialogChanged%(item%)
    
    docase
    case DlgValue(1) = 0 then  'if tone
        DlgEnable(1,2);  'Enable tone 
        DlgEnable(0,3);  'Disable BP low
        DlgEnable(0,4);  'Disable BP high
    case DlgValue(1) = 1 then  'if broadband noise
        DlgEnable(0,2);  'Disable tone 
        DlgEnable(0,3);  'Disable BP low
        DlgEnable(0,4);  'Disable BP high
    case DlgValue(1) = 2 then  'if bandpass noise
        DlgEnable(0,2);  'Disable tone 
        DlgEnable(1,3);  'Enable BP low
        DlgEnable(1,4);  'Enable BP high
    endcase

    return 1;


end;
'end RecELongToneDialogChanged%()



'===== RecAudiogramDialog ===== '-jj, all audiogram code

func RecAudiogramDialog%()
'**look at search dialog for important functional details!!!
    var i%; 'for DlgShow
    var status% := 0;
    
    var trwid% := 100;  'total dialog width, not sure what 'tr' means at this point, carried over
    var ewid% := 6;  'entry width
    var c1txt% := 2;  'column 1 text position
    var c1%;  'column 1 position
    c1% := c1txt%+22;
    var c2txt% := 36;
    var c2%;
    c2% := c2txt%+22;
    var c3txt% := 70;
    var c3%;
    c3% := c3txt%+22;
    
    'StringifyProgression2$ just needs a set of indices, they don't really do anything else
    var inds%[10];
    var j%;
    for j% := 0 to 9 do
        inds%[j%] := j%;
    next;
    var tempCount%;
    
    

    ' Fetch parameters from registry    
    RecAudiogramGetParams(); 
    
    ' Initial calculation of frequency steps
    if (recAudiogramToneFreqLow <> recAudiogramToneFreqHigh) and recAudiogramNFreqs% > 1 then
        GetLogProgression(recAudiogramToneFreqLow, recAudiogramToneFreqHigh, recAudiogramNFreqs%-1, recAudiogramFreqList[]); 
    else
        recAudiogramFreqList[0] := recAudiogramToneFreqLow;
    endif
        
    ' Followed by initial stringification, yikes.  Now loooooooong.
    tempCount% := recAudiogramNFreqs%;
    if tempCount% >= 10 then
        recAudiogramFreqList1$ := StringifyProgression2$(10, recAudiogramFreqList[0:10], inds%[],0);
    else
        recAudiogramFreqList1$ := StringifyProgression2$(tempCount%, recAudiogramFreqList[0:tempCount%], inds%[],0);
    endif;
    tempCount% := tempCount% - 10;
    docase
    case tempCount% <= 0 then
        recAudiogramFreqList2$ := "";
    case tempCount% >= 10 then
        recAudiogramFreqList2$ := StringifyProgression2$(10, recAudiogramFreqList[10:10], inds%[],0);
    else
        recAudiogramFreqList2$ := StringifyProgression2$(tempCount%, recAudiogramFreqList[10:tempCount%], inds%[],0);
    endcase;
    tempCount% := tempCount% - 10;
    docase
    case tempCount% <= 0 then
        recAudiogramFreqList3$ := "";
    case tempCount% >= 9 then
        recAudiogramFreqList3$ := StringifyProgression2$(9, recAudiogramFreqList[20:9], inds%[],0);
    else
        recAudiogramFreqList3$ := StringifyProgression2$(tempCount%, recAudiogramFreqList[20:tempCount%], inds%[],0);
    endcase;
    tempCount% := tempCount% - 9;
    docase
    case tempCount% <= 0 then
        recAudiogramFreqList4$ := "";
    case tempCount% >= 8 then
        recAudiogramFreqList4$ := StringifyProgression2$(8, recAudiogramFreqList[29:8], inds%[],0);
    else
        recAudiogramFreqList4$ := StringifyProgression2$(tempCount%, recAudiogramFreqList[29:tempCount%], inds%[],0);
    endcase;
    tempCount% := tempCount% - 8;
    docase
    case tempCount% <= 0 then
        recAudiogramFreqList5$ := "";
    case tempCount% >= 8 then
        recAudiogramFreqList5$ := StringifyProgression2$(8, recAudiogramFreqList[37:8], inds%[],0);
    else
        recAudiogramFreqList5$ := StringifyProgression2$(tempCount%, recAudiogramFreqList[37:tempCount%], inds%[],0);
    endcase;

    
    ' Generate the dialog
    DlgCreate("Audiogram dialog", 0,0,trwid%,19); '0,0=ctr of scrn; 50,16=size of dlg
    DlgGroup("Timing and Rewards",1,1,trwid%-2,4); 'just text for now to tell ppl where to go to change things
    DlgInteger(1,ewid%,1,16,c1%,2);  DlgText("S1 Speaker",c1txt%,2);
    DlgReal(2,ewid%,0,3,c2%,2); DlgText("Hit Reward, mL",c2txt%,2);
    
    DlgReal(3,ewid%,0,20,c1%,3); DlgText("Minimum Onset Delay, s",c1txt%,3);
    DlgReal(4,ewid%,0,20,c2%,3); DlgText("Variable Onset Delay, s",c2txt%,3);
    DlgReal(5,ewid%,0.5,10,c3%,3); DlgText("Response Window, s",c3txt%,3);
    
    DlgReal(6,ewid%,0.5,100,c1%,4); DlgText("Trial Initiation Window, s",c1txt%,4);
    DlgReal(7,ewid%,0,300,c2%,4); DlgText("False Alarm TO, s",c2txt%,4);
    '''Lazy monkey timeout excised!  Uncomment to reinstate!
'    DlgReal(8,ewid%,0,300,c3%,4); DlgText("Lazy Monkey TO, s",c3txt%,4);
    DlgReal(8,ewid%,0,300,c3%,4); DlgText("THIS DOES NOTHING, s",c3txt%,4);
    
    
    DlgGroup("Frequencies",1,5,trwid%-2,8);
    DlgInteger(9,ewid%,1,45,c1%,6); DlgText("# Frequenices",c1txt%,6);
    DlgReal(10,ewid%,0.001,40000,c2%,6);  DlgText("Minimum Frequency",c2txt%,6);
    DlgReal(11,ewid%,0.002,50000,c3%,6);  DlgText("Maximum Frequency",c3txt%,6);
    DlgText("List of Selected Freqs (rounded to nearest Hz):",c1txt%,7);
    recAudiogramFreqList1% := DlgText(recAudiogramFreqList1$,c1txt%,8,58);  'must set width of text boxes or it is based on
    recAudiogramFreqList2% := DlgText(recAudiogramFreqList2$,c1txt%,9,58);  'original text and updates can cause some
    recAudiogramFreqList3% := DlgText(recAudiogramFreqList3$,c1txt%,10,58);  'values to be "invisible" - also done for dB
    recAudiogramFreqList4% := DlgText(recAudiogramFreqList4$,c1txt%,11,58);  'values above (tone and rate-level) but probably
    recAudiogramFreqList5% := DlgText(recAudiogramFreqList5$,c1txt%,12,58);  'not crucial there.
    
    DlgGroup("Reversals and dB",1,13,trwid%-2,4);
    DlgInteger(12,ewid%,1,200,c1%,14);  DlgText("Number of Reversals",c1txt%,14);
    DlgCheck(13,"",c2%,14);  DlgText("Only Log Reversals",c2txt%,14);
    DlgReal(14,ewid%,.1,120,c1%,15);  DlgText("Start dB Level",c1txt%,15);
    DlgCheck(15,"",c2%,15);  DlgText("Initial Step is LOUDER",c2txt%,15);
    DlgReal(16,ewid%,.1,40,c1%,16);  DlgText("Initial dB Step",c1txt%,16);
    DlgReal(17,ewid%,.1,40,c2%,16);  DlgText("Louder dB Step",c2txt%,16);
    DlgReal(18,ewid%,.1,40,c3%,16);  DlgText("Quieter dB Step",c3txt%,16);
    


    DlgAllow(0xffff, 0, RecExpAudiogramDialogChanged%); 

    ' Show the dialog
    i% := DlgShow(recAudiogramS1Speaker%,recHitRewardmL,recMinOnsetDelay,recVarOnsetDelay,recResponseWindow,
                  recTrialInitWindow,recFalseAlarmTO,recLazyMonkeyTO,recAudiogramNFreqs%,recAudiogramToneFreqLow,
                  recAudiogramToneFreqHigh,recAudiogramNReversals%,recAudiogramOnlyLogReversals%,recAudiogramStartdB,
                  recAudiogramInitialDirection%,recAudiogramInitialdBStep,recAudiogramLouderdBStep,recAudiogramQuieterdBStep);  
     
    
    ' If user checked box and hit OK then save parameters (and return 1). 
	if i% = 1 then
        RecAudiogramSaveParams(); 
        
        'Assign fixation LED
        recFixLED% := 1;
        
        'Force experiment to be go/no-go (will still need to consult with Engine to make sure this will be OK but nothing else appears to be necessary in RecRoom)
        'recIsGoNoGo% := 1;  'Instead we should check the sandbox
        'Set the GNG sandbox variable
        recCheckGNGSandbox% := 1;
        
        'Do not allow reward incrementing for audiogram
        recHitRewardIncmL := 0;
        
        'Assign S1 Speaker...note that other variables aren't assigned like this
        recS1Speaker% := recAudiogramS1Speaker%;
        
        'Reset dialog OK button text on Select dialog, and note which experiment to run
        DlgEnable(1,3);  'make sure that the Nspeakers selection item is enabled on the main dialog
        DlgValue$(-1,"Run Audiogram"); 'to enable OK button? see also ~line 1156 in RecRoom (RecExpSearchDialog) 
        recExpToRun% := recExpAudiogramButton%;
        
        'Check to make sure that the joystick/lever is set up for GNG, if not, don't enable!
        if recIsGoNoGo% = 1 then
            recExpSelectDialogAllowOK% := 1;  'Prepare to enable OK button
            recExpSelectDialogChanged%(-1);  'Enables "OK" button, -1 is sham input
        else
            recExpSelectDialogAllowOK% := 0;  'Prepare to disable OK button
            recExpSelectDialogChanged%(-1);  'Disables "OK" button, -1 is sham input
            recExpSelectDialogAllowOK% := -1;  'But inform the joystick/lever dialog that we're good to go once GNG is fixed
            message("Audiogram must be Go/No-Go, but the joystick dialog is set for Forced Choice!");
        endif
               
        
        
        recAudiogramCurrentdB := recAudiogramStartdB;
        recMatGenStim% := 1;  'Always generate stimuli for Audiogram
        recActive% := 1; 
        recDoRove% := 0;  'Do not allow roving in audiogram
    
        status% := 1;
    else
        'Set the GNG sandbox to -1 (don't check) if cancelled
        recCheckGNGSandbox% := -1;
        status% := 1;
    endif
    
	return status%;


end; 'end func
'end RecAudiogramDialog 

'===== RecAudiogramDialogChanged ===== 

func RecExpAudiogramDialogChanged%(item%)
    
    'Quickly build a list of indices that we need
    var inds%[10];
    var j%;
    for j% := 0 to 9 do
        inds%[j%] := j%;
    next;
    var tempCount%;
    
    docase
    case item% = 9 or item% = 10 or item% = 11 then  'frequencies or # of frequencies changed, update values
        'Update values in variables
        recAudiogramNFreqs% := DlgValue(9);
        recAudiogramToneFreqLow := DlgValue(10);
        recAudiogramToneFreqHigh := DlgValue(11);
        'Recalculate log progression
        if (recAudiogramToneFreqLow <> recAudiogramToneFreqHigh) and recAudiogramNFreqs% > 1 then
            GetLogProgression(recAudiogramToneFreqLow, recAudiogramToneFreqHigh, recAudiogramNFreqs%-1, recAudiogramFreqList[]); 
        else
            recAudiogramFreqList[0] := recAudiogramToneFreqLow;
            DlgValue(9,1);
            recAudiogramNFreqs% := 1;
        endif
        'Update strings
        tempCount% := recAudiogramNFreqs%;
        if tempCount% >= 10 then
            recAudiogramFreqList1$ := StringifyProgression2$(10, recAudiogramFreqList[0:10], inds%[],0);
        else
            recAudiogramFreqList1$ := StringifyProgression2$(tempCount%, recAudiogramFreqList[0:tempCount%], inds%[],0);
        endif;
        tempCount% := tempCount% - 10;
        docase
        case tempCount% <= 0 then
            recAudiogramFreqList2$ := "";
        case tempCount% >= 10 then
            recAudiogramFreqList2$ := StringifyProgression2$(10, recAudiogramFreqList[10:10], inds%[],0);
        else
            recAudiogramFreqList2$ := StringifyProgression2$(tempCount%, recAudiogramFreqList[10:tempCount%], inds%[],0);
        endcase;
        tempCount% := tempCount% - 10;
        docase
        case tempCount% <= 0 then
            recAudiogramFreqList3$ := "";
        case tempCount% >= 9 then
            recAudiogramFreqList3$ := StringifyProgression2$(9, recAudiogramFreqList[20:9], inds%[],0);
        else
            recAudiogramFreqList3$ := StringifyProgression2$(tempCount%, recAudiogramFreqList[20:tempCount%], inds%[],0);
        endcase;
        tempCount% := tempCount% - 9;
        docase
        case tempCount% <= 0 then
            recAudiogramFreqList4$ := "";
        case tempCount% >= 8 then
            recAudiogramFreqList4$ := StringifyProgression2$(8, recAudiogramFreqList[29:8], inds%[],0);
        else
            recAudiogramFreqList4$ := StringifyProgression2$(tempCount%, recAudiogramFreqList[29:tempCount%], inds%[],0);
        endcase;
        tempCount% := tempCount% - 8;
        docase
        case tempCount% <= 0 then
            recAudiogramFreqList5$ := "";
        case tempCount% >= 8 then
            recAudiogramFreqList5$ := StringifyProgression2$(8, recAudiogramFreqList[37:8], inds%[],0);
        else
            recAudiogramFreqList5$ := StringifyProgression2$(tempCount%, recAudiogramFreqList[37:tempCount%], inds%[],0);
        endcase;
        'Update GUI
        DlgValue$(recAudiogramFreqList1%,recAudiogramFreqList1$);
        DlgValue$(recAudiogramFreqList2%,recAudiogramFreqList2$);
        DlgValue$(recAudiogramFreqList3%,recAudiogramFreqList3$);
        DlgValue$(recAudiogramFreqList4%,recAudiogramFreqList4$);
        DlgValue$(recAudiogramFreqList5%,recAudiogramFreqList5$);
        
    endcase;
    
    
    
    return 1;


end;
'end RecExpAudiogramDialogChanged%()




'
'
'===== RecExpAMDiscDialog =====

'A dialog for the AMDisc experiment

func RecExpAMDiscDialog%()
    
    var i%;
    var status% := 0;
    
    ' Fetch parameters from registry    
    RecAMDiscGetParams();
    RecAMDiscExpListLoadGetParams(recAMDiscExpNameLoad$[],recAMDiscStimcalNameLoad$[],recAMDiscTrialsNameLoad$[]);
    RecAMDiscExpListGenGetParams(recAMDiscExpNameGen$[],recAMDiscStimcalNameGen$[],recAMDiscTrialsNameGen$[]);
        
    
    ' Generate the dialog    
    DlgCreate("AM Discrimination Dialog",0,0,75,14);
    
    DlgGroup("Stimulus Selection",1,1,73,4);
    DlgCheck(1,"Create Stimuli?",2,2);
    DlgList(2,27,recAMDiscExpNameGen$[],recAMDiscNumExps%,24,3); 'For list box, set width and put in a DlgText
    recAMDiscText1% := DlgText("Select Exp't (Create Stim)",2,3);
    DlgList(3,27,recAMDiscExpNameLoad$[],recAMDiscNumExps%,24,4);
    recAMDiscText2% := DlgText("Select Exp't (Load Stim)",2,4);
    DlgButton(recAMDiscAddExpButton%, "  Add Experiment  ", RecAMDiscAddExp%,53,3);
    DlgButton(recAMDiscDeleteExpButton%, "Delete Experiment ", RecAMDiscDeleteExp%,53,4);
    DlgButton(recAMDiscReportExpButton%, "  Experiment Details  ", RecAMDiscReportExp%,53,2);  
    
    DlgGroup("Variables",1,6,73,6);
    'DlgInteger(4,6,1,20,27,6);  'S1 speaker  'Removing S1 speaker as S1s will be determined by trials in trials file
    'DlgText("Preferred Speaker",8,6);
    DlgInteger(4,6,1,9,27,7);  'Min S1
    DlgText("Minimum S1 Presentations",2,7);
    DlgCheck(9,"Trial initiation reward?",46,7);
    'DlgReal(10,4,0,3,65,8); DlgText("Training Reward, mL",46,8);
    DlgCheck(10,"Trial Hold reward?",46,8);    

    DlgInteger(5,6,0,8,27,8);  'Var S1
    DlgText("Variable S1 Presentations",2,8);
    DlgReal(6,6,0,1,27,9);  'Proportion of catch trials
    DlgText("Proportion of Catch Trials",2,9);
    DlgText("(if catch trials are in trials file, set to 0)",2,10);
    DlgReal(7,6,0,100,65,9);  'dB level
    DlgText("dB Level",46,9);
    'DlgInteger(8,6,1,100,65,10);  'Repeats
    'DlgText("Repeats per stimulus",46,10);
    DlgInteger(8,6,1,100,27,11);  'Repeats
    DlgText("Repeats per stimulus",2,11);
    DlgCheck(11,"Active task?",2,12);
    DlgCheck(12,"Rove stimuli?",46,10);
    DlgReal(13,6,0,3,65,11);  'Rove db
    DlgText("Rove dB, +/-",46,11);
    
    DlgAllow(0xffff, 0, RecExpAMDiscDialogChanged%);
    
    ' Show the dialog. 
    'i%:=DlgShow(recAMDiscMatGenStim%,recAMDiscExpIndexGen%,recAMDiscExpIndexLoad%,recAMDiscS1Speaker%,recAMDiscMinS1%,recAMDiscVarS1%,
    '            recAMDiscPropCatch,recAMDiscdBLevel,recAMDiscRepeatsPerStim%);  
    
    i%:=DlgShow(recAMDiscMatGenStim%,recAMDiscExpIndexGen%,recAMDiscExpIndexLoad%,recAMDiscMinS1%,recAMDiscVarS1%,
    recAMDiscPropCatch,recAMDiscdBLevel,recAMDiscRepeatsPerStim%, recAMDiscTrialInitReward%, 
    recAMDiscTrialHoldReward%, recAMDiscActive%, recAMDiscDoRove%, recAMDiscRovedB);  'not setting recAMDiscS1Speaker% in this version

    
    ' If user hit OK then save parameters (and return 1). 
	if i% = 1 then
        RecAMDiscSaveParams();
        
        'Set the GNG sandbox to -1 (don't check, value isn't present in this dialog)
        recCheckGNGSandbox% := -1;
        
        if recAMDiscMinS1% + recAMDiscVarS1% <= recMaxStimPerTrial%-1 then
            'Reset dialog OK button text on Select dialog, and note which experiment to run
            DlgValue$(-1,"Run AM Disc");
            DlgEnable(1,3);  'make sure that the Nspeakers selection item is enabled on the main dialog
            recExpToRun% := recExpAMDiscButton%;
            recExpSelectDialogAllowOK% := 1;  'Prepare to enable OK button
            recExpSelectDialogChanged%(-1);  'Enables "OK" button, -1 is sham input
        
            'assign AM-Disc-specific variables to experiment-wide variables (so we can keep separate defaults but only code once)
            recS1Speaker% := recAMDiscS1Speaker%;
            recS2Speaker% := recAMDiscS1Speaker%;  'S2 is same as S1
            recMinS1% := recAMDiscMinS1%;
            recVarS1% := recAMDiscVarS1%;
            recPropCatch := recAMDiscPropCatch;  'Make sure we need this
            recDeltadBLevel := 65-recAMDiscdBLevel;
            recActive% := recAMDiscActive%;
            recFixLED% := 1;
            recMatGenStim% := recAMDiscMatGenStim%;
            recTrialInitReward% := recAMDiscTrialInitReward%;
            recTrialHoldReward% := recAMDiscTrialHoldReward%;
            recDoRove% := recAMDiscDoRove%;
            recRovedB := recAMDiscRovedB;
        else
            message("The number of variable + constant S1s is greater than the maximum allowed number (%d)",recMaxStimPerTrial%-1);
            DlgValue$(-1,"OK");
            recExpSelectDialogAllowOK% := 0;  'Prepare to disable OK button
            recExpSelectDialogChanged%(-1);  'Disables "OK" button, -1 is sham input
        endif;   
        
'           'We might need to specify a number of trials here...I'm assuming yes.  Note that SEARCH runs until the
'           'user stops it, but this may be difficult to implement in practice - it would require fresh round(s) of
'           'trial list generation that don't happen for other experiment types.  Most likely the easiest way to do
'           'this is just to make a huge number of trials that the user won't exhaust, like 10,000 or something.        
        
        
        status% := 1;
    else
        status% := 1;
    endif
    
	return status%;
   
end;

'===== End RecExpAMDiscDialog =====
'
'




'
'
'===== RecExpAMDiscDialogChanged =====

func RecExpAMDiscDialogChanged%(item%) 
 
    docase
    case DlgValue(1) = 1 then
        DlgEnable(1,2);  'Enable use of generate list box
        DlgEnable(0,3);  'Disenable use of load list box
        DlgEnable(1,recAMDiscText1%);  'Enable use of generate list box
        DlgEnable(0,recAMDiscText2%);  'Disable use of load list box
    case DlgValue(1) = 0 then
        DlgEnable(0,2);  'Disenable use of generate list box
        DlgEnable(1,3);  'Enable use of load list box  
        DlgEnable(0,recAMDiscText1%);  'Enable use of generate list box
        DlgEnable(1,recAMDiscText2%);  'Disable use of load list box        
    endcase;
    
    'Enable/diable dB value based on rove checkbox
    DlgEnable(DlgValue(12),13);
    
    return 1;
end

'===== End RecExpAMDiscDialogChanged =====
'
'


'
'
'===== RecExpSpaceDisDialog =====

'A dialog for the SpaceDis experiment

func RecExpSpaceDisDialog%()
    
    var i%;
    var status% := 0;
    
    ' Fetch parameters from registry    
    RecSpaceDisGetParams();
    RecSpaceDisExpListLoadGetParams(recSpaceDisExpNameLoad$[],recSpaceDisStimcalNameLoad$[],recSpaceDisTrialsNameLoad$[]);
    RecSpaceDisExpListGenGetParams(recSpaceDisExpNameGen$[],recSpaceDisStimcalNameGen$[],recSpaceDisTrialsNameGen$[]);
        
    
    ' Generate the dialog    
    DlgCreate("Space Discrimination Dialog",0,0,75,14);
    
    DlgGroup("Stimulus Selection",1,1,73,4);
    DlgCheck(1,"Create Stimuli?",2,2);
    DlgList(2,27,recSpaceDisExpNameGen$[],recSpaceDisNumExps%,24,3); 'For list box, set width and put in a DlgText
    recSpaceDisText1% := DlgText("Select Exp't (Create Stim)",2,3);
    DlgList(3,27,recSpaceDisExpNameLoad$[],recSpaceDisNumExps%,24,4);
    recSpaceDisText2% := DlgText("Select Exp't (Load Stim)",2,4);
    DlgButton(recSpaceDisAddExpButton%, "  Add Experiment  ", RecSpaceDisAddExp%,53,3);
    DlgButton(recSpaceDisDeleteExpButton%, "Delete Experiment ", RecSpaceDisDeleteExp%,53,4);
    DlgButton(recSpaceDisReportExpButton%, "  Experiment Details  ", RecSpaceDisReportExp%,53,2);  'needs actual function written
    
    DlgGroup("Variables",1,6,73,6);
    'DlgInteger(4,6,1,20,27,6);  'S1 speaker  'Removing S1 speaker as S1s will be determined by trials in trials file
    'DlgText("Preferred Speaker",8,6);
    DlgInteger(4,6,1,9,27,7);  'Min S1
    DlgText("Minimum S1 Presentations",2,7);
    DlgCheck(9,"Trial initiation reward?",46,7);
    'DlgReal(10,4,0,3,65,8); DlgText("Training Reward, mL",46,8); 
    DlgCheck(10,"Trial hold reward?",46,8);
    
    DlgInteger(5,6,0,8,27,8);  'Var S1
    DlgText("Variable S1 Presentations",2,8);
    DlgReal(6,6,0,1,27,9);  'Proportion of catch trials
    DlgText("Proportion of Catch Trials",2,9);
    DlgText("(if catch trials are in trials file, set to 0)",2,10);
    DlgReal(7,6,0,100,65,9);  'dB level
    DlgText("dB Level",46,9);
    'DlgInteger(8,6,1,100,65,10);  'Repeats
    'DlgText("Repeats per stimulus",46,10);
    DlgInteger(8,6,1,100,27,11);  'Repeats
    DlgText("Repeats per stimulus",2,11);
    DlgCheck(11,"Active task?",2,12);
    DlgCheck(12,"Rove stimuli?",46,10);
    DlgReal(13,6,0,3,65,11);  'Rove db
    DlgText("Rove dB, +/-",46,11);
    
    DlgAllow(0xffff, 0, RecExpSpaceDisDialogChanged%);
    
    ' Show the dialog. 
    'i%:=DlgShow(recAMDiscMatGenStim%,recAMDiscExpIndexGen%,recAMDiscExpIndexLoad%,recAMDiscS1Speaker%,recAMDiscMinS1%,recAMDiscVarS1%,
    '            recAMDiscPropCatch,recAMDiscdBLevel,recAMDiscRepeatsPerStim%);  
    
    i%:=DlgShow(recSpaceDisMatGenStim%,recSpaceDisExpIndexGen%,recSpaceDisExpIndexLoad%,recSpaceDisMinS1%,recSpaceDisVarS1%,
    recSpaceDisPropCatch,recSpaceDisdBLevel,recSpaceDisRepeatsPerStim%, recSpaceDisTrialInitReward%, 
    recSpaceDisTrialHoldReward%, recSpaceDisActive%, recSpaceDisDoRove%, recSpaceDisRovedB);  'not setting recAMDiscS1Speaker% in this version

    
    ' If user hit OK then save parameters (and return 1). 
	if i% = 1 then
        RecSpaceDisSaveParams();
        
        'Set the GNG sandbox to -1 (don't check, value isn't present in this dialog)
        recCheckGNGSandbox% := -1;
        
        if recSpaceDisMinS1% + recSpaceDisVarS1% <= recMaxStimPerTrial%-1 then
            'Reset dialog OK button text on Select dialog, and note which experiment to run
            DlgValue$(-1,"Run Space Dis");
            DlgEnable(1,3);  'make sure that the Nspeakers selection item is enabled on the main dialog
            recExpToRun% := recExpSpaceDisButton%;
            recExpSelectDialogAllowOK% := 1;  'Prepare to enable OK button
            recExpSelectDialogChanged%(-1);  'Enables "OK" button, -1 is sham input
        
            'assign AM-Disc-specific variables to experiment-wide variables (so we can keep separate defaults but only code once)
'            recS1Speaker% := recSpaceDisS1Speaker%;
'            recS2Speaker% := recSpaceDisS1Speaker%;  'from AMDis
            recMinS1% := recSpaceDisMinS1%;
            recVarS1% := recSpaceDisVarS1%;
            recPropCatch := recSpaceDisPropCatch;  'Make sure we need this
            recDeltadBLevel := 65-recSpaceDisdBLevel;
            recActive% := recSpaceDisActive%; 
            recFixLED% := 1;
            recMatGenStim% := recSpaceDisMatGenStim%;
            recTrialInitReward% := recSpaceDisTrialInitReward%;
            recTrialHoldReward% := recSpaceDisTrialHoldReward%;
            recDoRove% := recSpaceDisDoRove%;
            recRovedB := recSpaceDisRovedB;
        else
            message("The number of variable + constant S1s is greater than the maximum allowed number (%d)",recMaxStimPerTrial%-1);
            DlgValue$(-1,"OK");
            recExpSelectDialogAllowOK% := 0;  'Prepare to disable OK button
            recExpSelectDialogChanged%(-1);  'Enables "OK" button, -1 is sham input
        endif;   
        
'           'We might need to specify a number of trials here...I'm assuming yes.  Note that SEARCH runs until the
'           'user stops it, but this may be difficult to implement in practice - it would require fresh round(s) of
'           'trial list generation that don't happen for other experiment types.  Most likely the easiest way to do
'           'this is just to make a huge number of trials that the user won't exhaust, like 10,000 or something.        
        
        
        status% := 1;
    else
        status% := 1;
    endif
    
	return status%;
   
end;

'===== End RecExpSpaceDisDialog% =====
'
'




'
'
'===== RecExpSpaceDisDialogChanged =====

func RecExpSpaceDisDialogChanged%(item%) 
 
    docase
    case DlgValue(1) = 1 then
        DlgEnable(1,2);  'Enable use of generate list box
        DlgEnable(0,3);  'Disenable use of load list box
        DlgEnable(1,recSpaceDisText1%);  'Enable use of generate list box
        DlgEnable(0,recSpaceDisText2%);  'Disenable use of load list box
    case DlgValue(1) = 0 then
        DlgEnable(0,2);  'Disenable use of generate list box
        DlgEnable(1,3);  'Enable use of load list box  
        DlgEnable(0,recSpaceDisText1%);  'Enable use of generate list box
        DlgEnable(1,recSpaceDisText2%);  'Disenable use of load list box        
    endcase;
    
    'Enable/diable dB value based on rove checkbox
    DlgEnable(DlgValue(12),13);
    
    return 1;
end

'===== End RecExpSpaceDisDialogChanged =====
'
'

'
'
'===== RecExpCueingDialog =====

'A dialog for the Cueing experiment

func RecExpCueingDialog%()
    
    var i%;
    var status% := 0;
    
    ' Fetch parameters from registry    
   
    
    ' Generate the dialog
    
    DlgCreate("Cueing Experiment Dialog", 25, 10);
    DlgCheck(1, "Is this a dummy dialog?");
    
    ' Show the dialog. 
    i%:=DlgShow(dummyVar%);
    
    ' If user hit OK then save parameters (and return 1). 
	if i% = 1 then
        recExpToRun% := recExpCueingButton%;
        
        'Set the GNG sandbox to -1 (don't check, value isn't present in this dialog...I mean, for now!)
        recCheckGNGSandbox% := -1;
        
        status% := 1;
    else
        status% := 1;
    endif
    
	return status%;
   
end;

'===== End RecExpCueingDialog =====
'
'


'
'
'===== RecExpStereoDisDialog =====

'A dialog for the Stereo Distractor experiment(s?)

func RecExpStereoDisDialog%()
    
    var i%;
    var status% := 0;
    
    ' Fetch parameters from registry, forced choice  
    RecStereoDisGetParams();
    RecStereoDisExpListLoadGetParams(recStereoDisExpNameLoad$[],recStereoDisStimcalNameLoad$[],recStereoDisTrialsNameLoad$[],recStereoDisStimcalDistractorNameLoad$[]);
    RecStereoDisExpListGenGetParams(recStereoDisExpNameGen$[],recStereoDisStimNameGen$[],recStereoDisTrialsNameGen$[]);
    
    ' Fetch parameters from registry, GNG
    RecStereoDisGNGGetParams();
    RecStereoDisGNGExpListLoadGetParams(recStereoDisGNGExpNameLoad$[],recStereoDisGNGStimcalNameLoad$[],recStereoDisGNGTrialsNameLoad$[],recStereoDisGNGStimcalDistractorNameLoad$[]);
    RecStereoDisGNGExpListGenGetParams(recStereoDisGNGExpNameGen$[],recStereoDisGNGStimNameGen$[],recStereoDisGNGTrialsNameGen$[]);
    
    ' Generate the dialog    
    DlgCreate("Stereo Distractor Dialog",0,0,75,15);
    
    DlgCheck(1,"Do Forced Choice Experiment",2,1);
    DlgCheck(2,"Generate Stimuli",30,1);
    DlgButton(recStereoDisReportExpButton%, "  Experiment Details  ", RecStereoDisReportExp%,53,1);  'needs actual function written
    
    DlgGroup("Stimulus Selection, Forced Choice",1,2,73,3);
    DlgList(3,27,recStereoDisExpNameGen$[],recStereoDisNumExps%,24,3);
    DlgList(4,27,recStereoDisExpNameLoad$[],recStereoDisNumExps%,24,4);
    recAMDiscText1% := DlgText("Select Exp't (Gen Stim)",2,3);
    recAMDiscText2% := DlgText("Select Exp't (Load Stim)",2,4); 
    DlgButton(recExpStereoDisAddExpButton%, "   Add Experiment   ", RecStereoDisAddExp%,53,3);
    DlgButton(recExpStereoDisDeleteExpButton%, "Delete Experiment ", RecStereoDisDeleteExp%,53,4);
    
    DlgGroup("Stimulus Selection, Go/No-Go",1,5,73,3);
    DlgList(5,27,recStereoDisGNGExpNameGen$[],recStereoDisGNGNumExps%,24,6);
    DlgList(6,27,recStereoDisGNGExpNameLoad$[],recStereoDisGNGNumExps%,24,7);
    recAMDiscText3% := DlgText("Select Exp't (Gen Stim)",2,6); 
    recAMDiscText4% := DlgText("Select Exp't (Load Stim)",2,7); 
    DlgButton(recExpStereoDisGNGAddExpButton%, "   Add Experiment   ", RecStereoDisGNGAddExp%,53,6);
    DlgButton(recExpStereoDisGNGDeleteExpButton%, "Delete Experiment ", RecStereoDisGNGDeleteExp%,53,7);
    
    DlgInteger(7,"Repeats Per Stim",1,1000,18,9);
    DlgReal(8,"Stimulus dB",1,100,18,10);
    DlgCheck(9,"Rove stimuli?",2,11);
    DlgReal(10,"Rove dB, +/-",0,3,18,12);  'Rove db
    DlgCheck(11,"Active task?",2,13);
    
    DlgCheck(12,"Trial initiation reward?",46,9);
    DlgCheck(13,"Trial Hold reward?",46,10);   
    
    DlgAllow(0xffff, 0, RecExpStereoDisDialogChanged%);   
    
    
    i%:=DlgShow(recStereoDisExpDoFC%,recStereoDisExpDoGen%,recStereoDisExpIndexGen%,recStereoDisExpIndexLoad%,
    recStereoDisGNGExpIndexGen%,recStereoDisGNGExpIndexLoad%,recStereoDisRepeatsPerStim%,recStereoDisdB,
    recStereoDisDoRove%,recStereoDisRovedB,recStereoDisActive%,recStereoDisTrialInitReward%, 
    recStereoDisTrialHoldReward%);   'Yes, that's it!

    
    ' If user hit OK then save parameters (and return 1). 
	if i% = 1 then
        'set the GNG indicator
        recStereoDisExpDoGNG% := 1-recStereoDisExpDoFC%;
        'set the load stimulus indicator
        recStereoDisExpDoLoad% := 1-recStereoDisExpDoGen%;
        
        RecStereoDisSaveParams();        
        RecStereoDisGNGSaveParams();
        
        DlgValue$(-1,"Run StereoDis"); 'to enable OK button? see also ~line 1156 in RecRoom (RecExpSearchDialog) 
        recExpToRun% := recExpStereoDisButton%;
        
        'Set the GNG sandbox variable
        recCheckGNGSandbox% := 1 - recStereoDisExpDoFC%;
        'Check to make sure that the joystick/lever is set correct for for GNG, if not, don't enable!
        if recIsGoNoGo% = recCheckGNGSandbox% then
            recExpSelectDialogAllowOK% := 1;  'Prepare to enable OK button
            recExpSelectDialogChanged%(-1);  'Enables "OK" button, -1 is sham input
        else
            recExpSelectDialogAllowOK% := 0;  'Prepare to disable OK button
            recExpSelectDialogChanged%(-1);  'Disables "OK" button, -1 is sham input
            recExpSelectDialogAllowOK% := -1;  'But inform the joystick/lever dialog that we're good to go once GNG is fixed
            if recCheckGNGSandbox% = 1 then
                message("Go/No-Go was selected here, but the joystick dialog is set for Forced Choice!");
            else
                message("Forced Choice was selected here, but the joystick dialog is set for Go/No-Go!");
            endif
        endif
            
        recActive% := recStereoDisActive%;
        recFixLED% := 1;
        
        recTrialInitReward% := recStereoDisTrialInitReward%;
        recTrialHoldReward% := recStereoDisTrialHoldReward%;
        
        
        recMatGenStim% := recStereoDisExpDoGen%;
        
        
        recDeltadBLevel := 65-recStereoDisdB;
        recDoRove% := recStereoDisDoRove%;
        recRovedB := recStereoDisRovedB;
    
        status% := 1;
    else
        'Set the GNG sandbox to -1 (don't check) if cancelled
        recCheckGNGSandbox% := -1;
        status% := 1;
    endif
    
	return status%;
   
end;


'
'
'===== RecExpStereoDisDialogChanged =====

' This function is initially called with a "0" input
func RecExpStereoDisDialogChanged%(item%)
    
    'For now, we should simply disallow any entries in this dialog EXCEPT FC/Gen, which is the only pathway that is being used, and the
    'only pathway being fully worked out.  Once this pathway is set up, the others may not be too hard, but until such time...
    DlgValue(1,1);
    DlgValue(2,1);
    DlgEnable(0,1);
    DlgEnable(0,2);
        
    docase
    case item% <= 2 and DlgValue(1) = 1 and DlgValue(2) = 1 then  'if we are running FC/Gen, disable GNG/Load buttons
        DlgEnable(1,3); 'Enable FC list selection (gen)
        DlgEnable(0,4); 'Disable FC list selection (load)
        DlgEnable(1,-recExpStereoDisAddExpButton%); 'Enable FC add button
        DlgEnable(1,-recExpStereoDisDeleteExpButton%); 'Enable FC delete button
        DlgEnable(0,5); 'Disable GNG list selection (gen)
        DlgEnable(0,6); 'Disable GNG list selection (load)
        DlgEnable(0,-recExpStereoDisGNGAddExpButton%); 'Disable GNG add button
        DlgEnable(0,-recExpStereoDisGNGDeleteExpButton%); 'Disable GNG delete button
        DlgEnable(1,recAMDiscText1%);  'Enable FC generate list text
        DlgEnable(0,recAMDiscText2%);  'Disable FC load list text
        DlgEnable(0,recAMDiscText3%);  'Disable GNG generate list text
        DlgEnable(0,recAMDiscText4%);  'Disable GNG load list text
    case item% <= 2 and DlgValue(1) = 0 and DlgValue(2) = 1 then 'if we are running GNG/Gen, disable FC/Load buttons
        DlgEnable(0,3); 'Disable FC list selection (gen)
        DlgEnable(0,4); 'Disable FC list selection (load)
        DlgEnable(0,-recExpStereoDisAddExpButton%); 'Disable FC add button
        DlgEnable(0,-recExpStereoDisDeleteExpButton%); 'Disable FC delete button
        DlgEnable(1,5); 'Enable GNG list selection (gen)
        DlgEnable(0,6); 'Disable GNG list selection (load)
        DlgEnable(1,-recExpStereoDisGNGAddExpButton%); 'Enable GNG add button
        DlgEnable(1,-recExpStereoDisGNGDeleteExpButton%); 'Enable GNG delete button
        DlgEnable(0,recAMDiscText1%);  'Disable FC generate list text
        DlgEnable(0,recAMDiscText2%);  'Disable FC load list text
        DlgEnable(1,recAMDiscText3%);  'Enable GNG generate list text
        DlgEnable(0,recAMDiscText4%);  'Disable GNG load list text
    case item% <= 2 and DlgValue(1) = 1 and DlgValue(2) = 0 then  'if we are running FC/Load, disable GNG/Gen buttons
        DlgEnable(0,3); 'Disable FC list selection (gen)
        DlgEnable(1,4); 'Enable FC list selection (load)
        DlgEnable(1,-recExpStereoDisAddExpButton%); 'Enable FC add button
        DlgEnable(1,-recExpStereoDisDeleteExpButton%); 'Enable FC delete button
        DlgEnable(0,5); 'Disable GNG list selection (gen)
        DlgEnable(0,6); 'Disable GNG list selection (load)
        DlgEnable(0,-recExpStereoDisGNGAddExpButton%); 'Disable GNG add button
        DlgEnable(0,-recExpStereoDisGNGDeleteExpButton%); 'Disable GNG delete button
        DlgEnable(0,recAMDiscText1%);  'Disable FC generate list text
        DlgEnable(1,recAMDiscText2%);  'Enable FC load list text
        DlgEnable(0,recAMDiscText3%);  'Disable GNG generate list text
        DlgEnable(0,recAMDiscText4%);  'Disable GNG load list text
    case item% <= 2 and DlgValue(1) = 0 and DlgValue(2) = 0 then 'if we are running GNG/Load, disable FC/Gen buttons
        DlgEnable(0,3); 'Disable FC list selection (gen)
        DlgEnable(0,4); 'Disable FC list selection (load)
        DlgEnable(0,-recExpStereoDisAddExpButton%); 'Disable FC add button
        DlgEnable(0,-recExpStereoDisDeleteExpButton%); 'Disable FC delete button
        DlgEnable(0,5); 'Disable GNG list selection (gen)
        DlgEnable(1,6); 'Enable GNG list selection (load)
        DlgEnable(1,-recExpStereoDisGNGAddExpButton%); 'Enable GNG add button
        DlgEnable(1,-recExpStereoDisGNGDeleteExpButton%); 'Enable GNG delete button
        DlgEnable(0,recAMDiscText1%);  'Disable FC generate list text
        DlgEnable(0,recAMDiscText2%);  'Disable FC load list text
        DlgEnable(0,recAMDiscText3%);  'Disable GNG generate list text
        DlgEnable(1,recAMDiscText4%);  'Enable GNG load list text
    endcase;
    
    'Enable/diable dB value based on rove checkbox
    DlgEnable(DlgValue(9),10);
    
    return 1;
end

'===== End RecExpStereoDisDialogChanged =====
'
'





'
'
'===== RecExpOneStimDiscrimDialog =====

'A dialog for the One Stim Discrimination experiment(s?)

func RecExpOneStimDiscrimDialog%()
    
    var i%;
    var status% := 0;
    var RecOneStimDiscrimTarget1$[5];
    var RecOneStimDiscrimVersus$[4];
    var RecOneStimDiscrimTarget2$[2];
    var RecOneStimDiscrimExptType$[3];
    var numChar%;
    
    RecOneStimDiscrimTarget1$[0] := "AMFreq";
    RecOneStimDiscrimTarget1$[1] := "ToneFreq";
    RecOneStimDiscrimTarget1$[2] := "Duration";
    RecOneStimDiscrimTarget1$[3] := "AMDepth";
    RecOneStimDiscrimTarget1$[4] := "StimName";
    
    RecOneStimDiscrimVersus$[0] := "Greater Than";
    RecOneStimDiscrimVersus$[1] := "Less Than";
    RecOneStimDiscrimVersus$[2] := "Equal To";
    RecOneStimDiscrimVersus$[3] := "Contains";
    
    RecOneStimDiscrimTarget2$[0] := "AMFreq2";
    RecOneStimDiscrimTarget2$[1] := "Value:";
    
    'Only one experiment type for now, but we will need this to allow flexible analysis of OneStimDiscrim data
    'The value here will be reported in the leading sampletext and will define the ExptType from there forward
    RecOneStimDiscrimExptType$[0] := "Generic";  
    RecOneStimDiscrimExptType$[1] := "AMFM"; 
    RecOneStimDiscrimExptType$[2] := "Boilermaker (ballistic if GNG)"; 
    
    ' Fetch parameters from registry, forced choice 
    RecOneStimDiscrimGetParams();
    RecOneStimDiscrimExpListLoadGetParams(recOneStimDiscrimExpNameLoad$[],recOneStimDiscrimStimcalNameLoad$[],recOneStimDiscrimTrialsNameLoad$[]);
    RecOneStimDiscrimExpListGenGetParams(recOneStimDiscrimExpNameGen$[],recOneStimDiscrimStimNameGen$[],recOneStimDiscrimTrialsNameGen$[]);
    
    ' Fetch parameters from registry, GNG
    RecOneStimDiscrimGNGGetParams();
    RecOneStimDiscrimGNGExpListLoadGetParams(recOneStimDiscrimGNGExpNameLoad$[],recOneStimDiscrimGNGStimcalNameLoad$[],recOneStimDiscrimGNGTrialsNameLoad$[]);
    RecOneStimDiscrimGNGExpListGenGetParams(recOneStimDiscrimGNGExpNameGen$[],recOneStimDiscrimGNGStimNameGen$[],recOneStimDiscrimGNGTrialsNameGen$[]);
    
    
    
    ' Generate the dialog    
    DlgCreate("One Stim Discrimination Dialog",0,0,75,19);
    
    
    DlgCheck(1,"Do Forced Choice Experiment",2,1);
    DlgCheck(2,"Generate Stimuli",30,1);
    'DlgCheck(1,"Generate Stimuli",2,1);
    DlgButton(recOneStimDiscrimReportExpButton%, "  Experiment Details  ", RecOneStimDiscrimReportExp%,53,1);  'needs actual function written
    
    DlgGroup("Stimulus Selection, Forced Choice",1,2,73,3);
    DlgList(3,27,recOneStimDiscrimExpNameGen$[],recOneStimDiscrimNumExps%,24,3);  'these are slow
    DlgList(4,27,recOneStimDiscrimExpNameLoad$[],recOneStimDiscrimNumExps%,24,4);
    recAMDiscText1% := DlgText("Select Exp't (Gen Stim)",2,3);
    recAMDiscText2% := DlgText("Select Exp't (Load Stim)",2,4); 
    DlgButton(recExpOneStimDiscrimAddExpButton%, "   Add Experiment   ", RecOneStimDiscrimAddExp%,53,3);
    DlgButton(recExpOneStimDiscrimDeleteExpButton%, "Delete Experiment ", RecOneStimDiscrimDeleteExp%,53,4);
    
    DlgGroup("Stimulus Selection, Go/No-Go",1,5,73,3);
    DlgList(5,27,recOneStimDiscrimGNGExpNameGen$[],recOneStimDiscrimGNGNumExps%,24,6);  'these are slow
    DlgList(6,27,recOneStimDiscrimGNGExpNameLoad$[],recOneStimDiscrimGNGNumExps%,24,7);
    recAMDiscText3% := DlgText("Select Exp't (Gen Stim)",2,6); 
    recAMDiscText4% := DlgText("Select Exp't (Load Stim)",2,7); 
    DlgButton(recExpOneStimDiscrimGNGAddExpButton%, "   Add Experiment   ", RecOneStimDiscrimGNGAddExp%,53,6);  'TODO the one stim discrim version doesn't exist yet
    DlgButton(recExpOneStimDiscrimGNGDeleteExpButton%, "Delete Experiment ", RecOneStimDiscrimGNGDeleteExp%,53,7);
    
    DlgInteger(7,"Repeats Per Stim",1,1000,18,9);
    DlgReal(8,"Stimulus dB",1,100,18,10);
    DlgCheck(9,"Rove stimuli?",2,11);
    DlgReal(10,"Rove dB, +/-",0,3,18,12);  'Rove db
    DlgCheck(11,"Active task?",2,13);
    
    DlgCheck(12,"Trial initiation reward?",46,9);
    DlgCheck(13,"Trial Hold reward?",46,10);   
    
    DlgGroup("Target (aka Response 1) Definition",1,14,73,4);
    DlgList(14,14,recOneStimDiscrimTarget1$[],5,3,15);
    DlgList(15,14,recOneStimDiscrimVersus$[],4,19,15);
    DlgList(16,14,recOneStimDiscrimTarget2$[],2,35,15);
    'DlgReal(17,12,0,50000,-3,15);   'Changing from real to string
    DlgString(17,12,40,"",-3,15); 
    DlgText("Experiment Type",2,16);
    DlgList(18,25,recOneStimDiscrimExptType$[],3,18,16);
    DlgCheck(19,"Update Reward By Gap",2,17);
    
    
    DlgAllow(0xffff, 0, RecExpOneStimDiscrimDialogChanged%);   
    
    
    i%:=DlgShow(recOneStimDiscrimExpDoFC%,recOneStimDiscrimExpDoGen%,recOneStimDiscrimExpIndexGen%,recOneStimDiscrimExpIndexLoad%,
    recOneStimDiscrimGNGExpIndexGen%,recOneStimDiscrimGNGExpIndexLoad%,recOneStimDiscrimRepeatsPerStim%,recOneStimDiscrimdB,
    recOneStimDiscrimDoRove%,recOneStimDiscrimRovedB,recOneStimDiscrimActive%,recOneStimDiscrimTrialInitReward%, 
    recOneStimDiscrimTrialHoldReward%,recOneStimDiscrimTarget1Ind%,recOneStimDiscrimVersusInd%,recOneStimDiscrimTarget2Ind%,
    recOneStimDiscrimValue$,recOneStimDiscrimExptType%,recUpdateRewardByGap%);

    
    ' If user hit OK then save parameters (and return 1). 
	if i% = 1 then
        'OK, honestly there are way too many indicators here, but in case they all get used, we can keep them.
        'set the GNG indicator.  We set generic indicators below, not sure if specifics are of any use.
        recOneStimDiscrimExpDoGNG% := 1-recOneStimDiscrimExpDoFC%;
        'set the load stimulus indicator
        recOneStimDiscrimExpDoLoad% := 1-recOneStimDiscrimExpDoGen%;
        
        RecOneStimDiscrimSaveParams();             
        
        'Set real value of comparison, if real value is needed
        if recOneStimDiscrimTarget1Ind% < 4 then  'if this is 4, we're looking for a stimulus name, if it's less, we're looking for a value
            recOneStimDiscrimValue := Val(recOneStimDiscrimValue$,numChar%);
            if numChar% = 0 then
                message("Error: The comparison value was empty or a string, must be a number!  Quitting!");
                halt;
            endif
        endif
        
        
        DlgValue$(-1,"Run OneStimDisc"); 'to enable OK button? see also ~line 1156 in RecRoom (RecExpSearchDialog) 
        recExpToRun% := recExpOneStimDiscrimButton%;
        
        'Set the GNG sandbox variable
        recCheckGNGSandbox% := recOneStimDiscrimExpDoGNG%;
        'Check to make sure that the joystick/lever is set correct for for GNG, if not, don't enable!
        if recIsGoNoGo% = recCheckGNGSandbox% then
            recExpSelectDialogAllowOK% := 1;  'Prepare to enable OK button
            recExpSelectDialogChanged%(-1);  'Enables "OK" button, -1 is sham input
        else
            recExpSelectDialogAllowOK% := 0;  'Prepare to disable OK button
            recExpSelectDialogChanged%(-1);  'Disables "OK" button, -1 is sham input
            recExpSelectDialogAllowOK% := -1;  'But inform the joystick/lever dialog that we're good to go once GNG is fixed
            if recCheckGNGSandbox% = 1 then
                message("Go/No-Go was selected here, but the joystick dialog is set for Forced Choice!");
            else
                message("Forced Choice was selected here, but the joystick dialog is set for Go/No-Go!");
            endif
        endif
        
        recActive% := recOneStimDiscrimActive%;
        recFixLED% := 1;
        
        recTrialInitReward% := recOneStimDiscrimTrialInitReward%;
        recTrialHoldReward% := recOneStimDiscrimTrialHoldReward%;
        
        recOneStimDiscrimExptLabel$ := recOneStimDiscrimExptType$[recOneStimDiscrimExptType%];
        
        recMatGenStim% := recOneStimDiscrimExpDoGen%;
        
        recDeltadBLevel := 65-recOneStimDiscrimdB;
        recDoRove% := recOneStimDiscrimDoRove%;
        recRovedB := recOneStimDiscrimRovedB;
        
        'Set ballistic here - as of first implementation 1/19/24, this is the only place 
        'ballistic is set, and only for Boilermaker GNG (but code should work for other
        'circumstances)
        if recOneStimDiscrimExptType% = 2 and recActive% = 1 and recIsGoNoGo% = 1 then
            doBallistic% := 1;
            'The idea behind ballistic is that in this case, for GNG non-target trials where 
            'no response (i.e. hold) is the correct response (i.e. correct rejections), we
            'want the animal to continue holding and the next stimulus will begin promptly,
            'rather than request a move to the origin and a new press to initiate a new trial.
            'Typically we would not expect these CRs to be rewarded, but because we can't be
            'sure this will always be true, the CR reward will have to be turned off at the
            'timing/reward dialog.  We will need to enforce continued hold in the initiation
            'position through the beginning of presentation of the next stimulus (at which
            'point the hold is naturally enforced); break of hold should be given FA penalty.
        else
            doBallistic% := 0;
        endif
        
        'Do not allow recUpdateRewardByGap% if experiment is not Boilermaker
        if recOneStimDiscrimExptType% <> 2 then
            recUpdateRewardByGap% := 0;
        endif
        
        status% := 1;
    else
        'Set the GNG sandbox to -1 (don't check) if cancelled
        recCheckGNGSandbox% := -1;
        
        'Make sure to reset recUpdateRewardByGap% if we do not click OK
        recUpdateRewardByGap% := 0;
        
        status% := 1;
    endif
    
	return status%;
   
end;


'
'
'===== RecExpOneStimDiscrimDialogChanged =====

' This function is initially called with a "0" input
func RecExpOneStimDiscrimDialogChanged%(item%)
    
    'For now, we should simply disallow any LOAD entries in this dialog and only allow GEN, we can add load
    'later if we need to
    'Full steam ahead, boys, we're adding LOAD!
    'DlgValue(1,2);
    'DlgEnable(0,2);
    'DlgEnable(0,4); 'Disable FC list selection (load)
        
'    docase
'    case DlgValue(2) = 1 then  'if we are running Gen, disable Load buttons
'        DlgEnable(1,3); 'Enable FC list selection (gen)
'        DlgEnable(0,4); 'Disable FC list selection (load)
'        'DlgEnable(1,-recExpOneStimDiscrimAddExpButton%); 'Enable FC add button
'        'DlgEnable(1,-recExpOneStimDiscrimDeleteExpButton%); 'Enable FC delete button
'        DlgEnable(1,recAMDiscText1%);  'Enable FC generate list text
'        DlgEnable(0,recAMDiscText2%);  'Disable FC load list text
'    case DlgValue(2) = 0 then 'if we are running Load, disable Gen buttons
'        DlgEnable(0,3); 'Disable FC list selection (gen)
'        DlgEnable(1,34); 'Enable FC list selection (load)
'        'DlgEnable(0,-recExpOneStimDiscrimAddExpButton%); 'Disable FC add button
'        'DlgEnable(0,-recExpOneStimDiscrimDeleteExpButton%); 'Disable FC delete button
'        DlgEnable(0,recAMDiscText1%);  'Disable FC generate list text
'        DlgEnable(1,recAMDiscText2%);  'Enable FC load list text
'    endcase;
    
    docase
    case item% <= 2 and DlgValue(1) = 1 and DlgValue(2) = 1 then  'if we are running FC/Gen, disable GNG/Load buttons
        DlgEnable(1,3); 'Enable FC list selection (gen)
        DlgEnable(0,4); 'Disable FC list selection (load)
        DlgEnable(1,-recExpOneStimDiscrimAddExpButton%); 'Enable FC add button
        DlgEnable(1,-recExpOneStimDiscrimDeleteExpButton%); 'Enable FC delete button
        DlgEnable(0,5); 'Disable GNG list selection (gen)
        DlgEnable(0,6); 'Disable GNG list selection (load)
        DlgEnable(0,-recExpOneStimDiscrimGNGAddExpButton%); 'Disable GNG add button
        DlgEnable(0,-recExpOneStimDiscrimGNGDeleteExpButton%); 'Disable GNG delete button
        DlgEnable(1,recAMDiscText1%);  'Enable FC generate list text
        DlgEnable(0,recAMDiscText2%);  'Disable FC load list text
        DlgEnable(0,recAMDiscText3%);  'Disable GNG generate list text
        DlgEnable(0,recAMDiscText4%);  'Disable GNG load list text
    case item% <= 2 and DlgValue(1) = 0 and DlgValue(2) = 1 then 'if we are running GNG/Gen, disable FC/Load buttons
        DlgEnable(0,3); 'Disable FC list selection (gen)
        DlgEnable(0,4); 'Disable FC list selection (load)
        DlgEnable(0,-recExpOneStimDiscrimAddExpButton%); 'Disable FC add button
        DlgEnable(0,-recExpOneStimDiscrimDeleteExpButton%); 'Disable FC delete button
        DlgEnable(1,5); 'Enable GNG list selection (gen)
        DlgEnable(0,6); 'Disable GNG list selection (load)
        DlgEnable(1,-recExpOneStimDiscrimGNGAddExpButton%); 'Enable GNG add button
        DlgEnable(1,-recExpOneStimDiscrimGNGDeleteExpButton%); 'Enable GNG delete button
        DlgEnable(0,recAMDiscText1%);  'Disable FC generate list text
        DlgEnable(0,recAMDiscText2%);  'Disable FC load list text
        DlgEnable(1,recAMDiscText3%);  'Enable GNG generate list text
        DlgEnable(0,recAMDiscText4%);  'Disable GNG load list text
    case item% <= 2 and DlgValue(1) = 1 and DlgValue(2) = 0 then  'if we are running FC/Load, disable GNG/Gen buttons
        DlgEnable(0,3); 'Disable FC list selection (gen)
        DlgEnable(1,4); 'Enable FC list selection (load)
        DlgEnable(1,-recExpOneStimDiscrimAddExpButton%); 'Enable FC add button
        DlgEnable(1,-recExpOneStimDiscrimDeleteExpButton%); 'Enable FC delete button
        DlgEnable(0,5); 'Disable GNG list selection (gen)
        DlgEnable(0,6); 'Disable GNG list selection (load)
        DlgEnable(0,-recExpOneStimDiscrimGNGAddExpButton%); 'Disable GNG add button
        DlgEnable(0,-recExpOneStimDiscrimGNGDeleteExpButton%); 'Disable GNG delete button
        DlgEnable(0,recAMDiscText1%);  'Disable FC generate list text
        DlgEnable(1,recAMDiscText2%);  'Enable FC load list text
        DlgEnable(0,recAMDiscText3%);  'Disable GNG generate list text
        DlgEnable(0,recAMDiscText4%);  'Disable GNG load list text
    case item% <= 2 and DlgValue(1) = 0 and DlgValue(2) = 0 then 'if we are running GNG/Load, disable FC/Gen buttons
        DlgEnable(0,3); 'Disable FC list selection (gen)
        DlgEnable(0,4); 'Disable FC list selection (load)
        DlgEnable(0,-recExpOneStimDiscrimAddExpButton%); 'Disable FC add button
        DlgEnable(0,-recExpOneStimDiscrimDeleteExpButton%); 'Disable FC delete button
        DlgEnable(0,5); 'Disable GNG list selection (gen)
        DlgEnable(1,6); 'Enable GNG list selection (load)
        DlgEnable(1,-recExpOneStimDiscrimGNGAddExpButton%); 'Enable GNG add button
        DlgEnable(1,-recExpOneStimDiscrimGNGDeleteExpButton%); 'Enable GNG delete button
        DlgEnable(0,recAMDiscText1%);  'Disable FC generate list text
        DlgEnable(0,recAMDiscText2%);  'Disable FC load list text
        DlgEnable(0,recAMDiscText3%);  'Disable GNG generate list text
        DlgEnable(1,recAMDiscText4%);  'Enable GNG load list text
    endcase;
    
    
    
    
    
    'Enable/diable dB value based on rove checkbox
    DlgEnable(DlgValue(8),10);
    
    'Do not allow illegal selections in the drop down boxes
    if DlgValue(14) > 0 then  'If we are not using AMFreq in the first value, AMFreq2 cannot be the second value!
        'Do not allow second comparator to be AMFreq2, must be Value
        DlgValue(16,1);  'We don't have to check, just set it
    endif
    if DlgValue(2) = 1 and DlgValue(14) = 4 then  'If we are generating stimuli, we don't have a StimName!
        DlgValue(14,0);  'force to AMFreq
    endif;
    if DlgValue(14) = 4 then  'if we are doing StimName
        'Do not allow "greater than" or "less than"
        if DlgValue(15) < 2 then
            DlgValue(15,2);  'force to "equal to"
        endif
        'Do not allow second comparator to be AMFreq2, must be Value
        DlgValue(16,1);  'We don't have to check, just set it
    else 'if we are NOT doing StimName
        'Do not allow "contains"
        if DlgValue(15) = 3 then
            DlgValue(15,2);  'force to "equal to"
        endif
    endif
    
    'Enable/disable "value" of target based on third dropdown list
    DlgEnable(DlgValue(16),17);
    
    'Enable/disable value of recUpdateRewardByGap% based on third dropdown list
    if DlgValue(18) = 2 then
        DlgEnable(1,19);
    else
        DlgEnable(0,19);
        DlgValue(19,0);  'set value to 0
    endif
    
    return 1;
end

'===== End RecExpOneStimDiscrimDialogChanged =====
'
'













'
'
'===== RecExpTimingRewardDialog =====

'A dialog for Timing and Rewards

func RecExpTimingRewardDialog%()
    
    var i%;
    var dummy%;
    var status% := 0;
    'var trwid% := 42;
    var trwid% := 84;
    var intStr$[2];
    var c1%;
    c1% := trwid%-56;
    var c1txt% := 2;
    var c2%;
    c2% := trwid%-14;
    var c2txt%;
    c2txt% := trwid%-40;
    
    var rewardType$[4];
    rewardType$[0] := "Water/Small Booth";
    rewardType$[1] := "Juice/Small Booth";
    rewardType$[2] := "Water/Big Booth";
    rewardType$[3] := "Juice/Big Booth";
    
'Retained code for using stimulation reward that will probably never ever come back     
'    var rewardType$[6];
'    rewardType$[0] := "Juice Only";
'    rewardType$[1] := "Stimulation Only";
'    rewardType$[2] := "Juice+Stim";
'    rewardType$[3] := "Cycle J/Stim/J+Stim";
'    rewardType$[4] := "Set probabilities";
'    rewardType$[5] := "Juice + Stim(sometimes)";
    
    var houseLightType$[3];
    houseLightType$[0] := "None";
    houseLightType$[1] := "House Light On";
    houseLightType$[2] := "House Light w/Timeout";
    
    intStr$[0] := "Stop Sound";
    intStr$[1] := "Complete Sound";

    
    ' Fetch parameters from registry , only if not a runtime call, in a runtime call, use current (i.e. most recent) values
    if recRunTimeCall% = 0 then   
        RecTimingRewardGetParams();   'RecTimingRewardGetParams() is below 
    endif;
    
    'Set up container for reals so we can have more than 20 elements in the dialog
    var eightReals[8];
    eightReals[0] := recInitRewardmL;
    eightReals[1] := recHoldRewardmL;
    eightReals[2] := recHitRewardmL;
    eightReals[3] := recCRRewardmL;
    eightReals[4] := recMaxHitRewardmL;
    eightReals[5] := recMaxCRRewardmL;
    eightReals[6] := recHitRewardIncmL;
    eightReals[7] := recS1RewardIncmL;
    
    'This will tell us how much is neither juice nor Stimulation
    var pctBoth%;
    pctBoth% := 100 - recPctJuice% - recPctStimulation%;
    
    
    ' Because the Audiogram experiment reassigns some of the values from this dialog, if this
    ' dialog is selected AFTER the audiogram dialog is selected, disable "OK" and force audiogram
    ' dialog to be selected again.  But don't do this if this dialog is called mid-recording because
    ' the dialog changed function will not refer to a valid dialog
    if recExpToRun% = recExpAudiogramButton% and recRunTimeCall% = 0 then
        DlgValue$(-1,"Reselect Audiogram"); 'to rename OK button 
        recExpSelectDialogAllowOK% := 0;  'Prepare to disable OK button
        recExpSelectDialogChanged%(-1);  'Disables "OK" button, -1 is sham input
        'I'd like to point out how cool this is.
    endif;
    
    
    ' Generate the dialog
    
    DlgCreate("Timing and Reward Dialog", 0, 0, trwid%, 25);
    DlgGroup("Timing Parameters",1,1,trwid%-2,4);
    DlgReal(1,12,0,10,c1%,2); DlgText("Minimum Onset Delay (ITI), s",c1txt%,2);
    DlgReal(2,12,0,10,c1%,3); DlgText("Variable Onset Delay (ITI), s",c1txt%,3);
    DlgReal(3,12,0,10,c2%,2); DlgText("Minimum ISI, s",c2txt%,2);
    DlgReal(4,12,0,10,c2%,3); DlgText("Variable ISI, s",c2txt%,3);
    DlgReal(5,12,0.5,100,c1%,4); DlgText("Trial Initiation Window, s",c1txt%,4);
    DlgReal(6,12,0.5,100,c2%,4); DlgText("Response Window, s",c2txt%,4);
  '  DlgReal(18,12,0,100,c2%,4); DlgText("Joystick Min Duration, s",c2txt%,4); 'this variable doesn't seem to be used anywhere; same as MinOnsetDelay ??
    
    DlgGroup("Time Outs, etc.",1,6,trwid%-2,4);
    '''Lazy monkey timeout excised!  Uncomment to reinstate!
'    DlgReal(6,12,0,300,c1%,9); DlgText("Lazy Monkey TO, s",c1txt%,9);
    DlgReal(7,12,0,300,c1%,9); DlgText("THIS DOES NOTHING, s",c1txt%,9);
    
    DlgReal(8,12,0,300,c1%,7); DlgText("Miss TO, s",c1txt%,7);
    DlgReal(9,12,0,300,c1%,8); DlgText("False Alarm TO, s",c1txt%,8);
    DlgCheck(20,"Do Miss Repeats?",c2txt%+8,7);
    DlgInteger(21,12,0,30,c2%,8); DlgText("Max # Miss Repeats", c2txt%,8);
    
    DlgGroup("Rewards",1,11,trwid%-2,7);
    DlgReal(10,12,0,3,c1%,12); DlgText("Init Training Reward, mL",c1txt%,12); 'recInitRewardmL
    DlgReal(11,12,0,3,c2%,12); DlgText("Hold Training Reward, mL",c2txt%,12); 'recHoldRewardmL
    DlgReal(12,12,0,3,c1%,13); DlgText("Hit Reward, mL",c1txt%,13);
    DlgReal(13,12,0,3,c2%,13); DlgText("CR Reward, mL",c2txt%,13);
    DlgReal(14,12,0,3,c1%,14); DlgText("Max Hit Reward, mL",c1txt%,14);
    DlgReal(15,12,0,3,c2%,14); DlgText("Max CR Reward, mL",c2txt%,14);
    DlgReal(16,12,0,1,c1%,15); DlgText("Reward Increment on hits, mL",c1txt%,15);
    DlgReal(17,12,0,1,c2%,15); DlgText("Reward Increment Per S1, mL",c2txt%,15);
    DlgList(22,19,rewardType$[],4,c1%-7,16); DlgText("Reward Type",c1txt%,16);
    DlgReal(23,12,0,1500,c2%,16); DlgText("Start Water/Juice Volume (mL)", c2txt%,16);
    
'Retained code for using stimulation reward that will probably never ever come back    
'    DlgList(21,19,rewardType$[],6,c1%-7,16); DlgText("Reward Type",c1txt%,16);    
'    DlgInteger(22,12,0,100,c1%-15,17); DlgText("Pct Juice",c1txt%,17);  'note that these are on a three-per line and use different values
'    DlgInteger(23,12,0,100,c1%+15,17); DlgText("Pct Stimulation",c1%+1,17);
'    DlgLabel(24,"Pct Juice+Stimulation = "+Str$(pctBoth%),c1%+29,17);
'    DlgInteger(25,12,0,500,c2%,16); DlgText("Stim Delay rel. to Juice (ms)", c2txt%,16);
    
    DlgGroup("Interrupts",1,19,trwid%-2,2);
    DlgList(18,20,intStr$[],2,c1%-8,20); DlgText("On S1 Interrupt",c1txt%,20);
    DlgList(19,20,intStr$[],2,c2%-8,20); DlgText("On S2 Interrupt",c2txt%,20);
    
    DlgGroup("House Light",1,22,trwid%-2,2);
    DlgList(24,20,houseLightType$[],3,c1%-8,23); DlgText("House Light",c1txt%,23);
    
    DlgAllow(0xffff, 0, RecExpTimingRewardDialogChanged%);
        
    i%:=DlgShow(recMinOnsetDelay,recVarOnsetDelay,recISI,recISIVariable,recTrialInitWindow,recResponseWindow,recLazyMonkeyTO,recMissTO,recFalseAlarmTO,
                eightReals[],recContinueSoundOnS1Interrupt%,recContinueSoundOnS2Interrupt%,recMissRepeats%, recMissRepeatsMax%, 
                recJuiceWaterBooth%,recInitialJuiceVolumemL,recHouseLight%);
    
'Retained code for using stimulation reward that will probably never ever come back    
'    i%:=DlgShow(recMinOnsetDelay,recVarOnsetDelay,recISI,recTrialInitWindow,recResponseWindow,recLazyMonkeyTO,recMissTO,recFalseAlarmTO,
'                eightReals[],recContinueSoundOnS1Interrupt%,recContinueSoundOnS2Interrupt%,recMissRepeats%, recMissRepeatsMax%, 
'                recRewardType%,recPctJuice%,recPctStimulation%,dummy%,recJuiceToStimDelay%);
    
    ' If user hit OK then save parameters (and return 1). 
	if i% = 1 then
        'unpack eightReals
        recInitRewardmL := eightReals[0];
        recHoldRewardmL := eightReals[1];
        recHitRewardmL := eightReals[2];
        recCRRewardmL := eightReals[3];
        recMaxHitRewardmL := eightReals[4];
        recMaxCRRewardmL := eightReals[5];
        recHitRewardIncmL := eightReals[6];
        recS1RewardIncmL := eightReals[7];
        
        recCurrentJuiceVolumemL := recInitialJuiceVolumemL;  'Set the volume of juice in the juicer, current volume will be updated continuously
        
'Retained code for using stimulation reward that will probably never ever come back         
'        'make sure that probability values are valid
'        if recRewardType% = 4 then
'            if recPctJuice% + recPctStimulation% > 100 then
'                message("The percentage of Juice + Stimulation is greater than 100!  Reverting to 'cycled' reward! \nPlease re-try dialog!");
'                recRewardType% := 3;
'            endif;
'        endif;
'        
'        'set first reward type randomly if cycling (this will actually be cycled before the first trial, but it gets us a random start point
'        'also, set reward type permanently if not changing
'        docase
'        case recRewardType% = 3 then
'            recCurrentRewardType% := Floor(Rand(3,0));  'will give [0, 1, 2] for [juice, stim, both]
'        case recRewardType% = 2 then 
'            recCurrentRewardType% := 2;  'if juice + stim, set to juice + stim
'        case recRewardType% = 1 then
'            recCurrentRewardType% := 1;  'if only stim, set to stim
'        case recRewardType% = 0 then
'            recCurrentRewardType% := 0;  'if only juice, set to juice
'        endcase;
        
        'set maximum number of electrodes allowed, based on whether we need stimulation ports
        'if recRewardType% > 0 then 'if stimulating
        '    maxTrodes% := 4;  'per Conor, Reclab will NOT be using multi-contact probes and stimulation together
        'else
        '    maxTrodes% := 28;  
        'endif;
        
        
        'if recRunTimeCall% = 0 then 'only save parameters if it's a non-run-time call, run-time calls are often for late-session adjustments and shouldn't start the next session
        'Request has come down to countermand that directive - save parameters to the registry even on a runtime call!
            RecTimingRewardSaveParams();   'RecTimingRewardSaveParams() is below 
        'endif;
        
        'After saving to registry, turn off recMissRepeats% if recMissRepeatsMax% is 0; set recMissRepeatsMax% to 0 if recMissRepeats% is off
        'This was only implemented 11-21-2023 because of confusion on the analysis side
        'recDatabase was similarly adjusted
        if recMissRepeats% = 0 or recMissRepeatsMax% = 0 then
            recMissRepeats% := 0;
            recMissRepeatsMax% := 0;
        endif;
        
        
        status% := 1;
    else
        status% := 1;
    endif
    
	return status%;
   
end;

'===== End RecExpTimingRewardDialog =====
'
'



'
'
'===== RecExpTimingRewardDialogChanged =====

' This function is initially called with a "0" input
func RecExpTimingRewardDialogChanged%(item%) 
    
    
    'Note that if the stimulation protocol is returned, these Dialog numbers will no longer be valid, can't just uncomment
'    docase
'    case DlgValue(20) = 4 then  'if setting probabilities of juice, etc.
'        DlgEnable(1,21); 'Enable juice probability
'        DlgEnable(1,22); 'Enable stim probability
'        DlgEnable(1,23); 'Enable juice+stim probability label
'    case DlgValue(20) = 5 then 'if setting juice + stim, but it's always juice
'        DlgEnable(0,21); 'Disable juice probability
'        DlgEnable(1,22); 'Enable stim probability
'        DlgEnable(0,23); 'Disable juice+stim probability label
'    else
'        DlgEnable(0,21); 'Disable juice probability
'        DlgEnable(0,22); 'Disable stim probability
'        DlgEnable(0,23); 'Disable juice+stim probability label
'    endcase;
'    
'    if DlgValue(20) = 0 then 'if only juice
'        DlgEnable(0,24); 'Disable stim delay
'    else
'        DlgEnable(1,24); 'Enable stim delay
'    endif;
    
    
'Retained code for using stimulation reward that will probably never ever come back 
'    DlgEnable(0,21); 'Disable stimulation reward
'    DlgEnable(0,22); 'Disable juice pct
'    DlgEnable(0,23); 'Disable stim pct
'    DlgEnable(0,24); 'Disable label
'    DlgEnable(0,25); 'Disable stim delay
    
    
'    'update value in text label
'    if item% = 22 or item% = 23 then
'        printlog("val should be %s\n",Str$(100-DlgValue(22)-DlgValue(23)));
'        DlgValue$(24,"Pct Juice+Stimulation = "+Str$(100-DlgValue(22)-DlgValue(23)));
'    endif;
    
    DlgEnable(0,15); 'Disable max CR reward, not implemented
    DlgEnable(0,17); 'Disable increment on S1, not implemented    
    
    'Set max CR reward to whatever the current CR reward is
    if item% = 13 then
        DlgValue(15,DlgValue(13));
    endif;
    
    'And zero out the increment on S1 value - hate to do it every single time the dialog is updated, but whatevs.
    DlgValue(17,0);
    
    return 1;
end

'===== End RecExpTimingRewardDialogChanged =====
'
'




'
'
'===== RecLeverJoystickDialog =====

'A dialog for Lever/Joystick settings

func RecExpLeverJoystickDialog%()
    
    var i%;
    var status% := 0;
    var trwid% := 45;
    var joyStr$[5];
    var initStr$[7];
    var resp1Str$[7];
    var resp2Str$[8];
    var c1%;
    c1% := trwid%-15;
    var c1txt% := 2;
    var nxax%;
    var nyax%;
    
    'This variable will allow us to set limits in a threshold subfunction based on whether or not
    'incrementing is happening, must set this to 0 before exiting function
    incrementDialogItem% := 5;
    
    joyStr$[0] := "Lever";
    joyStr$[1] := "Joystick";
    joyStr$[2] := "Joystick, Flip X";
    joyStr$[3] := "Joystick, Flip Y";
    joyStr$[4] := "Joystick, Flip Both";
    
    initStr$[0] := "Not Allowed";
    initStr$[1] := "Down";
    initStr$[2] := "Up";
    initStr$[3] := "Right";
    initStr$[4] := "Left";
    initStr$[5] := "X Axis";
    initStr$[6] := "Y Axis";
    
    resp1Str$[0] := "Center";
    resp1Str$[1] := "Down";
    resp1Str$[2] := "Up";
    resp1Str$[3] := "Right";
    resp1Str$[4] := "Left";
    resp1Str$[5] := "X Axis";
    resp1Str$[6] := "Y Axis";
    
    resp2Str$[0] := "Center";
    resp2Str$[1] := "Down";
    resp2Str$[2] := "Up";
    resp2Str$[3] := "Right";
    resp2Str$[4] := "Left";
    resp2Str$[5] := "X Axis";
    resp2Str$[6] := "Y Axis";
    resp2Str$[7] := "None";
    
    
    ' Fetch parameters from registry
    RecLeverJoystickGetParams();   'RecLeverJoystickGetParams() is below    
    
    
    ' Generate the dialog
    
    DlgCreate("Joystick/Lever Dialog", 0, 0, trwid%, 11);
    DlgList(1,20,joyStr$[],5,c1%-6,1); DlgText("Response Device",c1txt%,1);
    DlgList(2,20,initStr$[],7,c1%-6,2); DlgText("Trial Initiation Position",c1txt%,2);
    DlgCheck(6,"Expt is Go/No-Go",2,3);
    DlgList(3,20,resp1Str$[],7,c1%-6,4); DlgText("Response 1 (S2) Position",c1txt%,4);
    DlgList(4,20,resp2Str$[],8,c1%-6,5); DlgText("Response 2 (S1) Position",c1txt%,5);
    DlgButton(2,"Joystick Thresholds",SetJoystickThresholdDialog%,2,6);
    DlgCheck(5,"Do Increments",2,7);
    DlgButton(3,"Joystick Increments",SetJoystickThresholdIncrementDialog%,2,8);
    DlgButton(4,"Joystick Limits",SetJoystickThresholdLimitDialog%,2,9);
    
    'set dialog changed function
    DlgAllow(0xffff, 0, RecExpLeverJoystickDialogChanged%);
    
    ' Show the dialog. 
    i%:=DlgShow(recUseJoystick%,recTrialInitPosition%,recTrialResponsePosition1%,recTrialResponsePosition2%,recDoIncrements%,recIsGoNoGo%);
    
    ' If user hit OK then save parameters (and return 1). 
	if i% = 1 then
        
        if recRunTimeCall% = 0 then  'don't run the dialog changed function that applies to the main dialog if the main dialog isn't open!
            RecExpSelectDialogChanged%(0); 'this might work?  Yep!  This changes the button label on the main dialog, if necessary
            
            'Check GNG sandbox, if necessary
            if recCheckGNGSandbox% > -1 then
                if recIsGoNoGo% <> recCheckGNGSandbox% then
                    message("The FC/GNG value set here does not match the value set in the active experiment!");
                else
                    'Enable the OK button if all was well in a dialog whose GNG/FC value conflicted with here
                    if recExpSelectDialogAllowOK% = -1 then
                        recExpSelectDialogAllowOK% := 1;  'Prepare to enable OK button
                        recExpSelectDialogChanged%(-1);  'Enables "OK" button, -1 is sham input
                    endif
                endif
            endif
        endif
        
        
        'Apply flip, be explicit
        docase
        case recUseJoystick% = 1 then
            flipx := 1;  'no flip, etc.
            flipy := 1;
        case recUseJoystick% = 2 then
            flipx := -1;  'flip, etc.
            flipy := 1;
        case recUseJoystick% = 3 then
            flipx := 1;
            flipy := -1; 
        case recUseJoystick% = 4 then
            flipx := -1;  
            flipy := -1;            
        endcase
        
        
        'here's an attempt at being clever and saving some time
        'the following three DOCASES just tally up the number of times a certain position (e.g. "up", "left")
        'is called for in the three boxes.  Many results of 2 or lower are legal; any result of 3 or higher
        'is illegal; any result of 0 is illegal in forced choice.
        docase
        case recTrialInitPosition% = 3 or recTrialInitPosition% = 4 then 'left OR right
            nxax% := nxax% + 1;
        case recTrialInitPosition% = 1 or recTrialInitPosition% = 2 then 'up OR down
            nyax% := nyax% +1;
        case recTrialInitPosition% = 5 then 'both x-axis used
            nxax% := nxax% +2;  
        case recTrialInitPosition% = 6 then 'both y-axis used
            nyax% := nyax% +2;
        endcase
        
        docase
        case recTrialResponsePosition1% = 3 or recTrialResponsePosition1% = 4 then 'left OR right
            nxax% := nxax% + 1;
        case recTrialResponsePosition1% = 1 or recTrialResponsePosition1% = 2 then 'up OR down 
            nyax% := nyax% +1;
        case recTrialResponsePosition1% = 5 then 'both x-axis used
            nxax% := nxax% +2;  
        case recTrialResponsePosition1% = 6 then 'both y-axis used
            nyax% := nyax% +2;
        endcase
        
        docase
        case recTrialResponsePosition2% = 3 or recTrialResponsePosition2% = 4 then 'left OR right
            nxax% := nxax% + 1;
        case recTrialResponsePosition2% = 1 or recTrialResponsePosition2% = 2 then 'up OR down
            nyax% := nyax% +1;
        case recTrialResponsePosition2% = 5 then 'both x-axis used
            nxax% := nxax% +2;  
        case recTrialResponsePosition2% = 6 then 'both y-axis used
            nyax% := nyax% +2;
        endcase
        
        docase
        case recIsGoNoGo% = 0 and recTrialResponsePosition2% = 7 then
            message("Error - Response Position 2 cannot be 'None' for Forced Choice");
            RecExpLeverJoystickDialog%();  'call recursively - you can eat your soup right out of the ash trays if you wanna, it's OK, they're clean!
            status% := 1
        case nyax% > 2 or nxax% > 2 then
            message("Error - Init/resp1/resp2 positions cannot coincide!");
            RecExpLeverJoystickDialog%();  'call recursively - you can eat your soup right out of the ash trays if you wanna, it's OK, they're clean!
            status% := 1;
        case recIsGoNoGo% = 0 and (nyax% = 0 or nxax% = 0) then
            message("Error - Forced choice positions can't be on a line (think about it)!");
            'Note that if the origin were allowed to be somewhere other than the center (which it's not)
            'then the trial init position COULD be the center (currently can't be) and then this case
            'would no longer apply
            RecExpLeverJoystickDialog%();  'call recursively - you can eat your soup right out of the ash trays if you wanna, it's OK, they're clean!
            status% := 1;
        case recTrialInitPosition% = 0 then
            message("Error - You selected 'Not Allowed', you turd!");
            RecExpLeverJoystickDialog%();  'call recursively - you can eat your soup right out of the ash trays if you wanna, it's OK, they're clean!
            status% := 1
        case recTrialInitPosition% = recTrialResponsePosition1% or recTrialInitPosition% = recTrialResponsePosition2% or recTrialResponsePosition1% = recTrialResponsePosition2% then
            message("Error - Init/resp1/resp2 positions cannot coincide!");
            RecExpLeverJoystickDialog%();  'call recursively - you can eat your soup right out of the ash trays if you wanna, it's OK, they're clean!
            status% := 1;
        else
            RecLeverJoystickSaveParams();  
            'apply the changed values to the voltage versions of the variables            
            GetJoystickDegreesInVoltage(joystickVoltageConversionFactor);  
            status% := 1;
        endcase;
        
'This is an older version, using very simple rules        
'        'set incrementing variables, start by zeroing everything, then add change what is needed
'        'The current increment/decrement rules are as follows: 
'        'Increment on completion of a correct trial (H/CR)
'        'Decrement on Lazy Monkey Timeout for non-initiation of trial
'        'Do Not adjust on Lazy Monkey Timeout for non-return to center
'        'Do Not adjust in any other circumstance
'        doIncUp% := 0;
'        doIncDown% := 0;
'        doIncLeft% := 0;
'        doIncRight% := 0;
'        if recDoIncrements% = 1 then
'            'right now, only the init position can be set, this will require more thought if response position
'            'can be set in the future
'            if recTrialInitPosition% = 1 or recTrialInitPosition% = 6 then
'                doIncDown% := 1;
'            endif;
'            if recTrialInitPosition% = 2 or recTrialInitPosition% = 6 then
'                doIncUp% := 1;
'            endif;
'            if recTrialInitPosition% = 3 or recTrialInitPosition% = 5 then
'                doIncRight% := 1;
'            endif;
'            if recTrialInitPosition% = 4 or recTrialInitPosition% = 5 then
'                doIncLeft% := 1;
'            endif;            
'        endif;
        
        'Set incrementing variables, start by zeroing everything then change what is needed
        '[0] = up, [1] = down, [2] = left, [3] = right
        'The current increment/decerement rules are as follows:
        'Increment trial initiation direction on successful trial initiation 
        'Decrement trial initiation direction on failed trial initiation 
        'Increment S2 response direction on Hit, FC only (GNG is return to center)
        'Decrement S2 response direction on NR to S2H (no decrement on resp to S2L)
        'Increment S1 response direction on CR, for FC only (GNG is hold)
        'Decrement S1 response direction on NR to S2L (no decrement on resp to S2H)
        ArrConst(doIncTrialInit%[],0);
        ArrConst(doDecTrialInit%[],0);
        ArrConst(doIncHit%[],0);
        ArrConst(doDecNoRespS2H%[],0);
        ArrConst(doIncCR%[],0);
        ArrConst(doDecNoRespS2L%[],0);
        if recDoIncrements% = 1 then
            docase
            case recTrialInitPosition% = 1 then
                doIncTrialInit%[1] := 1;
                doDecTrialInit%[1] := -1;
            case recTrialInitPosition% = 2 then
                doIncTrialInit%[0] := 1;
                doDecTrialInit%[0] := -1;
            case recTrialInitPosition% = 3 then
                doIncTrialInit%[3] := 1;
                doDecTrialInit%[3] := -1;
            case recTrialInitPosition% = 4 then
                doIncTrialInit%[2] := 1;
                doDecTrialInit%[2] := -1;
            case recTrialInitPosition% = 5 then
                doIncTrialInit%[2] := 1;
                doDecTrialInit%[2] := -1;
                doIncTrialInit%[3] := 1;
                doDecTrialInit%[3] := -1;    
            case recTrialInitPosition% = 6 then
                doIncTrialInit%[0] := 1;
                doDecTrialInit%[0] := -1;
                doIncTrialInit%[1] := 1;
                doDecTrialInit%[1] := -1;
            endcase
            'Note that because there is no logical to inc/dec a return to center (it just conflicts with
            'the trial initiation inc/dec), these docases are structured exactly the same as the trial init one above
            'This is S2/S2H response direction
            docase
            case recTrialResponsePosition1% = 1 then
                doIncHit%[1] := 1;
                doDecNoRespS2H%[1] := -1;
            case recTrialResponsePosition1% = 2 then
                doIncHit%[0] := 1;
                doDecNoRespS2H%[0] := -1;
            case recTrialResponsePosition1% = 3 then
                doIncHit%[3] := 1;
                doDecNoRespS2H%[3] := -1;
            case recTrialResponsePosition1% = 4 then
                doIncHit%[2] := 1;
                doDecNoRespS2H%[2] := -1;
            case recTrialResponsePosition1% = 5 then
                doIncHit%[2] := 1;
                doDecNoRespS2H%[2] := -1;
                doIncHit%[3] := 1;
                doDecNoRespS2H%[3] := -1;    
            case recTrialResponsePosition1% = 6 then
                doIncHit%[0] := 1;
                doDecNoRespS2H%[0] := -1;
                doIncHit%[1] := 1;
                doDecNoRespS2H%[1] := -1;
            endcase    
            'This is S1/S2L response direction
            docase
            case recTrialResponsePosition2% = 1 then
                doIncCR%[1] := 1;
                doDecNoRespS2L%[1] := -1;
            case recTrialResponsePosition2% = 2 then
                doIncCR%[0] := 1;
                doDecNoRespS2L%[0] := -1;
            case recTrialResponsePosition2% = 3 then
                doIncCR%[3] := 1;
                doDecNoRespS2L%[3] := -1;
            case recTrialResponsePosition2% = 4 then
                doIncCR%[2] := 1;
                doDecNoRespS2L%[2] := -1;
            case recTrialResponsePosition2% = 5 then
                doIncCR%[2] := 1;
                doDecNoRespS2L%[2] := -1;
                doIncCR%[3] := 1;
                doDecNoRespS2L%[3] := -1;    
            case recTrialResponsePosition2% = 6 then
                doIncCR%[0] := 1;
                doDecNoRespS2L%[0] := -1;
                doIncCR%[1] := 1;
                doDecNoRespS2L%[1] := -1;
            endcase    
                
                
        endif;
        
        
    else
        status% := 1;
    endif
    
    incrementDialogItem% := 0;  'must set to 0 on exit
    
        
	return status%;
   
end;

'===== End RecLeverJoystickDialog =====
'
'




'
'
'===== RecExpLeverJoystickDialogChanged =====

' This function is initially called with a "0" input
func RecExpLeverJoystickDialogChanged%(item%) 
    
    if DlgValue(1) = 0 then  'if we're using the lever, disable the init position, etc.
        DlgEnable(0,2);
        DlgEnable(0,3);
        DlgEnable(0,4);
        DlgEnable(0,5);
        DlgValue(6,1);
        DlgEnable(0,6);
        DlgEnable(0,-2);  'this is the threshold dialog button
        
    else
        DlgEnable(1,2); 'if we're using the joystick, enbable the init position, etc.
        DlgEnable(1,3);
        DlgEnable(1,4);
        DlgEnable(1,5);
        DlgEnable(1,6);
        DlgEnable(1,-2);  'this is the threshold dialog button
    endif;
    
    if DlgValue(5) = 1 and DlgValue(1) = 1 then
        DlgEnable(1,-3);  'this is the threshold increment dialog button
        DlgEnable(1,-4);  'this is the threshold limit dialog button
    else
        DlgEnable(0,-3);  'this is the threshold increment dialog button
        DlgEnable(0,-4);  'this is the threshold limit dialog button
    endif
    
    
    if DlgValue(6) = 1 then  'if it's go/no-go
        'DlgEnable(1,2); 'if we're using the joystick, enbable the init position, etc. 'what will this do???
        DlgValue(3,0); 'set the response position 1 to "center"
        DlgValue(4,7); 'set the response position 2 to "none"
        DlgEnable(0,3); 'and disable these
        DlgEnable(0,4);
    else
        DlgEnable(1,3); 'enable these
        DlgEnable(1,4);
    endif;
    
    
    return 1;
end

'===== End RecExpLeverJoystickDialogChanged =====
'
'









'================================================================================================
'End Dialog/DialogChanged functions
'
'












'
'
'Begin Get/Save Params
'================================================================================================

'
'
'===== RecDebugGetParams =====

'Fetch Debugging parameters from the registry
proc RecDebugGetParams()
	var key$;
    key$:="Reclab\\DebugParam";
    
    recMatlabIsPresent% := GetIntRegistryValue%(key$, "MatlabIsPresent", recMatlabIsPresent%);
    recTDTIsPresent% := GetIntRegistryValue%(key$, "TDTIsPresent", recTDTIsPresent%);
    recCEDIsPresent% := GetIntRegistryValue%(key$, "CEDIsPresent", recCEDIsPresent%);
    recCalibIsPresent% := GetIntRegistryValue%(key$, "CalibIsPresent", recCalibIsPresent%);
    recSoundRecording% := GetIntRegistryValue%(key$, "SoundRecording", recSoundRecording%);
    recDebug% := GetIntRegistryValue%(key$, "Debug", recDebug%);
    LongDur3 := GetFloatRegistryValue(key$, "LongDur3", LongDur3);
    recUseLiteMemory% := GetIntRegistryValue%(key$, "UseLiteMemory", recUseLiteMemory%);
    recThisStimLengthSec := GetFloatRegistryValue(key$, "ThisStimLengthSec", recMaxStimLengthSec);  'note this is tricky, not using orig value as "default"
    
    
    
	return;
end

'===== End RecDebugGetParams =====
'
'



'
'
'===== RecDebugSaveParams =====

'Save Debugging parameters to the registry
proc RecDebugSaveParams()

	var key$;
    key$:="Reclab\\DebugParam";

    SetIntRegistryValue(key$, "MatlabIsPresent", recMatlabIsPresent%);   
    SetIntRegistryValue(key$, "TDTIsPresent", recTDTIsPresent%); 
    SetIntRegistryValue(key$, "CEDIsPresent", recCEDIsPresent%); 
    SetIntRegistryValue(key$, "CalibIsPresent", recCalibIsPresent%); 
    SetIntRegistryValue(key$, "SoundRecording", recSoundRecording%);
    SetIntRegistryValue(key$, "Debug", recDebug%); 
    SetFloatRegistryValue(key$, "LongDur3", LongDur3);
    SetIntRegistryValue(key$, "UseLiteMemory", recUseLiteMemory%);
    SetFloatRegistryValue(key$, "ThisStimLengthSec", recThisStimLengthSec);
    
	return;
end

'===== End RecDebugSaveParams =====
'
'




'
'
'===== RecSearchGetParams =====

'Fetch Debugging parameters from the registry
proc RecSearchGetParams()
	var key$;
    key$:="Reclab\\SearchParam";
    
    recSearchStimType% := GetIntRegistryValue%(key$, "SearchStimType", recSearchStimType%);
    recSearchToneFreq := GetFloatRegistryValue(key$, "SearchToneFreq", recSearchToneFreq);
    recSearchBPLowerLim := GetFloatRegistryValue(key$, "SearchBPLowerLim", recSearchBPLowerLim);
    recSearchBPUpperLim := GetFloatRegistryValue(key$, "SearcBPUpperLim", recSearchBPUpperLim);
    recSearchSpeakerSweepRepeats% := GetIntRegistryValue%(key$, "recSearchSpeakerSweepRepeats%", recSearchSpeakerSweepRepeats%);
    recSearchToneSweepRepeats% := GetIntRegistryValue%(key$, "SearchToneSweepRepeats", recSearchToneSweepRepeats%);
    recSearchToneSweepLowLim := GetFloatRegistryValue(key$, "SearchToneSweepLowLim", recSearchToneSweepLowLim);
    recSearchToneSweepUpperLim := GetFloatRegistryValue(key$, "SearchToneSweepUpperLim", recSearchToneSweepUpperLim);
    'recSearchToneSweepOctaveStep := GetFloatRegistryValue(key$, "SearchToneSweepOctaveStep", recSearchToneSweepOctaveStep);
    recSearchToneSweepNSteps% := GetIntRegistryValue%(key$, "SearchToneSweepNSteps", recSearchToneSweepNSteps%);
    recSearchFMStartFreq := GetFloatRegistryValue(key$, "SearchFMStartFreq", recSearchFMStartFreq);
    recSearchFMEndFreq := GetFloatRegistryValue(key$, "SearchFMEndFreq", recSearchFMEndFreq);
    recSearchFMNumReverses% := GetIntRegistryValue%(key$, "SearchFMNumReverses", recSearchFMNumReverses%);
    recSearchFMDur := GetFloatRegistryValue(key$, "SearchFMDur", recSearchFMDur);
    recSearchS1Speaker% := GetIntRegistryValue%(key$, "SearchS1Speaker", recSearchS1Speaker%);
    recSearchS2Speaker% := GetIntRegistryValue%(key$, "SearchS2Speaker", recSearchS2Speaker%);
    recSearchMinS1% := GetIntRegistryValue%(key$, "SearchMinS1", recSearchMinS1%);
    recSearchVarS1% := GetIntRegistryValue%(key$, "SearchVarS1", recSearchVarS1%);
    recSearchPropCatch := GetFloatRegistryValue(key$, "SearchPropCatch", recSearchPropCatch);
    recSearchdBLevel := GetFloatRegistryValue(key$, "SearchdBLevel", recSearchdBLevel);
    recSearchActive% := GetIntRegistryValue%(key$, "SearchActive", recSearchActive%);
    recSearchFixLED% := GetIntRegistryValue%(key$, "SearchFixLED", recSearchFixLED%);
    recSearchDoPSTH% := GetIntRegistryValue%(key$, "SearchDoPSTH", recSearchDoPSTH%);
    recSearchWMPorts%[0] := GetIntRegistryValue%(key$, "SearchWMPort1", recSearchWMPorts%[0]);  'This is unusual syntax but compiles!
    recSearchWMPorts%[1] := GetIntRegistryValue%(key$, "SearchWMPort2", recSearchWMPorts%[1]);
    recSearchWMPorts%[2] := GetIntRegistryValue%(key$, "SearchWMPort3", recSearchWMPorts%[2]);
    recSearchWMPorts%[3] := GetIntRegistryValue%(key$, "SearchWMPort4", recSearchWMPorts%[3]);
    
    
    'This is only allowed in Project Boilermaker, do not allow "Select Boiler->Cancel->Select This" to activate it.
    recUpdateRewardByGap% := 0;
    
	return;
end

'===== End RecSearchGetParams =====
'
'




'
'
'===== RecSearchSaveParams =====

'Save Debugging parameters to the registry
proc RecSearchSaveParams()

	var key$;
    key$:="Reclab\\SearchParam";

    SetIntRegistryValue(key$, "SearchStimType", recSearchStimType%);
    SetFloatRegistryValue(key$, "SearchToneFreq", recSearchToneFreq);
    SetFloatRegistryValue(key$, "SearchBPLowerLim", recSearchBPLowerLim);
    SetFloatRegistryValue(key$, "SearcBPUpperLim", recSearchBPUpperLim);
    SetIntRegistryValue(key$, "recSearchSpeakerSweepRepeats%", recSearchSpeakerSweepRepeats%);
    SetIntRegistryValue(key$, "SearchToneSweepRepeats", recSearchToneSweepRepeats%);
    SetFloatRegistryValue(key$, "SearchToneSweepLowLim", recSearchToneSweepLowLim);
    SetFloatRegistryValue(key$, "SearchToneSweepUpperLim", recSearchToneSweepUpperLim);
    'SetFloatRegistryValue(key$, "SearchToneSweepOctaveStep", recSearchToneSweepOctaveStep); 
    SetIntRegistryValue(key$, "SearchToneSweepNSteps", recSearchToneSweepNSteps%);
    SetFloatRegistryValue(key$, "SearchFMStartFreq", recSearchFMStartFreq);
    SetFloatRegistryValue(key$, "SearchFMEndFreq", recSearchFMEndFreq);
    SetIntRegistryValue(key$, "SearchFMNumReverses", recSearchFMNumReverses%);
    SetFloatRegistryValue(key$, "SearchFMDur", recSearchFMDur);
    SetIntRegistryValue(key$, "SearchS1Speaker", recSearchS1Speaker%);
    SetIntRegistryValue(key$, "SearchS2Speaker", recSearchS2Speaker%);
    SetIntRegistryValue(key$, "SearchMinS1", recSearchMinS1%);
    SetIntRegistryValue(key$, "SearchVarS1", recSearchVarS1%);
    SetFloatRegistryValue(key$, "SearchPropCatch", recSearchPropCatch);
    SetFloatRegistryValue(key$, "SearchdBLevel", recSearchdBLevel);
    SetIntRegistryValue(key$, "SearchActive", recSearchActive%);
    SetIntRegistryValue(key$, "SearchFixLED", recSearchFixLED%);
    SetIntRegistryValue(key$, "SearchDoPSTH", recSearchDoPSTH%);
    SetIntRegistryValue(key$, "SearchWMPort1", recSearchWMPorts%[0]);
    SetIntRegistryValue(key$, "SearchWMPort2", recSearchWMPorts%[1]);
    SetIntRegistryValue(key$, "SearchWMPort3", recSearchWMPorts%[2]);
    SetIntRegistryValue(key$, "SearchWMPort4", recSearchWMPorts%[3]);
    
	return;
end

'===== End RecSearchSaveParams =====
'
'




'
'
'===== RecCharDialogFRAGetParams =====

'Fetch FRA (dialog) parameters from the registry
'Note that while this dialog has had a name change (FRA-->Char) the registry entries are being left as-is
proc RecCharDialogFRAGetParams()
	var key$;
    key$:="Reclab\\FRAParam";
    
    recCharS1Speaker% := GetIntRegistryValue%(key$, "FRAS1Speaker", recCharS1Speaker%);
    recRateLeveldBLow := GetFloatRegistryValue(key$, "RateLeveldBLow", recRateLeveldBLow);
    recRateLeveldBHigh := GetFloatRegistryValue(key$, "RateLeveldBHigh", recRateLeveldBHigh);
    recFRATonedBLow := GetFloatRegistryValue(key$, "FRATonedBLow", recFRATonedBLow);
    recFRATonedBHigh := GetFloatRegistryValue(key$, "FRATonedBHigh", recFRATonedBHigh);
    recFRAToneFreqLow := GetFloatRegistryValue(key$, "FRAToneFreqLow", recFRAToneFreqLow);
    recFRAToneFreqHigh := GetFloatRegistryValue(key$, "FRAToneFreqHigh", recFRAToneFreqHigh);
    recSpaceS2dBLevel := GetFloatRegistryValue(key$, "FRAS2dBLevel", recSpaceS2dBLevel);  
    recSpaceNRepeats% := GetFloatRegistryValue(key$, "SpaceNRepeats", recSpaceNRepeats%);  
    recS1AMnoiseReps% := GetFloatRegistryValue(key$, "recS1AMnoiseReps", recS1AMnoiseReps%);  
    recCharMinS1% := GetIntRegistryValue%(key$, "FRAMinS1", recCharMinS1%);
    recCharVarS1% := GetIntRegistryValue%(key$, "FRAVarS1", recCharVarS1%);   
    recRateLevelNRepeats% := GetIntRegistryValue%(key$, "RateLevelNRepeats", recRateLevelNRepeats%);
    recFRANRepeats% := GetIntRegistryValue%(key$, "FRANRepeats", recFRANRepeats%);
    recFMSweepRepeats% := GetIntRegistryValue%(key$, "FRAFMSweepRepeats", recFMSweepRepeats%);
    recFMSweepStart% := GetIntRegistryValue%(key$, "FRAFMSweepStart", recFMSweepStart%);
    recFMSweepEnd% := GetIntRegistryValue%(key$, "FRAFMSweepEnd", recFMSweepEnd%);
    recFMSweepDur1% := GetIntRegistryValue%(key$, "FRAFMSweepDur1", recFMSweepDur1%);
    recFMSweepDur2% := GetIntRegistryValue%(key$, "FRAFMSweepDur2", recFMSweepDur2%);
    recFMSweepDur3% := GetIntRegistryValue%(key$, "FRAFMSweepDur3", recFMSweepDur3%);
    recFMSweepDur4% := GetIntRegistryValue%(key$, "FRAFMSweepDur4", recFMSweepDur4%);
    recFMSweepDur5% := GetIntRegistryValue%(key$, "FRAFMSweepDur5", recFMSweepDur5%);
    recCharActive% := GetIntRegistryValue%(key$, "recFRAActive", recCharActive%);
    recCharExpIndexLoadFRA% := GetIntRegistryValue%(key$, "FRAExpIndexLoad", recCharExpIndexLoadFRA%);
    recCharLoadStim% := GetIntRegistryValue%(key$, "FRALoadStim", recCharLoadStim%);
    recCharExpIndexLoadSigNoise% := GetIntRegistryValue%(key$, "CharExpIndexLoadSigNoise", recCharExpIndexLoadSigNoise%);
    recCharExpIndexGenFRA% := GetIntRegistryValue%(key$, "CharExpIndexGenFRA", recCharExpIndexGenFRA%);
    recCharExpIndexGenSigNoise% := GetIntRegistryValue%(key$, "CharExpIndexGenSigNoise", recCharExpIndexGenSigNoise%);
    recCharExpIndexLoadArbStim% := GetIntRegistryValue%(key$, "CharExpIndexLoadArbStim", recCharExpIndexLoadArbStim%);
    
    
    'This is only allowed in Project Boilermaker, do not allow "Select Boiler->Cancel->Select This" to activate it.
    recUpdateRewardByGap% := 0;
    
	return;
end

'===== End RecCharDialogFRAGetParams =====
'
'



'
'
'===== RecCharDialogCharSaveParams =====

'Note that while this dialog has had a name change (FRA-->Char) the registry entries are being left as-is
'Save FRA (dialog) parameters to the registry
proc RecCharDialogFRASaveParams()
	var key$;
    key$:="Reclab\\FRAParam";
    
    SetIntRegistryValue(key$, "FRAS1Speaker", recCharS1Speaker%);
    SetFloatRegistryValue(key$, "RateLeveldBLow", recRateLeveldBLow);
    SetFloatRegistryValue(key$, "RateLeveldBHigh", recRateLeveldBHigh);
    SetFloatRegistryValue(key$, "FRATonedBLow", recFRATonedBLow);
    SetFloatRegistryValue(key$, "FRATonedBHigh", recFRATonedBHigh);
    SetFloatRegistryValue(key$, "FRAToneFreqLow", recFRAToneFreqLow);
    SetFloatRegistryValue(key$, "FRAToneFreqHigh", recFRAToneFreqHigh);
    SetFloatRegistryValue(key$, "FRAS2dBLevel", recSpaceS2dBLevel);   
    SetFloatRegistryValue(key$, "SpaceNRepeats", recSpaceNRepeats%); 
    SetFloatRegistryValue(key$, "recS1AMnoiseReps", recS1AMnoiseReps%);  
    SetIntRegistryValue(key$, "FRAMinS1", recCharMinS1%);
    SetIntRegistryValue(key$, "FRAVarS1", recCharVarS1%); 
    SetIntRegistryValue(key$, "RateLevelNRepeats", recRateLevelNRepeats%);
    SetIntRegistryValue(key$, "FRANRepeats", recFRANRepeats%);
    SetIntRegistryValue(key$, "FRAFMSweepRepeats", recFMSweepRepeats%);
    SetIntRegistryValue(key$, "FRAFMSweepStart", recFMSweepStart%);
    SetIntRegistryValue(key$, "FRAFMSweepEnd", recFMSweepEnd%);
    SetIntRegistryValue(key$, "FRAFMSweepDur1", recFMSweepDur1%);
    SetIntRegistryValue(key$, "FRAFMSweepDur2", recFMSweepDur2%);
    SetIntRegistryValue(key$, "FRAFMSweepDur3", recFMSweepDur3%);
    SetIntRegistryValue(key$, "FRAFMSweepDur4", recFMSweepDur4%);
    SetIntRegistryValue(key$, "FRAFMSweepDur5", recFMSweepDur5%);
    SetIntRegistryValue(key$, "recFRAActive", recCharActive%);
    SetIntRegistryValue(key$, "FRAExpIndexLoad", recCharExpIndexLoadFRA%);
    SetIntRegistryValue(key$, "FRALoadStim", recCharLoadStim%);
    SetIntRegistryValue(key$, "CharExpIndexLoadSigNoise", recCharExpIndexLoadSigNoise%);
    SetIntRegistryValue(key$, "CharExpIndexGenFRA", recCharExpIndexGenFRA%);
    SetIntRegistryValue(key$, "CharExpIndexGenSigNoise", recCharExpIndexGenSigNoise%);
    SetIntRegistryValue(key$, "CharExpIndexLoadArbStim", recCharExpIndexLoadArbStim%);
	return;
end

'===== End RecCharDialogFCharSaveParams =====
'
'



'
'
'===== RecAMDiscGetParams =====

'Fetch Debugging parameters from the registry
proc RecAMDiscGetParams()
	var key$;
    key$:="Reclab\\AMDiscParam";
    
    recAMDiscS1Speaker% := GetIntRegistryValue%(key$, "AMDiscS1Speaker", recAMDiscS1Speaker%);
    recAMDiscMinS1% := GetIntRegistryValue%(key$, "AMDiscMinS1", recAMDiscMinS1%);
    recAMDiscVarS1% := GetIntRegistryValue%(key$, "AMDiscVarS1", recAMDiscVarS1%);
    recAMDiscPropCatch := GetFloatRegistryValue(key$, "AMDiscPropCatch", recAMDiscPropCatch);
    recAMDiscdBLevel := GetFloatRegistryValue(key$, "AMDiscdBLevel", recAMDiscdBLevel);
    recAMDiscRepeatsPerStim% := GetIntRegistryValue%(key$, "AMDiscRepeatsPerStim", recAMDiscRepeatsPerStim%);
    recAMDiscMatGenStim% := GetIntRegistryValue%(key$, "AMDiscMatGenStim", recAMDiscMatGenStim%);
    recAMDiscExpIndexGen% := GetIntRegistryValue%(key$, "AMDiscExpIndexGen", recAMDiscExpIndexGen%);
    recAMDiscExpIndexLoad% := GetIntRegistryValue%(key$, "AMDiscExpIndexLoad", recAMDiscExpIndexLoad%);   
    recAMDiscTrialInitReward% := GetIntRegistryValue%(key$, "TrialInitReward", recAMDiscTrialInitReward%);
    recAMDiscTrialHoldReward% := GetIntRegistryValue%(key$, "TrialHoldReward", recAMDiscTrialHoldReward%);
    recAMDiscDoRove% := GetIntRegistryValue%(key$, "DoRove", recAMDiscDoRove%);
    recAMDiscRovedB := GetFloatRegistryValue(key$, "RovedB", recAMDiscRovedB);
    
    recAMDiscActive% := GetIntRegistryValue%(key$, "ActiveTask", recAMDiscActive%);
    
    
    'This is only allowed in Project Boilermaker, do not allow "Select Boiler->Cancel->Select This" to activate it.
    recUpdateRewardByGap% := 0;
    
	return;
end

'===== End RecAMDiscGetParams =====
'
'



'
'
'===== RecAMDiscSaveParams =====

'Fetch Debugging parameters from the registry
proc RecAMDiscSaveParams()
	var key$;
    key$:="Reclab\\AMDiscParam";
    
    SetIntRegistryValue(key$, "AMDiscS1Speaker", recAMDiscS1Speaker%);
    SetIntRegistryValue(key$, "AMDiscMinS1", recAMDiscMinS1%);
    SetIntRegistryValue(key$, "AMDiscVarS1", recAMDiscVarS1%);
    SetFloatRegistryValue(key$, "AMDiscPropCatch", recAMDiscPropCatch);
    SetFloatRegistryValue(key$, "AMDiscdBLevel", recAMDiscdBLevel);
    SetIntRegistryValue(key$, "AMDiscRepeatsPerStim", recAMDiscRepeatsPerStim%);
    SetIntRegistryValue(key$, "AMDiscMatGenStim", recAMDiscMatGenStim%);
    SetIntRegistryValue(key$, "AMDiscExpIndexGen", recAMDiscExpIndexGen%);
    SetIntRegistryValue(key$, "AMDiscExpIndexLoad", recAMDiscExpIndexLoad%);
    SetIntRegistryValue(key$, "TrialInitReward", recAMDiscTrialInitReward%);
    SetIntRegistryValue(key$, "TrialHoldReward", recAMDiscTrialHoldReward%);
    SetIntRegistryValue(key$, "DoRove", recAMDiscDoRove%);
    SetFloatRegistryValue(key$, "RovedB", recAMDiscRovedB);
    SetIntRegistryValue(key$, "ActiveTask", recAMDiscActive%);
    
	return;
end

'===== End RecAMDiscSaveParams =====
'
'


'
'
'===== RecSpaceDisGetParams =====

'Fetch Debugging parameters from the registry
proc RecSpaceDisGetParams()
	var key$;
    key$:="Reclab\\SpaceDisParam";
    
'    recAMDiscS1Speaker% := GetIntRegistryValue%(key$, "SpaceDisS1Speaker", recASpaceDisSpeaker%);
    recSpaceDisMinS1% := GetIntRegistryValue%(key$, "SpaceDisMinS1", recSpaceDisMinS1%);
    recSpaceDisVarS1% := GetIntRegistryValue%(key$, "SpaceDisVarS1", recSpaceDisVarS1%);
    recSpaceDisPropCatch := GetFloatRegistryValue(key$, "SpaceDisPropCatch", recSpaceDisPropCatch);
    recSpaceDisdBLevel := GetFloatRegistryValue(key$, "SpaceDisdBLevel", recSpaceDisdBLevel);
    recSpaceDisRepeatsPerStim% := GetIntRegistryValue%(key$, "SpaceDisRepeatsPerStim", recSpaceDisRepeatsPerStim%);
    recSpaceDisMatGenStim% := GetIntRegistryValue%(key$, "SpaceDisMatGenStim", recSpaceDisMatGenStim%);
    recSpaceDisExpIndexGen% := GetIntRegistryValue%(key$, "SpaceDisExpIndexGen", recSpaceDisExpIndexGen%);
    recSpaceDisExpIndexLoad% := GetIntRegistryValue%(key$, "SpaceDisExpIndexLoad", recSpaceDisExpIndexLoad%);   
    recSpaceDisTrialInitReward% := GetIntRegistryValue%(key$, "TrialInitReward", recSpaceDisTrialInitReward%);
    recSpaceDisTrialHoldReward% := GetIntRegistryValue%(key$, "TrialHoldReward", recSpaceDisTrialHoldReward%);
    recSpaceDisDoRove% := GetIntRegistryValue%(key$, "DoRove", recSpaceDisDoRove%);
    recSpaceDisRovedB := GetFloatRegistryValue(key$, "RovedB", recSpaceDisRovedB);
    recSpaceDisActive% := GetIntRegistryValue%(key$, "ActiveTask", recSpaceDisActive%);
    
    
    'This is only allowed in Project Boilermaker, do not allow "Select Boiler->Cancel->Select This" to activate it.
    recUpdateRewardByGap% := 0;
    
	return;
end

'===== End RecSpaceDisGetParams =====
'
'



'
'
'===== RecSpaceDisSaveParams =====

'Fetch Debugging parameters from the registry
proc RecSpaceDisSaveParams()
	var key$;
    key$:="Reclab\\SpaceDisParam";
    
'    SetIntRegistryValue(key$, "SpaceDisS1Speaker", recSpaceDisS1Speaker%);
    SetIntRegistryValue(key$, "SpaceDisMinS1", recSpaceDisMinS1%);
    SetIntRegistryValue(key$, "SpaceDisVarS1", recSpaceDisVarS1%);
    SetFloatRegistryValue(key$, "SpaceDisPropCatch", recSpaceDisPropCatch);
    SetFloatRegistryValue(key$, "SpaceDisdBLevel", recSpaceDisdBLevel);
    SetIntRegistryValue(key$, "SpaceDisRepeatsPerStim", recSpaceDisRepeatsPerStim%);
    SetIntRegistryValue(key$, "SpaceDisMatGenStim", recSpaceDisMatGenStim%);
    SetIntRegistryValue(key$, "SpaceDisExpIndexGen", recSpaceDisExpIndexGen%);
    SetIntRegistryValue(key$, "SpaceDisExpIndexLoad", recSpaceDisExpIndexLoad%);
    SetIntRegistryValue(key$, "TrialInitReward", recSpaceDisTrialInitReward%);
    SetIntRegistryValue(key$, "TrialHoldReward", recSpaceDisTrialHoldReward%); 
    SetIntRegistryValue(key$, "DoRove", recSpaceDisDoRove%);
    SetFloatRegistryValue(key$, "RovedB", recSpaceDisRovedB);    
    SetIntRegistryValue(key$, "ActiveTask", recSpaceDisActive%);

	return;
end

'===== End RecSpaceDisSaveParams =====
'
'


'
'===== RecStereoDisSaveParams =====

'Fetch Debugging parameters from the registry
proc RecStereoDisSaveParams()
	var key$;
    key$:="Reclab\\HumanFCParam";  'renamed experiment from HumanFC to StereoDis, just keep old name for registry, it's easier
    
    SetIntRegistryValue(key$, "HumanFCExpIndexLoad", recStereoDisExpIndexLoad%); 
    SetIntRegistryValue(key$, "HumanFCExpIndexGen", recStereoDisExpIndexGen%);
    SetIntRegistryValue(key$, "HumanFCRepeatsPerStim", recStereoDisRepeatsPerStim%);
    SetIntRegistryValue(key$, "StereoDisExpDoFC", recStereoDisExpDoFC%);
    SetIntRegistryValue(key$, "StereoDisExpDoGen", recStereoDisExpDoGen%);
    SetFloatRegistryValue(key$, "StereoDisdB", recStereoDisdB);
    SetIntRegistryValue(key$, "StereoDisDoRove", recStereoDisDoRove%);
    SetFloatRegistryValue(key$, "StereoDisRovedB", recStereoDisRovedB);
    SetIntRegistryValue(key$, "StereoDisActive", recStereoDisActive%);
    SetIntRegistryValue(key$, "StereoDisTrialInitReward", recStereoDisTrialInitReward%); 
    SetIntRegistryValue(key$, "StereoDisTrialHoldReward", recStereoDisTrialHoldReward%);
    
    
    
	return;
end

'===== End RecStereoDisSaveParams =====
'
'
'
'===== RecStereoDisGetParams =====

'Fetch Debugging parameters from the registry
proc RecStereoDisGetParams()
	var key$;
    key$:="Reclab\\HumanFCParam";  'renamed experiment from HumanFC to StereoDis, just keep old name for registry, it's easier
    
    recStereoDisExpIndexLoad% := GetIntRegistryValue%(key$, "HumanFCExpIndexLoad", recStereoDisExpIndexLoad%); 
    recStereoDisExpIndexGen% := GetIntRegistryValue%(key$, "HumanFCExpIndexGen", recStereoDisExpIndexGen%);
    recStereoDisRepeatsPerStim% := GetIntRegistryValue%(key$, "HumanFCRepeatsPerStim", recStereoDisRepeatsPerStim%);
    recStereoDisExpDoFC% := GetIntRegistryValue%(key$, "StereoDisExpDoFC", recStereoDisExpDoFC%);
    recStereoDisExpDoGen% := GetIntRegistryValue%(key$, "StereoDisExpDoGen", recStereoDisExpDoGen%);
    recStereoDisdB := GetFloatRegistryValue(key$, "StereoDisdB", recStereoDisdB);
    recStereoDisDoRove% := GetIntRegistryValue%(key$, "StereoDisDoRove", recStereoDisDoRove%);
    recStereoDisRovedB := GetFloatRegistryValue(key$, "StereoDisRovedB", recStereoDisRovedB);
    recStereoDisActive% := GetIntRegistryValue%(key$, "StereoDisActive", recStereoDisActive%);
    recStereoDisTrialInitReward% := GetIntRegistryValue%(key$, "StereoDisTrialInitReward", recStereoDisTrialInitReward%); 
    recStereoDisTrialHoldReward% := GetIntRegistryValue%(key$, "StereoDisTrialHoldReward", recStereoDisTrialHoldReward%);
    
    
    'This is only allowed in Project Boilermaker, do not allow "Select Boiler->Cancel->Select This" to activate it.
    recUpdateRewardByGap% := 0;
    
	return;
end

'===== End RecStereoDisGetParams =====
'
'


'
'===== RecStereoDisGNGSaveParams =====

'Fetch Debugging parameters from the registry
proc RecStereoDisGNGSaveParams()
	var key$;
    key$:="Reclab\\StereoDisParam";  
    
    SetIntRegistryValue(key$, "StereoDisGNGExpIndexLoad", recStereoDisGNGExpIndexLoad%); 
    SetIntRegistryValue(key$, "StereoDisGNGExpIndexGen", recStereoDisGNGExpIndexGen%);
    SetIntRegistryValue(key$, "StereoDisGNGRepeatsPerStim", recStereoDisGNGRepeatsPerStim%);
    SetIntRegistryValue(key$, "StereoDisExpDoGNG", recStereoDisExpDoGNG%);
    
	return;
end

'===== End RecStereoDisGNGSaveParams =====
'
'
'
'===== RecStereoDisGNGGetParams =====

'Fetch Debugging parameters from the registry
proc RecStereoDisGNGGetParams()
	var key$;
    key$:="Reclab\\StereoDisParam";  
    
    recStereoDisGNGExpIndexLoad% := GetIntRegistryValue%(key$, "StereoDisGNGExpIndexLoad", recStereoDisGNGExpIndexLoad%); 
    recStereoDisGNGExpIndexGen% := GetIntRegistryValue%(key$, "StereoDisGNGExpIndexGen", recStereoDisGNGExpIndexGen%);
    recStereoDisGNGRepeatsPerStim% := GetIntRegistryValue%(key$, "StereoDisGNGRepeatsPerStim", recStereoDisGNGRepeatsPerStim%);   
    recStereoDisExpDoGNG% := GetIntRegistryValue%(key$, "StereoDisExpDoGNG", recStereoDisExpDoGNG%);
    
	return;
end

'===== End RecStereoDisGNGGetParams =====
'
'


'
'===== RecOneStimDiscrimSaveParams =====

'Fetch Debugging parameters from the registry
proc RecOneStimDiscrimSaveParams()
	var key$;
    key$:="Reclab\\OneStimDiscrimParam";
    
    SetIntRegistryValue(key$, "OneStimDiscrimExpIndexLoad", recOneStimDiscrimExpIndexLoad%); 
    SetIntRegistryValue(key$, "OneStimDiscrimExpIndexGen", recOneStimDiscrimExpIndexGen%);
    SetIntRegistryValue(key$, "OneStimDiscrimRepeatsPerStim", recOneStimDiscrimRepeatsPerStim%);
    SetFloatRegistryValue(key$, "OneStimDiscrimdB", recOneStimDiscrimdB);
    SetIntRegistryValue(key$, "OneStimDiscrimDoRove", recOneStimDiscrimDoRove%);
    SetFloatRegistryValue(key$, "OneStimDiscrimRovedB", recOneStimDiscrimRovedB);
    SetIntRegistryValue(key$, "OneStimDiscrimActive", recOneStimDiscrimActive%);
    SetIntRegistryValue(key$, "OneStimDiscrimTrialInitReward", recOneStimDiscrimTrialInitReward%); 
    SetIntRegistryValue(key$, "OneStimDiscrimTrialHoldReward", recOneStimDiscrimTrialHoldReward%);
    SetIntRegistryValue(key$, "OneStimDiscrimTarget1Ind", recOneStimDiscrimTarget1Ind%);
    SetIntRegistryValue(key$, "OneStimDiscrimVersusInd", recOneStimDiscrimVersusInd%);
    SetIntRegistryValue(key$, "OneStimDiscrimTarget2Ind", recOneStimDiscrimTarget2Ind%);
    'SetFloatRegistryValue(key$, "OneStimDiscrimValue", recOneStimDiscrimValue);
    SetStringRegistryValue(key$, "OneStimDiscrimValueStr", recOneStimDiscrimValue$);
    SetIntRegistryValue(key$, "OneStimDiscrimTargetExptType", recOneStimDiscrimExptType%);
    SetIntRegistryValue(key$, "UpdateRewardByGap", recUpdateRewardByGap%);

    
	return;
end

'===== End RecOneStimDiscrimSaveParams =====
'
'
'
'===== RecOneStimDiscrimGetParams =====

'Fetch Debugging parameters from the registry
proc RecOneStimDiscrimGetParams()
	var key$;
    key$:="Reclab\\OneStimDiscrimParam";
    
    recOneStimDiscrimExpIndexLoad% := GetIntRegistryValue%(key$, "OneStimDiscrimExpIndexLoad", recOneStimDiscrimExpIndexLoad%); 
    recOneStimDiscrimExpIndexGen% := GetIntRegistryValue%(key$, "OneStimDiscrimExpIndexGen", recOneStimDiscrimExpIndexGen%);
    recOneStimDiscrimRepeatsPerStim% := GetIntRegistryValue%(key$, "OneStimDiscrimRepeatsPerStim", recOneStimDiscrimRepeatsPerStim%);
    recOneStimDiscrimdB := GetFloatRegistryValue(key$, "OneStimDiscrimdB", recOneStimDiscrimdB);
    recOneStimDiscrimDoRove% := GetIntRegistryValue%(key$, "OneStimDiscrimDoRove", recOneStimDiscrimDoRove%);
    recOneStimDiscrimRovedB := GetFloatRegistryValue(key$, "OneStimDiscrimRovedB", recOneStimDiscrimRovedB);
    recOneStimDiscrimActive% := GetIntRegistryValue%(key$, "OneStimDiscrimActive", recOneStimDiscrimActive%);
    recOneStimDiscrimTrialInitReward% := GetIntRegistryValue%(key$, "OneStimDiscrimTrialInitReward", recOneStimDiscrimTrialInitReward%); 
    recOneStimDiscrimTrialHoldReward% := GetIntRegistryValue%(key$, "OneStimDiscrimTrialHoldReward", recOneStimDiscrimTrialHoldReward%);
    recOneStimDiscrimTarget1Ind% := GetIntRegistryValue%(key$, "OneStimDiscrimTarget1Ind", recOneStimDiscrimTarget1Ind%);
    recOneStimDiscrimVersusInd% := GetIntRegistryValue%(key$, "OneStimDiscrimVersusInd", recOneStimDiscrimVersusInd%);
    recOneStimDiscrimTarget2Ind% := GetIntRegistryValue%(key$, "OneStimDiscrimTarget2Ind", recOneStimDiscrimTarget2Ind%);
    'recOneStimDiscrimValue := GetFloatRegistryValue(key$, "OneStimDiscrimValue", recOneStimDiscrimValue);
    recOneStimDiscrimValue$ := GetStringRegistryValue$(key$, "OneStimDiscrimValueStr", recOneStimDiscrimValue$);
    recOneStimDiscrimExptType% := GetIntRegistryValue%(key$, "OneStimDiscrimTargetExptType", recOneStimDiscrimExptType%);
    recUpdateRewardByGap% := GetIntRegistryValue%(key$, "UpdateRewardByGap", recUpdateRewardByGap%);
    
    
    
	return;
end

'===== End RecOneStimDiscrimGetParams =====
'
'



'
'===== RecOneStimDiscrimGNGSaveParams =====

'Fetch Debugging parameters from the registry
proc RecOneStimDiscrimGNGSaveParams()
	var key$;
    key$:="Reclab\\OneStimDiscrimParam";  
    
    SetIntRegistryValue(key$, "OneStimDiscrimGNGExpIndexLoad", recOneStimDiscrimGNGExpIndexLoad%); 
    SetIntRegistryValue(key$, "OneStimDiscrimGNGExpIndexGen", recOneStimDiscrimGNGExpIndexGen%);
    SetIntRegistryValue(key$, "OneStimDiscrimGNGRepeatsPerStim", recOneStimDiscrimGNGRepeatsPerStim%);
    SetIntRegistryValue(key$, "OneStimDiscrimExpDoGNG", recOneStimDiscrimExpDoGNG%);
    
	return;
end

'===== End RecOneStimDiscrimGNGSaveParams =====
'
'
'
'===== RecOneStimDiscrimGNGGetParams =====

'Fetch Debugging parameters from the registry
proc RecOneStimDiscrimGNGGetParams()
	var key$;
    key$:="Reclab\\OneStimDiscrimParam";  
    
    recOneStimDiscrimGNGExpIndexLoad% := GetIntRegistryValue%(key$, "OneStimDiscrimGNGExpIndexLoad", recOneStimDiscrimGNGExpIndexLoad%); 
    recOneStimDiscrimGNGExpIndexGen% := GetIntRegistryValue%(key$, "OneStimDiscrimGNGExpIndexGen", recOneStimDiscrimGNGExpIndexGen%);
    recOneStimDiscrimGNGRepeatsPerStim% := GetIntRegistryValue%(key$, "OneStimDiscrimGNGRepeatsPerStim", recOneStimDiscrimGNGRepeatsPerStim%);   
    recOneStimDiscrimExpDoGNG% := GetIntRegistryValue%(key$, "OneStimDiscrimExpDoGNG", recOneStimDiscrimExpDoGNG%);
    
	return;
end

'===== End RecOneStimDiscrimGNGGetParams =====
'
'







'
'===== RecExpSelectDialogGetParams =====

'Fetch Debugging parameters from the registry
proc RecExpSelectDialogGetParams()
	var key$;
    key$:="Reclab\\ExpSelectDialog";
    
    recShuffle% := GetIntRegistryValue%(key$, "Shuffle", recShuffle%); 
    recTurnOffReward% := GetIntRegistryValue%(key$, "TurnOffReward", recTurnOffReward%); 
    recNBAKs% := GetIntRegistryValue%(key$, "NBAKs", recNBAKs%);    
    recExpSelectSamplingRateIndex% := GetIntRegistryValue%(key$, "SampRateIndex", recExpSelectSamplingRateIndex%);
    recExpSelectPlayRateIndex% := GetIntRegistryValue%(key$, "PlayRateIndex", recExpSelectPlayRateIndex%);
    recAddFilter% := GetIntRegistryValue%(key$, "AddFilter", recAddFilter%);
    
	return;
end

'===== End RecExpSelectDialogGetParams =====
'
'



'
'===== RecExpSelectDialogSaveParams =====

'Fetch Debugging parameters from the registry
proc RecExpSelectDialogSaveParams()
	var key$;
    key$:="Reclab\\ExpSelectDialog";
    
    SetIntRegistryValue(key$, "Shuffle", recShuffle%); 
    SetIntRegistryValue(key$, "TurnOffReward", recTurnOffReward%);
    SetIntRegistryValue(key$, "NBAKs", recNBAKs%);
    SetIntRegistryValue(key$, "SampRateIndex", recExpSelectSamplingRateIndex%);
    SetIntRegistryValue(key$, "PlayRateIndex", recExpSelectPlayRateIndex%);
    SetIntRegistryValue(key$, "AddFilter", recAddFilter%);
    
	return;
end

'===== RecExpSelectDialogSaveParams =====
'
'





'===== RecJoyTrainGetParams ===== '*jao

func RecJoyTrainGetParams()
	var key$;
    key$:="Reclab\\LeverJoystick";

    recDoJoyTrain%:= GetIntRegistryValue%(key$, "DoJoyTrain", recDoJoyTrain%);
    recMinOnsetDelay := GetFloatRegistryValue(key$, "MinOnsetDelay", recMinOnsetDelay);
    recHitRewardmL := GetFloatRegistryValue(key$, "HitRewardmL", recHitRewardmL);
	recHitRewardIncmL := GetFloatRegistryValue(key$, "HitRewardIncmL", recHitRewardIncmL);
    recMinOnsetDelay := GetFloatRegistryValue(key$, "MinOnsetDelay", recMinOnsetDelay);
    recTrialInitPosition% := GetFloatRegistryValue(key$, "TrialInitPosition", recTrialInitPosition%);
    recDoIncrements% := GetFloatRegistryValue(key$, "DoIncrements", recDoIncrements%);
    
    
    'This is only allowed in Project Boilermaker, do not allow "Select Boiler->Cancel->Select This" to activate it.
    recUpdateRewardByGap% := 0;
    
    return;

end; 
'end  RecJoyTrainGetParams(); '*jao


'===== RecJoyTrainSaveParams ===== '*jao

func RecJoyTrainSaveParams()
	var key$;
    key$:="Reclab\\LeverJoystick";

    SetIntRegistryValue(key$, "DoJoyTrain", recDoJoyTrain%);
    SetFloatRegistryValue(key$, "MinOnsetDelay", recMinOnsetDelay);
    SetFloatRegistryValue(key$, "HitRewardmL", recHitRewardmL);   
    SetFloatRegistryValue(key$, "HitRewardIncmL", recHitRewardIncmL);    
    SetFloatRegistryValue(key$, "MinOnsetDelay", recMinOnsetDelay);
    SetFloatRegistryValue(key$, "TrialInitPosition", recTrialInitPosition%);
    SetFloatRegistryValue(key$, "DoIncrements", recDoIncrements%);
    
	return;

end; 
'end  RecJoyTrainSaveParams(); '*jao


'===== RecLongToneGetParams ===== 

func RecLongToneGetParams()
	var key$;
    key$:="Reclab\\Longtone";
    
    recLongToneSpeaker% := GetIntRegistryValue%(key$, "LongToneSpeaker", recLongToneSpeaker%);
    recLongToneDuration := GetFloatRegistryValue(key$, "LongToneDuration", recLongToneDuration);
    recLongToneFreq := GetFloatRegistryValue(key$, "LongToneFreq", recLongToneFreq);
    recLongToneBPLow := GetFloatRegistryValue(key$, "LongToneBPLow", recLongToneBPLow);
    recLongToneBPHigh := GetFloatRegistryValue(key$, "LongToneBPHigh", recLongToneBPHigh);
    recLongToneType% := GetIntRegistryValue%(key$, "LongToneType", recLongToneType%);
    recLongToneNRepeats% := GetIntRegistryValue%(key$, "LongToneNRepeats", recLongToneNRepeats%);
    recLongToneISI := GetFloatRegistryValue(key$, "LongToneISI", recLongToneISI);  
    recLongToneSilentDur := GetFloatRegistryValue(key$, "LongToneSilentDur", recLongToneSilentDur); 
    recLongToneTargetdB := GetFloatRegistryValue(key$, "LongToneTargetdB", recLongToneTargetdB);  
    recLongToneRewardProb := GetFloatRegistryValue(key$, "LongToneRewardProb", recLongToneRewardProb);
    
    
    'This is only allowed in Project Boilermaker, do not allow "Select Boiler->Cancel->Select This" to activate it.
    recUpdateRewardByGap% := 0;
    
    return;

end; 
'end  RecLongToneGetParams(); 


'===== RecLongToneSaveParams ===== 

func RecLongToneSaveParams()
	var key$;
    key$:="Reclab\\Longtone";

    SetIntRegistryValue(key$, "LongToneSpeaker", recLongToneSpeaker%);
    SetFloatRegistryValue(key$, "LongToneDuration", recLongToneDuration);
    SetFloatRegistryValue(key$, "LongToneFreq", recLongToneFreq);
    SetFloatRegistryValue(key$, "LongToneBPLow", recLongToneBPLow);
    SetFloatRegistryValue(key$, "LongToneBPHigh", recLongToneBPHigh);
    SetIntRegistryValue(key$, "LongToneType", recLongToneType%);
    SetIntRegistryValue(key$, "LongToneNRepeats", recLongToneNRepeats%);
    SetFloatRegistryValue(key$, "LongToneISI", recLongToneISI);
    SetFloatRegistryValue(key$, "LongToneSilentDur", recLongToneSilentDur); 
    SetFloatRegistryValue(key$, "LongToneTargetdB", recLongToneTargetdB);
    SetFloatRegistryValue(key$, "LongToneRewardProb", recLongToneRewardProb);

	return;

end; 
'end  RecLongToneSaveParams(); 



'===== RecAudiogramGetParams ===== 

func RecAudiogramGetParams()
	var key$;
    key$:="Reclab\\Audiogram";
    'for the audiogram we want to pull a few parameters that are going to override params from the standard
    'timing/reward dialog box, but not OVERWRITE them.  Audiogram will likely be done rarely and it will
    'have its own set of default values.
    
    recAudiogramS1Speaker% := GetIntRegistryValue%(key$, "AGSpeaker", recAudiogramS1Speaker%);
    recHitRewardmL := GetFloatRegistryValue(key$, "AGHitRewardmL", recHitRewardmL);
    recMinOnsetDelay := GetFloatRegistryValue(key$, "AGMinOnsetDelay", recMinOnsetDelay);
    recVarOnsetDelay := GetFloatRegistryValue(key$, "AGVarOnsetDelay", recVarOnsetDelay);
    recResponseWindow := GetFloatRegistryValue(key$, "AGResponseWindow", recResponseWindow);
    recTrialInitWindow := GetFloatRegistryValue(key$, "AGTrialInitWindow", recTrialInitWindow);
    recFalseAlarmTO := GetFloatRegistryValue(key$, "AGFalseAlarmTO", recFalseAlarmTO);
    recLazyMonkeyTO := GetFloatRegistryValue(key$, "AGLazyMonkeyTO", recLazyMonkeyTO);
    recAudiogramToneFreqLow := GetFloatRegistryValue(key$, "AGToneFreqLow", recAudiogramToneFreqLow);
    recAudiogramToneFreqHigh := GetFloatRegistryValue(key$, "AGToneFreqHigh", recAudiogramToneFreqHigh);
    recAudiogramNFreqs% := GetIntRegistryValue%(key$, "AGFreqNSteps", recAudiogramNFreqs%);
    recAudiogramNReversals% := GetIntRegistryValue%(key$, "AGNReversals", recAudiogramNReversals%);
    recAudiogramOnlyLogReversals% := GetIntRegistryValue%(key$, "AGOnlyLogReversals", recAudiogramOnlyLogReversals%);
    recAudiogramStartdB := GetFloatRegistryValue(key$, "AGStartdB", recAudiogramStartdB);
    recAudiogramInitialDirection% := GetIntRegistryValue%(key$, "AGInitialDirection", recAudiogramInitialDirection%);
    recAudiogramInitialdBStep := GetFloatRegistryValue(key$, "AGInitialdBStep", recAudiogramInitialdBStep);
    recAudiogramLouderdBStep := GetFloatRegistryValue(key$, "AGLouderdBStep", recAudiogramLouderdBStep);
    recAudiogramQuieterdBStep := GetFloatRegistryValue(key$, "AGQuieterdBStep", recAudiogramQuieterdBStep);
    
    
    'This is only allowed in Project Boilermaker, do not allow "Select Boiler->Cancel->Select This" to activate it.
    recUpdateRewardByGap% := 0;
    
    return;

end; 
'end  RecAudiogramGetParams(); 


'===== RecAudiogramSaveParams ===== 

func RecAudiogramSaveParams()
	var key$;
    key$:="Reclab\\Audiogram";

    SetIntRegistryValue(key$, "AGSpeaker", recAudiogramS1Speaker%);
    SetFloatRegistryValue(key$, "AGHitRewardmL", recHitRewardmL);
    SetFloatRegistryValue(key$, "AGMinOnsetDelay", recMinOnsetDelay);
    SetFloatRegistryValue(key$, "AGVarOnsetDelay", recVarOnsetDelay);
    SetFloatRegistryValue(key$, "AGResponseWindow", recResponseWindow);
    SetFloatRegistryValue(key$, "AGTrialInitWindow", recTrialInitWindow);
    SetFloatRegistryValue(key$, "AGFalseAlarmTO", recFalseAlarmTO);
    SetFloatRegistryValue(key$, "AGLazyMonkeyTO", recLazyMonkeyTO);
    SetFloatRegistryValue(key$, "AGToneFreqLow", recAudiogramToneFreqLow);
    SetFloatRegistryValue(key$, "AGToneFreqHigh", recAudiogramToneFreqHigh);
    SetIntRegistryValue(key$, "AGFreqNSteps", recAudiogramNFreqs%);
    SetIntRegistryValue(key$, "AGNReversals", recAudiogramNReversals%);
    SetIntRegistryValue(key$, "AGOnlyLogReversals", recAudiogramOnlyLogReversals%);
    SetFloatRegistryValue(key$, "AGStartdB", recAudiogramStartdB);
    SetIntRegistryValue(key$, "AGInitialDirection", recAudiogramInitialDirection%);
    SetFloatRegistryValue(key$, "AGInitialdBStep", recAudiogramInitialdBStep);
    SetFloatRegistryValue(key$, "AGLouderdBStep", recAudiogramLouderdBStep);
    SetFloatRegistryValue(key$, "AGQuieterdBStep", recAudiogramQuieterdBStep);

    
	return;

end; 
'end  RecAudiogramSaveParams(); 


'
'
'===== RecTimingRewardGetParams =====

'Fetch Timing/Reward parameters from the registry
proc RecTimingRewardGetParams()
	var key$;
    key$:="Reclab\\TimingRewardParam";

    recMinOnsetDelay := GetFloatRegistryValue(key$, "MinOnsetDelay", recMinOnsetDelay);
    recVarOnsetDelay := GetFloatRegistryValue(key$, "VarOnsetDelay", recVarOnsetDelay);
    recISI := GetFloatRegistryValue(key$, "ISI", recISI);
    recISIVariable := GetFloatRegistryValue(key$, "ISIVariable", recISIVariable);
    recTrialInitWindow := GetFloatRegistryValue(key$, "TrialInitWindow", recTrialInitWindow);
    recResponseWindow := GetFloatRegistryValue(key$, "ResponseWindow", recResponseWindow);
    recLazyMonkeyTO := GetFloatRegistryValue(key$, "LazyMonkeyTO", recLazyMonkeyTO);
    recMissTO := GetFloatRegistryValue(key$, "MissTO", recMissTO);
    recFalseAlarmTO := GetFloatRegistryValue(key$, "FalseAlarmTO", recFalseAlarmTO);
    recInterruptTO := GetFloatRegistryValue(key$, "InterruptTO", recInterruptTO);
    recInitRewardmL := GetFloatRegistryValue(key$, "InitRewardmL", recInitRewardmL);
    recHoldRewardmL := GetFloatRegistryValue(key$, "HoldRewardmL", recHoldRewardmL);
    recHitRewardmL := GetFloatRegistryValue(key$, "HitRewardmL", recHitRewardmL);
    recCRRewardmL := GetFloatRegistryValue(key$, "CRRewardmL", recCRRewardmL);
    recMaxHitRewardmL := GetFloatRegistryValue(key$, "MaxHitRewardmL", recMaxHitRewardmL);
    recMaxCRRewardmL := GetFloatRegistryValue(key$, "MaxCRRewardmL", recMaxCRRewardmL);
    recHitRewardIncmL := GetFloatRegistryValue(key$, "HitRewardIncmL", recHitRewardIncmL);
    recS1RewardIncmL := GetFloatRegistryValue(key$, "S1RewardIncmL", recS1RewardIncmL);
    recMinJoystickRespTime := GetFloatRegistryValue(key$, "MinJoystickRespTime", recMinJoystickRespTime);
    recContinueSoundOnS1Interrupt% := GetIntRegistryValue%(key$, "ContinueSoundOnS1Interrupt", recContinueSoundOnS1Interrupt%);
    recContinueSoundOnS2Interrupt% := GetIntRegistryValue%(key$, "ContinueSoundOnS2Interrupt", recContinueSoundOnS2Interrupt%);
    recMissRepeats% := GetIntRegistryValue%(key$, "MissRepeats", recMissRepeats%);
    recMissRepeatsMax% := GetIntRegistryValue%(key$, "MissRepeatsMax", recMissRepeatsMax%);
    recRewardType% := GetIntRegistryValue%(key$, "RewardType", recRewardType%);
    recPctJuice% := GetIntRegistryValue%(key$, "PctJuice", recPctJuice%);
    recPctStimulation% := GetIntRegistryValue%(key$, "PctStimulation", recPctStimulation%);
    recJuiceToStimDelay% := GetIntRegistryValue%(key$, "JuiceToStimDelay", recJuiceToStimDelay%);
    recJuiceWaterBooth% := GetIntRegistryValue%(key$, "JuiceWaterBooth", recJuiceWaterBooth%);
    recInitialJuiceVolumemL := GetFloatRegistryValue(key$, "InitialJuiceVolumemL", recInitialJuiceVolumemL);
    recHouseLight% := GetIntRegistryValue%(key$, "HouseLight", recHouseLight%);
    
	return;
end

'===== End RecTimingRewardGetParams =====
'
'



'
'
'===== RecTimingRewardSaveParams =====

'Save Timing/Reward parameters to the registry
proc RecTimingRewardSaveParams()

	var key$;
    key$:="Reclab\\TimingRewardParam";

    SetFloatRegistryValue(key$, "MinOnsetDelay", recMinOnsetDelay);
    SetFloatRegistryValue(key$, "VarOnsetDelay", recVarOnsetDelay);
    SetFloatRegistryValue(key$, "ISI", recISI);
    SetFloatRegistryValue(key$, "ISIVariable", recISIVariable);
    SetFloatRegistryValue(key$, "TrialInitWindow", recTrialInitWindow);
    SetFloatRegistryValue(key$, "ResponseWindow", recResponseWindow);
    SetFloatRegistryValue(key$, "LazyMonkeyTO", recLazyMonkeyTO);
    SetFloatRegistryValue(key$, "MissTO", recMissTO);
    SetFloatRegistryValue(key$, "FalseAlarmTO", recFalseAlarmTO);
    SetFloatRegistryValue(key$, "InterruptTO", recInterruptTO);
    SetFloatRegistryValue(key$, "InitRewardmL", recInitRewardmL);
    SetFloatRegistryValue(key$, "HoldRewardmL", recHoldRewardmL);
    SetFloatRegistryValue(key$, "HitRewardmL", recHitRewardmL);
    SetFloatRegistryValue(key$, "CRRewardmL", recCRRewardmL);
    SetFloatRegistryValue(key$, "MaxHitRewardmL", recMaxHitRewardmL);
    SetFloatRegistryValue(key$, "MaxCRRewardmL", recMaxCRRewardmL);
    SetFloatRegistryValue(key$, "HitRewardIncmL", recHitRewardIncmL);
    SetFloatRegistryValue(key$, "S1RewardIncmL", recS1RewardIncmL); 
    SetFloatRegistryValue(key$, "MinJoystickRespTime", recMinJoystickRespTime);
    SetIntRegistryValue(key$, "ContinueSoundOnS1Interrupt", recContinueSoundOnS1Interrupt%);
    SetIntRegistryValue(key$, "ContinueSoundOnS2Interrupt", recContinueSoundOnS2Interrupt%);
    SetIntRegistryValue(key$, "MissRepeats", recMissRepeats%);
    SetIntRegistryValue(key$, "MissRepeatsMax", recMissRepeatsMax%);
    SetIntRegistryValue(key$, "RewardType", recRewardType%);
    SetIntRegistryValue(key$, "PctJuice", recPctJuice%);
    SetIntRegistryValue(key$, "PctStimulation", recPctStimulation%);
    SetIntRegistryValue(key$, "JuiceToStimDelay", recJuiceToStimDelay%);
    SetIntRegistryValue(key$, "JuiceWaterBooth", recJuiceWaterBooth%);
    SetFloatRegistryValue(key$, "InitialJuiceVolumemL", recInitialJuiceVolumemL);
    SetIntRegistryValue(key$, "HouseLight", recHouseLight%);
    
	return;
end

'===== End RecTimingRewardSaveParams =====
'
'








'
'
'===== RecLeverJoystickGetParams =====

'Fetch Lever/Joystick parameters from the registry
proc RecLeverJoystickGetParams()
	var key$;
    key$:="Reclab\\LeverJoystick";

    recUseJoystick% := GetIntRegistryValue%(key$, "UseJoystick", recUseJoystick%);
    recIsGoNoGo% := GetIntRegistryValue%(key$, "IsGoNoGo", recIsGoNoGo%);
    recTrialInitPosition% := GetIntRegistryValue%(key$, "TrialInitPosition", recTrialInitPosition%);
    recTrialResponsePosition1% := GetIntRegistryValue%(key$, "TrialResponsePosition1", recTrialResponsePosition1%);
    recTrialResponsePosition2% := GetIntRegistryValue%(key$, "TrialResponsePosition2", recTrialResponsePosition2%);
    recDoIncrements% := GetIntRegistryValue%(key$, "DoIncrements", recDoIncrements%);
    
    
	return;
end

'===== End RecJoystickLeverGetParams =====
'
'



'
'
'===== RecLeverJoystickSaveParams =====

'Save Lever/Joystick parameters to the registry
proc RecLeverJoystickSaveParams()

	var key$;
    key$:="Reclab\\LeverJoystick";
    
    SetIntRegistryValue(key$, "UseJoystick", recUseJoystick%);
    SetIntRegistryValue(key$, "IsGoNoGo", recIsGoNoGo%);
    SetIntRegistryValue(key$, "TrialInitPosition", recTrialInitPosition%);
    SetIntRegistryValue(key$, "TrialResponsePosition1", recTrialResponsePosition1%);
    SetIntRegistryValue(key$, "TrialResponsePosition2", recTrialResponsePosition2%);
    SetIntRegistryValue(key$, "DoIncrements", recDoIncrements%);
    
	return;
end

'===== End RecLeverJoystickSaveParams =====
'
'





'================================================================================================
'End Get/Save Params
'
'







'
'
'Begin Add/Delete Experiment Functions
'================================================================================================



'===== RecCharAddExpLoadFRA =====

'This is a dialog that comes up to allow adding "experiments" to FRA, Load version
'Please note that in order to reset the list box in the calling dialog, we have to actually
'CLOSE the calling dialog and reopen it.  That's gotta be manual.
func RecCharAddExpLoadFRA%()
    
    var i%;
    var j%;
    var k%;
    var status% := 0;
    'var createMode%;   'Not using this, could potentially have been useful if we passed the value in, but we're not doing that
    var mystr$;
    var mystr2$;
    var mystr3$;

    ' Generate the dialog
    DlgCreate("FRA (Load) Experiment ADD Dialog", 62, 10);
    DlgString(1,40,100,"a-zA-Z0-9",26,1);
    DlgText("Name of New Experiment",2,1);
    DlgButton(recSelectStimFileButton%,   "Select Stim/Cal File", RecSelectStimFile%,2,2);
    DlgButton(recSelectTrialsFileButton%, " Select Trials File ", RecSelectTrialsFile%,2,3);
    DlgString(2,40,200,"",26,2);  'for visual confirmation of selected stim file
    DlgString(3,40,200,"",26,3);  'for visual confirmation of selected trials file
    
    ' Show the dialog. 
    i%:=DlgShow(mystr$,mystr2$,mystr3$);
    
    ' If user hit OK then add new experiment 
	if i% = 1 then 
        'load parameters
        RecCharExpListLoadFRAGetParams(recCharExpNameLoadFRA$[],recCharStimcalFileLoadFRA$[],recCharTrialsFileLoadFRA$[]);
        'find first empty slot
        j% := 0;
        k% := -1;
        while j% < recCharNumExps% do
            if recCharExpNameLoadFRA$[j%] = "" then
                k% := j%;  'k% holds index of first empty slot
                j% := recCharNumExps%;
            endif;
            j%+=1;
        wend
        'Return if all slots are full
        if k% = -1 then
            Message("All " + Str$(recCharNumExps%) + " slots are full!  You must delete an experiment!");
            return 1;
        endif;
        'Otherwise place values 
        recCharExpNameLoadFRA$[k%] := mystr$;
        recCharStimcalFileLoadFRA$[k%] := mystr2$;
        recCharTrialsFileLoadFRA$[k%] := mystr3$;
        'And save them
        RecCharExpListLoadFRASaveParams(recCharExpNameLoadFRA$[],recCharStimcalFileLoadFRA$[],recCharTrialsFileLoadFRA$[]);
        status% := 0;  'close the calling dialog - necessary to refresh list in Dialog

    else
        status% := 1;
    endif
    
	return status%;

end;

'===== End RecCharAddExpLoadFRA =====
'
'



'
'
'===== RecCharDeleteExpLoadFRA =====

'This is a dialog that comes up to allow deleting "experiments" from FRA (Load version)
func RecCharDeleteExpLoadFRA%()

    var i%;
    var j%;
    var status% := 0;
    var mystr$[recCharNumExps%];
    var mystr1$[recCharNumExps%];
    var mystr2$[recCharNumExps%];
    
    var sli%;

    ' Fetch parameters from registry    
    RecCharExpListLoadFRAGetParams(mystr$[],mystr1$[],mystr2$[]);
    
    ' Generate the dialog
    
    DlgCreate("FRA (Load) Experiment DELETE Dialog", 62, 10);
    DlgText("Select Experiment to Delete",2,1);
    DlgList(1,27,mystr$,recCharNumExps%,28,1);

    ' Show the dialog. 
    i%:=DlgShow(sli%);
    
    ' If user hit OK then save parameters (and return 1). 
	if i% = 1 then
        'Remove experiment that has been selected and move everything up one
        if sli% < recCharNumExps%-1 then  'Without this "if", would crash if asked to remove final entry
            for j% := sli% to recCharNumExps%-2 do
                mystr$[j%] := mystr$[j%+1];
                mystr1$[j%] := mystr1$[j%+1];
                mystr2$[j%] := mystr2$[j%+1];
            next;
        endif;
        'Clear the final experiment slot, this is the only part to execute if asked to remove final entry
        mystr$[recCharNumExps%-1] := "";
        mystr1$[recCharNumExps%-1] := "";
        mystr2$[recCharNumExps%-1] := "";
        
        'Save the new values
        RecCharExpListLoadFRASaveParams(mystr$[],mystr1$[],mystr2$[]);
        
        status% := 0;  'Close the calling dialog
    else
        status% := 1;
    endif
    
	return status%;
    
end;

'===== End RecCharDeleteExpLoadFRA =====



'===== RecCharAddExpLoadSigNoise =====

'This is a dialog that comes up to allow adding "experiments" to SigNoise, Load version
'Please note that in order to reset the list box in the calling dialog, we have to actually
'CLOSE the calling dialog and reopen it.  That's gotta be manual.
func RecCharAddExpLoadSigNoise%()
    
    var i%;
    var j%;
    var k%;
    var status% := 0;
    'var createMode%;   'Not using this, could potentially have been useful if we passed the value in, but we're not doing that
    var mystr$;
    var mystr2$;
    var mystr3$;

    ' Generate the dialog
    DlgCreate("SigNoise (Load) Experiment ADD Dialog", 62, 10);
    DlgString(1,40,100,"a-zA-Z0-9",26,1);
    DlgText("Name of New Experiment",2,1);
    DlgButton(recSelectStimFileButton%,   "Select Stim/Cal File", RecSelectStimFile%,2,2);
    DlgButton(recSelectTrialsFileButton%, " Select Trials File ", RecSelectTrialsFile%,2,3);
    DlgString(2,40,200,"",26,2);  'for visual confirmation of selected stim file
    DlgString(3,40,200,"",26,3);  'for visual confirmation of selected trials file
    
    ' Show the dialog. 
    i%:=DlgShow(mystr$,mystr2$,mystr3$);
    
    ' If user hit OK then add new experiment 
	if i% = 1 then 
        'load parameters
        RecCharExpListLoadSigNoiseGetParams(recCharExpNameLoadSigNoise$[],recCharStimcalFileLoadSigNoise$[],recCharTrialsFileLoadSigNoise$[]);
        'find first empty slot
        j% := 0;
        k% := -1;
        while j% < recCharNumExps% do
            if recCharExpNameLoadSigNoise$[j%] = "" then
                k% := j%;  'k% holds index of first empty slot
                j% := recCharNumExps%;
            endif;
            j%+=1;
        wend
        'Return if all slots are full
        if k% = -1 then
            Message("All " + Str$(recCharNumExps%) + " slots are full!  You must delete an experiment!");
            return 1;
        endif;
        'Otherwise place values 
        recCharExpNameLoadSigNoise$[k%] := mystr$;
        recCharStimcalFileLoadSigNoise$[k%] := mystr2$;
        recCharTrialsFileLoadSigNoise$[k%] := mystr3$;
        'And save them
        RecCharExpListLoadSigNoiseSaveParams(recCharExpNameLoadSigNoise$[],recCharStimcalFileLoadSigNoise$[],recCharTrialsFileLoadSigNoise$[]);
        status% := 0;  'close the calling dialog - necessary to refresh list in Dialog

    else
        status% := 1;
    endif
    
	return status%;

end;

'===== End RecCharAddExpLoadSigNoise =====
'
'



'
'
'===== RecCharDeleteExpLoadSigNoise =====

'This is a dialog that comes up to allow deleting "experiments" from the Char dialog (Load SigNoise version)
func RecCharDeleteExpLoadSigNoise%()

    var i%;
    var j%;
    var status% := 0;
    var mystr$[recCharNumExps%];
    var mystr1$[recCharNumExps%];
    var mystr2$[recCharNumExps%];
    
    var sli%;

    ' Fetch parameters from registry    
    RecCharExpListLoadSigNoiseGetParams(mystr$[],mystr1$[],mystr2$[]);
    
    ' Generate the dialog
    
    DlgCreate("SigNoise (Load) Experiment DELETE Dialog", 62, 10);
    DlgText("Select Experiment to Delete",2,1);
    DlgList(1,27,mystr$,recCharNumExps%,28,1);

    ' Show the dialog. 
    i%:=DlgShow(sli%);
    
    ' If user hit OK then save parameters (and return 1). 
	if i% = 1 then
        'Remove experiment that has been selected and move everything up one
        if sli% < recCharNumExps%-1 then  'Without this "if", would crash if asked to remove final entry
            for j% := sli% to recCharNumExps%-2 do
                mystr$[j%] := mystr$[j%+1];
                mystr1$[j%] := mystr1$[j%+1];
                mystr2$[j%] := mystr2$[j%+1];
            next;
        endif;
        'Clear the final experiment slot, this is the only part to execute if asked to remove final entry
        mystr$[recCharNumExps%-1] := "";
        mystr1$[recCharNumExps%-1] := "";
        mystr2$[recCharNumExps%-1] := "";
        
        'Save the new values
        RecCharExpListLoadSigNoiseSaveParams(mystr$[],mystr1$[],mystr2$[]);
        
        status% := 0;  'Close the calling dialog
    else
        status% := 1;
    endif
    
	return status%;
    
end;

'===== End RecCharDeleteExpLoadSigNoise =====




'===== RecCharAddExpGenFRA =====

'This is a dialog that comes up to allow adding "experiments" to FRA, Gen version
'Please note that in order to reset the list box in the calling dialog, we have to actually
'CLOSE the calling dialog and reopen it.  That's gotta be manual.
func RecCharAddExpGenFRA%()
    
    var i%;
    var j%;
    var k%;
    var status% := 0;
    'var createMode%;  'Don't do this for the FRA/FRAGen, since there are separate functions
    var mystr$;
    var mystr2$;
    var mystr3$;    
      
    ' Generate the dialog
    DlgCreate("FRA (Gen) Experiment ADD Dialog", 62, 10);
    DlgString(1,40,100,"a-zA-Z0-9",26,1);
    DlgText("Name of New Experiment",2,1);
    DlgButton(recSelectStimFileButton%,   "  Select Stim File  ", RecSelectStimFile%,2,2);
    DlgButton(recSelectTrialsFileButton%, " Select Trials File ", RecSelectTrialsFile%,2,3);
    DlgString(2,40,200,"",26,2);  'for visual confirmation of selected stim file
    DlgString(3,40,200,"",26,3);  'for visual confirmation of selected trials file
    
    ' Show the dialog. 
    i%:=DlgShow(mystr$,mystr2$,mystr3$);
    
    ' If user hit OK then add new experiment 
	if i% = 1 then

        'load parameters
        RecCharExpListGenFRAGetParams(recCharExpNameGenFRA$[],recCharStimFileGenFRA$[],recCharTrialsFileGenFRA$[]);
        'find first empty slot
        j% := 0;
        k% := -1;
        while j% < recCharNumExps% do
            if recCharExpNameGenFRA$[j%] = "" then
                k% := j%;  'k% holds index of first empty slot
                j% := recCharNumExps%;
            endif;
            j%+=1;
        wend
        'Return if all slots are full
        if k% = -1 then
            Message("All " + Str$(recCharNumExps%) + " slots are full!  You must delete an experiment!");
            return 1;
        endif;
        'Otherwise place values 
        recCharExpNameGenFRA$[k%] := mystr$;
        recCharStimFileGenFRA$[k%] := mystr2$;
        recCharTrialsFileGenFRA$[k%] := mystr3$;
        'And save them
        RecCharExpListGenFRASaveParams(recCharExpNameGenFRA$[],recCharStimFileGenFRA$[],recCharTrialsFileGenFRA$[]);
        status% := 0;  'close the calling dialog - necessary to refresh list in Dialog
    else
        status% := 1;
    endif
    
	return status%;

end;

'===== End RecCharAddExpGenFRA =====
'
'



'
'
'===== RecCharDeleteExpGenFRA =====

'This is a dialog that comes up to allow deleting "experiments" from FRA (Gen version)
func RecCharDeleteExpGenFRA%()

    var i%;
    var j%;
    var status% := 0;
    'var createMode%;
    var mystr$[recCharNumExps%];
    var mystr1$[recCharNumExps%];
    var mystr2$[recCharNumExps%];
    
    var sli%;

    ' Fetch parameters from registry    
    RecCharExpListGenFRAGetParams(mystr$[],mystr1$[],mystr2$[]);

    ' Generate the dialog 
    DlgCreate("FRA (Gen) Experiment DELETE Dialog", 62, 10);
    DlgText("Select Experiment to Delete",2,1);
    DlgList(1,27,mystr$,recCharNumExps%,28,1);

    ' Show the dialog. 
    i%:=DlgShow(sli%);
    
    ' If user hit OK then save parameters (and return 1). 
	if i% = 1 then
        'Remove experiment that has been selected and move everything up one
        if sli% < recCharNumExps%-1 then  'Without this "if", would crash if asked to remove final entry
            for j% := sli% to recCharNumExps%-2 do
                mystr$[j%] := mystr$[j%+1];
                mystr1$[j%] := mystr1$[j%+1];
                mystr2$[j%] := mystr2$[j%+1];
            next;
        endif;
        'Clear the final experiment slot, this is the only part to execute if asked to remove final entry
        mystr$[recCharNumExps%-1] := "";
        mystr1$[recCharNumExps%-1] := "";
        mystr2$[recCharNumExps%-1] := "";
        
        'Save the new values
        RecCharExpListGenFRASaveParams(mystr$[],mystr1$[],mystr2$[]);
        
        status% := 0;  'Close the calling dialog
    else
        status% := 1;
    endif
    
	return status%;
    
end;

'===== End RecCharDeleteExpGenFRA =====





'===== RecCharAddExpGenSigNoise =====

'This is a dialog that comes up to allow adding "experiments" to the Characterization dialog, SigNoise Gen version
'Please note that in order to reset the list box in the calling dialog, we have to actually
'CLOSE the calling dialog and reopen it.  That's gotta be manual.
func RecCharAddExpGenSigNoise%()
    
    var i%;
    var j%;
    var k%;
    var status% := 0;
    var mystr$;
    var mystr2$;
    var mystr3$;    
      
    ' Generate the dialog
    DlgCreate("SigNoise (Gen) Experiment ADD Dialog", 62, 10);
    DlgString(1,40,100,"a-zA-Z0-9",26,1);
    DlgText("Name of New Experiment",2,1);
    DlgButton(recSelectStimFileButton%,   "  Select Stim File  ", RecSelectStimFile%,2,2);
    DlgButton(recSelectTrialsFileButton%, " Select Trials File ", RecSelectTrialsFile%,2,3);
    DlgString(2,40,200,"",26,2);  'for visual confirmation of selected stim file
    DlgString(3,40,200,"",26,3);  'for visual confirmation of selected trials file
    
    ' Show the dialog. 
    i%:=DlgShow(mystr$,mystr2$,mystr3$);
    
    ' If user hit OK then add new experiment 
	if i% = 1 then

        'load parameters
        RecCharExpListGenSigNoiseGetParams(recCharExpNameGenSigNoise$[],recCharStimFileGenSigNoise$[],recCharTrialsFileGenSigNoise$[]);
        'find first empty slot
        j% := 0;
        k% := -1;
        while j% < recCharNumExps% do
            if recCharExpNameGenSigNoise$[j%] = "" then
                k% := j%;  'k% holds index of first empty slot
                j% := recCharNumExps%;
            endif;
            j%+=1;
        wend
        'Return if all slots are full
        if k% = -1 then
            Message("All " + Str$(recCharNumExps%) + " slots are full!  You must delete an experiment!");
            return 1;
        endif;
        'Otherwise place values 
        recCharExpNameGenSigNoise$[k%] := mystr$;
        recCharStimFileGenSigNoise$[k%] := mystr2$;
        recCharTrialsFileGenSigNoise$[k%] := mystr3$;
        'And save them
        RecCharExpListGenSigNoiseSaveParams(recCharExpNameGenSigNoise$[],recCharStimFileGenSigNoise$[],recCharTrialsFileGenSigNoise$[]);
        status% := 0;  'close the calling dialog - necessary to refresh list in Dialog
    else
        status% := 1;
    endif
    
	return status%;

end;

'===== End RecCharAddExpGenSigNoise =====
'
'



'
'
'===== RecCharDeleteExpGenSigNoise =====

'This is a dialog that comes up to allow deleting "experiments" from the Characterization dialog (SigNoise Gen version)
func RecCharDeleteExpGenSigNoise%()

    var i%;
    var j%;
    var status% := 0;
    'var createMode%;
    var mystr$[recCharNumExps%];
    var mystr1$[recCharNumExps%];
    var mystr2$[recCharNumExps%];
    
    var sli%;

    ' Fetch parameters from registry    
    RecCharExpListGenSigNoiseGetParams(mystr$[],mystr1$[],mystr2$[]);

    ' Generate the dialog 
    DlgCreate("SigNoise (Gen) Experiment DELETE Dialog", 62, 10);
    DlgText("Select Experiment to Delete",2,1);
    DlgList(1,27,mystr$,recCharNumExps%,28,1);

    ' Show the dialog. 
    i%:=DlgShow(sli%);
    
    ' If user hit OK then save parameters (and return 1). 
	if i% = 1 then
        'Remove experiment that has been selected and move everything up one
        if sli% < recCharNumExps%-1 then  'Without this "if", would crash if asked to remove final entry
            for j% := sli% to recCharNumExps%-2 do
                mystr$[j%] := mystr$[j%+1];
                mystr1$[j%] := mystr1$[j%+1];
                mystr2$[j%] := mystr2$[j%+1];
            next;
        endif;
        'Clear the final experiment slot, this is the only part to execute if asked to remove final entry
        mystr$[recCharNumExps%-1] := "";
        mystr1$[recCharNumExps%-1] := "";
        mystr2$[recCharNumExps%-1] := "";
        
        'Save the new values
        RecCharExpListGenSigNoiseSaveParams(mystr$[],mystr1$[],mystr2$[]);
        
        status% := 0;  'Close the calling dialog
    else
        status% := 1;
    endif
    
	return status%;
    
end;

'===== End RecCharDeleteExpGenSigNoise =====



'===== RecCharAddExpLoadArbStim =====

'This is a dialog that comes up to allow adding "experiments" to ArbStim, Load version
'Please note that in order to reset the list box in the calling dialog, we have to actually
'CLOSE the calling dialog and reopen it.  That's gotta be manual.
func RecCharAddExpLoadArbStim%()
    
    var i%;
    var j%;
    var k%;
    var status% := 0;
    'var createMode%;   'Not using this, could potentially have been useful if we passed the value in, but we're not doing that
    var mystr$;
    var mystr2$;
    var mystr3$;
    var mystr4$;

    ' Generate the dialog
    DlgCreate("Arbitrary Stimulus (Load) Experiment ADD Dialog", 62, 10);
    DlgString(1,40,100,"a-zA-Z0-9",26,1);
    DlgText("Name of New Experiment",2,1);
    DlgButton(recSelectStimFileButton%,   "Select Stim/Cal File", RecSelectStimFile%,2,2);
    DlgButton(recSelectTrialsFileButton%, " Select Trials File ", RecSelectTrialsFile%,2,3);
    DlgString(2,40,200,"",26,2);  'for visual confirmation of selected stim file
    DlgString(3,40,200,"",26,3);  'for visual confirmation of selected trials file
    DlgString(4,40,100,"a-zA-Z0-9",26,4);
    DlgText("Prefix of New Experiment",2,4);
    
    
    ' Show the dialog. 
    i%:=DlgShow(mystr$,mystr2$,mystr3$,mystr4$);
    
    ' If user hit OK then add new experiment 
	if i% = 1 then 
        'load parameters
        RecCharExpListLoadArbStimGetParams(recCharExpNameLoadArbStim$[],recCharStimcalFileLoadArbStim$[],recCharTrialsFileLoadArbStim$[],recCharExpPrefixLoadArbStim$[]);
        'find first empty slot
        j% := 0;
        k% := -1;
        while j% < recCharNumExps% do
            if recCharExpNameLoadArbStim$[j%] = "" then
                k% := j%;  'k% holds index of first empty slot
                j% := recCharNumExps%;
            endif;
            j%+=1;
        wend
        'Return if all slots are full
        if k% = -1 then
            Message("All " + Str$(recCharNumExps%) + " slots are full!  You must delete an experiment!");
            return 1;
        endif;
        'Otherwise place values 
        recCharExpNameLoadArbStim$[k%] := mystr$;
        recCharStimcalFileLoadArbStim$[k%] := mystr2$;
        recCharTrialsFileLoadArbStim$[k%] := mystr3$;
        recCharExpPrefixLoadArbStim$[k%] := mystr4$;
        'And save them
        RecCharExpListLoadArbStimSaveParams(recCharExpNameLoadArbStim$[],recCharStimcalFileLoadArbStim$[],recCharTrialsFileLoadArbStim$[],recCharExpPrefixLoadArbStim$[]);
        status% := 0;  'close the calling dialog - necessary to refresh list in Dialog

    else
        status% := 1;
    endif
    
	return status%;

end;

'===== End RecCharAddExpLoadArbStim =====
'
'



'
'
'===== RecCharDeleteExpLoadArbStim =====

'This is a dialog that comes up to allow deleting "experiments" from the Char dialog (Load ArbStim version)
func RecCharDeleteExpLoadArbStim%()

    var i%;
    var j%;
    var status% := 0;
    var mystr$[recCharNumExps%];
    var mystr1$[recCharNumExps%];
    var mystr2$[recCharNumExps%];
    var mystr3$[recCharNumExps%];
    
    var sli%;

    ' Fetch parameters from registry    
    RecCharExpListLoadArbStimGetParams(mystr$[],mystr1$[],mystr2$[],mystr3$[]);
    
    ' Generate the dialog
    
    DlgCreate("ArbStim (Load) Experiment DELETE Dialog", 62, 10);
    DlgText("Select Experiment to Delete",2,1);
    DlgList(1,27,mystr$,recCharNumExps%,28,1);

    ' Show the dialog. 
    i%:=DlgShow(sli%);
    
    ' If user hit OK then save parameters (and return 1). 
	if i% = 1 then
        'Remove experiment that has been selected and move everything up one
        if sli% < recCharNumExps%-1 then  'Without this "if", would crash if asked to remove final entry
            for j% := sli% to recCharNumExps%-2 do
                mystr$[j%] := mystr$[j%+1];
                mystr1$[j%] := mystr1$[j%+1];
                mystr2$[j%] := mystr2$[j%+1];
                mystr3$[j%] := mystr3$[j%+1];
            next;
        endif;
        'Clear the final experiment slot, this is the only part to execute if asked to remove final entry
        mystr$[recCharNumExps%-1] := "";
        mystr1$[recCharNumExps%-1] := "";
        mystr2$[recCharNumExps%-1] := "";
        mystr3$[recCharNumExps%-1] := "";
        
        'Save the new values
        RecCharExpListLoadArbStimSaveParams(mystr$[],mystr1$[],mystr2$[],mystr3$[]);
        
        status% := 0;  'Close the calling dialog
    else
        status% := 1;
    endif
    
	return status%;
    
end;

'===== End RecCharDeleteExpLoadArbStim =====




'
'
'===== RecCharReportExp =====

'This function will report (both to a message box and to the log file) the full path of the stim/trials files
'for the current experiment - it's just a simple function that we need rather than continually diving into the
'registry to figure this out.
func RecCharReportExp%()
    
    var currIndex%;
    var ssExpName$;  'variable to hold a "split string" - we don't want to have our strings be too long because they don't fit on the Message dialog
    var ssStimcalName$;
    var ssTrialsName$;
    var ssStimcalDistractor$;
    
    docase
    case DlgValue(25) = 0 then
        return 1;  'do nothing!
    case DlgValue(25) = 1 then  'Load FRA
        currIndex% := DlgValue(26);
        RecCharExpListLoadFRAGetParams(recExpName$[],recStimcalName$[],recTrialsName$[]);
    case DlgValue(25) = 2 then  'Load SigNoise
        currIndex% := DlgValue(27);
        RecCharExpListLoadSigNoiseGetParams(recExpName$[],recStimcalName$[],recTrialsName$[]);
    case DlgValue(25) = 3 then  'Gen FRA
        currIndex% := DlgValue(28);
        RecCharExpListGenFRAGetParams(recExpName$[],recStimcalName$[],recTrialsName$[]);
    case DlgValue(25) = 4 then  'Gen SigNoise
        RecCharExpListGenSigNoiseGetParams(recExpName$[],recStimcalName$[],recTrialsName$[]);
        currIndex% := DlgValue(29);
    case DlgValue(25) = 5 then  ' Load Arbitrary
        RecCharExpListLoadArbStimGetParams(recExpName$[],recStimcalName$[],recTrialsName$[],recStimcalDistractor$[]);  'the final value isn't a distractor, but we can go with it
        '...also it appears to be filling with trailing commas that don't exist anywhere, which I can't figure out...
        'Verdict: I DON'T KNOW AND I DON'T CARE
        currIndex% := DlgValue(30);
    endcase;  
    
    'report
    ssExpName$ := SplitString$(recExpName$[currIndex%],"slash","\n",60);
    ssStimcalName$ := SplitString$(recStimcalName$[currIndex%],"slash","\n",60);
    ssTrialsName$ := SplitString$(recTrialsName$[currIndex%],"slash","\n",60);
    if DlgValue(25) < 5 then
        printlog("\nExperiment name: %s\nStim(cal) file: %s\nTrials file: %s\n\n",recExpName$[currIndex%],recStimcalName$[currIndex%],recTrialsName$[currIndex%]);
        'Message("Experiment name: %s\nStim(cal) file: %s\nTrials file: %s",recExpName$[currIndex%],recStimcalName$[currIndex%],recTrialsName$[currIndex%]);
        Message("Experiment name: %s\nStim(cal) file: %s\nTrials file: %s",ssExpName$,ssStimcalName$,ssTrialsName$);
    else
        'Please note that recStimcalDistractor$[] is not filled if we are doing the arbitrary stimulus, so we can only mess with it during "load" experiments - note that load experiments are untested...
        ssStimcalDistractor$ := SplitString$(recStimcalDistractor$[currIndex%],"slash","\n",60);
        printlog("\nExperiment name: %s\nStim(cal) file: %s\nTrials file: %s\nPrefix: %s\n\n",recExpName$[currIndex%],recStimcalName$[currIndex%],recTrialsName$[currIndex%],recStimcalDistractor$[currIndex%]);
        'Message("Experiment name: %s\nStim(cal) file: %s\nTrials file: %s\nPrefix: %s",recExpName$[currIndex%],recStimcalName$[currIndex%],recTrialsName$[currIndex%],recStimcalDistractor$[currIndex%]);
        Message("Experiment name: %s\nStim(cal) file: %s\nTrials file: %s\nPrefix: %s",ssExpName$,ssStimcalName$,ssTrialsName$,ssStimcalDistractor$);
    endif
    

return 1

end;

'===== End RecCharReportExp =====
'
'









'
'
'===== RecAMDiscAddExp =====

'This is a dialog that comes up to allow adding "experiments" to the AMDisc dialog
'Please note that in order to reset the list box in the calling dialog, we have to actually
'CLOSE the calling dialog and reopen it.  That's gotta be manual.
func RecAMDiscAddExp%()
    
    var i%;
    var j%;
    var k%;
    var status% := 0;
    var createMode%;
    var mystr$;
    var mystr2$;
    var mystr3$;
    
    if DlgValue(1) = 1 then
        createMode% := 1;
    else
        createMode% := 0;
    endif;
    
    
    ' Fetch parameters from registry    
    
    
    ' Generate the dialog
    
    DlgCreate("Cueing Experiment ADD Dialog", 62, 10);
    DlgString(1,40,100,"a-zA-Z0-9",26,1);
    DlgText("Name of New Experiment",2,1);
    if createMode% = 0 then
        DlgButton(recSelectStimFileButton%,   "Select Stim/Cal File", RecSelectStimFile%,2,2);
    else
        DlgButton(recSelectStimFileButton%,   "  Select Stim File  ", RecSelectStimFile%,2,2);
    endif;
    DlgButton(recSelectTrialsFileButton%, " Select Trials File ", RecSelectTrialsFile%,2,3);
    DlgString(2,40,200,"",26,2);  'for visual confirmation of selected stim file
    DlgString(3,40,200,"",26,3);  'for visual confirmation of selected trials file
    
    ' Show the dialog. 
    i%:=DlgShow(mystr$,mystr2$,mystr3$);
    
    ' If user hit OK then add new experiment 
	if i% = 1 then
        if createMode% = 0 then 
            'reload parameters
            RecAMDiscExpListLoadGetParams(recAMDiscExpNameLoad$[],recAMDiscStimcalNameLoad$[],recAMDiscTrialsNameLoad$[]);
            'find first empty slot
            j% := 0;
            k% := -1;
            while j% < recAMDiscNumExps% do
                if recAMDiscExpNameLoad$[j%] = "" then
                    k% := j%;  'k% holds index of first empty slot
                    j% := recAMDiscNumExps%;
                endif;
                j%+=1;
            wend
            'Return if all slots are full
            if k% = -1 then
                Message("All " + Str$(recAMDiscNumExps%) + " slots are full!  You must delete an experiment!");
                return 1;
            endif;
            'Otherwise place values 
            recAMDiscExpNameLoad$[k%] := mystr$;
            recAMDiscStimcalNameLoad$[k%] := mystr2$;
            recAMDiscTrialsNameLoad$[k%] := mystr3$;
            'And save them
            RecAMDiscExpListLoadSaveParams(recAMDiscExpNameLoad$[],recAMDiscStimcalNameLoad$[],recAMDiscTrialsNameLoad$[]);
            status% := 0;  'close the calling dialog - necessary to refresh list in AMDisDialog
        else
            'reload parameters
            RecAMDiscExpListGenGetParams(recAMDiscExpNameGen$[],recAMDiscStimcalNameGen$[],recAMDiscTrialsNameGen$[]);
            'find first empty slot
            j% := 0;
            k% := -1;
            while j% < recAMDiscNumExps% do
                if recAMDiscExpNameGen$[j%] = "" then
                    k% := j%;  'k% holds index of first empty slot
                    j% := recAMDiscNumExps%;
                endif;
                j%+=1;
            wend
            'Return if all slots are full
            if k% = -1 then
                Message("All " + Str$(recAMDiscNumExps%) + " slots are full!  You must delete an experiment!");
                return 1;
            endif;
            'Otherwise place values 
            recAMDiscExpNameGen$[k%] := mystr$;
            recAMDiscStimcalNameGen$[k%] := mystr2$;
            recAMDiscTrialsNameGen$[k%] := mystr3$;
            'And save them
            RecAMDiscExpListGenSaveParams(recAMDiscExpNameGen$[],recAMDiscStimcalNameGen$[],recAMDiscTrialsNameGen$[]);
            status% := 0;  'close the calling dialog
        endif;
    else
        status% := 1;
    endif
    
	return status%;

end;

'===== End RecAMDiscAddExp =====
'
'



'
'
'===== RecAMDiscDeleteExp =====

'This is a dialog that comes up to allow deleting "experiments" from the AMDisc dialog
func RecAMDiscDeleteExp%()

    var i%;
    var j%;
    var status% := 0;
    var createMode%;
    var mystr$[recAMDiscNumExps%];
    var mystr1$[recAMDiscNumExps%];
    var mystr2$[recAMDiscNumExps%];
    
    var sli%;
    
    if DlgValue(1) = 1 then
        createMode% := 1;
    else
        createMode% := 0;
    endif;
    
    
    ' Fetch parameters from registry    
    if createMode% = 0 then 
        'fetch parameters
        RecAMDiscExpListLoadGetParams(mystr$[],mystr1$[],mystr2$[]);
    else
        RecAMDiscExpListGenGetParams(mystr$[],mystr1$[],mystr2$[]);
    endif;
    
    
    ' Generate the dialog
    
    DlgCreate("Cueing Experiment DELETE Dialog", 62, 10);
    DlgText("Select Experiment to Delete",2,1);
    DlgList(1,27,mystr$,recAMDiscNumExps%,28,1);

    ' Show the dialog. 
    i%:=DlgShow(sli%);
    
    ' If user hit OK then save parameters (and return 1). 
	if i% = 1 then
        'Remove experiment that has been selected and move everything up one
        if sli% < recAMDiscNumExps%-1 then  'Without this "if", would crash if asked to remove final entry
            for j% := sli% to recAMDiscNumExps%-2 do
                mystr$[j%] := mystr$[j%+1];
                mystr1$[j%] := mystr1$[j%+1];
                mystr2$[j%] := mystr2$[j%+1];
            next;
        endif;
        'Clear the final experiment slot, this is the only part to execute if asked to remove final entry
        mystr$[recAMDiscNumExps%-1] := "";
        mystr1$[recAMDiscNumExps%-1] := "";
        mystr2$[recAMDiscNumExps%-1] := "";
        
        'Save the new values
        if createMode% = 0 then 
            RecAMDiscExpListLoadSaveParams(mystr$[],mystr1$[],mystr2$[]);
        else
            RecAMDiscExpListGenSaveParams(mystr$[],mystr1$[],mystr2$[]);
        endif;
        
        status% := 0;  'Close the calling dialog
    else
        status% := 1;
    endif
    
	return status%;
    
end;

'===== End RecAMDiscDeleteExp =====
'
'


'
'
'===== RecAMDiscReportExp =====

'This function will report (both to a message box and to the log file) the full path of the stim/trials files
'for the current experiment - it's just a simple function that we need rather than continually diving into the
'registry to figure this out.
func RecAMDiscReportExp%()
    
    var currIndex%;
    var ssExpName$;  'variable to hold a "split string" - we don't want to have our strings be too long because they don't fit on the Message dialog
    var ssStimcalName$;
    var ssTrialsName$;
    
    if DlgValue(1) = 1 then
        'get "gen" parameters
        RecAMDiscExpListGenGetParams(recExpName$[],recStimcalName$[],recTrialsName$[]);
        currIndex% := DlgValue(2);
    else
        'get "load" parameters
        RecAMDiscExpListLoadGetParams(recExpName$[],recStimcalName$[],recTrialsName$[]);
        currIndex% := DlgValue(3);
    endif;  

    'report
    ssExpName$ := SplitString$(recExpName$[currIndex%],"slash","\n",60);
    ssStimcalName$ := SplitString$(recStimcalName$[currIndex%],"slash","\n",60);
    ssTrialsName$ := SplitString$(recTrialsName$[currIndex%],"slash","\n",60);
    printlog("\nExperiment name: %s\nStim(cal) file: %s\nTrials file: %s\n\n",recExpName$[currIndex%],recStimcalName$[currIndex%],recTrialsName$[currIndex%]);
    'Message("Experiment name: %s\nStim(cal) file: %s\nTrials file: %s",recExpName$[currIndex%],recStimcalName$[currIndex%],recTrialsName$[currIndex%]);
    Message("Experiment name: %s\nStim(cal) file: %s\nTrials file: %s",ssExpName$,ssStimcalName$,ssTrialsName$);
return 1

end;

'===== End RecAMDiscReportExp =====
'
'





'
'
'===== RecSpaceDisAddExp =====

'This is a dialog that comes up to allow adding "experiments" to the SpaceDis dialog
'Please note that in order to reset the list box in the calling dialog, we have to actually
'CLOSE the calling dialog and reopen it.  That's gotta be manual.
func RecSpaceDisAddExp%()
    
    var i%;
    var j%;
    var k%;
    var status% := 0;
    var createMode%;
    var mystr$;
    var mystr2$;
    var mystr3$;
    
    if DlgValue(1) = 1 then
        createMode% := 1;
    else
        createMode% := 0;
    endif;
    
    
    ' Fetch parameters from registry    
    
    
    ' Generate the dialog
    
    DlgCreate("Cueing Experiment ADD Dialog", 62, 10);
    DlgString(1,40,100,"a-zA-Z0-9",26,1);
    DlgText("Name of New Experiment",2,1);
    if createMode% = 0 then
        DlgButton(recSelectStimFileButton%,   "Select Stim/Cal File", RecSelectStimFile%,2,2);
    else
        DlgButton(recSelectStimFileButton%,   "  Select Stim File  ", RecSelectStimFile%,2,2);
    endif;
    DlgButton(recSelectTrialsFileButton%, " Select Trials File ", RecSelectTrialsFile%,2,3);
    DlgString(2,40,200,"",26,2);  'for visual confirmation of selected stim file
    DlgString(3,40,200,"",26,3);  'for visual confirmation of selected trials file
    
    ' Show the dialog. 
    i%:=DlgShow(mystr$,mystr2$,mystr3$);
    
    ' If user hit OK then add new experiment 
	if i% = 1 then
        if createMode% = 0 then 
            'reload parameters
            RecSpaceDisExpListLoadGetParams(recSpaceDisExpNameLoad$[],recSpaceDisStimcalNameLoad$[],recSpaceDisTrialsNameLoad$[]);
            'find first empty slot
            j% := 0;
            k% := -1;
            while j% < recSpaceDisNumExps% do
                if recSpaceDisExpNameLoad$[j%] = "" then
                    k% := j%;  'k% holds index of first empty slot
                    j% := recSpaceDisNumExps%;
                endif;
                j%+=1;
            wend
            'Return if all slots are full
            if k% = -1 then
                Message("All " + Str$(recSpaceDisNumExps%) + " slots are full!  You must delete an experiment!");
                return 1;
            endif;
            'Otherwise place values 
            recSpaceDisExpNameLoad$[k%] := mystr$;
            recSpaceDisStimcalNameLoad$[k%] := mystr2$;
            recSpaceDisTrialsNameLoad$[k%] := mystr3$;
            'And save them
            RecSpaceDisExpListLoadSaveParams(recSpaceDisExpNameLoad$[],recSpaceDisStimcalNameLoad$[],recSpaceDisTrialsNameLoad$[]);
            status% := 0;  'close the calling dialog - necessary to refresh list in AMDisDialog
        else
            'reload parameters
            RecSpaceDisExpListGenGetParams(recSpaceDisExpNameGen$[],recSpaceDisStimcalNameGen$[],recSpaceDisTrialsNameGen$[]);
            'find first empty slot
            j% := 0;
            k% := -1;
            while j% < recSpaceDisNumExps% do
                if recSpaceDisExpNameGen$[j%] = "" then
                    k% := j%;  'k% holds index of first empty slot
                    j% := recSpaceDisNumExps%;
                endif;
                j%+=1;
            wend
            'Return if all slots are full
            if k% = -1 then
                Message("All " + Str$(recSpaceDisNumExps%) + " slots are full!  You must delete an experiment!");
                return 1;
            endif;
            'Otherwise place values 
            recSpaceDisExpNameGen$[k%] := mystr$;
            recSpaceDisStimcalNameGen$[k%] := mystr2$;
            recSpaceDisTrialsNameGen$[k%] := mystr3$;
            'And save them
            RecSpaceDisExpListGenSaveParams(recSpaceDisExpNameGen$[],recSpaceDisStimcalNameGen$[],recSpaceDisTrialsNameGen$[]);
            status% := 0;  'close the calling dialog
        endif;
    else
        status% := 1;
    endif
    
	return status%;

end;

'===== End RecSpaceDisAddExp =====
'
'



'
'
'===== RecSpaceDisDeleteExp =====

'This is a dialog that comes up to allow deleting "experiments" from the SpaceDis dialog
func RecSpaceDisDeleteExp%()

    var i%;
    var j%;
    var status% := 0;
    var createMode%;
    var mystr$[recSpaceDisNumExps%];
    var mystr1$[recSpaceDisNumExps%];
    var mystr2$[recSpaceDisNumExps%];
    
    var sli%;
    
    if DlgValue(1) = 1 then
        createMode% := 1;
    else
        createMode% := 0;
    endif;
    
    
    ' Fetch parameters from registry    
    if createMode% = 0 then 
        'fetch parameters
        RecSpaceDisExpListLoadGetParams(mystr$[],mystr1$[],mystr2$[]);
    else
        RecSpaceDisExpListGenGetParams(mystr$[],mystr1$[],mystr2$[]);
    endif;
    
    
    ' Generate the dialog
    
    DlgCreate("Cueing Experiment DELETE Dialog", 62, 10);
    DlgText("Select Experiment to Delete",2,1);
    DlgList(1,27,mystr$,recSpaceDisNumExps%,28,1);

    ' Show the dialog. 
    i%:=DlgShow(sli%);
    
    ' If user hit OK then save parameters (and return 1). 
	if i% = 1 then
        'Remove experiment that has been selected and move everything up one
        if sli% < recSpaceDisNumExps%-1 then  'Without this "if", would crash if asked to remove final entry
            for j% := sli% to recSpaceDisNumExps%-2 do
                mystr$[j%] := mystr$[j%+1];
                mystr1$[j%] := mystr1$[j%+1];
                mystr2$[j%] := mystr2$[j%+1];
            next;
        endif;
        'Clear the final experiment slot, this is the only part to execute if asked to remove final entry
        mystr$[recSpaceDisNumExps%-1] := "";
        mystr1$[recSpaceDisNumExps%-1] := "";
        mystr2$[recSpaceDisNumExps%-1] := "";
        
        'Save the new values
        if createMode% = 0 then 
            RecSpaceDisExpListLoadSaveParams(mystr$[],mystr1$[],mystr2$[]);
        else
            RecSpaceDisExpListGenSaveParams(mystr$[],mystr1$[],mystr2$[]);
        endif;
        
        status% := 0;  'Close the calling dialog
    else
        status% := 1;
    endif
    
	return status%;
    
end;

'===== End RecSpaceDisDeleteExp =====
'
'



'
'
'===== RecSpaceDisReportExp =====

'This function will report (both to a message box and to the log file) the full path of the stim/trials files
'for the current experiment - it's just a simple function that we need rather than continually diving into the
'registry to figure this out.
func RecSpaceDisReportExp%()
    
    var currIndex%;
    var ssExpName$;  'variable to hold a "split string" - we don't want to have our strings be too long because they don't fit on the Message dialog
    var ssStimcalName$;
    var ssTrialsName$;
    
    if DlgValue(1) = 1 then
        'get "gen" parameters
        RecSpaceDisExpListGenGetParams(recExpName$[],recStimcalName$[],recTrialsName$[]);
        currIndex% := DlgValue(2);
    else
        'get "load" parameters
        RecSpaceDisExpListLoadGetParams(recExpName$[],recStimcalName$[],recTrialsName$[]);
        currIndex% := DlgValue(3);
    endif;  

    'report
    ssExpName$ := SplitString$(recExpName$[currIndex%],"slash","\n",60);
    ssStimcalName$ := SplitString$(recStimcalName$[currIndex%],"slash","\n",60);
    ssTrialsName$ := SplitString$(recTrialsName$[currIndex%],"slash","\n",60);
    printlog("\nExperiment name: %s\nStim(cal) file: %s\nTrials file: %s\n\n",recExpName$[currIndex%],recStimcalName$[currIndex%],recTrialsName$[currIndex%]);
    'Message("Experiment name: %s\nStim(cal) file: %s\nTrials file: %s",recExpName$[currIndex%],recStimcalName$[currIndex%],recTrialsName$[currIndex%]);
    Message("Experiment name: %s\nStim(cal) file: %s\nTrials file: %s",ssExpName$,ssStimcalName$,ssTrialsName$);
return 1

end;

'===== End RecSpaceDisReportExp =====
'
'




'
'
'===== RecStereoDisAddExp =====

'This is a dialog that comes up to allow adding "experiments" to the StereoDis dialog
'Please note that in order to reset the list box in the calling dialog, we have to actually
'CLOSE the calling dialog and reopen it.  That's gotta be manual.
func RecStereoDisAddExp%()
    
    var i%;
    var j%;
    var k%;
    var status% := 0;
    var mystr$;
    var mystr2$;
    var mystr3$;
    var mystr4$;
    var createMode%;
    
    if DlgValue(2) = 1 then
        createMode% := 1;  'generate stimuli
    else
        createMode% := 0;  'load stimuli
    endif;
    
    ' Fetch parameters from registry    
    
    
    ' Generate the dialog
    
    DlgCreate("Stereo Distractor Experiment ADD Dialog", 62, 10);
    DlgString(1,40,100,"a-zA-Z0-9",26,1);
    DlgText("Name of New Experiment",2,1);
    if createMode% = 0 then
        DlgButton(recSelectStimFileButton%,   "S1/S2 Stim/Cal File", RecSelectStimFile%,2,2);
    else
        DlgButton(recSelectStimFileButton%,   "S1/S2 Stim File", RecSelectStimFile%,2,2);
    endif
    DlgString(2,40,200,"",26,2);  'for visual confirmation of selected stim file
    DlgButton(recSelectTrialsFileButton%, "    Trials File   ", RecSelectTrialsFile%,2,3);
    DlgString(3,40,200,"",26,3);  'for visual confirmation of selected trials file
    if createMode% = 0 then
        DlgButton(recSelectStimDistractorFileButton%,   "Distractor Stim/Cal File", RecSelectStimFile2%,2,4);
        DlgString(4,40,200,"",26,4);  'for visual confirmation of selected distractor stim file
    endif
    
    
    ' Show the dialog. 
    if createMode% = 0 then
        i%:=DlgShow(mystr$,mystr2$,mystr3$,mystr4$);
    else
        i%:=DlgShow(mystr$,mystr2$,mystr3$);
    endif
    
    
    ' If user hit OK then add new experiment 
	if i% = 1 then
        'reload parameters
        if createMode% = 0 then
            RecStereoDisExpListLoadGetParams(recStereoDisExpNameLoad$[],recStereoDisStimcalNameLoad$[],recStereoDisTrialsNameLoad$[],recStereoDisStimcalDistractorNameLoad$[]);
            'find first empty slot
            j% := 0;
            k% := -1;
            while j% < recStereoDisNumExps% do
                if recStereoDisExpNameLoad$[j%] = "" then
                    k% := j%;  'k% holds index of first empty slot
                    j% := recStereoDisNumExps%;
                endif;
                j%+=1;
            wend
            'Return if all slots are full
            if k% = -1 then
                Message("All " + Str$(recStereoDisNumExps%) + " slots are full!  You must delete an experiment!");
                return 1;
            endif;
            'Otherwise place values 
            recStereoDisExpNameLoad$[k%] := mystr$;
            recStereoDisStimcalNameLoad$[k%] := mystr2$;
            recStereoDisTrialsNameLoad$[k%] := mystr3$;
            recStereoDisStimcalDistractorNameLoad$[k%] := mystr4$;
            'And save them
            RecStereoDisExpListLoadSaveParams(recStereoDisExpNameLoad$[],recStereoDisStimcalNameLoad$[],recStereoDisTrialsNameLoad$[],recStereoDisStimcalDistractorNameLoad$[]);
        else
            RecStereoDisExpListGenGetParams(recStereoDisExpNameGen$[],recStereoDisStimNameGen$[],recStereoDisTrialsNameGen$[]);
            'find first empty slot
            j% := 0;
            k% := -1;
            while j% < recStereoDisNumExps% do
                if recStereoDisExpNameGen$[j%] = "" then
                    k% := j%;  'k% holds index of first empty slot
                    j% := recStereoDisNumExps%;
                endif;
                j%+=1;
            wend
            'Return if all slots are full
            if k% = -1 then
                Message("All " + Str$(recStereoDisNumExps%) + " slots are full!  You must delete an experiment!");
                return 1;
            endif;
            'Otherwise place values 
            recStereoDisExpNameGen$[k%] := mystr$;
            recStereoDisStimNameGen$[k%] := mystr2$;
            recStereoDisTrialsNameGen$[k%] := mystr3$;
            'And save them
            RecStereoDisExpListGenSaveParams(recStereoDisExpNameGen$[],recStereoDisStimNameGen$[],recStereoDisTrialsNameGen$[]);
        endif;
        
        status% := 0;  'close the calling dialog - necessary to refresh list in StereoDisDialog
    else
        status% := 1;
    endif
    
	return status%;

end;

'===== End RecStereoDisAddExp =====
'
'



'
'
'===== RecStereoDisDeleteExp =====

'This is a dialog that comes up to allow deleting "experiments" from the AMDisc dialog
func RecStereoDisDeleteExp%()

    var i%;
    var j%;
    var status% := 0;
    var mystr$[recStereoDisNumExps%];
    var mystr2$[recStereoDisNumExps%];
    var mystr3$[recStereoDisNumExps%];
    var mystr4$[recStereoDisNumExps%];
    var sli%;
    var createMode%;
    
    if DlgValue(2) = 1 then
        createMode% := 1;  'generate stimuli
    else
        createMode% := 0;  'load stimuli
    endif;
    
    ' Fetch parameters from registry  
    if createMode% = 0 then
        RecStereoDisExpListLoadGetParams(mystr$[],mystr2$[],mystr3$[],mystr4$[]);
    else
        RecStereoDisExpListGenGetParams(mystr$[],mystr2$[],mystr3$[]);
    endif;
    
    
    ' Generate the dialog
    
    DlgCreate("Stereo Distractor Experiment DELETE Dialog", 62, 10);
    DlgText("Select Experiment to Delete",2,1);
    DlgList(1,27,mystr$,recStereoDisNumExps%,28,1);

    ' Show the dialog. 
    i%:=DlgShow(sli%);
    
    ' If user hit OK then save parameters (and return 1). 
	if i% = 1 then
        'Remove experiment that has been selected and move everything up one
        if createMode% = 0 then
            if sli% < recStereoDisNumExps%-1 then  'Without this "if", would crash if asked to remove final entry
                for j% := sli% to recStereoDisNumExps%-2 do
                    mystr$[j%] := mystr$[j%+1];
                    mystr2$[j%] := mystr2$[j%+1];
                    mystr3$[j%] := mystr3$[j%+1];
                    mystr4$[j%] := mystr4$[j%+1];
                next;
            endif;
            'Clear the final experiment slot, this is the only part to execute if asked to remove final entry
            mystr$[recStereoDisNumExps%-1] := "";
            mystr2$[recStereoDisNumExps%-1] := "";
            mystr3$[recStereoDisNumExps%-1] := "";
            mystr4$[recStereoDisNumExps%-1] := "";
            
            'Save the new values
            RecStereoDisExpListLoadSaveParams(mystr$[],mystr2$[],mystr3$[],mystr4$[]);
        else
            if sli% < recStereoDisNumExps%-1 then  'Without this "if", would crash if asked to remove final entry
                for j% := sli% to recStereoDisNumExps%-2 do
                    mystr$[j%] := mystr$[j%+1];
                    mystr2$[j%] := mystr2$[j%+1];
                    mystr3$[j%] := mystr3$[j%+1];
                next;
            endif;
            'Clear the final experiment slot, this is the only part to execute if asked to remove final entry
            mystr$[recStereoDisNumExps%-1] := "";
            mystr2$[recStereoDisNumExps%-1] := "";
            mystr3$[recStereoDisNumExps%-1] := "";
            
            'Save the new values
            RecStereoDisExpListGenSaveParams(mystr$[],mystr2$[],mystr3$[]);
        endif;
        
        
        status% := 0;  'Close the calling dialog
    else
        status% := 1;
    endif
    
	return status%;
    
end;

'===== End RecStereoDisDeleteExp =====
'
'




'
'
'===== RecStereoDisReportExp =====

'This function will report (both to a message box and to the log file) the full path of the stim/trials files
'for the current experiment - it's just a simple function that we need rather than continually diving into the
'registry to figure this out.
func RecStereoDisReportExp%()
    
    var currIndex%;
    var ssExpName$;  'variable to hold a "split string" - we don't want to have our strings be too long because they don't fit on the Message dialog
    var ssStimcalName$;
    var ssTrialsName$;
    var ssStimcalDistractor$;
    
    docase
    case DlgValue(1) = 1 and DlgValue(2) = 1 then  'forced choice gen
        currIndex% := DlgValue(3);
        RecStereoDisExpListGenGetParams(recExpName$[],recStimcalName$[],recTrialsName$[]);
    case DlgValue(1) = 1 and DlgValue(2) = 0 then  'forced choice load
        currIndex% := DlgValue(4);
        RecStereoDisExpListLoadGetParams(recExpName$[],recStimcalName$[],recTrialsName$[],recStimcalDistractor$[]);
    case DlgValue(1) = 0 and DlgValue(2) = 1 then  'GNG gen
        currIndex% := DlgValue(5);
        RecStereoDisGNGExpListGenGetParams(recExpName$[],recStimcalName$[],recTrialsName$[]);
    else                                           'GNG load
        RecStereoDisGNGExpListLoadGetParams(recExpName$[],recStimcalName$[],recTrialsName$[],recStimcalDistractor$[]);
        currIndex% := DlgValue(6);
    endcase;  
    
    'report
    ssExpName$ := SplitString$(recExpName$[currIndex%],"slash","\n",60);
    ssStimcalName$ := SplitString$(recStimcalName$[currIndex%],"slash","\n",60);
    ssTrialsName$ := SplitString$(recTrialsName$[currIndex%],"slash","\n",60);
    if DlgValue(2) = 1 then
        printlog("\nExperiment name: %s\nStim(cal) file: %s\nTrials file: %s\n\n",recExpName$[currIndex%],recStimcalName$[currIndex%],recTrialsName$[currIndex%]);
        'Message("Experiment name: %s\nStim(cal) file: %s\nTrials file: %s",recExpName$[currIndex%],recStimcalName$[currIndex%],recTrialsName$[currIndex%]);
        Message("Experiment name: %s\nStim(cal) file: %s\nTrials file: %s",ssExpName$,ssStimcalName$,ssTrialsName$);
    else
        'Please note that recStimcalDistractor$[] is not filled if we are generating the stimulus, so we can only mess with it during "load" experiments - note that load experiments are untested...
        ssStimcalDistractor$ := SplitString$(recStimcalDistractor$[currIndex%],"slash","\n",60);
        printlog("\nExperiment name: %s\nStim(cal) file: %s\nTrials file: %s\nStim(cal) distractor file: %s\n\n",recExpName$[currIndex%],recStimcalName$[currIndex%],recTrialsName$[currIndex%],recStimcalDistractor$[currIndex%]);
        Message("Experiment name: %s\nStim(cal) file: %s\nTrials file: %s\nStim(cal) distractor file: %s",recExpName$[currIndex%],recStimcalName$[currIndex%],recTrialsName$[currIndex%],recStimcalDistractor$[currIndex%]);
        'Message("Experiment name: %s\nStim(cal) file: %s\nTrials file: %s\nStim(cal) distractor file: %s",ssExpName$,ssStimcalName$,ssTrialsName$,ssStimcalDistractor$);
    endif
    

return 1

end;

'===== End RecStereoDisReportExp =====
'
'



'
'
'===== RecStereoDisGNGAddExp =====

'This is a dialog that comes up to allow adding "experiments" to the StereoDis dialog
'Please note that in order to reset the list box in the calling dialog, we have to actually
'CLOSE the calling dialog and reopen it.  That's gotta be manual.
func RecStereoDisGNGAddExp%()
    
    var i%;
    var j%;
    var k%;
    var status% := 0;
    var mystr$;
    var mystr2$;
    var mystr3$;
    var mystr4$;
    var createMode%;
    
    if DlgValue(2) = 1 then
        createMode% := 1;  'generate stimuli
    else
        createMode% := 0;  'load stimuli
    endif;
    
    ' Fetch parameters from registry    
    
    
    ' Generate the dialog
    
    DlgCreate("Stereo Distractor Experiment ADD Dialog", 62, 10);
    DlgString(1,40,100,"a-zA-Z0-9",26,1);
    DlgText("Name of New Experiment",2,1);
    if createMode% = 0 then
        DlgButton(recSelectStimFileButton%,   "S1/S2 Stim/Cal File", RecSelectStimFile%,2,2);
    else
        DlgButton(recSelectStimFileButton%,   "S1/S2 Stim File", RecSelectStimFile%,2,2);
    endif;
    DlgString(2,40,200,"",26,2);  'for visual confirmation of selected stim file
    DlgButton(recSelectTrialsFileButton%, "    Trials File   ", RecSelectTrialsFile%,2,3);
    DlgString(3,40,200,"",26,3);  'for visual confirmation of selected trials file
    if createMode% = 0 then
        DlgButton(recSelectStimDistractorFileButton%,   "Distractor Stim/Cal File", RecSelectStimFile2%,2,4);
        DlgString(4,40,200,"",26,4);  'for visual confirmation of selected distractor stim file
    endif;
    
    ' Show the dialog. 
    if createMode% = 0 then
        i%:=DlgShow(mystr$,mystr2$,mystr3$,mystr4$);
    else
        i%:=DlgShow(mystr$,mystr2$,mystr3$);
    endif;
    
    
    ' If user hit OK then add new experiment 
	if i% = 1 then
        'reload parameters
        if createMode% = 0 then
            RecStereoDisGNGExpListLoadGetParams(recStereoDisGNGExpNameLoad$[],recStereoDisGNGStimcalNameLoad$[],recStereoDisGNGTrialsNameLoad$[],recStereoDisGNGStimcalDistractorNameLoad$[]);
            'find first empty slot
            j% := 0;
            k% := -1;
            while j% < recStereoDisGNGNumExps% do
                if recStereoDisGNGExpNameLoad$[j%] = "" then
                    k% := j%;  'k% holds index of first empty slot
                    j% := recStereoDisGNGNumExps%;
                endif;
                j%+=1;
            wend
            'Return if all slots are full
            if k% = -1 then
                Message("All " + Str$(recStereoDisGNGNumExps%) + " slots are full!  You must delete an experiment!");
                return 1;
            endif;
            'Otherwise place values 
            recStereoDisGNGExpNameLoad$[k%] := mystr$;
            recStereoDisGNGStimcalNameLoad$[k%] := mystr2$;
            recStereoDisGNGTrialsNameLoad$[k%] := mystr3$;
            recStereoDisGNGStimcalDistractorNameLoad$[k%] := mystr4$;
            'And save them
            RecStereoDisGNGExpListLoadSaveParams(recStereoDisGNGExpNameLoad$[],recStereoDisGNGStimcalNameLoad$[],recStereoDisGNGTrialsNameLoad$[],recStereoDisGNGStimcalDistractorNameLoad$[]);
        else
            RecStereoDisGNGExpListGenGetParams(recStereoDisGNGExpNameGen$[],recStereoDisGNGStimNameGen$[],recStereoDisGNGTrialsNameGen$[]);
            'find first empty slot
            j% := 0;
            k% := -1;
            while j% < recStereoDisGNGNumExps% do
                if recStereoDisGNGExpNameGen$[j%] = "" then
                    k% := j%;  'k% holds index of first empty slot
                    j% := recStereoDisGNGNumExps%;
                endif;
                j%+=1;
            wend
            'Return if all slots are full
            if k% = -1 then
                Message("All " + Str$(recStereoDisGNGNumExps%) + " slots are full!  You must delete an experiment!");
                return 1;
            endif;
            'Otherwise place values 
            recStereoDisGNGExpNameGen$[k%] := mystr$;
            recStereoDisGNGStimNameGen$[k%] := mystr2$;
            recStereoDisGNGTrialsNameGen$[k%] := mystr3$;
            'And save them
            RecStereoDisGNGExpListGenSaveParams(recStereoDisGNGExpNameGen$[],recStereoDisGNGStimNameGen$[],recStereoDisGNGTrialsNameGen$[]);
        endif;
        
        
        status% := 0;  'close the calling dialog - necessary to refresh list in StereoDisDialog
    else
        status% := 1;
    endif
    
	return status%;

end;

'===== End RecStereoDisGNGAddExp =====
'
'



'
'
'===== RecStereoDisGNGDeleteExp =====

'This is a dialog that comes up to allow deleting "experiments" from the AMDisc dialog
func RecStereoDisGNGDeleteExp%()

    var i%;
    var j%;
    var status% := 0;
    var mystr$[recStereoDisGNGNumExps%];
    var mystr1$[recStereoDisGNGNumExps%];
    var mystr2$[recStereoDisGNGNumExps%];
    var mystr3$[recStereoDisGNGNumExps%];
    
    var sli%;

    
    ' Fetch parameters from registry     
    RecStereoDisGNGExpListLoadGetParams(mystr$[],mystr1$[],mystr2$[],mystr3$[]);
    
    
    ' Generate the dialog
    
    DlgCreate("Stereo Distractor Experiment DELETE Dialog", 62, 10);
    DlgText("Select Experiment to Delete",2,1);
    DlgList(1,27,mystr$,recStereoDisGNGNumExps%,28,1);

    ' Show the dialog. 
    i%:=DlgShow(sli%);
    
    ' If user hit OK then save parameters (and return 1). 
	if i% = 1 then
        'Remove experiment that has been selected and move everything up one
        if sli% < recStereoDisGNGNumExps%-1 then  'Without this "if", would crash if asked to remove final entry
            for j% := sli% to recStereoDisGNGNumExps%-2 do
                mystr$[j%] := mystr$[j%+1];
                mystr1$[j%] := mystr1$[j%+1];
                mystr2$[j%] := mystr2$[j%+1];
                mystr3$[j%] := mystr3$[j%+1];
            next;
        endif;
        'Clear the final experiment slot, this is the only part to execute if asked to remove final entry
        mystr$[recStereoDisGNGNumExps%-1] := "";
        mystr1$[recStereoDisGNGNumExps%-1] := "";
        mystr2$[recStereoDisGNGNumExps%-1] := "";
        mystr3$[recStereoDisGNGNumExps%-1] := "";
        
        'Save the new values
        RecStereoDisGNGExpListLoadSaveParams(mystr$[],mystr1$[],mystr2$[],mystr3$[]);
        
        status% := 0;  'Close the calling dialog
    else
        status% := 1;
    endif
    
	return status%;
    
end;

'===== End RecStereoDisGNGDeleteExp =====
'
'




'
'
'===== RecOneStimDiscrimAddExp =====

'This is a dialog that comes up to allow adding "experiments" to the OneStimDiscrim dialog
'Please note that in order to reset the list box in the calling dialog, we have to actually
'CLOSE the calling dialog and reopen it.  That's gotta be manual.
func RecOneStimDiscrimAddExp%()
    
    var i%;
    var j%;
    var k%;
    var status% := 0;
    var mystr$;
    var mystr2$;
    var mystr3$;
    var createMode%;
    
    if DlgValue(2) = 1 then
        createMode% := 1;  'generate stimuli
    else
        createMode% := 0;  'load stimuli
    endif;
    
    ' Fetch parameters from registry    
    
    
    ' Generate the dialog
    
    DlgCreate("OneStimDiscrim Experiment ADD Dialog", 62, 10);
    DlgString(1,40,100,"a-zA-Z0-9",26,1);
    DlgText("Name of New Experiment",2,1);
    if createMode% = 0 then
        DlgButton(recSelectStimFileButton%,   "S1/S2 Stim/Cal File", RecSelectStimFile%,2,2);
    else
        DlgButton(recSelectStimFileButton%,   "S1/S2 Stim File", RecSelectStimFile%,2,2);
    endif
    DlgString(2,40,200,"",26,2);  'for visual confirmation of selected stim file
    DlgButton(recSelectTrialsFileButton%, "    Trials File   ", RecSelectTrialsFile%,2,3);
    DlgString(3,40,200,"",26,3);  'for visual confirmation of selected trials file

    
    
    ' Show the dialog. 
    i%:=DlgShow(mystr$,mystr2$,mystr3$);
    
    
    ' If user hit OK then add new experiment 
	if i% = 1 then
        'reload parameters
        if createMode% = 0 then
            RecOneStimDiscrimExpListLoadGetParams(recOneStimDiscrimExpNameLoad$[],recOneStimDiscrimStimcalNameLoad$[],recOneStimDiscrimTrialsNameLoad$[]);
            'find first empty slot
            j% := 0;
            k% := -1;
            while j% < recOneStimDiscrimNumExps% do
                if recOneStimDiscrimExpNameLoad$[j%] = "" then
                    k% := j%;  'k% holds index of first empty slot
                    j% := recOneStimDiscrimNumExps%;
                endif;
                j%+=1;
            wend
            'Return if all slots are full
            if k% = -1 then
                Message("All " + Str$(recOneStimDiscrimNumExps%) + " slots are full!  You must delete an experiment!");
                return 1;
            endif;
            'Otherwise place values 
            recOneStimDiscrimExpNameLoad$[k%] := mystr$;
            recOneStimDiscrimStimcalNameLoad$[k%] := mystr2$;
            recOneStimDiscrimTrialsNameLoad$[k%] := mystr3$;
            'And save them
            RecOneStimDiscrimExpListLoadSaveParams(recOneStimDiscrimExpNameLoad$[],recOneStimDiscrimStimcalNameLoad$[],recOneStimDiscrimTrialsNameLoad$[]);
        else
            RecOneStimDiscrimExpListGenGetParams(recOneStimDiscrimExpNameGen$[],recOneStimDiscrimStimNameGen$[],recOneStimDiscrimTrialsNameGen$[]);
            'find first empty slot
            j% := 0;
            k% := -1;
            while j% < recOneStimDiscrimNumExps% do
                if recOneStimDiscrimExpNameGen$[j%] = "" then
                    k% := j%;  'k% holds index of first empty slot
                    j% := recOneStimDiscrimNumExps%;
                endif;
                j%+=1;
            wend
            'Return if all slots are full
            if k% = -1 then
                Message("All " + Str$(recOneStimDiscrimNumExps%) + " slots are full!  You must delete an experiment!");
                return 1;
            endif;
            'Otherwise place values 
            recOneStimDiscrimExpNameGen$[k%] := mystr$;
            recOneStimDiscrimStimNameGen$[k%] := mystr2$;
            recOneStimDiscrimTrialsNameGen$[k%] := mystr3$;
            'And save them
            RecOneStimDiscrimExpListGenSaveParams(recOneStimDiscrimExpNameGen$[],recOneStimDiscrimStimNameGen$[],recOneStimDiscrimTrialsNameGen$[]);
        endif;
        
        status% := 0;  'close the calling dialog - necessary to refresh list in OneStimDiscrimDialog
    else
        status% := 1;
    endif
    
	return status%;

end;

'===== End RecOneStimDiscrimAddExp =====
'
'



'
'
'===== RecOneStimDiscrimDeleteExp =====

'This is a dialog that comes up to allow deleting "experiments" from the AMDisc dialog
func RecOneStimDiscrimDeleteExp%()

    var i%;
    var j%;
    var status% := 0;
    var mystr$[recOneStimDiscrimNumExps%];
    var mystr2$[recOneStimDiscrimNumExps%];
    var mystr3$[recOneStimDiscrimNumExps%];
    var sli%;
    var createMode%;
    
    if DlgValue(2) = 1 then
        createMode% := 1;  'generate stimuli
    else
        createMode% := 0;  'load stimuli
    endif;
    
    ' Fetch parameters from registry  
    if createMode% = 0 then
        RecOneStimDiscrimExpListLoadGetParams(mystr$[],mystr2$[],mystr3$[]);
    else
        RecOneStimDiscrimExpListGenGetParams(mystr$[],mystr2$[],mystr3$[]);
    endif;
    
    
    ' Generate the dialog
    
    DlgCreate("OneStimDiscrim Experiment DELETE Dialog", 62, 10);
    DlgText("Select Experiment to Delete",2,1);
    DlgList(1,27,mystr$,recOneStimDiscrimNumExps%,28,1);

    ' Show the dialog. 
    i%:=DlgShow(sli%);
    
    ' If user hit OK then save parameters (and return 1). 
	if i% = 1 then
        'Remove experiment that has been selected and move everything up one
        if createMode% = 0 then
            if sli% < recOneStimDiscrimNumExps%-1 then  'Without this "if", would crash if asked to remove final entry
                for j% := sli% to recOneStimDiscrimNumExps%-2 do
                    mystr$[j%] := mystr$[j%+1];
                    mystr2$[j%] := mystr2$[j%+1];
                    mystr3$[j%] := mystr3$[j%+1];
                next;
            endif;
            'Clear the final experiment slot, this is the only part to execute if asked to remove final entry
            mystr$[recOneStimDiscrimNumExps%-1] := "";
            mystr2$[recOneStimDiscrimNumExps%-1] := "";
            mystr3$[recOneStimDiscrimNumExps%-1] := "";
            
            'Save the new values
            RecOneStimDiscrimExpListLoadSaveParams(mystr$[],mystr2$[],mystr3$[]);
        else
            if sli% < recOneStimDiscrimNumExps%-1 then  'Without this "if", would crash if asked to remove final entry
                for j% := sli% to recOneStimDiscrimNumExps%-2 do
                    mystr$[j%] := mystr$[j%+1];
                    mystr2$[j%] := mystr2$[j%+1];
                    mystr3$[j%] := mystr3$[j%+1];
                next;
            endif;
            'Clear the final experiment slot, this is the only part to execute if asked to remove final entry
            mystr$[recOneStimDiscrimNumExps%-1] := "";
            mystr2$[recOneStimDiscrimNumExps%-1] := "";
            mystr3$[recOneStimDiscrimNumExps%-1] := "";
            
            'Save the new values
            RecOneStimDiscrimExpListGenSaveParams(mystr$[],mystr2$[],mystr3$[]);
        endif;
        
        
        status% := 0;  'Close the calling dialog
    else
        status% := 1;
    endif
    
	return status%;
    
end;

'===== End RecOneStimDiscrimDeleteExp =====
'
'




'
'
'===== RecOneStimDiscrimReportExp =====

'This function will report (both to a message box and to the log file) the full path of the stim/trials files
'for the current experiment - it's just a simple function that we need rather than continually diving into the
'registry to figure this out.
'Note that the report version of the code will base its output on the value of the forced choice checkbox automatically,
'no need for a second GNG version of the function
func RecOneStimDiscrimReportExp%()
    
    var currIndex%;
    var ssExpName$;  'variable to hold a "split string" - we don't want to have our strings be too long because they don't fit on the Message dialog
    var ssStimcalName$;
    var ssTrialsName$;
    
    docase
    case DlgValue(2) = 1 and DlgValue(1) = 1 then  'FC, gen
        currIndex% := DlgValue(3);
        RecOneStimDiscrimExpListGenGetParams(recExpName$[],recStimcalName$[],recTrialsName$[]);
    case DlgValue(2) = 0 and DlgValue(1) = 1 then  'FC, load
        currIndex% := DlgValue(4);
        RecOneStimDiscrimExpListLoadGetParams(recExpName$[],recStimcalName$[],recTrialsName$[]);
    case DlgValue(2) = 1 and DlgValue(1) = 0 then  'GNG, gen
        currIndex% := DlgValue(5);
        RecOneStimDiscrimGNGExpListGenGetParams(recExpName$[],recStimcalName$[],recTrialsName$[]);
    case DlgValue(2) = 0 and DlgValue(1) = 0 then  'GNG, load
        currIndex% := DlgValue(6);
        RecOneStimDiscrimGNGExpListLoadGetParams(recExpName$[],recStimcalName$[],recTrialsName$[]);
    endcase;  
    
    'report
    ssExpName$ := SplitString$(recExpName$[currIndex%],"slash","\n",60);
    ssStimcalName$ := SplitString$(recStimcalName$[currIndex%],"slash","\n",60);
    ssTrialsName$ := SplitString$(recTrialsName$[currIndex%],"slash","\n",60);
    if DlgValue(2) = 1 then
        printlog("\nExperiment name: %s\nStim(cal) file: %s\nTrials file: %s\n\n",recExpName$[currIndex%],recStimcalName$[currIndex%],recTrialsName$[currIndex%]);
        Message("Experiment name: %s\nStim(cal) file: %s\nTrials file: %s",ssExpName$,ssStimcalName$,ssTrialsName$);
    else
        printlog("\nExperiment name: %s\nStim(cal) file: %s\nTrials file: %s\n\n",recExpName$[currIndex%],recStimcalName$[currIndex%],recTrialsName$[currIndex%]);
        Message("Experiment name: %s\nStim(cal) file: %s\nTrials file: %s",recExpName$[currIndex%],recStimcalName$[currIndex%],recTrialsName$[currIndex%]);
    endif
    

return 1

end;

'===== End RecOneStimDiscrimReportExp =====
'
'









'
'
'===== RecOneStimDiscrimGNGAddExp =====

'This is a dialog that comes up to allow adding "experiments" to the OneStimDiscrim dialog
'Please note that in order to reset the list box in the calling dialog, we have to actually
'CLOSE the calling dialog and reopen it.  That's gotta be manual.
func RecOneStimDiscrimGNGAddExp%()
    
    var i%;
    var j%;
    var k%;
    var status% := 0;
    var mystr$;
    var mystr2$;
    var mystr3$;
    var createMode%;
    
    if DlgValue(2) = 1 then
        createMode% := 1;  'generate stimuli
    else
        createMode% := 0;  'load stimuli
    endif;
    
    ' Fetch parameters from registry    
    
    
    ' Generate the dialog
    
    DlgCreate("OneStimDiscrim GNG Experiment ADD Dialog", 62, 10);
    DlgString(1,40,100,"a-zA-Z0-9",26,1);
    DlgText("Name of New Experiment",2,1);
    if createMode% = 0 then
        DlgButton(recSelectStimFileButton%,   "S1/S2 Stim/Cal File", RecSelectStimFile%,2,2);
    else
        DlgButton(recSelectStimFileButton%,   "S1/S2 Stim File", RecSelectStimFile%,2,2);
    endif
    DlgString(2,40,200,"",26,2);  'for visual confirmation of selected stim file
    DlgButton(recSelectTrialsFileButton%, "    Trials File   ", RecSelectTrialsFile%,2,3);
    DlgString(3,40,200,"",26,3);  'for visual confirmation of selected trials file

    
    
    ' Show the dialog. 
    i%:=DlgShow(mystr$,mystr2$,mystr3$);
    
    
    ' If user hit OK then add new experiment 
	if i% = 1 then
        'reload parameters
        if createMode% = 0 then
            RecOneStimDiscrimGNGExpListLoadGetParams(recOneStimDiscrimGNGExpNameLoad$[],recOneStimDiscrimGNGStimcalNameLoad$[],recOneStimDiscrimGNGTrialsNameLoad$[]);
            'find first empty slot
            j% := 0;
            k% := -1;
            while j% < recOneStimDiscrimGNGNumExps% do
                if recOneStimDiscrimGNGExpNameLoad$[j%] = "" then
                    k% := j%;  'k% holds index of first empty slot
                    j% := recOneStimDiscrimGNGNumExps%;
                endif;
                j%+=1;
            wend
            'Return if all slots are full
            if k% = -1 then
                Message("All " + Str$(recOneStimDiscrimGNGNumExps%) + " slots are full!  You must delete an experiment!");
                return 1;
            endif;
            'Otherwise place values 
            recOneStimDiscrimGNGExpNameLoad$[k%] := mystr$;
            recOneStimDiscrimGNGStimcalNameLoad$[k%] := mystr2$;
            recOneStimDiscrimGNGTrialsNameLoad$[k%] := mystr3$;
            'And save them
            RecOneStimDiscrimGNGExpListLoadSaveParams(recOneStimDiscrimGNGExpNameLoad$[],recOneStimDiscrimGNGStimcalNameLoad$[],recOneStimDiscrimGNGTrialsNameLoad$[]);
        else
            RecOneStimDiscrimGNGExpListGenGetParams(recOneStimDiscrimGNGExpNameGen$[],recOneStimDiscrimGNGStimNameGen$[],recOneStimDiscrimGNGTrialsNameGen$[]);
            'find first empty slot
            j% := 0;
            k% := -1;
            while j% < recOneStimDiscrimGNGNumExps% do
                if recOneStimDiscrimGNGExpNameGen$[j%] = "" then
                    k% := j%;  'k% holds index of first empty slot
                    j% := recOneStimDiscrimGNGNumExps%;
                endif;
                j%+=1;
            wend
            'Return if all slots are full
            if k% = -1 then
                Message("All " + Str$(recOneStimDiscrimGNGNumExps%) + " slots are full!  You must delete an experiment!");
                return 1;
            endif;
            'Otherwise place values 
            recOneStimDiscrimGNGExpNameGen$[k%] := mystr$;
            recOneStimDiscrimGNGStimNameGen$[k%] := mystr2$;
            recOneStimDiscrimGNGTrialsNameGen$[k%] := mystr3$;
            'And save them
            RecOneStimDiscrimGNGExpListGenSaveParams(recOneStimDiscrimGNGExpNameGen$[],recOneStimDiscrimGNGStimNameGen$[],recOneStimDiscrimGNGTrialsNameGen$[]);
        endif;
        
        status% := 0;  'close the calling dialog - necessary to refresh list in OneStimDiscrimDialog
    else
        status% := 1;
    endif
    
	return status%;

end;

'===== End RecOneStimDiscrimAddExp =====
'
'



'
'
'===== RecOneStimDiscrimGNGDeleteExp =====

'This is a dialog that comes up to allow deleting "experiments" from the OneStimDiscrim dialog
func RecOneStimDiscrimGNGDeleteExp%()

    var i%;
    var j%;
    var status% := 0;
    var mystr$[recOneStimDiscrimGNGNumExps%];
    var mystr2$[recOneStimDiscrimGNGNumExps%];
    var mystr3$[recOneStimDiscrimGNGNumExps%];
    var sli%;
    var createMode%;
    
    if DlgValue(2) = 1 then
        createMode% := 1;  'generate stimuli
    else
        createMode% := 0;  'load stimuli
    endif;
    
    ' Fetch parameters from registry  
    if createMode% = 0 then
        RecOneStimDiscrimGNGExpListLoadGetParams(mystr$[],mystr2$[],mystr3$[]);
    else
        RecOneStimDiscrimGNGExpListGenGetParams(mystr$[],mystr2$[],mystr3$[]);
    endif;
    
    
    ' Generate the dialog
    
    DlgCreate("OneStimDiscrim GNG Experiment DELETE Dialog", 62, 10);
    DlgText("Select Experiment to Delete",2,1);
    DlgList(1,27,mystr$,recOneStimDiscrimNumExps%,28,1);

    ' Show the dialog. 
    i%:=DlgShow(sli%);
    
    ' If user hit OK then save parameters (and return 1). 
	if i% = 1 then
        'Remove experiment that has been selected and move everything up one
        if createMode% = 0 then
            if sli% < recOneStimDiscrimGNGNumExps%-1 then  'Without this "if", would crash if asked to remove final entry
                for j% := sli% to recOneStimDiscrimGNGNumExps%-2 do
                    mystr$[j%] := mystr$[j%+1];
                    mystr2$[j%] := mystr2$[j%+1];
                    mystr3$[j%] := mystr3$[j%+1];
                next;
            endif;
            'Clear the final experiment slot, this is the only part to execute if asked to remove final entry
            mystr$[recOneStimDiscrimGNGNumExps%-1] := "";
            mystr2$[recOneStimDiscrimGNGNumExps%-1] := "";
            mystr3$[recOneStimDiscrimGNGNumExps%-1] := "";
            
            'Save the new values
            RecOneStimDiscrimGNGExpListLoadSaveParams(mystr$[],mystr2$[],mystr3$[]);
        else
            if sli% < recOneStimDiscrimGNGNumExps%-1 then  'Without this "if", would crash if asked to remove final entry
                for j% := sli% to recOneStimDiscrimGNGNumExps%-2 do
                    mystr$[j%] := mystr$[j%+1];
                    mystr2$[j%] := mystr2$[j%+1];
                    mystr3$[j%] := mystr3$[j%+1];
                next;
            endif;
            'Clear the final experiment slot, this is the only part to execute if asked to remove final entry
            mystr$[recOneStimDiscrimGNGNumExps%-1] := "";
            mystr2$[recOneStimDiscrimGNGNumExps%-1] := "";
            mystr3$[recOneStimDiscrimGNGNumExps%-1] := "";
            
            'Save the new values
            RecOneStimDiscrimGNGExpListGenSaveParams(mystr$[],mystr2$[],mystr3$[]);
        endif;
        
        
        status% := 0;  'Close the calling dialog
    else
        status% := 1;
    endif
    
	return status%;
    
end;

'===== End RecOneStimDiscrimGNGDeleteExp =====
'
'








'================================================================================================
'End Add/Delete Experiment Functions
'
'



'
'
'Begin Experiment List Load/Get Params - from registry
'================================================================================================




'
'
'===== RecAMDiscExpListLoadGetParams =====

'Fetch experiment lists from the registry for AMDisc, loading stim, experiments
proc RecAMDiscExpListLoadGetParams(&expName$[],&stimcalName$[],&trialsName$[])
	var key$;
    var i%;
    key$:="Reclab\\AMDiscExpListLoadParam";
    
    for i% := 0 to recAMDiscNumExps%-1 do
        expName$[i%] := GetStringRegistryValue$(key$, "ExpName"+Str$(i%), expName$[i%]);
        stimcalName$[i%] := GetStringRegistryValue$(key$, "StimcalName"+Str$(i%), stimcalName$[i%]);
        trialsName$[i%] := GetStringRegistryValue$(key$, "TrialsName"+Str$(i%), trialsName$[i%]);
    next;
     
	return;
end

'===== End RecAMDiscExpListLoadGetParams =====
'
'




'
'
'===== RecAMDiscExpListGenGetParams =====

'Fetch experiment lists from the registry for AMDisc, generating stim, experiments
proc RecAMDiscExpListGenGetParams(&expName$[],&stimcalName$[],&trialsName$[])
	var key$;
    var i%;
    key$:="Reclab\\AMDiscExpListGenParam";
    
    for i% := 0 to recAMDiscNumExps%-1 do
        expName$[i%] := GetStringRegistryValue$(key$, "ExpName"+Str$(i%), expName$[i%]);
        stimcalName$[i%] := GetStringRegistryValue$(key$, "StimcalName"+Str$(i%), stimcalName$[i%]);
        trialsName$[i%] := GetStringRegistryValue$(key$, "TrialsName"+Str$(i%), trialsName$[i%]);
    next;
	
	return;
end

'===== End RecAMDiscExpListGenGetParams =====
'
'





'
'
'===== RecAMDiscExpListLoadSaveParams =====

'Save experiment lists to the registry for AMDisc, loading stim, experiments
proc RecAMDiscExpListLoadSaveParams(expName$[],stimcalName$[],trialsName$[])
	var key$;
    var i%;
    key$:="Reclab\\AMDiscExpListLoadParam";
    
    for i% := 0 to recAMDiscNumExps%-1 do
        SetStringRegistryValue(key$, "ExpName"+Str$(i%), expName$[i%]);
        SetStringRegistryValue(key$, "StimcalName"+Str$(i%), stimcalName$[i%]);
        SetStringRegistryValue(key$, "TrialsName"+Str$(i%), trialsName$[i%]);
    next;
     
	return;
end

'===== End RecAMDiscExpListLoadSaveParams =====
'
'




'
'
'===== RecAMDiscExpListGenSaveParams =====

'Save experiment lists to the registry for AMDisc, loading stim, experiments
proc RecAMDiscExpListGenSaveParams(expName$[],stimcalName$[],trialsName$[])
	var key$;
    var i%;
    key$:="Reclab\\AMDiscExpListGenParam";
    
    for i% := 0 to recAMDiscNumExps%-1 do
        SetStringRegistryValue(key$, "ExpName"+Str$(i%), expName$[i%]);
        SetStringRegistryValue(key$, "StimcalName"+Str$(i%), stimcalName$[i%]);
        SetStringRegistryValue(key$, "TrialsName"+Str$(i%), trialsName$[i%]);
    next;
     
	return;
end

'===== End RecAMDiscExpListGenSaveParams =====
'
'




'
'
'===== RecCharExpListLoadFRAGetParams =====

'Fetch experiment lists from the registry for AMDisc, loading stim, experiments
proc RecCharExpListLoadFRAGetParams(&expName$[],&stimcalName$[],&trialsName$[])
	var key$;
    var i%;
    key$:="Reclab\\FRAExpListLoadParam";
    
    'Note that the file locations for StimCal and Trials files are not the normal default path
    'Note that this really doesn't seem like a sensible thing to do, given that the function that
    'selects the file location via the GUI saves a full-path, not partial-path location in the variable
    'that is being saved in the registry.  This path concatenation should probably be done away with
    'ASARP, with the caveat that apparently all the currently defined FRA experiments will have to be
    're-done in the dialog box.
    for i% := 0 to recCharNumExps%-1 do
        expName$[i%] := GetStringRegistryValue$(key$, "ExpName"+Str$(i%), expName$[i%]);
        stimcalName$[i%] := GetStringRegistryValue$(key$, "StimcalName"+Str$(i%), stimcalName$[i%]);
        trialsName$[i%] := GetStringRegistryValue$(key$, "TrialsName"+Str$(i%), trialsName$[i%]);
    next;

    PrintLog("RecCharExpListLoadFRAGetParams\n");
     
	return;
end

'===== End RecCharExpListLoadFRAGetParams =====
'
'


'
'
'===== RecCharExpListLoadSigNoiseGetParams =====

'Fetch experiment lists from the registry for Loaded SigNoise, loading stim, experiments
proc RecCharExpListLoadSigNoiseGetParams(&expName$[],&stimcalName$[],&trialsName$[])
	var key$;
    var i%;
    key$:="Reclab\\SigNoiseExpListLoadParam";
    
    for i% := 0 to recCharNumExps%-1 do
        expName$[i%] := GetStringRegistryValue$(key$, "ExpName"+Str$(i%), expName$[i%]);
        stimcalName$[i%] := GetStringRegistryValue$(key$, "StimcalName"+Str$(i%), stimcalName$[i%]);
        trialsName$[i%] := GetStringRegistryValue$(key$, "TrialsName"+Str$(i%), trialsName$[i%]);
    next;

    PrintLog("RecCharExpListLoadSigNoiseGetParams\n");
     
	return;
end

'===== End RecCharExpListLoadSigNoiseGetParams =====
'
'

'
'
'===== RecCharExpListGenFRAGetParams =====

'Fetch experiment lists from the registry for FRA, generating stim, experiments
proc RecCharExpListGenFRAGetParams(&expName$[],&stimcalName$[],&trialsName$[])
	var key$;
    var i%;
    key$:="Reclab\\FRAExpListGenParam";  'Note function name does not match registry key as function name has been updated
    
    for i% := 0 to recCharNumExps%-1 do
        expName$[i%] := GetStringRegistryValue$(key$, "ExpName"+Str$(i%), expName$[i%]);
        stimcalName$[i%] := GetStringRegistryValue$(key$, "StimcalName"+Str$(i%), stimcalName$[i%]);
        trialsName$[i%] := GetStringRegistryValue$(key$, "TrialsName"+Str$(i%), trialsName$[i%]);
    next;
	
	return;
end

'===== End RecCharExpListGenFRAGetParams =====
'
'



'
'
'===== RecCharExpListGenSigNoiseGetParams =====

'Fetch experiment lists from the registry for SigNoise, generating stim, experiments
proc RecCharExpListGenSigNoiseGetParams(&expName$[],&stimcalName$[],&trialsName$[])
	var key$;
    var i%;
    key$:="Reclab\\CZExpListGenSigNoiseParam";  'This is not the same convention as the others, but it has been used, so it stays
    
    for i% := 0 to recCharNumExps%-1 do
        expName$[i%] := GetStringRegistryValue$(key$, "ExpName"+Str$(i%), expName$[i%]);
        stimcalName$[i%] := GetStringRegistryValue$(key$, "StimcalName"+Str$(i%), stimcalName$[i%]);
        trialsName$[i%] := GetStringRegistryValue$(key$, "TrialsName"+Str$(i%), trialsName$[i%]);
    next;
	
	return;
end

'===== End RecCharExpListGenSigNoiseGetParams =====
'
'


'
'
'===== RecCharExpListLoadArbStimGetParams =====

'Fetch experiment lists from the registry for Arbitrary stimulus characterization, loading stim, experiments
proc RecCharExpListLoadArbStimGetParams(&expName$[],&stimcalName$[],&trialsName$[],&expPrefix$[])
	var key$;
    var i%;
    key$:="Reclab\\ArbStimExpListLoadParam";
    
    'Note that the file locations for StimCal and Trials files are not the normal default path
    'Note that this really doesn't seem like a sensible thing to do, given that the function that
    'selects the file location via the GUI saves a full-path, not partial-path location in the variable
    'that is being saved in the registry.  This path concatenation should probably be done away with
    'ASARP, with the caveat that apparently all the currently defined FRA experiments will have to be
    're-done in the dialog box.
    for i% := 0 to recCharNumExps%-1 do
        expName$[i%] := GetStringRegistryValue$(key$, "ExpName"+Str$(i%), expName$[i%]);
        stimcalName$[i%] := GetStringRegistryValue$(key$, "StimcalName"+Str$(i%), stimcalName$[i%]);
        trialsName$[i%] := GetStringRegistryValue$(key$, "TrialsName"+Str$(i%), trialsName$[i%]);
        expPrefix$[i%] := GetStringRegistryValue$(key$, "ExpPrefix"+Str$(i%), expPrefix$[i%]);
    next;

    PrintLog("RecCharExpListLoadArbStimGetParams\n");
     
	return;
end

'===== End RecCharExpListLoadArbStimGetParams =====
'
'



'
'
'===== RecCharExpListLoadFRASaveParams =====

'Save experiment lists to the registry for AMDisc, loading stim, experiments
proc RecCharExpListLoadFRASaveParams(expName$[],stimcalName$[],trialsName$[])
	var key$;
    var i%;
    key$:="Reclab\\FRAExpListLoadParam";
    
    for i% := 0 to recCharNumExps%-1 do
        SetStringRegistryValue(key$, "ExpName"+Str$(i%), expName$[i%]);
        SetStringRegistryValue(key$, "StimcalName"+Str$(i%), stimcalName$[i%]);
        SetStringRegistryValue(key$, "TrialsName"+Str$(i%), trialsName$[i%]);
    next;
     
	return;
end

'===== End RecCharExpListLoadFRASaveParams =====
'
'



'
'
'===== RecCharExpListLoadSigNoiseSaveParams =====

'Save experiment lists to the registry for AMDisc, loading stim, experiments
proc RecCharExpListLoadSigNoiseSaveParams(expName$[],stimcalName$[],trialsName$[])
	var key$;
    var i%;
    key$:="Reclab\\SigNoiseExpListLoadParam";
    
    for i% := 0 to recCharNumExps%-1 do
        SetStringRegistryValue(key$, "ExpName"+Str$(i%), expName$[i%]);
        SetStringRegistryValue(key$, "StimcalName"+Str$(i%), stimcalName$[i%]);
        SetStringRegistryValue(key$, "TrialsName"+Str$(i%), trialsName$[i%]);
    next;
     
	return;
end

'===== End RecCharExpListLoadSigNoiseSaveParams =====
'
'



'
'
'===== RecCharExpListGenFRASaveParams =====

'Save experiment lists to the registry for AMDisc, loading stim, experiments
proc RecCharExpListGenFRASaveParams(expName$[],stimcalName$[],trialsName$[])
	var key$;
    var i%;
    key$:="Reclab\\FRAExpListGenParam";  'Note function name does not match registry key as function name has been updated
    
    for i% := 0 to recCharNumExps%-1 do
        SetStringRegistryValue(key$, "ExpName"+Str$(i%), expName$[i%]);
        SetStringRegistryValue(key$, "StimcalName"+Str$(i%), stimcalName$[i%]);
        SetStringRegistryValue(key$, "TrialsName"+Str$(i%), trialsName$[i%]);
    next;
     
	return;
end

'===== End RecCharExpListGenFRASaveParams =====
'
'



'
'
'===== RecCharExpListGenSigNoiseSaveParams =====

'Save experiment lists to the registry for AMDisc, loading stim, experiments
proc RecCharExpListGenSigNoiseSaveParams(expName$[],stimcalName$[],trialsName$[])
	var key$;
    var i%;
    key$:="Reclab\\CZExpListGenSigNoiseParam";
    
    for i% := 0 to recCharNumExps%-1 do
        SetStringRegistryValue(key$, "ExpName"+Str$(i%), expName$[i%]);
        SetStringRegistryValue(key$, "StimcalName"+Str$(i%), stimcalName$[i%]);
        SetStringRegistryValue(key$, "TrialsName"+Str$(i%), trialsName$[i%]);
    next;
     
	return;
end

'===== End RecCharExpListGenSigNoiseSaveParams =====
'
'


'
'
'===== RecCharExpListLoadArbStimSaveParams =====

'Save experiment lists to the registry for AMDisc, loading stim, experiments
proc RecCharExpListLoadArbStimSaveParams(expName$[],stimcalName$[],trialsName$[],expPrefix$[])
	var key$;
    var i%;
    key$:="Reclab\\ArbStimExpListLoadParam";
    
    for i% := 0 to recCharNumExps%-1 do
        SetStringRegistryValue(key$, "ExpName"+Str$(i%), expName$[i%]);
        SetStringRegistryValue(key$, "StimcalName"+Str$(i%), stimcalName$[i%]);
        SetStringRegistryValue(key$, "TrialsName"+Str$(i%), trialsName$[i%]);
        SetStringRegistryValue(key$, "ExpPrefix"+Str$(i%), expPrefix$[i%]);
    next;
     
	return;
end

'===== End RecCharExpListLoadArbStimSaveParams =====
'
'


'
'
'===== RecSpaceDisExpListLoadGetParams =====

'Fetch experiment lists from the registry for SpaceDis, loading stim, experiments
proc RecSpaceDisExpListLoadGetParams(&expName$[],&stimcalName$[],&trialsName$[])
	var key$;
    var i%;
    key$:="Reclab\\SpaceDisExpListLoadParam";
    
    for i% := 0 to recSpaceDisNumExps%-1 do
        expName$[i%] := GetStringRegistryValue$(key$, "ExpName"+Str$(i%), expName$[i%]);
        stimcalName$[i%] := GetStringRegistryValue$(key$, "StimcalName"+Str$(i%), stimcalName$[i%]);
        trialsName$[i%] := GetStringRegistryValue$(key$, "TrialsName"+Str$(i%), trialsName$[i%]);
    next;
     
	return;
end

'===== End RecSpaceDisExpListLoadGetParams =====
'
'




'
'
'===== RecSpaceDisExpListGenGetParams =====

'Fetch experiment lists from the registry for SpaceDis, generating stim, experiments
proc RecSpaceDisExpListGenGetParams(&expName$[],&stimcalName$[],&trialsName$[])
	var key$;
    var i%;
    key$:="Reclab\\SpaceDisExpListGenParam";
    
    for i% := 0 to recSpaceDisNumExps%-1 do
        expName$[i%] := GetStringRegistryValue$(key$, "ExpName"+Str$(i%), expName$[i%]);
        stimcalName$[i%] := GetStringRegistryValue$(key$, "StimcalName"+Str$(i%), stimcalName$[i%]);
        trialsName$[i%] := GetStringRegistryValue$(key$, "TrialsName"+Str$(i%), trialsName$[i%]);
    next;
     
	return;
end

'===== End RecSpaceDisExpListGenGetParams =====
'
'





'
'
'===== RecSpaceDisExpListLoadSaveParams =====

'Save experiment lists to the registry for SpaceDis, loading stim, experiments
proc RecSpaceDisExpListLoadSaveParams(expName$[],stimcalName$[],trialsName$[])
	var key$;
    var i%;
    key$:="Reclab\\SpaceDisExpListLoadParam";
    
    for i% := 0 to recSpaceDisNumExps%-1 do
        SetStringRegistryValue(key$, "ExpName"+Str$(i%), expName$[i%]);
        SetStringRegistryValue(key$, "StimcalName"+Str$(i%), stimcalName$[i%]);
        SetStringRegistryValue(key$, "TrialsName"+Str$(i%), trialsName$[i%]);
    next;
     
	return;
end

'===== End RecSpaceDisExpListLoadSaveParams =====
'
'




'
'
'===== RecSpaceDisExpListGenSaveParams =====

'Save experiment lists to the registry for SpaceDis, loading stim, experiments
proc RecSpaceDisExpListGenSaveParams(expName$[],stimcalName$[],trialsName$[])
	var key$;
    var i%;
    key$:="Reclab\\SpaceDisExpListGenParam";
    
    for i% := 0 to recSpaceDisNumExps%-1 do
        SetStringRegistryValue(key$, "ExpName"+Str$(i%), expName$[i%]);
        SetStringRegistryValue(key$, "StimcalName"+Str$(i%), stimcalName$[i%]);
        SetStringRegistryValue(key$, "TrialsName"+Str$(i%), trialsName$[i%]);
    next;
     
	return;
end

'===== End RecSpaceDisExpListGenSaveParams =====
'
'


'
'
'===== RecStereoDisExpListLoadGetParams =====

'Fetch experiment lists from the registry for StereoDis, loading stim, experiments
proc RecStereoDisExpListLoadGetParams(&expName$[],&stimcalName$[],&trialsName$[],&stimcalDistName$[])
	var key$;
    var i%;
    key$:="Reclab\\HumanFCExpListLoadParam";  'renamed experiment from HumanFC to StereoDis, just keep old name for registry, it's easier
    
    for i% := 0 to recStereoDisNumExps%-1 do
        expName$[i%] := GetStringRegistryValue$(key$, "ExpName"+Str$(i%), expName$[i%]);
        stimcalName$[i%] := GetStringRegistryValue$(key$, "StimcalName"+Str$(i%), stimcalName$[i%]);
        stimcalDistName$[i%] := GetStringRegistryValue$(key$, "StimcalDistName"+Str$(i%), stimcalDistName$[i%]);
        trialsName$[i%] := GetStringRegistryValue$(key$, "TrialsName"+Str$(i%), trialsName$[i%]);
    next;
     
	return;
end

'===== End RecStereoDisExpListLoadGetParams =====
'
'

'
'
'===== RecStereoDisExpListLoadSaveParams =====

'Save experiment lists to the registry for StereoDis, loading stim, experiments
proc RecStereoDisExpListLoadSaveParams(expName$[],stimcalName$[],trialsName$[],stimcalDistName$[])
	var key$;
    var i%;
    key$:="Reclab\\HumanFCExpListLoadParam";  'renamed experiment from HumanFC to StereoDis, just keep old name for registry, it's easier
    
    for i% := 0 to recStereoDisNumExps%-1 do
        SetStringRegistryValue(key$, "ExpName"+Str$(i%), expName$[i%]);
        SetStringRegistryValue(key$, "StimcalName"+Str$(i%), stimcalName$[i%]);
        SetStringRegistryValue(key$, "StimcalDistName"+Str$(i%), stimcalDistName$[i%]);
        SetStringRegistryValue(key$, "TrialsName"+Str$(i%), trialsName$[i%]);
    next;
     
	return;
end

'===== End RecStereoDisExpListLoadSaveParams =====
'
'



'
'
'===== RecStereoDisExpListGenGetParams =====

'Fetch experiment lists from the registry for StereoDis, loading stim, experiments
proc RecStereoDisExpListGenGetParams(&expName$[],&stimName$[],&trialsName$[])
	var key$;
    var i%;
    key$:="Reclab\\HumanFCExpListGenParam";  'renamed experiment from HumanFC to StereoDis, just keep old name for registry, it's easier
    
    for i% := 0 to recStereoDisNumExps%-1 do
        expName$[i%] := GetStringRegistryValue$(key$, "ExpName"+Str$(i%), expName$[i%]);
        stimName$[i%] := GetStringRegistryValue$(key$, "StimName"+Str$(i%), stimName$[i%]);
        trialsName$[i%] := GetStringRegistryValue$(key$, "TrialsName"+Str$(i%), trialsName$[i%]);
    next;
     
	return;
end

'===== End RecStereoDisExpListGenGetParams =====
'
'

'
'
'===== RecStereoDisExpListGenSaveParams =====

'Save experiment lists to the registry for StereoDis, loading stim, experiments
proc RecStereoDisExpListGenSaveParams(expName$[],stimName$[],trialsName$[])
	var key$;
    var i%;
    key$:="Reclab\\HumanFCExpListGenParam";  'renamed experiment from HumanFC to StereoDis, just keep old name for registry, it's easier
    
    for i% := 0 to recStereoDisNumExps%-1 do
        SetStringRegistryValue(key$, "ExpName"+Str$(i%), expName$[i%]);
        SetStringRegistryValue(key$, "StimName"+Str$(i%), stimName$[i%]);
        SetStringRegistryValue(key$, "TrialsName"+Str$(i%), trialsName$[i%]);
    next;
     
	return;
end

'===== End RecStereoDisExpListGenSaveParams =====
'
'





'
'
'===== RecStereoDisGNGExpListLoadGetParams =====

'Fetch experiment lists from the registry for StereoDis, loading stim, experiments
proc RecStereoDisGNGExpListLoadGetParams(&expName$[],&stimcalName$[],&trialsName$[],&stimcalDistName$[])
	var key$;
    var i%;
    key$:="Reclab\\StereoDisExpListLoadParam";  
    
    for i% := 0 to recStereoDisNumExps%-1 do
        expName$[i%] := GetStringRegistryValue$(key$, "ExpName"+Str$(i%), expName$[i%]);
        stimcalName$[i%] := GetStringRegistryValue$(key$, "StimcalName"+Str$(i%), stimcalName$[i%]);
        stimcalDistName$[i%] := GetStringRegistryValue$(key$, "StimcalDistName"+Str$(i%), stimcalDistName$[i%]);
        trialsName$[i%] := GetStringRegistryValue$(key$, "TrialsName"+Str$(i%), trialsName$[i%]);
    next;
     
	return;
end

'===== End RecStereoDisGNGExpListLoadGetParams =====
'
'

'
'
'===== RecStereoDisGNGExpListLoadSaveParams =====

'Save experiment lists to the registry for StereoDis, loading stim, experiments
proc RecStereoDisGNGExpListLoadSaveParams(expName$[],stimcalName$[],trialsName$[],stimcalDistName$[])
	var key$;
    var i%;
    key$:="Reclab\\StereoDisExpListLoadParam";  
    
    for i% := 0 to recStereoDisNumExps%-1 do
        SetStringRegistryValue(key$, "ExpName"+Str$(i%), expName$[i%]);
        SetStringRegistryValue(key$, "StimcalName"+Str$(i%), stimcalName$[i%]);
        SetStringRegistryValue(key$, "StimcalDistName"+Str$(i%), stimcalDistName$[i%]);
        SetStringRegistryValue(key$, "TrialsName"+Str$(i%), trialsName$[i%]);
    next;
     
	return;
end

'===== End RecStereoDisGNGExpListLoadSaveParams =====
'
'



'
'
'===== RecStereoDisGNGExpListGenGetParams =====

'Fetch experiment lists from the registry for StereoDis, loading stim, experiments
proc RecStereoDisGNGExpListGenGetParams(&expName$[],&stimName$[],&trialsName$[])
	var key$;
    var i%;
    key$:="Reclab\\StereoDisExpListGenParam";  
    
    for i% := 0 to recStereoDisNumExps%-1 do
        expName$[i%] := GetStringRegistryValue$(key$, "ExpName"+Str$(i%), expName$[i%]);
        stimName$[i%] := GetStringRegistryValue$(key$, "StimName"+Str$(i%), stimName$[i%]);
        trialsName$[i%] := GetStringRegistryValue$(key$, "TrialsName"+Str$(i%), trialsName$[i%]);
    next;
     
	return;
end

'===== End RecStereoDisGNGExpListGenGetParams =====
'
'

'
'
'===== RecStereoDisGNGExpListGenSaveParams =====

'Save experiment lists to the registry for StereoDis, loading stim, experiments
proc RecStereoDisGNGExpListGenSaveParams(expName$[],stimName$[],trialsName$[])
	var key$;
    var i%;
    key$:="Reclab\\StereoDisExpListGenParam";  
    
    for i% := 0 to recStereoDisNumExps%-1 do
        SetStringRegistryValue(key$, "ExpName"+Str$(i%), expName$[i%]);
        SetStringRegistryValue(key$, "StimName"+Str$(i%), stimName$[i%]);
        SetStringRegistryValue(key$, "TrialsName"+Str$(i%), trialsName$[i%]);
    next;
     
	return;
end

'===== End RecStereoDisGNGExpListGenSaveParams =====
'
'




'
'
'===== RecOneStimDiscrimExpListLoadGetParams =====

'Fetch experiment lists from the registry for OneStimDiscrim, loading stim, experiments
proc RecOneStimDiscrimExpListLoadGetParams(&expName$[],&stimcalName$[],&trialsName$[])
	var key$;
    var i%;
    key$:="Reclab\\OneStimDiscrimExpListLoadParam";
    
    for i% := 0 to recOneStimDiscrimNumExps%-1 do
        expName$[i%] := GetStringRegistryValue$(key$, "ExpName"+Str$(i%), expName$[i%]);
        stimcalName$[i%] := GetStringRegistryValue$(key$, "StimcalName"+Str$(i%), stimcalName$[i%]);
        trialsName$[i%] := GetStringRegistryValue$(key$, "TrialsName"+Str$(i%), trialsName$[i%]);
    next;
     
	return;
end

'===== End RecOneStimDiscrimExpListLoadGetParams =====
'
'

'
'
'===== RecOneStimDiscrimExpListLoadSaveParams =====

'Save experiment lists to the registry for OneStimDiscrim, loading stim, experiments
proc RecOneStimDiscrimExpListLoadSaveParams(expName$[],stimcalName$[],trialsName$[])
	var key$;
    var i%;
    key$:="Reclab\\OneStimDiscrimExpListLoadParam"; 
    
    for i% := 0 to recOneStimDiscrimNumExps%-1 do
        SetStringRegistryValue(key$, "ExpName"+Str$(i%), expName$[i%]);
        SetStringRegistryValue(key$, "StimcalName"+Str$(i%), stimcalName$[i%]);
        SetStringRegistryValue(key$, "TrialsName"+Str$(i%), trialsName$[i%]);
    next;
     
	return;
end

'===== End RecOneStimDiscrimExpListLoadSaveParams =====
'
'



'
'
'===== RecOneStimDiscrimExpListGenGetParams =====

'Fetch experiment lists from the registry for OneStimDiscrim, loading stim, experiments
proc RecOneStimDiscrimExpListGenGetParams(&expName$[],&stimName$[],&trialsName$[])
	var key$;
    var i%;
    key$:="Reclab\\OneStimDiscrimExpListGenParam";  
    
    for i% := 0 to recOneStimDiscrimNumExps%-1 do
        expName$[i%] := GetStringRegistryValue$(key$, "ExpName"+Str$(i%), expName$[i%]);
        stimName$[i%] := GetStringRegistryValue$(key$, "StimName"+Str$(i%), stimName$[i%]);
        trialsName$[i%] := GetStringRegistryValue$(key$, "TrialsName"+Str$(i%), trialsName$[i%]);
    next;
     
	return;
end

'===== End RecOneStimDiscrimExpListGenGetParams =====
'
'

'
'
'===== RecOneStimDiscrimExpListGenSaveParams =====

'Save experiment lists to the registry for OneStimDiscrim, loading stim, experiments
proc RecOneStimDiscrimExpListGenSaveParams(expName$[],stimName$[],trialsName$[])
	var key$;
    var i%;
    key$:="Reclab\\OneStimDiscrimExpListGenParam";  
    
    for i% := 0 to recOneStimDiscrimNumExps%-1 do
        SetStringRegistryValue(key$, "ExpName"+Str$(i%), expName$[i%]);
        SetStringRegistryValue(key$, "StimName"+Str$(i%), stimName$[i%]);
        SetStringRegistryValue(key$, "TrialsName"+Str$(i%), trialsName$[i%]);
    next;
     
	return;
end

'===== End RecOneStimDiscrimExpListGenSaveParams =====
'
'





'
'
'===== RecOneStimDiscrimGNGExpListLoadGetParams =====

'Fetch experiment lists from the registry for OneStimDiscrim, loading stim, experiments
proc RecOneStimDiscrimGNGExpListLoadGetParams(&expName$[],&stimcalName$[],&trialsName$[])
	var key$;
    var i%;
    key$:="Reclab\\OneStimDiscrimGNGExpListLoadParam";  
    
    for i% := 0 to recOneStimDiscrimNumExps%-1 do
        expName$[i%] := GetStringRegistryValue$(key$, "ExpName"+Str$(i%), expName$[i%]);
        stimcalName$[i%] := GetStringRegistryValue$(key$, "StimcalName"+Str$(i%), stimcalName$[i%]);
        trialsName$[i%] := GetStringRegistryValue$(key$, "TrialsName"+Str$(i%), trialsName$[i%]);
    next;
     
	return;
end

'===== End RecOneStimDiscrimGNGExpListLoadGetParams =====
'
'

'
'
'===== RecOneStimDiscrimGNGExpListLoadSaveParams =====

'Save experiment lists to the registry for OneStimDiscrim, loading stim, experiments
proc RecOneStimDiscrimGNGExpListLoadSaveParams(expName$[],stimcalName$[],trialsName$[])
	var key$;
    var i%;
    key$:="Reclab\\OneStimDiscrimGNGExpListLoadParam";  
    
    for i% := 0 to recOneStimDiscrimNumExps%-1 do
        SetStringRegistryValue(key$, "ExpName"+Str$(i%), expName$[i%]);
        SetStringRegistryValue(key$, "StimcalName"+Str$(i%), stimcalName$[i%]);
        SetStringRegistryValue(key$, "TrialsName"+Str$(i%), trialsName$[i%]);
    next;
     
	return;
end

'===== End RecOneStimDiscrimGNGExpListLoadSaveParams =====
'
'



'
'
'===== RecOneStimDiscrimGNGExpListGenGetParams =====

'Fetch experiment lists from the registry for OneStimDiscrim, loading stim, experiments
proc RecOneStimDiscrimGNGExpListGenGetParams(&expName$[],&stimName$[],&trialsName$[])
	var key$;
    var i%;
    key$:="Reclab\\OneStimDiscrimGNGExpListGenParam";  
    
    for i% := 0 to recOneStimDiscrimNumExps%-1 do
        expName$[i%] := GetStringRegistryValue$(key$, "ExpName"+Str$(i%), expName$[i%]);
        stimName$[i%] := GetStringRegistryValue$(key$, "StimName"+Str$(i%), stimName$[i%]);
        trialsName$[i%] := GetStringRegistryValue$(key$, "TrialsName"+Str$(i%), trialsName$[i%]);
    next;
     
	return;
end

'===== End RecOneStimDiscrimGNGExpListGenGetParams =====
'
'

'
'
'===== RecOneStimDiscrimGNGExpListGenSaveParams =====

'Save experiment lists to the registry for OneStimDiscrim, loading stim, experiments
proc RecOneStimDiscrimGNGExpListGenSaveParams(expName$[],stimName$[],trialsName$[])
	var key$;
    var i%;
    key$:="Reclab\\OneStimDiscrimGNGExpListGenParam";  
    
    for i% := 0 to recOneStimDiscrimNumExps%-1 do
        SetStringRegistryValue(key$, "ExpName"+Str$(i%), expName$[i%]);
        SetStringRegistryValue(key$, "StimName"+Str$(i%), stimName$[i%]);
        SetStringRegistryValue(key$, "TrialsName"+Str$(i%), trialsName$[i%]);
    next;
     
	return;
end

'===== End RecOneStimDiscrimGNGExpListGenSaveParams =====
'
'







'================================================================================================
'End Experiment List Load/Get Params - from registry
'
'