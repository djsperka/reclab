'RecRoom - the outer shell script which allows you to run the entire gambit of Recanzone lab CED experiments
'Barring a fatal error, once this script is started the user will be redirected to the experiment selection dialog
'after every experiment is complete; spike shapes definitions will carry across experiments; ultimate closure of
'this script will be done from the experiment selection dialog

'this is a comment

'
'
'Begin #include Files which do not depend on global variables
'================================================================================================

' Unless noted #include files do not execute code and are not order-dependent
#include "LogUtilities.s2s"  'for non-time-specific logging, time-specific logging included in RECGEN
#include "matlab.s2s"
#include "recfuncs.s2s"
'#include "RecJoystickFuncs.s2s"
#include "RegistryUtils.s2s"
#include "extract_space_functions.s2s"
#include "filesystemvars.s2s"
#include "triallistgen.s2s"


'================================================================================================
'End #include Files
'
'


'
'
'Begin Global Variables
'================================================================================================

'Variables which will be used throughout the RecRoom Suite
if 1 then  'this IF is just to fold away the variables

'Debugging variables
var recMatlabIsPresent%:=1;         'Is Matlab present? Default to 1 (yes), default will apply after debug period
var recTDTIsPresent%:=1;            'Is TDT present? Default to 1 (yes), default will apply after debug period
var recCEDIsPresent%:=1;            'Is CED 1401 present? Default to 1 (yes), default will apply after debug period
var matlabOpenSuccess%:=-1;         'Was Matlab opened successfully?  Default to -1 (no matlab open)
var recCalibIsPresent%:=1;          'Is the calibration file present?  Default to 1 (yes), default will apply after debug period    
var recDebug%:=1;                   'Write debug log statements? 
var recSoundRecording%;             'Record sound output?
var dummyVar%;                      'For placeholder GUIs, just lets me have a checkbox setting SOMETHING


'Dialog button variables and other dialog variables
var recExpSearchButton%:=2;         'Arbitrary button value for the Search experiment
var recExpFRAButton%:=3;            'Etc.   
var recExpAMDiscButton%:=4;
var recExpCueingButton%:=5;
var recExpTimingRewardButton%:=6;
var recAMDiscAddExpButton%:=7;
var recAMDiscDeleteExpButton%:=8;
var recSelectStimFileButton%:=9;
var recSelectTrialsFileButton%:=10;
var recLeverJoystickButton%:=11;
var recExpJoyTrnButton%:=12; '*jao
var recExpSpaceDisButton%:=13; '*jao 
var recSpaceDisAddExpButton%:=14; 'more buttons!
var recSpaceDisDeleteExpButton%:=15;  'moar buttons!!
var recExpAudiogramButton%:=16;  'maori buttons!!!! 
var recExpStereoDisButton%:=17;    
var recExpStereoDisAddExpButton%:=18;
var recExpStereoDisDeleteExpButton%:=19;
var recFRAAddExpButton%:=20;
var recFRADeleteExpButton%:=21;    
var recSelectStimDistractorFileButton%:=22;  
var recExpStereoDisGNGAddExpButton%:=23;
var recExpStereoDisGNGDeleteExpButton%:=24;  
var recExpLongToneButton%:=25;    
    

'Selection Dialog variables
var recExpSelectDialogAllowOK%;     'Does not allow the "OK" button to be pressed until an experiment is selected
var recSpeakerArrayIndex%;          'Allows selection of a speaker array via dialog list
var recSpeakerArrayIndex2%;         'Allows selection of another speaker array via dialog list (to assign which PA4 if there are two)    
var recDoNotShuffle%;               'Allows non-shuffle of trial order

'Search Dialog variables
var recSearchStimType%;             'Integer index to experiment selection list
var recSearchToneFreq;              'Frequency of tone
var recSearchBPLowerLim;            'Lower frequency limit of bandpass noise
var recSearchBPUpperLim;             'Upper frequency limit of bandpass noise
var recSearchSpeakerSweepRepeats%;  'Number of repeats of noise per speaker for speaker sweeps
var recSearchToneSweepRepeats%;     'Number of repeats of tone sweeps
var recSearchToneSweepLowLim;       'Lower frequency limit of tone sweeps
var recSearchToneSweepUpperLim;     'Upper frequency limit of tone sweeps
'var recSearchToneSweepOctaveStep;   'Octave step of tone sweep
var recSearchToneSweepNSteps%;      'Number of steps in the tone sweep
const recSearchToneSweepMaxSteps%:=10;        'Max number of frequency steps in search tone sweep curve
var recSearchS1Speaker%;            'Speaker on which S1 plays, transferred to recS1Speaker% if Search is selected
var recSearchS2Speaker%;            'Speaker on which S2 plays, transferred to recS2Speaker% if Search is selected
var recSearchMinS1%;                'Minimum number of S1s, transferred to recMinS1% if Search is selected
var recSearchVarS1%;                'Variable number of S2s, transferred to recVarS1% if Search is selected
var recSearchPropCatch;             'Proportion of catch trials, transferred to recPropCatch if Search is selected
var recSearchdBLevel;               'Set dB level, transferred to recdBLevel if Search is selected
var recSearchActive%;               'Is experiment active or passive, transferred to recActive% if Search is selected
var recSearchFixLED%;               'Use fixation LED, transferred to recFixLED% if Search is selected


'FRA/Rate-Level/Space Dialog variables
var recFRAS1Speaker%;               'Preferred speaker (S1 stimulus location)
var recFRAMinS1%;
var recFRAVarS1%;    
var recRateLeveldBLow:=30;          'Lower bound of rate-level curve - must give a default value or program will crash with nothing in the registry
var recRateLeveldBHigh:=80;         'Higher bound of rate-level curve - must give a default value or program will crash with nothing in the registry
var recRateLevelNRepeats%:=12;      'number of repeats for rate-level experiment    
var recFRATonedBLow:=30;            'Lower dB bound of FRA - must give a default value or program will crash with nothing in the registry
var recFRATonedBHigh:=80;           'Higher dB bound of FRA - must give a default value or program will crash with nothing in the registry
var recFRAToneFreqLow:=1000;        'Lower frequency bound of FRA - must give a default value or program will crash with nothing in the registry
var recFRAToneFreqHigh:=20000;      'Higher frequency bound of FRA - must give a default value or program will crash with nothing in the registry
var recFRANRepeats%:=1;             'number of repeats for FRA    
var recFRAS2dBLevel;                'dB level of S2 stimuli (space curve), should match a level in the Rate-Level Curve
var recSpaceNRepeats%;
var recS1AMnoiseReps%; 
const nMTFrates% := 11;
var MTFrates[nMTFrates%]; 
const recRateLeveldBNSteps%:=10;    'Number of dB steps in rate-level curve
const recFRAdBNSteps%:=10;          'Number of dB steps in FRA curve
const recFRAFreqNSteps%:=45;        'Number of frequency steps in FRA curve    
var recRateLeveldBList[recRateLeveldBNSteps%];       'List of dB steps in rate-level curve
var recFRAdBList[recFRAdBNSteps%];                   'List of dB steps in FRA curve
var recFRAFreqList[recFRAFreqNSteps%];               'List of frequency steps in FRA curve
var recSearchToneSweepFreqList[recSearchToneSweepMaxSteps%];     'List of frequency steps in search tone sweep curve    
var recRLList1$;                    'Text string, displays selected values
var recRLList2$;                    'Etc.
var recFRAdBList1$;
var recFRAdBList2$;
var recFRAFreqList1$;
var recFRAFreqList2$;
var recFRAFreqList3$;
var recFRAFreqList4$;
var recFRAFreqList5$;
'var recMTFfreqList$;
var recSearchToneSweepFreqList$;
var recRLList1%;                    'Dialog item #, allows update of text
var recRLList2%;                    'Etc.
var recFRAdBList1%;
var recFRAdBList2%;
var recFRAFreqList1%;
var recFRAFreqList2%;
var recFRAFreqList3%;
var recFRAFreqList4%;
var recFRAFreqList5%;
var recSearchToneSweepFreqList%;
var recFRAFMSweepRepeats%;
var recFRAFMSweepStart%;
var recFRAFMSweepEnd%;
var recFRAFMSweep%[2];
var recFRAFMSweepDur1%;
var recFRAFMSweepDur2%;
var recFRAFMSweepDur3%;
var recFRAFMSweepDur4%;
var recFRAFMSweepDur5%;
var recFRAFMSweepDur%[5];
var recFRAActive% := 0;
var recBPnoiseReps%;
const nBPnoises% := 20;    
var recBPnoisesLOs%[nBPnoises%];
var recBPnoisesHIs%[nBPnoises%];
    
const recFRANumExps% := 40;      'The allowable number of defined experiments in AMDisc, DO NOT CHANGE WITHOUT OVERHAUL OF GETPARAM, ETC. STUFF        
var recFRAMatGenStim%;           'If 1, generate stimuli with matlab, if 0 read from disk    
var recFRAExpNameLoad$[recFRANumExps%];       'Experiment names, loading files
var recFRAStimcalNameLoad$[recFRANumExps%];   'Stim/Cal file names, loading files
var recFRATrialsNameLoad$[recFRANumExps%];    'Trials file names, loading files
var recFRAExpIndexLoad%;         'Experiment index, for loading stims, helps us look up stimcal/trials files
var recFRAExpIndexGen%;          'Experiment index, for generating stims, etc. 
var recFRARepeatsPerStim% := 1;       'Number of repeats for each stimulus defined in the trials file   
var recStereoDisRepeatsPerStim% := 1;  
var recStereoDisGNGRepeatsPerStim% := 1;    
var recRepeatsPerStim%;       'Number of repeats for each stimulus defined in the trials file    
var recFRAText2%;    
var recFRALoadStim% := 1;
var recDur;     
    
'Long Tone Dialog variables
var recLongToneDuration;
var recLongToneFreq;
var recLongToneBPLow;
var recLongToneBPHigh;
var recLongToneType%;  '0 = tone, 1 = broadband noise, 2 = bandpass noise
var recLongToneSpeaker%;
var recLongToneNRepeats%;     
var recLongToneISI;   
var recLongToneSilentDur;
var recLongToneTargetdB;
var recLongToneRewardProb;
const nLongTones% := 5;
const LongDur0 := 0.1 + 0.020;  'add in 10-ms ramp on each side
const LongDur1 := 1 + 0.020;  'add in 10-ms ramp on each side
const LongDur2 := 10 + 0.020;  'add in 10-ms ramp on each side
const LongDur3 := 100 + 0.020;  'add in 10-ms ramp on each side  
var LongDurs[nLongTones%];  'setting this in GenTrialsLongTones, so it's with the silent trial setting
'var recLongToneCycleStartTime;
'var recLongToneCyclesRemaining%;    
    
'Audiogram dialog variables
var recAudiogramS1Speaker%;  
var recAudiogramToneFreqLow:=1000;   'Lower frequency bound of audiogram - must give a default value or program will crash with nothing in the registry
var recAudiogramToneFreqHigh:=20000; 'Higher frequency bound of audiogram - must give a default value or program will crash with nothing in the registry
var recAudiogramNFreqs%:=45;   'Max Number of frequencies in audiogram, unlike FRA this value can be smaller 
var recAudiogramFreqList[45];   'List of frequency steps in audiogram    
var recAudiogramFreqList1$;
var recAudiogramFreqList2$;
var recAudiogramFreqList3$;
var recAudiogramFreqList4$;
var recAudiogramFreqList5$;  
var recAudiogramFreqList1%;
var recAudiogramFreqList2%;
var recAudiogramFreqList3%;
var recAudiogramFreqList4%;
var recAudiogramFreqList5%;    
var recAudiogramNReversals%;
var recAudiogramOnlyLogReversals%;
var recAudiogramStartdB;
var recAudiogramInitialDirection%;  '1 = up, 0 = down
var recAudiogramInitialdBStep;
var recAudiogramLouderdBStep;
var recAudiogramQuieterdBStep;
'Audiogram logic variables    
var recAudiogramCurrentReversals%;     
var recAudiogramCurrentdB; 
var recAudiogramPreviousdB;
var recAudiogramStartNewTrial% := 1;  'on first presentation, do increment trial counter
var recAudiogramCurrentDirection%;  '1 = up, 0 = down
var recAudiogramIsInitialDirection% := 1;   'audiogram will start on the initial direction 
'var recAudiogramLastResult%;    '1 = last result hit, -1 = last result miss, 0 = no results yet    
    
    
    
    

'AM Discrimination Dialog variables
var recAMDiscS1Speaker%;            'Speaker on which S1 plays, transferred to recS1Speaker% if Search is selected
var recAMDiscMinS1%;                'Minimum number of S1s, transferred to recMinS1% if Search is selected
var recAMDiscVarS1%;                'Variable number of S2s, transferred to recVarS1% if Search is selected
var recAMDiscPropCatch;             'Proportion of catch trials, transferred to recPropCatch if Search is selected
var recAMDiscdBLevel;               'Set dB level, transferred to recdBLevel if Search is selected
var recAMDiscRepeatsPerStim%;       'Number of repeats for each stimulus defined in the trials file
var recAMDiscMatGenStim%;           'If 1, generate stimuli with matlab, if 0 read from disk
var recAMDiscText1%;                'Allows enable/disable (= black/grey) of text item 1
var recAMDiscText2%;                'Allows enable/disable (= black/grey) of text item 2
var recAMDiscText3%;                'Allows enable/disable (= black/grey) of text item 3
var recAMDiscText4%;                'Allows enable/disable (= black/grey) of text item 4    
var recSelectedStimFile$;           'Stim or stim/cal file selected in add/delete 
var recSelectedStimDistractorFile$;    
var recSelectedTrialsFile$;         'Trials file selected in add/delete
const recAMDiscNumExps% := 40;      'The allowable number of defined experiments in AMDisc, DO NOT CHANGE WITHOUT OVERHAUL OF GETPARAM, ETC. STUFF
var recAMDiscExpNameLoad$[recAMDiscNumExps%];       'Experiment names, loading files
var recAMDiscStimcalNameLoad$[recAMDiscNumExps%];   'Stim/Cal file names, loading files
var recAMDiscTrialsNameLoad$[recAMDiscNumExps%];    'Trials file names, loading files
var recAMDiscExpNameGen$[recAMDiscNumExps%];       'Experiment names, generating stims
var recAMDiscStimcalNameGen$[recAMDiscNumExps%];   'Stim file names, generating stims
var recAMDiscTrialsNameGen$[recAMDiscNumExps%];    'Trials file names, generating stims
var recAMDiscExpIndexLoad%;         'Experiment index, for loading stims, helps us look up stimcal/trials files
var recAMDiscExpIndexGen%;          'Experiment index, for generating stims, etc.
var recTrialInitReward%;            'Give training reward for successful trial initiation *jao
var recAMDiscTrialInitReward%;      'Separate out training reward for AMDisc
var recSpaceDisTrialInitReward%;    'Separate out training reward for SpaceDisc
var recTrialHoldReward%;            'Give training reward for successful trial hold through stimulus, without response
var recAMDiscTrialHoldReward%;      'Separate out training reward for AMDisc
var recSpaceDisTrialHoldReward%;    'Separate out training reward for SpaceDisc
var recAMSPPassiveTask%;            'Passive version of am / sp        
    
    
'Space Discrimination Dialog variables (unused or reused vars are commented out)
'var recSpaceDisS1Speaker%;            'Speaker on which S1 plays, transferred to recS1Speaker% if Search is selected
var recSpaceDisMinS1%;                'Minimum number of S1s, transferred to recMinS1% if Search is selected
var recSpaceDisVarS1%;                'Variable number of S2s, transferred to recVarS1% if Search is selected
var recSpaceDisPropCatch;             'Proportion of catch trials, transferred to recPropCatch if Search is selected
var recSpaceDisdBLevel;               'Set dB level, transferred to recdBLevel if Search is selected
var recSpaceDisRepeatsPerStim%;       'Number of repeats for each stimulus defined in the trials file
var recSpaceDisMatGenStim%;           'If 1, generate stimuli with matlab, if 0 read from disk
var recSpaceDisText1%;                'Allows enable/disable (= black/grey) of text item 1
var recSpaceDisText2%;                'Allows enable/disable (= black/grey) of text item 2
'var recSelectedStimFile$;           'Stim or stim/cal file selected in add/delete 
'var recSelectedTrialsFile$;         'Trials file selected in add/delete
const recSpaceDisNumExps% := 40;      'The allowable number of defined experiments in AMDisc, DO NOT CHANGE WITHOUT OVERHAUL OF GETPARAM, ETC. STUFF
var recSpaceDisExpNameLoad$[recAMDiscNumExps%];       'Experiment names, loading files
var recSpaceDisStimcalNameLoad$[recAMDiscNumExps%];   'Stim/Cal file names, loading files
var recSpaceDisTrialsNameLoad$[recAMDiscNumExps%];    'Trials file names, loading files
var recSpaceDisExpNameGen$[recAMDiscNumExps%];       'Experiment names, generating stims
var recSpaceDisStimcalNameGen$[recAMDiscNumExps%];   'Stim file names, generating stims
var recSpaceDisTrialsNameGen$[recAMDiscNumExps%];    'Trials file names, generating stims
var recSpaceDisExpIndexLoad%;         'Experiment index, for loading stims, helps us look up stimcal/trials files
var recSpaceDisExpIndexGen%;          'Experiment index, for generating stims, etc.
    
    
'Stereo Distractor Dialog variables
const recStereoDisNumExps% := 40;
var recStereoDisExpNameLoad$[recStereoDisNumExps%];
var recStereoDisStimcalNameLoad$[recStereoDisNumExps%];
var recStereoDisStimcalDistractorNameLoad$[recStereoDisNumExps%];
var recStereoDisTrialsNameLoad$[recStereoDisNumExps%];
var recStereoDisExpIndexLoad%;
var recStereoDisExpNameGen$[recStereoDisNumExps%];
var recStereoDisStimNameGen$[recStereoDisNumExps%];
var recStereoDisTrialsNameGen$[recStereoDisNumExps%];
var recStereoDisExpIndexGen%;
var recStereoDisExpDoFC%;
var recStereoDisExpDoGen%;
var recStereoDisExpDoLoad%;    
const recStereoDisGNGNumExps% := 40;
var recStereoDisGNGExpNameLoad$[recStereoDisGNGNumExps%];
var recStereoDisGNGStimcalNameLoad$[recStereoDisGNGNumExps%];
var recStereoDisGNGStimcalDistractorNameLoad$[recStereoDisGNGNumExps%];
var recStereoDisGNGTrialsNameLoad$[recStereoDisGNGNumExps%];
var recStereoDisGNGExpIndexLoad%;  
var recStereoDisGNGExpNameGen$[recStereoDisGNGNumExps%];
var recStereoDisGNGStimNameGen$[recStereoDisGNGNumExps%];
var recStereoDisGNGTrialsNameGen$[recStereoDisGNGNumExps%];
var recStereoDisGNGExpIndexGen%;
var recStereoDisExpDoGNG%;    
    
'Experiment variables
var recCurrentlySampling%:=0;       'If 1, indicates that sampling is currently already started - don't start it again!
var recMonkPrefix$;                 'String to hold monkey prefix, used in naming files - bit of a misnomer, will be used as complete file name    
var blockTag$;                      'filename suffix used to denote new experiments or blocks (a,b,c,d,...) - added to MonkPrefix and Date to create filename
const recPrintLog$ := "recPrintLog"; 'an autosave printlog for BSOD debugging and whatever else might be useful. date & time printed on each call
var recLog%;                        'handle for recPrintLog
    
'Determine which drive has the CED stuff on it - it's different on different machines
var recDrivePath$;
    recDrivePath$ := GetDrivePath$();
    printlog("Drive path is %s\n",recDrivePath$);
if recDrivePath$ = "quit" then
    halt;
endif;    
    
var recFileSaveLoc$;    
recFileSaveLoc$  := recDrivePath$ + "Data\\";       'Have to set this...  
var recCalibLoc$;    
recCalibLoc$ := recDrivePath$ + "Data\\Calib\\";           'Have to set this too...
const recFileSaveLocKershaw$  := "E:\\Core Grant\\reclab2017\\testTextFiles\\";       'Have to set this...  
const recCalibLocKershaw$ := "E:\\Core Grant\\reclab2017\\testTextFiles\\";           'Have to set this too...   
var recNElectrodes%:=-1;            'Number of electrodes in use, determines number of channels recorded, start invalid on first run
var recNBAKs%;                      'Number of BAKs to record from, event channels
var recExpToRun%;                   'Integer holding which experiment to run - corresponds to dialog button value
var recLastExpRun%;                 'Holds last value of recExpToRun to suppress LEDReminderDialog in certain cases    
var recReadyToQuit%;                'Set this variable to 1 to escape the experiment loop
var recDeltadBLevel;                'Set dB level --> was "recdBLevel", changed to deltadB (atten from default of 65) to work with recDeltadBList
var recActive%;                     'Is experiment active or passive
var recFixLED%;                     'Use fixation LED?
var recMatGenStim%;                 'If 1, stim are to be generated by Matlab, if 0, read from file
var recSearchLoaded%;               'Allows PWAs to be loaded only once for SEARCH, since each trial is identical
var trialsOK%;                      'If 1, successfully loaded trials file
var stimOK%;                        'If 1, successfully loaded stim or stim/cal file
var calibOK%;                       'If 1, successfully loaded calibration file
const recPlayRateHz:=100000;         'Set stimulus play rate to 50 kHz, this will need to be constant   
const recMaxStimLengthSec:=1.6;       'Set maximum length of each individual stimulus, in seconds
const recDAC0% := 0;                'Set output channel to DAC 0, don't let this change
const recDAC1% := 1;    
var recExptText$ := "";             'text that describes this expt, for a SampleText
var recRunTimeCall%;                'will be 1 if dialog box is called during run time
var recWhichDialogCalled%;          'lets us know which dialog to call   
var recLogThisResult% := 1;         'by default, log every result, Audiogram (perhaps other exps later) will update this on a trial-by-trial basis and only log what is requested
    
'Speaker variables
const recMaxSpeaker%:=31;           'Maximum number of simultaneous speakers (31 is not currently implemented)
var recS1Speaker%;                  'Speaker on which S1 plays
var recS2Speaker%;                  'Speaker on which S2 plays
var recNSpeakers%;                  'How many speakers are there in the array (usually 15 or 16)  
var arrayPA4ID%;                    'What is the PA4 ID for the PA4 connected to the array?    
var standalonePA4ID%;               'What is the PA4 ID for the PA4 connected to the standalone speaker?    
    
'Trial list generation variables
const recMaxStim%:=1000;            'Maximum number of stimuli, 1000 is probably overlarge
const recMaxStimPerTrial%:=30;      'Holds the max number of stimuli per trial, this can exceed recMaxPWA% but only if there are at most recMaxPWA% unique stimuli
const recMaxPWA%:=10;               'Holds the maximum number of Play Wave Areas *don't change this! *jao 
const recMaxTrial%:=5000;           'Maximum number of trial TYPES, 5000 is probably overlarge again, but there is the problem of long Search stretches
const recMaxDistractor%:=6;         'Maximum number of distractors (= max number of S1.ns in distractor expt.), currently index 0 will remain empty as the true S1 has no distractor    
var recTotalStim%;                  'Total number of stimuli specified in Stim or Stim/Cal file
var recTotalDistractorStim%;        'Total number of stimuli specified in distractor version of Stim/Cal file    
var recMinS1%;                      'Minimum number of S1s
var recVarS1%;                      'Variable number of S1s
var recPropCatch;                   'Proportion of catch trials
var recTrialLoadLoc$[recMaxStim%];            'Disk location of files to load, stim/cal file
var recTrialLoadLocDistractor$[recMaxStim%];  'Disk location of files to load, stim/cal file, distractors
var recTrialDur[recMaxStim%];       '          Duration of each stimulus, in ms, stim/cal OR stim file
var recTrialDurDistractor[recMaxStim%];       'Duration of each stimulus, in ms, stim/cal OR stim file, distractors
var recTrialNumS1ns%[recMaxStim%];            'Number of S1.n stimuli on each trial, used for two-speaker distractor scenarios    
var recTrialMF[recMaxStim%];                  'Modulation frequency of each stimulus    
var recTrialMFDistractor[recMaxStim%];        'Modulation frequency of each stimulus, distractors
var recTrialCarrier$[recMaxStim%];            'Carrier type of each stimulus
var recTrialCarrierDistractor$[recMaxStim%];  'Carrier type of each stimulus, distractors 
var recTrialStimCal[recMaxStim%][recMaxSpeaker%];    'A calibration matrix, used for stim/cal when loading
var recTrialStimCalDistractor[recMaxStim%][recMaxSpeaker%];    'A calibration matrix, used for stim/cal when loading, distractors
var recTrialGenLowpassHz[recMaxStim%];               'A list of lowpass values - if -1, no lowpass, same as highpass means tone
var recTrialGenHighpassHz[recMaxStim%];              'Same as above, highpass
var recTrialGenIsSweep%[recMaxStim%];                'If 1, Lo/Hi Hz values will correspond to FM sweep instead of BP noise limits
var recTrialGenAMFreqHz[recMaxStim%];                'A list of AM frequency values, if 0 no AM
var recTrialGenAMDepthPct[recMaxStim%];              'A list of AM depth values in percent, if 0 no depth
var recTrialGenAMPhaseDeg[recMaxStim%];              'A list of AM phases, 0 = AM starts low, 90 = AM starts middle and rising, 180 = AM starts high, 270 = AM starts middle, falling
var recTrialGenTonePhaseDeg[recMaxStim%];            'A list of tone phases, 0 = tone starts middle, rising (sine phase), 90 = tone starts high (cosine phase), note different than AM phase, only used for tone, not noise
var recTrialGenGauss%[recMaxStim%];                  'If 1 create Gaussian noise, if 0 create uniform noise
var recTrialGenRampMS[recMaxStim%];                  'Duration in ms of front/back ramp, ramp is 1-Cos^2
var recTrialGenSeed%[recMaxStim%];                   'Seed for random number generator, 0 = unspecified, will make own random number
                                                         'Please note that the concept of using the RNG to get a seed for the RNG is hilarious, but not redundant in this case.
      
    
    
var recGeneratedAtten[recMaxPWA%];  'for calibration of generated stims  
    
var recTrialS1%[recMaxTrial%];                'Index corresponding to S1 stimulus (index to recTrialLoadLoc$ or recTrialGen...)
var recTrialS2%[recMaxTrial%];                'Index corresponding to S2 stimulus
var recTrialS1Spkr%[recMaxTrial%];            'Index corresponding to S1 speaker
var recTrialS2Spkr%[recMaxTrial%];            'Index corresponding to S2 speaker
var recTrialS1DeltadB[recMaxTrial%];          'Allows a single trial's S1 to be different from default intensity
var recTrialS2DeltadB[recMaxTrial%];          'Allows a single trial's S2 to be different from default intensity   
var recTrialDistractor%[recMaxTrial%][recMaxDistractor%];        'Index corresponding to distractor stimulus 
var recTrialDistractorSpkr%[recMaxTrial%][recMaxDistractor%];    'Index corresponding to distractor speaker
var recTrialDistractorDeltadB[recMaxTrial%][recMaxDistractor%];  'Allows a single trial's distractor to be different from default intensity     
    
var recPlayPoints%;                 'Holds the number of points to play for each stimulus    
var recPointsPlayed%;               'Allows us to stop the sound once the stimulus is over and the PWA is spitting out zeros    
const recMaxPoints% := recPlayRateHz*recMaxStimLengthSec;  'Holds the maximum number of points in a stimulus, must be a constant   
'const recMaxLongNoiseBPPoints% := recPlayRateHz*100;
'const recMaxLongNoisePoints% := recPlayRateHz;   'Not doing multiplication by seconds because seconds is by definition 1.
const LongPoints0% := LongDur0*recPlayRateHz;
const LongPoints1% := LongDur1*recPlayRateHz;
const LongPoints2% := LongDur2*recPlayRateHz;
const LongPoints3% := LongDur3*recPlayRateHz;
var recStimTransfer%[recMaxPoints%]; 'Will be used for loading, transferring stims
var rec2StimTransfer%[recMaxPoints%][2]; 'Will be used for loading, transferring stims (2-dim PWA!!)    
'var recStimTransferLongNoise%[recMaxLongNoisePoints%];  
'var recStimTransferLongNoiseBP%[recMaxLongNoiseBPPoints%];    
var recStimTransferLongNoise2%[LongPoints3%];
var recLongNoise3%[8][LongPoints3%];   'variables to hold long noises
var recLongNoise2%[8][LongPoints2%];    
var recLongNoise1%[8][LongPoints1%];
var recLongNoise0%[8][LongPoints0%];    
var recLongNoiseAtten[8][nLongTones%];                       'variables to hold long noise attenuation    
var recLongNoiseSeed[8][nLongTones%];                        'variables to hold long noise attenuation    
    
'Trial list variables
var recPWAList%[recMaxStimPerTrial%][recMaxTrial%];     'Holds indices to which PWA to use on each trial, and therefore also indexes recStimList%[][]    
var recStimList%[recMaxStimPerTrial%][recMaxTrial%];    'A list of unique stim/speaker combos on each trial
var recTrialTerminalIndex%[recMaxTrial%];               'For each trial, holds indices to which row of recPWAList%[][] holds the final stimulus
var recTrialTerminalIsS2%[recMaxTrial%];                'For each trial, if 1 trial is target (Hit/miss), if 0 trial is catch (CR/FA)
var recTotalTrials%;                                    'Holds the number of trials in the trials file, will not necessarily be the same as recNTrials% due to repeats    
var recNTrials%;                                        'Holds the total number of trials
var recNUniqueStims%[recMaxTrial%];                     'Holds the number of unique stims on each trial, for loading PWAs
var recSpeakerList%[recMaxStimPerTrial%][recMaxTrial%];          'Same as recStimList%[][], but holds speaker number
'var recAttenList%[recMaxStimPerTrial%][recMaxTrial%];   'Same as recStimList%[][], but holds CALIBRATING attenuation FROM A FILE, currently disabled
var recDeltadBList[recMaxStimPerTrial%][recMaxTrial%];  'Same as recPWAList%[][], but holds TRIAL-BASED attenuation (experimentally relevant)   
var recTrialOrder%[recMaxTrial%];                       'Holds order in which trials should be presented
var recCurrentTrial%;                                   'Holds current trial in ordinal sequence, will be used to index recTrialOrder%[]    
var recCurrRandomSeed%[recMaxPWA%];                     'Holds the random seeds used to generate each trial, only done on a trial-by-trial basis    
var recStimCount%;                                      'Counter for current recMaxStimPerTrial%   
var recLongToneDurationList[recMaxTrial%];              'Holds the duration of each long tone
var recLongToneDurationIndex%[recMaxTrial%];            'Holds the index of the duration, useful for triggering correct PWA, when necessary 
    
'FRA-specific trial list variables
var rec2StimList%[recMaxTrial%][2]; 'first dimension: trial number, second dimension: DAC0 stimuli, DAC1 stimuli)    
var rec2SpeakerList%[recMaxTrial%][2]; 'same format as 2stimlist
var rec2DeltadBList[recMaxTrial%][2];
var recFRAReward%[recMaxTrial%];    
    
    
'Stereo Distractor specific trial list variables
var recDistractorStimList%[recMaxStimPerTrial%][recMaxTrial%];
var recDistractorSpeakerList%[recMaxStimPerTrial%][recMaxTrial%];
var recDistractorDeltadBList[recMaxStimPerTrial%][recMaxTrial%];  
var recStereoDisGeneratedAttenList[recMaxStimPerTrial%][recMaxPWA%];
var recStereoDisSeedList%[recMaxStimPerTrial%][recMaxPWA%];    
    
    
'Timing Parameters
var recMinOnsetDelay;               'Minimum time between monkey's lever press and stimulus onset, seconds
var recVarOnsetDelay;               'Variable time added to recMinOnsetDelay, seconds
var recISI;                         'Interstimulus interval, seconds
var recTrialInitWindow;             'Allowable time for monkey to initiate trial before TO, seconds
var recResponseWindow;              'Allowable time for monkey to respond to target, seconds
var recMinJoystickRespTime;         'Minimum time required for a joystick move to be considered real, seconds

'Time-Outs
var recLazyMonkeyTO;                'Duration of time-out for not working, seconds
var recMissTO;                      'Duration of time-out for miss, seconds
var recFalseAlarmTO;                'Duration of time-out for false alarms, seconds
var recInterruptTO;
var recMissRepeats%;                'Whether to repeat missed trials '*jao
var recMissRepeatsMax%;             'Max # times to repeat missed trials
var recMissRepeatsCounter% := 0;    'Initialize consective miss repeat counter to 0 (this might be useful for staircase training later)
    
'Joystick variables    
var recUseJoystick%;                'Do we use the joystick, 1 = yes, 0 = no
var recIsGoNoGo%;                   'Is experiment go/no-go, 1 = yes, 0 = no, forced choice (two alternative)    
var recTrialInitPosition%:=1;       'Joystick trial initiation position; 0/1/2/3/4/5/6 = center/down/up/right/left/x/y, default to down
var recTrialResponsePosition1%;     'Joystick position of response 1, same values as init above
var recTrialResponsePosition2%:=7;  'Joystick position of response 2, 0/1/2/3/4/5/6/7, where 7 = no second response position, default to no second response position
var recDoIncrements%;   
var recDoJoyTrain%; '*jao
    
'Reward durations, etc.
var recTrainingRewardDur;           'Duration of training reward, seconds
var recHitRewardDur;                'Duration of hit reward, seconds
var recCRRewardDur;                 'Duration of correct rejection reward, seconds
'var recMaxHitRewardDur;             'Max duration of hit reward, seconds
'var recMaxCRRewardDur;              'Max duration of CR reward, seconds
var recTrainingRewardmL;            'Volume of training reward, milliliters
var recHitRewardmL;                 'Volume of hit reward, milliliters
var recCRRewardmL;                  'Volume of correct rejection reward, milliliters
var recMaxHitRewardmL;              'Max volume of hit reward, milliliters
var recMaxCRRewardmL;               'Max volume of CR reward, milliliters
var recRewardMs%;                   'Temp variable, used for duration of any reward, conversion to milliseconds
var recRewardMs;                    'float version    
'var recHitRewardInc;                'Reward increment per hit, seconds (both hit and CR rewards, will stop at max, will reset on miss/FA)
'var recS1RewardInc;                 'Reward increment per S1 stimulus, seconds (additional reward on each trial per S1)
var recHitRewardIncmL;              'Reward increment per hit, milliliters (both hit and CR rewards, will stop at max, will reset on miss/FA)
var recS1RewardIncmL;               'Reward increment per S1 stimulus, milliliters (additional reward on each trial per S1)
var lastHitReward; 'holds last hit reward given so that it can be incremented
var thisHitReward; 'initialize to base level
var recRewardType%;                 '0 = juice, 1 = Stimulation, 2 = cycle through on error, 3 = select via probability on error
var recCurrentRewardType%;          'Type of reward this trial, 0 = juice, 1 = stim, 2 = both
var recPctJuice%;                   'percentage of time variable reward will be juice    
var recPctStimulation%;             'percentage of time variable reward will be a Stimulation    
var recJuiceToStimDelay%;           'ms delay between (nominal) juice reward and stimulation reward, can attempt to deliver both at "same" time
var recChangeRewardType% := 1;      'Do we change reward type before this trial?  Do change on first trial, or after error    
var recTurnOffReward%;              'Do we turn off the reward?    
    
'Interrupts
var recContinueSoundOnS1Interrupt%; 'If 0, stop sound on S1 interrupt, otherwise continue
var recContinueSoundOnS2Interrupt%; 'If 0, stop sound on S2 interrupt, otherwise continue
    
'Utility variables
var iglob%;                         'General looping variable, global scope
var fhglob%;                        'General file handle variable, global scope
var tempglob%;                      'General temporary variable, global scope 
var statement$;                     'Holds statments to evaluate in Matlab
var result%;

endif;
'================================================================================================
'End Global Variables
'
'


'Include files that depend on global variables
#include "RecGoNoGoEngine.s2s"
'#include "RecJoystickFuncs.s2s" -- must be included in recGoNoGoEngine!!  Noted here for info purposes

'
'
'Begin Code Execution
'================================================================================================



'Run initial dialog to determine presence of Matlab/TDT/1401
'This dialog will be disabled once testing is complete, but the remainder of calls below it should remain
if RecDebugDialog%() <> 1 then   
    LogError("NoState", "RecDebugDialog% was cancelled!");
    halt;
endif;

'Open RecLog, use "Kershaw" location (now "Seager", but directory is the same) in lobby, RecLab location in RecLab
'(Minor Note: This used to happen before the RecDebugDialog, but now comes after since RecDebug% isn't filled yet)
if recDebug% = 2 then
    recLog% := FileOpen(recFileSaveLocKershaw$+recPrintLog$+".txt",8,3); 'open recLog, create if DNE (first time called)
    printlog("RecLog location is %s\n",recFileSaveLocKershaw$+recPrintLog$+".txt");
else
    recLog% := FileOpen(recFileSaveLoc$+recPrintLog$+".txt",8,3); 'open recLog, create if DNE (first time called)
    printlog("RecLog location is %s\n",recFileSaveLoc$+recPrintLog$+".txt");
endif;
view(recLog%).print("running RecRoom"+Date$(2,2,3,3,"-")+" "+Time$(1,3)+"\n");


'Open a Matlab instantiation, if present
if recMatlabIsPresent% = 1 then 
    ToolbarText("Opening Matlab, this could take up to 30 seconds");
    matlabOpenSuccess% := OpenMatlab%();
    if matlabOpenSuccess% < 0 then
        LogInfo("Open Matlab FAILED!");
        halt;
    endif;
    ToolbarText("");
else
    LogInfo("Client is in testing mode. Bypassing Matlab initialization.");
endif


'Initialize TDT, if present
if recTDTIsPresent% = 1 then
    ToolbarText("Initializing TDT, this could take up to 5 seconds");    
    if RecInitTDT%() < 0 then  'RecInitTDT%() is in recfuncs
        LogInfo("Init TDT FAILED!");
        CloseMatlab(matlabOpenSuccess%);  'close Matlab if it is open and we are quitting
        halt;
    endif
    ToolbarText("");
else
    LogInfo("Client is in testing mode. Bypassing TDT initialization.");
endif


'Note absence of CED 1401 if necessary
if recCEDIsPresent% = 0 then
    LogInfo("Client is in testing mode. CED 1401 is not present.");
endif



'Open experiment selection dialog, and run the experiment
while recReadyToQuit% = 0 do  
    
    RecTimingRewardGetParams();  'get default timing and reward parameters
    
    'Open experiment selection dialog, load appropriate trials file, stim or stim/cal file, calibration file
    if RecExpSelectDialog%() = 1 then  'run dialog, branch on run/cancel result
        view(recLog%).print("RecRoom: RecExpSelectDialog%() = 1\n");    
        view(recLog%).print("RecRoom: Are Stimuli Shuffled? = %d\n",1-recDoNotShuffle%);
        view(recLog%).print("RecRoom: Is Reward On? = %d\n",1-recTurnOffReward%);
        
        if recExpToRun% <> recLastExpRun% then
            RecLEDReminderDialog%(); 'call LED color switch reminder dialog before proceeding
            view(recLog%).print("RecRoom: RecLEDReminderDialog%()\n");    
        else 
            view(recLog%).print("RecRoom: Repeat Expt! RecLEDReminderDialog% skipped\n");    
        endif; 

        calibOK% := -1;  'logic is different for calibOK% because EvalMatlabStatement returns 0/-1 (success/failure)
        trialsOK% := 0;  'reset
        stimOK% := 0;  'reset
                
        'Load stim/cal file, trials file.
        'For generated stimuli, load calibration file to Matlab here
        docase
        case recExpToRun% = recExpLongToneButton% then 
            recExptText$ := "Running Long Tone "; 
            trialsOK% := 2;  'Short circuit, no trials file to load
            stimOK% := 1;  'Short circuit, no stim file to load
            'Load calibration file into Matlab's workspace
            'The file specified must contain a cell array named "calib" with recNSpeakers% cells inside
            'We will eventually pass a structure (syntax: AFFT(1,thisSpkr%) or AFilt(1,thisSpkr%)) to
            'Matlab when generating stimuli.  Reclab_Panstim will do the rest
            'I'm not sure the filter coefficient version is the best method - looks like the FFT version will be best
            if recMatlabIsPresent% = 1 and recCalibIsPresent% = 1 then
                statement$ := "load('" + recCalibLoc$ + "Array" + Str$(recNSpeakers%) + ".mat');";
                calibOK% := EvalMatlabStatement%(statement$);
                printlog("Matlab statement for load is: %s\n",statement$);
                printlog("CalibOK is %d where 0 is OK and -1 is not OK\n",calibOK%);
            else
                message("Either no Matlab or no calib, we will have to guess the correct attenuation!");
                'let it go forward
                calibOK% := 0; 
            endif;

        case recExpToRun% = recExpSearchButton% then  'For Search, all stimuli are generated
            recExptText$ := "Running Search " + recExptText$ + " ";  'the Search dialog puts a stimulus type in recExptText$ before we get here, this is the only expt that does that (thus far)
            trialsOK% := 2;  'Short circuit, no trials file to load
            stimOK% := 1;  'Short circuit, no stim file to load
            'Load calibration file into Matlab's workspace
            'The file specified must contain a cell array named "calib" with recNSpeakers% cells inside
            'We will eventually pass a structure (syntax: AFFT(1,thisSpkr%) or AFilt(1,thisSpkr%)) to
            'Matlab when generating stimuli.  Reclab_Panstim will do the rest
            'I'm not sure the filter coefficient version is the best method - looks like the FFT version will be best
            if recMatlabIsPresent% = 1 then
                if recCalibIsPresent% = 1 then
                    statement$ := "load('" + recCalibLoc$ + "Array" + Str$(recNSpeakers%) + ".mat');";
                    calibOK% := EvalMatlabStatement%(statement$);
                else
                    printlog("Calibration is not present, stimuli will be uncalibrated!\n");
                    calibOK% := 0;
                endif;
            else
                message("Matlab is not open, but you have selected a scenario that requires Matlab!");
                if recCEDIsPresent% = 0 then  'if both are not present, this must be a testing scenario - let it go forward
                    calibOK% := 0; 
                endif;
            endif;
            
        case recExpToRun% = recExpFRAButton% and recFRALoadStim% = 0 then  'FRA
            recExptText$ := "Running FRA (gen) "; 
            trialsOK% := 2;  'Short circuit, no trials file to load
            stimOK% := 1;  'Short circuit, no stim file to load
            'Load calibration file into Matlab's workspace, same details as above in Search
            if recMatlabIsPresent% = 1 then
                if recCalibIsPresent% = 1 then
                    statement$ := "load('" + recCalibLoc$ + "Array" + Str$(recNSpeakers%) + ".mat');";
                    calibOK% := EvalMatlabStatement%(statement$);
                else
                    printlog("Calibration is not present, stimuli will be uncalibrated!\n");
                    calibOK% := 0;
                endif;    
            else
                message("Matlab is not open, but you have selected a scenario that requires Matlab!");
                if recCEDIsPresent% = 0 then  'if both are not present, this must be a testing scenario - let it go forward
                    calibOK% := 0; 
                endif;
            endif;
            
        case recExpToRun% = recExpFRAButton% and recFRALoadStim% = 1 then  'FRA pulling stimuli from input table
            recExptText$ := "Running FRA (load) ";
            'Get stimfile and trials file lists
            RecFRAExpListLoadGetParams(recFRAExpNameLoad$[],recFRAStimcalNameLoad$[],recFRATrialsNameLoad$[]);
            'Load trials file, stim/cal file
            trialsOK% := RecLoadTrialsFile%(recFRATrialsNameLoad$[recFRAExpIndexLoad%],recTotalTrials%);
            if trialsOK% = 1 then  'Don't bother with loading Stim/Cal file if trials file is bad
                stimOK% := RecLoadStimCalFile%(recFRAStimcalNameLoad$[recFRAExpIndexLoad%],recNSpeakers%,recTotalStim%);
            endif;
            recSelectedStimFile$ := recFRAStimcalNameLoad$[recFRAExpIndexLoad%];  'var already declared but not used - need to print it to BehOutput*****
            recSelectedTrialsFile$ := recFRATrialsNameLoad$[recFRAExpIndexLoad%]; 'ditto. for BehOutput
                
            calibOK% := 0;  'Short circuit, this means OK.
            
        case recExpToRun% = recExpJoyTrnButton% then '*jao
            recExptText$ := "Running Joy Train ";
            trialsOK% := 2;  'Short circuit, no trials file to load
            stimOK% := 1;  'Short circuit, no stim file to load
            'Load calibration file into Matlab's workspace, same details as above in Search
            if recMatlabIsPresent% = 1 then
                if recCalibIsPresent% = 1 then
                    statement$ := "load('" + recCalibLoc$ + "Array" + Str$(recNSpeakers%) + ".mat');";
                    calibOK% := EvalMatlabStatement%(statement$);
                else
                    printlog("Calibration is not present, stimuli will be uncalibrated!\n");
                    calibOK% := 0;
                endif;
            else
                message("Matlab is not open, but you have selected a scenario that requires Matlab!");
                if recCEDIsPresent% = 0 then  'if both are not present, this must be a testing scenario - let it go forward
                    calibOK% := 0; 
                endif;
            endif; '*jao            
        case recExpToRun% = recExpAMDiscButton% and recMatGenStim% = 0 then  'Loading stims
            recExptText$ := "Running AMDisc (load) "; 
            'Get stimfile and trials file lists
            RecAMDiscExpListLoadGetParams(recAMDiscExpNameLoad$[],recAMDiscStimcalNameLoad$[],recAMDiscTrialsNameLoad$[]);
            'Load trials file, stim/cal file
            trialsOK% := RecLoadTrialsFile%(recAMDiscTrialsNameLoad$[recAMDiscExpIndexLoad%],recTotalTrials%);
            if trialsOK% = 1 then  'Don't bother with loading Stim/Cal file if trials file is bad
                stimOK% := RecLoadStimCalFile%(recAMDiscStimcalNameLoad$[recAMDiscExpIndexLoad%],recNSpeakers%,recTotalStim%);
            endif;
            recSelectedStimFile$ := recAMDiscStimcalNameLoad$[recAMDiscExpIndexLoad%];  'var already declared but not used - need to print it to BehOutput*****
            recSelectedTrialsFile$ := recAMDiscTrialsNameLoad$[recAMDiscExpIndexLoad%]; 'ditto. for BehOutput
                
            calibOK% := 0;  'Short circuit, this means OK.
                    
        case recExpToRun% = recExpAMDiscButton% and recMatGenStim% = 1 then  'Generating stims
            recExptText$ := "Running AMDisc (gen) "; 
            'Get stimfile and trials file lists
            RecAMDiscExpListGenGetParams(recAMDiscExpNameGen$[],recAMDiscStimcalNameGen$[],recAMDiscTrialsNameGen$[]);
            'Load trials file, stim file, cal file
            trialsOK% := RecLoadTrialsFile%(recAMDiscTrialsNameGen$[recAMDiscExpIndexGen%],recTotalTrials%);
            if trialsOK% = 1 then  'Don't bother with loading Stim file if trials file is bad
                stimOK% := RecLoadStimFile%(recAMDiscStimcalNameGen$[recAMDiscExpIndexGen%],recTotalStim%);
            endif;
            recSelectedStimFile$ := recAMDiscStimcalNameGen$[recAMDiscExpIndexGen%];  'var already declared but not used - need to print it to BehOutput*****
            recSelectedTrialsFile$ := recAMDiscTrialsNameGen$[recAMDiscExpIndexGen%]; 'ditto. for BehOutput
                
            if stimOK% = 1 then  'Don't bother with loading Calib file if trials or stim file is bad
                'Load calibration file into Matlab's workspace, same details as above in Search
                if recMatlabIsPresent% = 1 then
                    if recCalibIsPresent% = 1 then 
                        statement$ := "load('" + recCalibLoc$ + "Array" + Str$(recNSpeakers%) + ".mat');";
                        calibOK% := EvalMatlabStatement%(statement$);
                    else
                        printlog("Calibration is not present, stimuli will be uncalibrated!\n");
                        calibOK% := 0;
                    endif;
                else
                    message("Matlab is not open, but you have selected a scenario that requires Matlab!");
                endif;
            endif;
            
        case recExpToRun% = recExpSpaceDisButton% and recMatGenStim% = 0 then  'Loading stims
            recExptText$ := "Running SpaceDis (load) "; 
            'Get stimfile and trials file lists
            RecSpaceDisExpListLoadGetParams(recSpaceDisExpNameLoad$[],recSpaceDisStimcalNameLoad$[],recSpaceDisTrialsNameLoad$[]);
            'Load trials file, stim/cal file
            trialsOK% := RecLoadTrialsFile%(recSpaceDisTrialsNameLoad$[recSpaceDisExpIndexLoad%],recTotalTrials%);
            if trialsOK% = 1 then  'Don't bother with loading Stim/Cal file if trials file is bad
                stimOK% := RecLoadStimCalFile%(recSpaceDisStimcalNameLoad$[recSpaceDisExpIndexLoad%],recNSpeakers%,recTotalStim%);
            endif;
            recSelectedStimFile$ := recSpaceDisStimcalNameLoad$[recSpaceDisExpIndexLoad%];  'var already declared but not used - need to print it to BehOutput*****
            recSelectedTrialsFile$ := recSpaceDisTrialsNameLoad$[recSpaceDisExpIndexLoad%]; 'ditto. for BehOutput
                
            calibOK% := 0;  'Short circuit, this means OK.
                    
        case recExpToRun% = recExpSpaceDisButton% and recMatGenStim% = 1 then  'Generating stims
            recExptText$ := "Running SpaceDis (gen) "; 
            'Get stimfile and trials file lists
            RecSpaceDisExpListGenGetParams(recSpaceDisExpNameGen$[],recSpaceDisStimcalNameGen$[],recSpaceDisTrialsNameGen$[]);
            'Load trials file, stim file, cal file
            trialsOK% := RecLoadTrialsFile%(recSpaceDisTrialsNameGen$[recSpaceDisExpIndexGen%],recTotalTrials%);
            if trialsOK% = 1 then  'Don't bother with loading Stim file if trials file is bad
                stimOK% := RecLoadStimFile%(recSpaceDisStimcalNameGen$[recSpaceDisExpIndexGen%],recTotalStim%);
            endif;
            recSelectedStimFile$ := recSpaceDisStimcalNameGen$[recSpaceDisExpIndexGen%];  'var already declared but not used - need to print it to BehOutput*****
            recSelectedTrialsFile$ := recSpaceDisTrialsNameGen$[recSpaceDisExpIndexGen%]; 'ditto. for BehOutput
                
            if stimOK% = 1 then  'Don't bother with loading Calib file if trials or stim file is bad
                'Load calibration file into Matlab's workspace, same details as above in Search
                if recMatlabIsPresent% = 1 then
                    if recCalibIsPresent% = 1 then 
                        statement$ := "load('" + recCalibLoc$ + "Array" + Str$(recNSpeakers%) + ".mat');";
                        calibOK% := EvalMatlabStatement%(statement$);
                    else
                        printlog("Calibration is not present, stimuli will be uncalibrated!\n");
                        calibOK% := 0;
                    endif;
                else
                    message("Matlab is not open, but you have selected a scenario that requires Matlab!");
                endif;
            endif;
            
        case recExpToRun% = recExpCueingButton% and recMatGenStim% = 0 then  'Loading stims
            recExptText$ := "Running Cueing (load) "; 
            'Not Yet Implemented
            'Copy from load version of AM Disc when cueing is ready
            calibOK% := 0;  'Short circuit, this means OK.
            
        case recExpToRun% = recExpCueingButton% and recMatGenStim% = 1 then  'Generating stims
            recExptText$ := "Running Cueing (gen) "; '+ recExptText$???
            'Not Yet Implemented
            'Copy from generate version of AM Disc when cueing is ready
            'Load calibration file into Matlab's workspace, same details as above in Search
            if recMatlabIsPresent% = 1 then
                if recCalibIsPresent% = 1 then
                    statement$ := "load('" + recCalibLoc$ + "Array" + Str$(recNSpeakers%) + ".mat');";
                    calibOK% := EvalMatlabStatement%(statement$);
                else
                    printlog("Calibration is not present, stimuli will be uncalibrated!\n");
                    calibOK% := 0;
                endif;
            else
                message("Matlab is not open, but you have selected a scenario that requires Matlab!");
            endif;
            
        case recExpToRun% = recExpAudiogramButton% then  'For Audiogram, all stimuli are generated
            
            recExptText$ := "Running Audiogram ";  
            trialsOK% := 2;  'Short circuit, no trials file to load
            stimOK% := 1;  'Short circuit, no stim file to load
            
            'The following two settings are obligatory for Audiogram - these had been set in Audiogram dialog but subsequent calls of Timing/Reward were counterfeiting them.
            recIsGoNoGo% := 1;  'Force experiment to be go/no-go 
            recHitRewardIncmL := 0;  'Do not allow reward incrementing for audiogram
            
            'Also, set this explicitly every time, OK for first run, but on subsequent runs, has to be reset
            recAudiogramStartNewTrial% := 1;
            
            'Load calibration file into Matlab's workspace, same details as above in Search
            if recMatlabIsPresent% = 1 then
                if recCalibIsPresent% = 1 then
                    statement$ := "load('" + recCalibLoc$ + "Array" + Str$(recNSpeakers%) + ".mat');";
                    calibOK% := EvalMatlabStatement%(statement$);
                else
                    printlog("Calibration is not present, stimuli will be uncalibrated!\n");
                    calibOK% := 0;
                endif;    
            else
                message("Matlab is not open, but you have selected a scenario that requires Matlab!");
                if recCEDIsPresent% = 0 then  'if both are not present, this must be a testing scenario - let it go forward
                    calibOK% := 0; 
                endif;
            endif;
            
        case recExpToRun% = recExpStereoDisButton% and recStereoDisExpDoFC% = 1 and recStereoDisExpDoLoad% = 1 then  'For Stereo Distractor, FC, loading stimuli
            recExptText$ := "Running Stereo Distractor FC Loading Stims"; 
            
            'Get stimfile and trials file lists
            RecStereoDisExpListLoadGetParams(recStereoDisExpNameLoad$[],recStereoDisStimcalNameLoad$[],recStereoDisTrialsNameLoad$[],recStereoDisStimcalDistractorNameLoad$[]);
            'Load trials file, stim/cal file
            trialsOK% := RecLoadTrialsFile9%(recStereoDisTrialsNameLoad$[recStereoDisExpIndexLoad%],recTotalTrials%);
            if trialsOK% = 1 then  'Don't bother with loading Stim/Cal file if trials file is bad
                stimOK% := RecLoadStimCalDistractorFile%(recStereoDisStimcalDistractorNameLoad$[recStereoDisExpIndexLoad%],recNSpeakers%,recTotalDistractorStim%);
                if stimOK% = 1 then  'Don't bother with loading S1/S2 Stim/Cal file if distractor one is bad
                    stimOK% := RecLoadStimCalMFCarrierFile%(recStereoDisStimcalNameLoad$[recStereoDisExpIndexLoad%],1,recTotalStim%);  'here, there is only 1 S1/S2 speaker, at least for now
                else
                    stimOK% := -1;  'This is an indicator that the distractor file read failed, as opposed to S1/S2
                endif;
            endif;
            recSelectedStimFile$ := recStereoDisStimcalNameLoad$[recStereoDisExpIndexLoad%];  'var already declared but not used - need to print it to BehOutput*****
            recSelectedStimDistractorFile$ := recStereoDisStimcalDistractorNameLoad$[recStereoDisExpIndexLoad%];  'var already declared but not used - need to print it to BehOutput*****
            recSelectedTrialsFile$ := recStereoDisTrialsNameLoad$[recStereoDisExpIndexLoad%]; 'ditto. for BehOutput
                
            calibOK% := 0;  'Short circuit, this means OK.
            
        case recExpToRun% = recExpStereoDisButton% and recStereoDisExpDoFC% = 1 and recStereoDisExpDoGen% = 1 then  'For Stereo Distractor, FC, generating stimuli
            recExptText$ := "Running Stereo Distractor FC Generating Stims"; 
            
            'Get stimfile and trials file lists
            RecStereoDisExpListGenGetParams(recStereoDisExpNameGen$[],recStereoDisStimNameGen$[],recStereoDisTrialsNameGen$[]);
            'Load trials file, stim file
            trialsOK% := RecLoadTrialsFile9%(recStereoDisTrialsNameGen$[recStereoDisExpIndexGen%],recTotalTrials%);
            if trialsOK% = 1 then  'Don't bother with loading Stim file if trials file is bad
                stimOK% := RecLoadStimFile%(recStereoDisStimNameGen$[recStereoDisExpIndexGen%],recTotalStim%);
            endif;
            recSelectedStimFile$ := recStereoDisStimNameGen$[recStereoDisExpIndexGen%];  'var already declared but not used - need to print it to BehOutput*****
            recSelectedTrialsFile$ := recStereoDisTrialsNameGen$[recStereoDisExpIndexGen%]; 'ditto. for BehOutput
            
            'Load calibration file into Matlab's workspace, same details as above in Search
            if recMatlabIsPresent% = 1 then
                if recCalibIsPresent% = 1 then
                    statement$ := "load('" + recCalibLoc$ + "Array" + Str$(recNSpeakers%) + ".mat');";
                    calibOK% := EvalMatlabStatement%(statement$);
                    'Only load standalone calibration if the array load was successful
                    if calibOK% = 0 then
                        statement$ := "load('" + recCalibLoc$ + "Standalone.mat');";  'make sure variable inside this is "stAFFT"
                        calibOK% := EvalMatlabStatement%(statement$);
                    endif;
                else
                    printlog("Calibration is not present, stimuli will be uncalibrated!\n");
                    calibOK% := 0;
                endif;    
            else
                message("Matlab is not open, but you have selected a scenario that requires Matlab!");
                if recCEDIsPresent% = 0 then  'if both are not present, this must be a testing scenario - let it go forward
                    calibOK% := 0; 
                endif;
            endif; 
            
        case recExpToRun% = recExpStereoDisButton% and recStereoDisExpDoGNG% = 1 and recStereoDisExpDoLoad% = 1 then  'For Stereo Distractor, GNG, loading stimuli
            recExptText$ := "Running Stereo Distractor GNG Loading Stims"; 
            
            'Get stimfile and trials file lists
            RecStereoDisGNGExpListLoadGetParams(recStereoDisGNGExpNameLoad$[],recStereoDisGNGStimcalNameLoad$[],recStereoDisGNGTrialsNameLoad$[],recStereoDisGNGStimcalDistractorNameLoad$[]);
            'Load trials file, stim/cal file
            trialsOK% := RecLoadTrialsFile22%(recStereoDisGNGTrialsNameLoad$[recStereoDisGNGExpIndexLoad%],recTotalTrials%);
            if trialsOK% = 1 then  'Don't bother with loading Stim/Cal file if trials file is bad
                stimOK% := RecLoadStimCalDistractorFile%(recStereoDisGNGStimcalDistractorNameLoad$[recStereoDisGNGExpIndexLoad%],recNSpeakers%,recTotalDistractorStim%);
                if stimOK% = 1 then  'Don't bother with loading S1/S2 Stim/Cal file if distractor one is bad
                    stimOK% := RecLoadStimCalMFCarrierFile%(recStereoDisGNGStimcalNameLoad$[recStereoDisGNGExpIndexLoad%],1,recTotalStim%);  'here, there is only 1 S1/S2 speaker, at least for now
                else
                    stimOK% := -1;  'This is an indicator that the distractor file read failed, as opposed to S1/S2
                endif;
            endif;
            recSelectedStimFile$ := recStereoDisGNGStimcalNameLoad$[recStereoDisGNGExpIndexLoad%];  'var already declared but not used - need to print it to BehOutput*****
            recSelectedStimDistractorFile$ := recStereoDisGNGStimcalDistractorNameLoad$[recStereoDisGNGExpIndexLoad%];  'var already declared but not used - need to print it to BehOutput*****
            recSelectedTrialsFile$ := recStereoDisGNGTrialsNameLoad$[recStereoDisGNGExpIndexLoad%]; 'ditto. for BehOutput
                
            calibOK% := 0;  'Short circuit, this means OK.            
            
        case recExpToRun% = recExpStereoDisButton% and recStereoDisExpDoGNG% = 1 and recStereoDisExpDoGen% = 1 then  'For Stereo Distractor, GNG, generating stimuli
            'Not fully vetted!
            message("StereoDis, GNG, generating trials is not fully vetted!");
            trialsOK% := -1;  'short circuit the rest, go back to exp. selection dialog
            
'            recExptText$ := "Running Stereo Distractor GNG Generating Stims"; 
'            
'            'Get stimfile and trials file lists
'            RecStereoDisGNGExpListGenGetParams(recStereoDisGNGExpNameGen$[],recStereoDisGNGStimNameGen$[],recStereoDisGNGTrialsNameGen$[]);
'            'Load trials file, stim file
'            'trialsOK% := RecLoadTrialsFile22%(recStereoDisGNGTrialsNameLoad$[recStereoDisGNGExpIndexLoad%],recTotalTrials%);
'            trialsOK% := RecLoadTrialsFile9%(recStereoDisGNGTrialsNameGen$[recStereoDisGNGExpIndexGen%],recTotalTrials%);
'            if trialsOK% = 1 then  'Don't bother with loading Stim/Cal file if trials file is bad
'                stimOK% := RecLoadStimFile%(recStereoDisGNGStimNameGen$[recStereoDisGNGExpIndexGen%],recTotalStim%);
'            endif;
'            recSelectedStimFile$ := recStereoDisGNGStimNameGen$[recStereoDisGNGExpIndexGen%];  'var already declared but not used - need to print it to BehOutput*****
'            recSelectedTrialsFile$ := recStereoDisGNGTrialsNameGen$[recStereoDisGNGExpIndexGen%]; 'ditto. for BehOutput
'                
'            calibOK% := 0;  'Short circuit, this means OK. 
            
        endcase;
        
        calibOK% += 1;  'Just getting this into my "standard" 1-is-OK, 0-is-not-OK schema.
        
        'Verify trial/speaker numbers and stimuli if the trials/stim files check out, otherwise jump back to original dialog
        'This IF will not run on experiments that don't have a trials file (e.g. SEARCH, FRA)
        if trialsOK% = 1 and stimOK% = 1 and calibOK% = 1 then
            
            'Make sure that the trials file does not specify more stimuli than are present in the Stim or Stim/Cal file
            if max(recTrialS1%[max(recTrialS1%)],recTrialS2%[max(recTrialS2%)]) <= recTotalStim% then
                printlog("All stimuli in trials file are accounted for in Stim or Stim/Cal file!\n");
            else
                printlog("Maximum stimulus in trials file is %d but not only %d stimuli are specified in Stim or Stim/Cal file!\n",max(recTrialS1%[max(recTrialS1%)],recTrialS2%[max(recTrialS2%)]),recTotalStim%);
                message("Starting Over!|Trials File specifies illegal stimulus number!");
                trialsOK% := -1;
            endif;
            
            'Make sure that the trials file does not specify more speakers than are present in the selected speaker array
            'Use recTrialDur[], recTrialS1Spkr%[], recTrialS2Spkr%[]
            var tempSpeakerCount%;
            if recExpToRun% = recExpStereoDisButton% then  'For this experiment, the arrays are "switched", the S1/S2 stimuli are on the standalone speaker and the distractors are on the array
                tempSpeakerCount% := 1;
            else
                tempSpeakerCount% := recNSpeakers%;
            endif;
            if max(recTrialS1Spkr%[max(recTrialS1Spkr%)],recTrialS2Spkr%[max(recTrialS2Spkr%)]) <= tempSpeakerCount% then
                printlog("All speakers in trials file are present in array!\n");
            else
                printlog("Maximum speaker in trials file is %d but there are only %d speakers in the specified speaker array!\n",max(recTrialS1Spkr%[max(recTrialS1Spkr%)],recTrialS2Spkr%[max(recTrialS2Spkr%)]),tempSpeakerCount%);
                message("Starting Over!|Trials File specifies illegal speaker number!");
                trialsOK% := -1;
            endif;
            
            'Additional checks for StereoDis experiment
            'Make sure that the trials file does not specify more distractor stimuli than are present in the Distractor Stim or Stim/Cal file
            'Do the same for speakers and the speaker array
            'This is only relevant for the "load" version of StereoDis, as the "gen" version has distractors defined in the same stim file as S1/S2 stimuli
            if recExpToRun% = recExpStereoDisButton% and recStereoDisExpDoLoad% = 1 then
                var tempmax%[recMaxDistractor%];
                var iLoop%;
                
                'Can't max a 2-d array, have to loop to get max of each column                
                for iLoop% := 0 to recMaxDistractor%-1 do
                    tempmax%[iLoop%] := recTrialDistractor%[max(recTrialDistractor%[][iLoop%])][iLoop%];
                next

                if tempmax%[max(tempmax%)] <= recTotalDistractorStim% then
                    printlog("All distractor stimuli in trials file are accounted for in Distractor Stim or Stim/Cal file!\n");
                else
                    printlog("Maximum distractor stimulus in trials file is %d but not only %d stimuli are specified in Distractor Stim or Stim/Cal file!\n",tempmax%[max(tempmax%)],recTotalDistractorStim%);
                    message("Starting Over!|Trials File specifies illegal stimulus number!");
                    trialsOK% := -1;
                endif;
                
                'same thing for speaker
                ArrConst(tempmax%[],0);  'reset variable
                for iLoop% := 0 to recMaxDistractor%-1 do
                    tempmax%[iLoop%] := recTrialDistractorSpkr%[max(recTrialDistractorSpkr%[][iLoop%])][iLoop%];
                next
                if tempmax%[max(tempmax%)] <= recNSpeakers% then
                    printlog("All distractor speakers in trials file are present in array!\n");
                else
                    printlog("Maximum distractor speaker in trials file is %d but there are only %d speakers in the specified speaker array!\n",tempmax%[max(tempmax%)],recNSpeakers%);
                    message("Starting Over!|Trials File specifies illegal speaker number!");
                    trialsOK% := -1;
                endif;
            endif;
            
            'Make sure that all the stimuli in the Stim file actually exist, if loading
            if recMatGenStim% = 0 then
                tempglob% := 0;
                for iglob%:=0 to recTotalStim%-1 do
                    if tempglob% = 0 then  'this is because we can't break - and we don't want like 100 messages if all 100 stims don't exist
                        fhglob%:=fileopen(recTrialLoadLoc$[iglob%],9,0);
                        if fhglob%<0 then
                            message("Warning Message | Failed to load at least one stimulus waveform!");
                            printlog("Stim waveform %s failed to load!\n",recTrialLoadLoc$[iglob%]);
                            trialsOK% := -1;
                            'Can't BREAK prior to Spike2 v. 7.0!
                            tempglob% := 1;
                        endif;
                        fileclose();  'Close fhglob%, currently open file
                    endif;
                next;
                if recExpToRun% = recExpStereoDisButton% then  'Check distractors too
                    tempglob% := 0;
                    for iglob%:=0 to recTotalDistractorStim%-1 do
                        if tempglob% = 0 then  'this is because we can't break - and we don't want like 100 messages if all 100 stims don't exist
                            fhglob%:=fileopen(recTrialLoadLocDistractor$[iglob%],9,0);
                            if fhglob%<0 then
                                message("Warning Message | Failed to load at least one distractor stimulus waveform!");
                                printlog("Stim waveform %s failed to load!\n",recTrialLoadLocDistractor$[iglob%]);
                                trialsOK% := -1;
                                'Can't BREAK prior to Spike2 v. 7.0!
                                tempglob% := 1;
                            endif;
                            fileclose();  'Close fhglob%, currently open file
                        endif;
                    next;
                endif;
            endif;
        endif;
        
        
        'Only run the remainder of the experiment if the trials/stim files check out, otherwise jump back to original dialog
        docase
        case trialsOK% = -1 then
            'do nothing, error is already noted above
                        
        case trialsOK% = 0 then
            message("Failed to load trials file!");
            
        case stimOK% = 0 then
            message("Failed to load stim/stimcal file!");
            
        case stimOK% = -1 then
            message("Failed to load distractor stim/stimcal file!");    
            
        case calibOK% = 0 then
            message("Failed to load calibration file to Matlab workspace!");
            
        else
        
            'Run experiment-specific trial list generation
            'Do this prior to running the experiment for all exps
            'Note that recNTrials% will need to be set in all cases; it will need to be arbitrarily huge for Search
            docase 
            case recExpToRun% = recExpLongToneButton% then
                'do Trial List Generation stuff!
                result% := GenTrialsLongTone%();  'Generate trials for Long Tone.  Return result of 1 if OK, 0 if not.  Not sure how it's not OK.
            case recExpToRun% = recExpSearchButton% then
                'do Trial List Generation stuff!
                recSearchLoaded% := 0;  'reset variable to allow PWAs to be loaded only once for SEARCH
                recNTrials% := recMaxTrial%;  'Allow Search to run until experimenter stops it or the variable runs out
                if recDebug% > 0 then
                    recNTrials% := 10; 'testing
                endif;
                result% := GenTrialsSearch%();  'Generate trials for search.  Return result of 1 if OK, 0 if not.
                'recTrialOrder is set in GenTrialsSearch% because it should not be random for tone sweeps
                'note that recTrialOrder will then have to be set for EACH GenTrialsX%() call
                
                'message("SEARCH is not yet implemented!|I GUESS YOU WERE FOOLED!");  'debug placeholder
                
            case recExpToRun% = recExpFRAButton% and recFRALoadStim% = 0 then
                'do Trial List Generation stuff!
                result% := GenTrialsFRA%();  'Generate trials for FRA.  Return result of 1 if OK, 0 if not.
                'message("FRA is not yet implemented!|I GUESS YOU WERE FOOLED!");  'debug placeholder
                
            case recExpToRun% = recExpFRAButton% and recFRALoadStim% = 1 then
                'do Trial List Generation stuff!
                result% := GenTrialsFRALoad%();  'Generate trials for FRA.  Return result of 1 if OK, 0 if not.
                'message("FRA is not yet implemented!|I GUESS YOU WERE FOOLED!");  'debug placeholder
                
            case recExpToRun% = recExpJoyTrnButton% then '*jao
                'do Trial List Generation stuff!
                recSearchLoaded% := 0;  'reset variable to allow PWAs to be loaded only once for SEARCH, or JoyTrain, because all the trials are the same!
                recNTrials% := recMaxTrial%;  'Allow Search to run until experimenter stops it or the variable runs out
                if recDebug% > 0 then
                    recNTrials% := 10; 'testing
                endif;
                result% := GenTrialsJoyTrain%();  'Generate trials for JoyTrain
                '*jao
                
            case recExpToRun% = recExpAMDiscButton% then
                'do Trial List Generation stuff!
                result% := GenTrialsDis%(recExpAMDiscButton%);  'Generate trials for AMDis   '*jao
                'message("AM DISC is not yet implemented!|I GUESS YOU WERE FOOLED!");  'debug placeholder
                
            case recExpToRun% = RecExpSpaceDisButton% then
                'do Trial List Generation stuff!
                printlog("attempting to do run Space dis, calling GenTrialsSpaceDis%()... \n"); '*jao
                result% := GenTrialsDis%(RecExpSpaceDisButton%);  'Generate trials for AMDis   '*jao
                
            case recExpToRun% = recExpCueingButton% then
                'do Trial List Generation stuff!
                message("CUEING is not yet implemented!|I GUESS YOU WERE FOOLED!");  'debug placeholder
                
            case recExpToRun% = recExpAudiogramButton% then
                'do Trial List Generation stuff!
                'message("AUDIOGRAM is not yet implemented!|I GUESS YOU WERE FOOLED!");  'debug placeholder
                result% := GenTrialsAudiogram%();  'Generate trials for Audiogram.  Return result of 1 if OK, 0 if not.
                
            case recExpToRun% = recExpStereoDisButton%  and recStereoDisExpDoFC% = 1 and recStereoDisExpDoLoad% = 1 then
                'do Trial List Generation stuff!
                result% := GenTrialsStereoDis%();  'Generate trials for StereoDis.  Return result of 1 if OK, 0 if not.
                
            case recExpToRun% = recExpStereoDisButton%  and recStereoDisExpDoGNG% = 1 and recStereoDisExpDoLoad% = 1 then
                'do Trial List Generation stuff!
                result% := GenTrialsStereoDisGNG%();  'Generate trials for StereoDis.  Return result of 1 if OK, 0 if not.    
                
            case recExpToRun% = recExpStereoDisButton%  and recStereoDisExpDoFC% = 1 and recStereoDisExpDoGen% = 1 then
                'do Trial List Generation stuff!
                result% := GenTrialsStereoDis%();  'Generate trials for StereoDis.  Return result of 1 if OK, 0 if not.
                
            case recExpToRun% = recExpStereoDisButton%  and recStereoDisExpDoGNG% = 1 and recStereoDisExpDoGen% = 1 then
                'do Trial List Generation stuff!
                'result% := GenTrialsStereoDisGNG%();  'Generate trials for StereoDis.  Return result of 1 if OK, 0 if not. 
                message("GNG StereoDis, generating stimuli is not yet implemented!|I GUESS YOU WERE FOOLED!");  'debug placeholder
                
                
            endcase            
            recLastExpRun% := recExpToRun%; 'i think this should go here; remember the experiment that was just run for the next time around
            'Run presentation engine if CED is present or we are debugging
            if recCEDIsPresent% = 1 or recDebug% > 0 then
                view(recLog%).print("About to call RunGoNoGoEngine%().\n");    
                recReadyToQuit% := RunGoNoGoEngine%();  'will return 1 on fatal error
            endif;
            
            'Upon completion of engine, re-open experiment selection dialog (unless TDT error has occurred)
            'but on TDT error set recReadyToQuit% to 1
            'I don't think there's a lot of clean-up for the TDT.  Matlab clean-up is below, before the Halt
            
        endcase;
        
        
    else
        recReadyToQuit% := 1;  'If "Quit" is pressed on Experiment Selection dialog, then quit! 
    endif;
wend;

'If quit has been pressed on the experiment selection dialog, make sure sampling is stopped
' Stop sampling....
if recCEDIsPresent% = 1 and recCurrentlySampling% = 1 then
    SafeSampleKey("K");  'Kill reward, just in case
    var retVal%;
    retval% := SampleStop();
    printlog("SampleStop returned %d\n",retVal%);
    view(recLog%).print("SampleStop returned %d\n",retVal%);
    if retVal% < 0 then
        printlog("Samplestop error is %s\n",Error$(retVal%));
        view(recLog%).print("Samplestop error is %s\n",Error$(retVal%));
    endif;
    
    View(recDataWindowView%);  'Explicitly set view
'    FileSaveAs(recFileSaveLoc$ + recMonkPrefix$ + ".smr", -1); 'Save data file automagically 
    FileSaveAs(recFileSaveLoc$ + recMonkPrefix$ + "_"+ Date$(2,2,3,3,"-")+ blockTag$ + ".smr", -1); 'NEW FORMAT! add date automagically! 

endif;

CloseMatlab(matlabOpenSuccess%);  'close Matlab if it is open and we are quitting
fileclose(recLog%); 'close recLog!
halt;  'And get out of here!

'================================================================================================
'End Code Execution
'
'



'
'
'Local subfunctions
'================================================================================================




'
'
'===== RecDebugDialog =====

'A dialog used during debugging which allows use to variously "shut off" Matlab/TDT/CED capabilities

func RecDebugDialog%()
    
    var i%;
    var status% := 0;
    var debugLoc$[3];
    
    debugLoc$[0] := "No Debug Logging";
    debugLoc$[1] := "Debug Logging, Rec Lab";
    debugLoc$[2] := "Debug Logging, Jeff in lobby";
    
    ' Fetch parameters from registry    
    RecDebugGetParams();   'RecDebugGetParams() is below    
    
    ' Generate the dialog
    
    DlgCreate("Debug Dialog",0,0,40,8);
    DlgCheck(1, "Matlab is present");
    DlgCheck(2, "TDT is present");
    DlgCheck(3, "CED 1401 is present");
    DlgCheck(4, "Calibration file is present");
    DlgCheck(5, "Do Sound Recording");
    'DlgCheck(6, "Do Debug Logging");
    DlgList(6,30,debugLoc$[],3);
    
    ' Show the dialog. 
    i%:=DlgShow(recMatlabIsPresent%, recTDTIsPresent%, recCEDIsPresent%, recCalibIsPresent%, recSoundRecording%, recDebug%);
    
    ' If user hit OK then save parameters (and return 1). 
	if i% = 1 then
        RecDebugSaveParams();   'ReDebugSaveParams() is below
        if recMatlabIsPresent% = 0 then
            LogInfo("User reports no Matlab present.  Running in testing mode.  Bypassing all Matlab calls.");
        endif
        if recTDTIsPresent% = 0 then
            LogInfo("User reports no TDT present.  Running in testing mode.  Bypassing all TDT calls."); 
        endif
        if recCEDIsPresent% = 0 then
            LogInfo("User reports no 1401 present.  Running in testing mode.  Bypassing all 1401 calls.");
        endif
        status% := 1;
    else
        status% := 0;
    endif
    
	return status%;
   
end;

'===== End RecDebugDialog =====
'
'



'
'
'===== RecDebugGetParams =====

'Fetch Debugging parameters from the registry
proc RecDebugGetParams()
	var key$;
    key$:="Reclab\\DebugParam";
    
    recMatlabIsPresent% := GetIntRegistryValue%(key$, "MatlabIsPresent", recMatlabIsPresent%);
    recTDTIsPresent% := GetIntRegistryValue%(key$, "TDTIsPresent", recTDTIsPresent%);
    recCEDIsPresent% := GetIntRegistryValue%(key$, "CEDIsPresent", recCEDIsPresent%);
    recCalibIsPresent% := GetIntRegistryValue%(key$, "CalibIsPresent", recCalibIsPresent%);
    recSoundRecording% := GetIntRegistryValue%(key$, "SoundRecording", recSoundRecording%);
    recDebug% := GetIntRegistryValue%(key$, "Debug", recDebug%);
    
	return;
end

'===== End RecDebugGetParams =====
'
'



'
'
'===== RecDebugSaveParams =====

'Save Debugging parameters to the registry
proc RecDebugSaveParams()

	var key$;
    key$:="Reclab\\DebugParam";

    SetIntRegistryValue(key$, "MatlabIsPresent", recMatlabIsPresent%);   
    SetIntRegistryValue(key$, "TDTIsPresent", recTDTIsPresent%); 
    SetIntRegistryValue(key$, "CEDIsPresent", recCEDIsPresent%); 
    SetIntRegistryValue(key$, "CalibIsPresent", recCalibIsPresent%); 
    SetIntRegistryValue(key$, "SoundRecording", recSoundRecording%);
    SetIntRegistryValue(key$, "Debug", recDebug%); 
    
	return;
end

'===== End RecDebugSaveParams =====
'
'




'
'
'===== RecSearchGetParams =====

'Fetch Debugging parameters from the registry
proc RecSearchGetParams()
	var key$;
    key$:="Reclab\\SearchParam";
    
    recSearchStimType% := GetIntRegistryValue%(key$, "SearchStimType", recSearchStimType%);
    recSearchToneFreq := GetFloatRegistryValue(key$, "SearchToneFreq", recSearchToneFreq);
    recSearchBPLowerLim := GetFloatRegistryValue(key$, "SearchBPLowerLim", recSearchBPLowerLim);
    recSearchBPUpperLim := GetFloatRegistryValue(key$, "SearcBPUpperLim", recSearchBPUpperLim);
    recSearchSpeakerSweepRepeats% := GetIntRegistryValue%(key$, "recSearchSpeakerSweepRepeats%", recSearchSpeakerSweepRepeats%);
    recSearchToneSweepRepeats% := GetIntRegistryValue%(key$, "SearchToneSweepRepeats", recSearchToneSweepRepeats%);
    recSearchToneSweepLowLim := GetFloatRegistryValue(key$, "SearchToneSweepLowLim", recSearchToneSweepLowLim);
    recSearchToneSweepUpperLim := GetFloatRegistryValue(key$, "SearchToneSweepUpperLim", recSearchToneSweepUpperLim);
    'recSearchToneSweepOctaveStep := GetFloatRegistryValue(key$, "SearchToneSweepOctaveStep", recSearchToneSweepOctaveStep);
    recSearchToneSweepNSteps% := GetIntRegistryValue%(key$, "SearchToneSweepNSteps", recSearchToneSweepNSteps%);
    recSearchS1Speaker% := GetIntRegistryValue%(key$, "SearchS1Speaker", recSearchS1Speaker%);
    recSearchS2Speaker% := GetIntRegistryValue%(key$, "SearchS2Speaker", recSearchS2Speaker%);
    recSearchMinS1% := GetIntRegistryValue%(key$, "SearchMinS1", recSearchMinS1%);
    recSearchVarS1% := GetIntRegistryValue%(key$, "SearchVarS1", recSearchVarS1%);
    recSearchPropCatch := GetFloatRegistryValue(key$, "SearchPropCatch", recSearchPropCatch);
    recSearchdBLevel := GetFloatRegistryValue(key$, "SearchdBLevel", recSearchdBLevel);
    recSearchActive% := GetIntRegistryValue%(key$, "SearchActive", recSearchActive%);
    recSearchFixLED% := GetIntRegistryValue%(key$, "SearchFixLED", recSearchFixLED%);
        
	return;
end

'===== End RecSearchGetParams =====
'
'




'
'
'===== RecSearchSaveParams =====

'Save Debugging parameters to the registry
proc RecSearchSaveParams()

	var key$;
    key$:="Reclab\\SearchParam";

    SetIntRegistryValue(key$, "SearchStimType", recSearchStimType%);
    SetFloatRegistryValue(key$, "SearchToneFreq", recSearchToneFreq);
    SetFloatRegistryValue(key$, "SearchBPLowerLim", recSearchBPLowerLim);
    SetFloatRegistryValue(key$, "SearcBPUpperLim", recSearchBPUpperLim);
    SetIntRegistryValue(key$, "recSearchSpeakerSweepRepeats%", recSearchSpeakerSweepRepeats%);
    SetIntRegistryValue(key$, "SearchToneSweepRepeats", recSearchToneSweepRepeats%);
    SetFloatRegistryValue(key$, "SearchToneSweepLowLim", recSearchToneSweepLowLim);
    SetFloatRegistryValue(key$, "SearchToneSweepUpperLim", recSearchToneSweepUpperLim);
    'SetFloatRegistryValue(key$, "SearchToneSweepOctaveStep", recSearchToneSweepOctaveStep); 
    SetIntRegistryValue(key$, "SearchToneSweepNSteps", recSearchToneSweepNSteps%);
    SetIntRegistryValue(key$, "SearchS1Speaker", recSearchS1Speaker%);
    SetIntRegistryValue(key$, "SearchS2Speaker", recSearchS2Speaker%);
    SetIntRegistryValue(key$, "SearchMinS1", recSearchMinS1%);
    SetIntRegistryValue(key$, "SearchVarS1", recSearchVarS1%);
    SetFloatRegistryValue(key$, "SearchPropCatch", recSearchPropCatch);
    SetFloatRegistryValue(key$, "SearchdBLevel", recSearchdBLevel);
    SetIntRegistryValue(key$, "SearchActive", recSearchActive%);
    SetIntRegistryValue(key$, "SearchFixLED", recSearchFixLED%);

	return;
end

'===== End RecSearchSaveParams =====
'
'




'
'
'===== RecFRAGetParams =====

'Fetch Debugging parameters from the registry
proc RecFRAGetParams()
	var key$;
    key$:="Reclab\\FRAParam";
    
    recFRAS1Speaker% := GetIntRegistryValue%(key$, "FRAS1Speaker", recFRAS1Speaker%);
    recRateLeveldBLow := GetFloatRegistryValue(key$, "RateLeveldBLow", recRateLeveldBLow);
    recRateLeveldBHigh := GetFloatRegistryValue(key$, "RateLeveldBHigh", recRateLeveldBHigh);
    recFRATonedBLow := GetFloatRegistryValue(key$, "FRATonedBLow", recFRATonedBLow);
    recFRATonedBHigh := GetFloatRegistryValue(key$, "FRATonedBHigh", recFRATonedBHigh);
    recFRAToneFreqLow := GetFloatRegistryValue(key$, "FRAToneFreqLow", recFRAToneFreqLow);
    recFRAToneFreqHigh := GetFloatRegistryValue(key$, "FRAToneFreqHigh", recFRAToneFreqHigh);
    recFRAS2dBLevel := GetFloatRegistryValue(key$, "FRAS2dBLevel", recFRAS2dBLevel);  
    recSpaceNRepeats% := GetFloatRegistryValue(key$, "SpaceNRepeats", recSpaceNRepeats%);  
    recS1AMnoiseReps% := GetFloatRegistryValue(key$, "recS1AMnoiseReps", recS1AMnoiseReps%);  
    recFRAMinS1% := GetIntRegistryValue%(key$, "FRAMinS1", recFRAMinS1%);
    recFRAVarS1% := GetIntRegistryValue%(key$, "FRAVarS1", recFRAVarS1%);   
    recRateLevelNRepeats% := GetIntRegistryValue%(key$, "RateLevelNRepeats", recRateLevelNRepeats%);
    recFRANRepeats% := GetIntRegistryValue%(key$, "FRANRepeats", recFRANRepeats%);
    recFRAFMSweepRepeats% := GetIntRegistryValue%(key$, "FRAFMSweepRepeats", recFRAFMSweepRepeats%);
    recFRAFMSweepStart% := GetIntRegistryValue%(key$, "FRAFMSweepStart", recFRAFMSweepStart%);
    recFRAFMSweepEnd% := GetIntRegistryValue%(key$, "FRAFMSweepEnd", recFRAFMSweepEnd%);
    recFRAFMSweepDur1% := GetIntRegistryValue%(key$, "FRAFMSweepDur1", recFRAFMSweepDur1%);
    recFRAFMSweepDur2% := GetIntRegistryValue%(key$, "FRAFMSweepDur2", recFRAFMSweepDur2%);
    recFRAFMSweepDur3% := GetIntRegistryValue%(key$, "FRAFMSweepDur3", recFRAFMSweepDur3%);
    recFRAFMSweepDur4% := GetIntRegistryValue%(key$, "FRAFMSweepDur4", recFRAFMSweepDur4%);
    recFRAFMSweepDur5% := GetIntRegistryValue%(key$, "FRAFMSweepDur5", recFRAFMSweepDur5%);
    recFRAActive% := GetIntRegistryValue%(key$, "recFRAActive", recFRAActive%);
    recFRAExpIndexLoad% := GetIntRegistryValue%(key$, "FRAExpIndexLoad", recFRAExpIndexLoad%);
	return;
end

'===== End RecFRAGetParams =====
'
'



'
'
'===== RecFRASaveParams =====

'Fetch Debugging parameters from the registry
proc RecFRASaveParams()
	var key$;
    key$:="Reclab\\FRAParam";
    
    SetIntRegistryValue(key$, "FRAS1Speaker", recFRAS1Speaker%);
    SetFloatRegistryValue(key$, "RateLeveldBLow", recRateLeveldBLow);
    SetFloatRegistryValue(key$, "RateLeveldBHigh", recRateLeveldBHigh);
    SetFloatRegistryValue(key$, "FRATonedBLow", recFRATonedBLow);
    SetFloatRegistryValue(key$, "FRATonedBHigh", recFRATonedBHigh);
    SetFloatRegistryValue(key$, "FRAToneFreqLow", recFRAToneFreqLow);
    SetFloatRegistryValue(key$, "FRAToneFreqHigh", recFRAToneFreqHigh);
    SetFloatRegistryValue(key$, "FRAS2dBLevel", recFRAS2dBLevel);   
    SetFloatRegistryValue(key$, "SpaceNRepeats", recSpaceNRepeats%); 
    SetFloatRegistryValue(key$, "recS1AMnoiseReps", recS1AMnoiseReps%);  
    SetIntRegistryValue(key$, "FRAMinS1", recFRAMinS1%);
    SetIntRegistryValue(key$, "FRAVarS1", recFRAVarS1%); 
    SetIntRegistryValue(key$, "RateLevelNRepeats", recRateLevelNRepeats%);
    SetIntRegistryValue(key$, "FRANRepeats", recFRANRepeats%);
    SetIntRegistryValue(key$, "FRAFMSweepRepeats", recFRAFMSweepRepeats%);
    SetIntRegistryValue(key$, "FRAFMSweepStart", recFRAFMSweepStart%);
    SetIntRegistryValue(key$, "FRAFMSweepEnd", recFRAFMSweepEnd%);
    SetIntRegistryValue(key$, "FRAFMSweepDur1", recFRAFMSweepDur1%);
    SetIntRegistryValue(key$, "FRAFMSweepDur2", recFRAFMSweepDur2%);
    SetIntRegistryValue(key$, "FRAFMSweepDur3", recFRAFMSweepDur3%);
    SetIntRegistryValue(key$, "FRAFMSweepDur4", recFRAFMSweepDur4%);
    SetIntRegistryValue(key$, "FRAFMSweepDur5", recFRAFMSweepDur5%);
    SetIntRegistryValue(key$, "recFRAActive", recFRAActive%);
    SetIntRegistryValue(key$, "FRAExpIndexLoad", recFRAExpIndexLoad%);
	return;
end

'===== End RecFRASaveParams =====
'
'


'
'===== FRALoadSaveParams =====

'Fetch Debugging parameters from the registry
proc RecFRALoadSaveParams()
	var key$;
    key$:="Reclab\\FRAParam";
    
    SetIntRegistryValue(key$, "FRAExpIndexLoad", recFRAExpIndexLoad%); 
    
	return;
end

'===== End RecAMDiscSaveParams =====
'
'
'
'===== RecFRALoadGetParams =====

'Fetch Debugging parameters from the registry
proc RecFRALoadGetParams()
	var key$;
    key$:="Reclab\\FRAParam";
    
    recFRAExpIndexLoad% := GetIntRegistryValue%(key$, "FRAExpIndexLoad", recFRAExpIndexLoad%);   
	return;
end

'===== End RecFRALoadGetParams =====
'
'

'
'
'===== RecAMDiscGetParams =====

'Fetch Debugging parameters from the registry
proc RecAMDiscGetParams()
	var key$;
    key$:="Reclab\\AMDiscParam";
    
    recAMDiscS1Speaker% := GetIntRegistryValue%(key$, "AMDiscS1Speaker", recAMDiscS1Speaker%);
    recAMDiscMinS1% := GetIntRegistryValue%(key$, "AMDiscMinS1", recAMDiscMinS1%);
    recAMDiscVarS1% := GetIntRegistryValue%(key$, "AMDiscVarS1", recAMDiscVarS1%);
    recAMDiscPropCatch := GetFloatRegistryValue(key$, "AMDiscPropCatch", recAMDiscPropCatch);
    recAMDiscdBLevel := GetFloatRegistryValue(key$, "AMDiscdBLevel", recAMDiscdBLevel);
    recAMDiscRepeatsPerStim% := GetIntRegistryValue%(key$, "AMDiscRepeatsPerStim", recAMDiscRepeatsPerStim%);
    recAMDiscMatGenStim% := GetIntRegistryValue%(key$, "AMDiscMatGenStim", recAMDiscMatGenStim%);
    recAMDiscExpIndexGen% := GetIntRegistryValue%(key$, "AMDiscExpIndexGen", recAMDiscExpIndexGen%);
    recAMDiscExpIndexLoad% := GetIntRegistryValue%(key$, "AMDiscExpIndexLoad", recAMDiscExpIndexLoad%);   
    recAMDiscTrialInitReward% := GetIntRegistryValue%(key$, "TrialInitReward", recAMDiscTrialInitReward%);
    recAMDiscTrialHoldReward% := GetIntRegistryValue%(key$, "TrialHoldReward", recAMDiscTrialHoldReward%);
    'recTrainingRewardmL := GetIntRegistryValue%(key$, "TrainingRewardmL", recTrainingRewardmL);
    recAMSPPassiveTask% := GetIntRegistryValue%(key$, "AMSPPassiveTask", recAMSPPassiveTask%);

	return;
end

'===== End RecAMDiscGetParams =====
'
'



'
'
'===== RecAMDiscSaveParams =====

'Fetch Debugging parameters from the registry
proc RecAMDiscSaveParams()
	var key$;
    key$:="Reclab\\AMDiscParam";
    
    SetIntRegistryValue(key$, "AMDiscS1Speaker", recAMDiscS1Speaker%);
    SetIntRegistryValue(key$, "AMDiscMinS1", recAMDiscMinS1%);
    SetIntRegistryValue(key$, "AMDiscVarS1", recAMDiscVarS1%);
    SetFloatRegistryValue(key$, "AMDiscPropCatch", recAMDiscPropCatch);
    SetFloatRegistryValue(key$, "AMDiscdBLevel", recAMDiscdBLevel);
    SetIntRegistryValue(key$, "AMDiscRepeatsPerStim", recAMDiscRepeatsPerStim%);
    SetIntRegistryValue(key$, "AMDiscMatGenStim", recAMDiscMatGenStim%);
    SetIntRegistryValue(key$, "AMDiscExpIndexGen", recAMDiscExpIndexGen%);
    SetIntRegistryValue(key$, "AMDiscExpIndexLoad", recAMDiscExpIndexLoad%);
    SetIntRegistryValue(key$, "TrialInitReward", recAMDiscTrialInitReward%);
    SetIntRegistryValue(key$, "TrialHoldReward", recAMDiscTrialHoldReward%);
    'SetIntRegistryValue(key$, "TrainingRewardmL", recTrainingRewardmL);
    SetIntRegistryValue(key$, "AMSPPassiveTask", recAMSPPassiveTask%);
    
	return;
end

'===== End RecAMDiscSaveParams =====
'
'


'
'
'===== RecSpaceDisGetParams =====

'Fetch Debugging parameters from the registry
proc RecSpaceDisGetParams()
	var key$;
    key$:="Reclab\\SpaceDisParam";
    
'    recAMDiscS1Speaker% := GetIntRegistryValue%(key$, "SpaceDisS1Speaker", recASpaceDisSpeaker%);
    recSpaceDisMinS1% := GetIntRegistryValue%(key$, "SpaceDisMinS1", recSpaceDisMinS1%);
    recSpaceDisVarS1% := GetIntRegistryValue%(key$, "SpaceDisVarS1", recSpaceDisVarS1%);
    recSpaceDisPropCatch := GetFloatRegistryValue(key$, "SpaceDisPropCatch", recSpaceDisPropCatch);
    recSpaceDisdBLevel := GetFloatRegistryValue(key$, "SpaceDisdBLevel", recSpaceDisdBLevel);
    recSpaceDisRepeatsPerStim% := GetIntRegistryValue%(key$, "SpaceDisRepeatsPerStim", recSpaceDisRepeatsPerStim%);
    recSpaceDisMatGenStim% := GetIntRegistryValue%(key$, "SpaceDisMatGenStim", recSpaceDisMatGenStim%);
    recSpaceDisExpIndexGen% := GetIntRegistryValue%(key$, "SpaceDisExpIndexGen", recSpaceDisExpIndexGen%);
    recSpaceDisExpIndexLoad% := GetIntRegistryValue%(key$, "SpaceDisExpIndexLoad", recSpaceDisExpIndexLoad%);   
    recSpaceDisTrialInitReward% := GetIntRegistryValue%(key$, "TrialInitReward", recSpaceDisTrialInitReward%);
    recSpaceDisTrialHoldReward% := GetIntRegistryValue%(key$, "TrialHoldReward", recSpaceDisTrialHoldReward%);
    'recTrainingRewardmL := GetIntRegistryValue%(key$, "TrainingRewardmL", recTrainingRewardmL);
    recAMSPPassiveTask% := GetIntRegistryValue%(key$, "AMSPPassiveTask", recAMSPPassiveTask%);

	return;
end

'===== End RecSpaceDisGetParams =====
'
'



'
'
'===== RecSpaceDisSaveParams =====

'Fetch Debugging parameters from the registry
proc RecSpaceDisSaveParams()
	var key$;
    key$:="Reclab\\SpaceDisParam";
    
'    SetIntRegistryValue(key$, "SpaceDisS1Speaker", recSpaceDisS1Speaker%);
    SetIntRegistryValue(key$, "SpaceDisMinS1", recSpaceDisMinS1%);
    SetIntRegistryValue(key$, "SpaceDisVarS1", recSpaceDisVarS1%);
    SetFloatRegistryValue(key$, "SpaceDisPropCatch", recSpaceDisPropCatch);
    SetFloatRegistryValue(key$, "SpaceDisdBLevel", recSpaceDisdBLevel);
    SetIntRegistryValue(key$, "SpaceDisRepeatsPerStim", recSpaceDisRepeatsPerStim%);
    SetIntRegistryValue(key$, "SpaceDisMatGenStim", recSpaceDisMatGenStim%);
    SetIntRegistryValue(key$, "SpaceDisExpIndexGen", recSpaceDisExpIndexGen%);
    SetIntRegistryValue(key$, "SpaceDisExpIndexLoad", recSpaceDisExpIndexLoad%);
    SetIntRegistryValue(key$, "TrialInitReward", recSpaceDisTrialInitReward%);
    SetIntRegistryValue(key$, "TrialHoldReward", recSpaceDisTrialHoldReward%);
    'SetIntRegistryValue(key$, "TrainingRewardmL", recTrainingRewardmL);  
    SetIntRegistryValue(key$, "AMSPPassiveTask", recAMSPPassiveTask%);

	return;
end

'===== End RecSpaceDisSaveParams =====
'
'


'
'===== RecStereoDisSaveParams =====

'Fetch Debugging parameters from the registry
proc RecStereoDisSaveParams()
	var key$;
    key$:="Reclab\\HumanFCParam";  'renamed experiment from HumanFC to StereoDis, just keep old name for registry, it's easier
    
    SetIntRegistryValue(key$, "HumanFCExpIndexLoad", recStereoDisExpIndexLoad%); 
    SetIntRegistryValue(key$, "HumanFCRepeatsPerStim", recStereoDisRepeatsPerStim%);
    SetIntRegistryValue(key$, "StereoDisExpDoFC", recStereoDisExpDoFC%);
    SetIntRegistryValue(key$, "StereoDisExpDoGen", recStereoDisExpDoGen%);
    
    
	return;
end

'===== End RecStereoDisSaveParams =====
'
'
'
'===== RecStereoDisGetParams =====

'Fetch Debugging parameters from the registry
proc RecStereoDisGetParams()
	var key$;
    key$:="Reclab\\HumanFCParam";  'renamed experiment from HumanFC to StereoDis, just keep old name for registry, it's easier
    
    recStereoDisExpIndexLoad% := GetIntRegistryValue%(key$, "HumanFCExpIndexLoad", recStereoDisExpIndexLoad%); 
    recStereoDisRepeatsPerStim% := GetIntRegistryValue%(key$, "HumanFCRepeatsPerStim", recStereoDisRepeatsPerStim%);
    recStereoDisExpDoFC% := GetIntRegistryValue%(key$, "StereoDisExpDoFC", recStereoDisExpDoFC%);
    recStereoDisExpDoGen% := GetIntRegistryValue%(key$, "StereoDisExpDoGen", recStereoDisExpDoGen%);
    
	return;
end

'===== End RecStereoDisGetParams =====
'
'


'
'===== RecStereoDisGNGSaveParams =====

'Fetch Debugging parameters from the registry
proc RecStereoDisGNGSaveParams()
	var key$;
    key$:="Reclab\\StereoDisParam";  
    
    SetIntRegistryValue(key$, "StereoDisGNGExpIndexLoad", recStereoDisGNGExpIndexLoad%); 
    SetIntRegistryValue(key$, "StereoDisGNGRepeatsPerStim", recStereoDisGNGRepeatsPerStim%);
    SetIntRegistryValue(key$, "StereoDisExpDoGNG", recStereoDisExpDoGNG%);
    
	return;
end

'===== End RecStereoDisGNGSaveParams =====
'
'
'
'===== RecStereoDisGNGGetParams =====

'Fetch Debugging parameters from the registry
proc RecStereoDisGNGGetParams()
	var key$;
    key$:="Reclab\\StereoDisParam";  
    
    recStereoDisGNGExpIndexLoad% := GetIntRegistryValue%(key$, "StereoDisGNGExpIndexLoad", recStereoDisGNGExpIndexLoad%); 
    recStereoDisGNGRepeatsPerStim% := GetIntRegistryValue%(key$, "StereoDisGNGRepeatsPerStim", recStereoDisGNGRepeatsPerStim%);   
    recStereoDisExpDoGNG% := GetIntRegistryValue%(key$, "StereoDisExpDoGNG", recStereoDisExpDoGNG%);
    
	return;
end

'===== End RecStereoDisGNGGetParams =====
'
'



'
'===== RecExpSelectDialogSaveParams =====

'Fetch Debugging parameters from the registry
proc RecExpSelectDialogSaveParams()
	var key$;
    key$:="Reclab\\ExpSelectDialog";
    
    SetIntRegistryValue(key$, "DoNotShuffle", recDoNotShuffle%); 
    SetIntRegistryValue(key$, "TurnOffReward", recTurnOffReward%);
    SetIntRegistryValue(key$, "NBAKs", recNBAKs%);
    
	return;
end

'===== RecExpSelectDialogSaveParams =====
'
'
'
'===== RecExpSelectDialogGetParams =====

'Fetch Debugging parameters from the registry
proc RecExpSelectDialogGetParams()
	var key$;
    key$:="Reclab\\ExpSelectDialog";
    
    recDoNotShuffle% := GetIntRegistryValue%(key$, "DoNotShuffle", recDoNotShuffle%); 
    recTurnOffReward% := GetIntRegistryValue%(key$, "TurnOffReward", recTurnOffReward%); 
    recNBAKs% := GetIntRegistryValue%(key$, "NBAKs", recNBAKs%);    
    
	return;
end

'===== End RecExpSelectDialogGetParams =====
'
'



'
'
'===== RecExpSelectDialog =====

'A dialog which allows the selection of experiments

func RecExpSelectDialog%()
    
    var i%;
    var j%;
    var status% := 0;  
    var spkArr$[4];
    var levText$;
    spkArr$[0] := "None";
    spkArr$[1] := "15";
    spkArr$[2] := "16";
    spkArr$[3] := "Standalone";
    
    RecExpSelectDialogGetParams();
    
    recExpSelectDialogAllowOK% := 0;  'Disable OK button to start, force selection of experiment
    
    'get the LeverJoystick parameters so we know whether the Joystick or Lever is initially selected
    RecLeverJoystickGetParams();    
    if recUseJoystick% = 0 then
        levText$ := "    Lever Selected     ";
    else
        levText$ := "  Joystick Selected    ";
    endif;

    'Just DO this, even if we're not using the joystick.  Because I want it to just work.
    GetJoystickDegreesInVoltage(joystickVoltageConversionFactor);

    ' Generate the dialog
    
    DlgCreate("Experiment Selection Dialog",0,0,52,17);
    
    DlgGroup("Experimental Details", 1,1,50,7);
    DlgString(1,"Monkey Name",10,"",17,2);  'currently no "legal" specified, meaning all characters OK
    DlgText("File suffix letter",32,2); DlgString(6,"|e.g., a,b,c,d...",2,"",46,2);  'currently no "legal" specified, meaning all characters OK; max 2chars
    DlgInteger(2,"Number of electrodes (0 for behavioral)",-1,21,0,3); 
    DlgInteger(3,"Number of BAKs",0,2,0,4);
    DlgList(4,"Speaker array, first (left) PA4",spkArr$[],10,0,5);
    DlgList(5,"Speaker array, second (right) PA4",spkArr$[],10,0,6);
    
    DlgGroup("Experiments", 1,8,50,6);
    DlgButton(0,"         Quit         ");
    DlgButton(1,"          OK          ");
    DlgButton(recExpSearchButton%, "              Search              ", RecExpSearchDialog%, 2, 9);
    DlgButton(recExpFRAButton%,    "  FRA/Rate-level/Space  ", RecExpFRADialog%, 2, 10);
    DlgButton(recExpAMDiscButton%, "            AM Disc.           ", RecExpAMDiscDialog%, 26, 9);
    DlgButton(recExpSpaceDisButton%, "          Space Disc          ", RecExpSpaceDisDialog%, 26, 10);
    DlgButton(recExpCueingButton%, "             Cueing             ", RecExpCueingDialog%, 26, 11);
    DlgButton(recExpJoyTrnButton%,    " Joy Train (no stimulus)  ", RecJoyTrainDialog%, 2, 11); 'will go under FRA button '*jao
    DlgButton(recExpAudiogramButton%, "           Audiogram           ", RecAudiogramDialog%, 2, 12);  
    DlgButton(recExpStereoDisButton%, "     Stereo Distractor     ", RecExpStereoDisDialog%, 26, 12);
    DlgButton(recExpLongToneButton%, "           Long Tone           ", RecLongToneDialog%, 2, 13); 
    
    'DlgGroup("Change Timing/Reward Parameters", 1,13,50,2);
    DlgButton(recExpTimingRewardButton%, "   Timing/Reward    ", RecExpTimingRewardDialog%, 2, 7);
    DlgButton(recLeverJoystickButton%, levText$, RecExpLeverJoystickDialog%, 30, 7);
    
    DlgCheck(7,"Do Not Shuffle Stimuli",2,14);
    DlgCheck(8,"Turn Off Reward",2,15);
    
    DlgAllow(0xffff, 0, RecExpSelectDialogChanged%);
    
    ' Show the dialog. 
    i%:=DlgShow(recMonkPrefix$,recNElectrodes%,recNBAKs%,recSpeakerArrayIndex%,recSpeakerArrayIndex2%,blockTag$,recDoNotShuffle%,recTurnOffReward%);  'no items
    
    ' If user hit OK then save parameters (and return 1). 
	if i% = 1 then
        
        'Assign speaker number, old single PA4 version
'        docase
'        case recSpeakerArrayIndex% = 1 then
'            recNSpeakers% := 15;
'        case recSpeakerArrayIndex% = 2 then
'            recNSpeakers% := 16;
'        case recSpeakerArrayIndex% = 3 then
'            recNSpeakers% := 11;  %11-speaker array does not actually exist
'        endcase;
        
        'Assign speaker number and PA4 variables.  This is more complicated since the addition of a second PA4.
        'Speaker number has to be either 15 or 16, we do not have any scenarios which currently allow ONLY the
        'standalone speaker, nor any that allow two arrays, so recNSpeakers% applies to the main array, of which
        'there must be exactly one.
        docase
        case recSpeakerArrayIndex% = 1 or recSpeakerArrayIndex2% = 1 then  'both cannot be 1 due to the DlgAllow function
            recNSpeakers% := 15;
        case recSpeakerArrayIndex% = 2 or recSpeakerArrayIndex2% = 2 then  'both cannot be 2 due to the DlgAllow function
            recNSpeakers% := 16; 
        endcase;
        
        'Assign PA4 variables
        docase
        case recSpeakerArrayIndex% = 1 or recSpeakerArrayIndex% = 2 then
            arrayPA4ID% := xlnFirstPA4%;
        case recSpeakerArrayIndex2% = 1 or recSpeakerArrayIndex2% = 2 then
            arrayPA4ID% := xlnSecondPA4%;
        else
            message("Whoa! There does not appear to be an array selected and you should not have gotten this far!");
            halt;
        endcase
        
        docase 
        case recSpeakerArrayIndex% = 3 then
            standalonePA4ID% := xlnFirstPA4%;
        case recSpeakerArrayIndex2% = 3 then
            standalonePA4ID% := xlnSecondPA4%;
        else
            standalonePA4ID% := -1;  'No standalone PA4
        endcase
        'So now we have assigned recNSpeakers% to work as it always has, and two PA4IDs to be used when calling RecAttenByID%()
        
        RecExpSelectDialogSaveParams();
        
        status% := 1;
    else
        status% := 0;
    endif
    
	return status%;
   
end;

'===== End RecExpSelectDialog =====
'
'




'
'
'===== RecExpSelectDialogChanged =====

' This function is initially called with a "0" input
func RecExpSelectDialogChanged%(item%) 
    var levText$;
    var speakersOK% := 0;
    
    'Identifying legal speaker setups
    'Basically, at least one must be an array, they can't both be arrays
    docase
    case (DlgValue(4) = 1 or DlgValue(4) = 2) and (DlgValue(5) = 0 or DlgValue(5) = 3) then
        speakersOK% := 1;
    case (DlgValue(5) = 1 or DlgValue(5) = 2) and (DlgValue(4) = 0 or DlgValue(4) = 3) then
        speakersOK% := 1;    
    endcase
    'If a standalone is requested for the wrong experiment, the easiest thing to do is ignore it (but an error would be nice)
    
    
    'This disables the "OK" button (though it will have different labels) until an experiment is selected
    'AND a file name is chosen AND a number of electrodes is entered AND the speaker array selection is legal
    
    'if recExpSelectDialogAllowOK% = 1 and len(DlgValue$(1)) > 0 and DlgValue(2) > -1 and DlgValue(3) > 0 then
    if recExpSelectDialogAllowOK% = 1 and len(DlgValue$(1)) > 0 and DlgValue(2) > -1 and speakersOK% = 1 then
        DlgEnable(1,-1);  'enable "OK" 
    else
        DlgEnable(0,-1);  'Otherwise disable "OK"
    endif;
    
    'change button text based on selected response device
    if recUseJoystick% = 0 then
        levText$ := "    Lever Selected     ";
    else
        levText$ := "  Joystick Selected    ";
    endif;
    DlgValue$(-recLeverJoystickButton%, levText$);
    
    return 1;
end

'===== End RecExpSelectDialogChanged =====
'
'



'
'
'===== RecExpSearchDialog =====

'A dialog for the Search experiment

func RecExpSearchDialog%()
    
    var i%;
    var status% := 0;
    var inds%[10];
    var j%;
    for j% := 0 to 9 do
        inds%[j%] := j%;
    next;
    
    const searchListLen% := 6;
    var searchList$[searchListLen%];
    searchList$[0] := "Tones";
    searchList$[1] := "Broadband Noise";
    searchList$[2] := "Bandpass Noise";
    searchList$[3] := "Clicks";
    searchList$[4] := "Tone Sweeps";
    searchList$[5] := "Speaker Sweep (BbN)";
    
    ' Fetch parameters from registry    
    RecSearchGetParams();
    if recSearchStimType% = 4 then
        ' Initial calculation of dB steps for tone sweeps
        GetLogProgression(recSearchToneSweepLowLim, recSearchToneSweepUpperLim, recSearchToneSweepNSteps%-1, recSearchToneSweepFreqList[]);   
        ' Followed by initial stringification
        recSearchToneSweepFreqList$ := StringifyProgression2$(recSearchToneSweepNSteps%, recSearchToneSweepFreqList[0:recSearchToneSweepNSteps%], inds%[],0);
    else
        recSearchToneSweepFreqList$ := ""; 'Start with empty text if not doing tone sweeps
    endif;
    

    ' Generate the dialog    
    DlgCreate("Search Dialog",0,0,92,16);
    
    DlgGroup("Stimulus Selection",1,1,90,7);
    DlgList(1,"Select Experiment",searchList$[],searchListLen%,19,2);  '19 is min width for this dialog
    
    DlgGroup("Tones",40,2,22,2);
    DlgReal(2,6,0.001,50000,55,3);  'Frequency
    DlgText("Frequency, Hz",41,3);
    
    DlgGroup("Band Pass Noise",40,4,22,3);
    DlgReal(3,6,0,49999,55,5);  'BP lower limit
    DlgText("Lower Limit, Hz",41,5);
    DlgReal(4,6,0.001,50000,55,6);  'BP upper limit
    DlgText("Upper Limit, Hz",41,6);
    
    DlgText("Repeats for speaker sweep:",2,4);
    DlgInteger(17,3,1,10,27,4);

    DlgGroup("Tone Sweep",63,2,27,5);
    DlgInteger(5,6,1,100,83,3);  'Tone sweep repeats
    DlgText("Repeats of each tone",64,3);
    DlgReal(6,6,0.001,49999,83,4);  'Tone sweep low freq
    DlgText("Low Frequency, Hz",64,4);
    DlgReal(7,6,0.002,50000,83,5);  'Tone sweep high freq
    DlgText("High Frequency, Hz",64,5);
    DlgInteger(8,6,2,10,83,6);  'Tone sweep number of steps
    DlgText("Number of Steps",64,6);
    
    DlgText("Tone Sweep Steps:",2,7);
    recSearchToneSweepFreqList% := DlgText(recSearchToneSweepFreqList$,18,7,50);
    
    
    DlgGroup("Variables",1,9,90,6);
    DlgInteger(9,6,0,20,55,10);  'S1 speaker
    DlgText("S1 Speaker",41,10);
    DlgInteger(10,6,0,20,83,10);  'S2 speaker
    DlgText("S2 Speaker",64,10);
    
    ' djs 7/19/2018 Change min allowed value to 2 here. 
    ' Program logic converts this to an index, and tests the value of the stim index AFTER it has been incremented. 
    ' The test is equality, so if the var here is 1, the index is 0, and the first time the test is performed 
    ' (see RecGoNoGoEngine.s2s, line 1098)
    
    DlgInteger(11,6,2,19,55,11);  'Min S1
    DlgText("Minimum S1 Presentations",30,11);
    DlgInteger(12,6,0,19,55,12);  'Var S1
    DlgText("Variable S1 Presentations",30,12);
    DlgReal(13,6,0,1,55,13);  'Proportion of catch trials
    DlgText("Proportion of Catch Trials",30,13);
    DlgReal(14,6,0,100,83,12);  'dB level
    DlgText("dB Level",64,12);
    DlgCheck(15,"",54,14);  'Monkey does lever task
    DlgText("Monkey Does Lever Task",30,14);
    DlgCheck(16,"",82,14);  'Use Fixation LED
    DlgText("Use Fixation LED",64,14);
    
    
    DlgAllow(0xffff, 0, RecExpSearchDialogChanged%);
    
    ' Show the dialog. 
    i%:=DlgShow(recSearchStimType%,recSearchToneFreq,recSearchBPLowerLim,recSearchBPUpperLim,recSearchToneSweepRepeats%,
                recSearchToneSweepLowLim,recSearchToneSweepUpperLim,recSearchToneSweepNSteps%,recSearchS1Speaker%,
                recSearchS2Speaker%,recSearchMinS1%,recSearchVarS1%,recSearchPropCatch,recSearchdBLevel,
                recSearchActive%,recSearchFixLED%, recSearchSpeakerSweepRepeats%);
    
    ' If user hit OK then save parameters (and return 1). 
	if i% = 1 then 
        RecSearchSaveParams();
        recExptText$ := searchList$[recSearchStimType%];  'this puts the stimulus type into the values which will be SampleText'ed
        if recSearchMinS1% + recSearchVarS1% <= recMaxStimPerTrial%-1 then
            'Reset dialog OK button text on Select dialog, and note which experiment to run
            DlgValue$(-1,"Run Search");
            DlgEnable(1,3);  'make sure that the Nspeakers selection item is enabled on the main dialog
            recExpToRun% := recExpSearchButton%;
            recExpSelectDialogAllowOK% := 1;  'Prepare to enable OK button
            recExpSelectDialogChanged%(-1);  'Enables "OK" button, -1 is sham input
        
            'assign Search-specific variables to experiment-wide variables (so we can keep separate defaults but only code once)
            recS1Speaker% := recSearchS1Speaker%;
            recS2Speaker% := recSearchS2Speaker%;
            recMinS1% := recSearchMinS1%;
            recVarS1% := recSearchVarS1%;
            recPropCatch := recSearchPropCatch;
            recDeltadBLevel := 65-recSearchdBLevel;
            recActive% := recSearchActive%;
            recFixLED% := recSearchFixLED%;
            if recSearchStimType% >= 4 then  'adjustment of values - if doing tone sweep or speaker sweep, do not have task
                recActive% := 0;
                recHitRewardmL := 0;  'don't allow rewards for tone sweep or speaker sweep
                recCRRewardmL := 0;
            endif;
            if recActive% = 0 then 'adjustment of values, if not active, don't have second speaker or catch trials
                recPropCatch := 0;
                recS2Speaker% := recS1Speaker%;
            endif;
            recMatGenStim% := 1; 'Always generate stimuli during Search
            
            'fill stimulus creation variables as if we had loaded a stimfile
            'do indices 0 and 1 because if the S2 is on a different speaker, it has to have a different calibration value, index 1 is the S2
            arrconst(recTrialDur[0:2],200);              'Trial duration, hard code to 200 for all except 50 for tone sweeps
            arrconst(recTrialGenRampMS[0:2],2);          'Duration in ms of front/back ramp, ramp is 1-Cos^2
            'A bunch of stuff we're just not using in Search
            arrconst(recTrialGenIsSweep%[0:2],0);        'A list of whether each element is an FM sweep, if 0 no sweep
            arrconst(recTrialGenAMFreqHz[0:2],0);        'A list of AM frequency values, if 0 no AM
            arrconst(recTrialGenAMDepthPct[0:2],0);      'A list of AM depth values in percent, if 0 no depth
            arrconst(recTrialGenAMPhaseDeg[0:2],0);      'A list of AM phases, 0 = AM starts low, 90 = AM starts middle and rising, 180 = AM starts high, 270 = AM starts middle, falling
            arrconst(recTrialGenTonePhaseDeg[0:2],0);    'A list of tone phases, 0 = tone starts middle, rising (sine phase), 90 = tone starts high (cosine phase), note different than AM phase, only used for tone, not noise
            arrconst(recTrialGenGauss%[0:2],1);          'If 1 create Gaussian noise, if 0 create uniform noise
            arrconst(recTrialGenSeed%[0:2],0);           'Seed for random number generator, 0 = unspecified, will make own random number
            docase
            case recSearchStimType% = 0 then 'for tones
                arrconst(recTrialGenLowpassHz[0:2],recSearchToneFreq);       'A list of lowpass values - if -1, no lowpass, same as highpass means tone
                arrconst(recTrialGenHighpassHz[0:2],recSearchToneFreq);      'Same as above, highpass
                printlog("Tone (%f Hz) selected from search dialog\n",recSearchToneFreq);
            case recSearchStimType% = 1 then 'for broadband noise
                arrconst(recTrialGenLowpassHz[0:2],-1);       'A list of lowpass values - if -1, no lowpass, same as highpass means tone
                arrconst(recTrialGenHighpassHz[0:2],-1);      'Same as above, highpass
                printlog("Broadband noise selected from search dialog\n");
            case recSearchStimType% = 2 then 'for bandpass noise
                printlog("Bandpass noise (%f - %f Hz) selected from search dialog\n",recSearchBPLowerLim,recSearchBPUpperLim);
                if recSearchBPLowerLim = 0 then  'reclab_panstim expects -1 for no limit
                    recSearchBPLowerLim := -1;
                endif;
                if recSearchBPUpperLim = 50000 then  'reclab_panstim expects -1 for no limit
                    recSearchBPUpperLim := -1;
                endif;
                arrconst(recTrialGenLowpassHz[0:2],recSearchBPLowerLim);       'A list of lowpass values - if -1, no lowpass, same as highpass means tone
                arrconst(recTrialGenHighpassHz[0:2],recSearchBPUpperLim);      'Same as above, highpass
            case recSearchStimType% = 3 then  'for clicks, we won't use anything, just leave a note
                printlog("Clicks selected from search dialog\n");
            case recSearchStimType% = 4 then  'for tone sweeps
                'arrconst(recTrialDur[0:recSearchToneSweepNSteps%],50);
                arrconst(recTrialDur[0:recSearchToneSweepNSteps%],200);
                'get the log progression with the new values
                GetLogProgression(recSearchToneSweepLowLim, recSearchToneSweepUpperLim, recSearchToneSweepNSteps%-1, recSearchToneSweepFreqList[]);            
                'GetLinearProgression(recSearchToneSweepLowLim, recSearchToneSweepUpperLim, recSearchToneSweepNSteps%-1, recSearchToneSweepFreqList[]);
                for j% := 0 to recSearchToneSweepNSteps%-1 do
                    recTrialGenLowpassHz[j%] := recSearchToneSweepFreqList[j%];
                    recTrialGenHighpassHz[j%] := recSearchToneSweepFreqList[j%];
                    recTrialGenRampMS[j%] := 2;
                next
                printlog("Tone Sweep selected from search dialog, %d repeats\n",recSearchToneSweepRepeats%); 'n repeats of each tone
                printlog("Tone Sweep Progression is %d Hz\n",recSearchToneSweepFreqList[0:recSearchToneSweepNSteps%]);
            case recSearchStimType% = 5 then 'for speaker sweeps (broadband noise)
                arrconst(recTrialGenLowpassHz[0:2],-1);       'A list of lowpass values - if -1, no lowpass, same as highpass means tone
                arrconst(recTrialGenHighpassHz[0:2],-1);      'Same as above, highpass
                printlog("Speaker sweep (Broadband noise) selected from search dialog %d repeats\n", recSearchSpeakerSweepRepeats%);                
            endcase
            
        else
            message("The number of variable + constant S1s is greater than the maximum allowed number (%d)",recMaxStimPerTrial%-1);
            DlgValue$(-1,"OK");
            recExpSelectDialogAllowOK% := 0;  'Prepare to disable OK button
            recExpSelectDialogChanged%(-1);  'Enables "OK" button, -1 is sham input
        endif;            
            
        'We might need to specify a number of trials here...I'm assuming yes.  Note that SEARCH runs until the
        'user stops it, but this may be difficult to implement in practice - it would require fresh round(s) of
        'trial list generation that don't happen for other experiment types.  Most likely the easiest way to do
        'this is just to make a huge number of trials that the user won't exhaust, like 10,000 or something.
        
        status% := 1;
    else
        status% := 1;
    endif
    
	return status%;
   
end;

'===== End RecExpSearchDialog =====
'
'




'
'
'===== RecExpSearchDialogChanged =====

' This function is initially called with a "0" input
func RecExpSearchDialogChanged%(item%) 
    var checkLeverTaskVariable% := 1;  'do we check the lever task variable?  By default, yes.
    var inds%[10];
    var j%;
    for j% := 0 to 9 do
        inds%[j%] := j%;
    next;
    
    docase
    case DlgValue(1) = 0 then  'Tones
        DlgEnable(1,2);  'Enable frequency
        DlgEnable(0,3);  'Disable others
        DlgEnable(0,4);
        DlgEnable(0,5); 
        DlgEnable(0,6); 
        DlgEnable(0,7);
        DlgEnable(0,8); 
        DlgEnable(1,10); 'Enable S2 speaker
        DlgEnable(1,13); 'Enable prop. catch trials
        DlgEnable(1,14); 'Enable dB level
        DlgEnable(1,15); 'Enable lever task
    case DlgValue(1) = 1 then  'Broadband noise
        DlgEnable(0,2);  'Disable all
        DlgEnable(0,3);  
        DlgEnable(0,4);
        DlgEnable(0,5); 
        DlgEnable(0,6); 
        DlgEnable(0,7);
        DlgEnable(0,8);
        DlgEnable(1,10); 'Enable S2 speaker
        DlgEnable(1,13); 'Enable prop. catch trials
        DlgEnable(1,14); 'Enable dB level
        DlgEnable(1,15); 'Enable lever task
    case DlgValue(1) = 2 then  'Band pass noise
        DlgEnable(0,2);  
        DlgEnable(1,3);  'Enable
        DlgEnable(1,4);  'BP limits
        DlgEnable(0,5); 
        DlgEnable(0,6); 
        DlgEnable(0,7);
        DlgEnable(0,8);
        DlgEnable(1,10); 'Enable S2 speaker
        DlgEnable(1,13); 'Enable prop. catch trials
        DlgEnable(1,14); 'Enable dB level
        DlgEnable(1,15); 'Enable lever task
    case DlgValue(1) = 3 then  'Clicks
        DlgEnable(0,2);  'Disable all
        DlgEnable(0,3);   
        DlgEnable(0,4);   
        DlgEnable(0,5); 
        DlgEnable(0,6); 
        DlgEnable(0,7);
        DlgEnable(0,8);
        DlgEnable(1,10); 'Enable S2 speaker
        DlgEnable(1,13); 'Enable prop. catch trials
        DlgEnable(0,14); 'Disable dB level
        DlgEnable(1,15); 'Enable lever task        
    case DlgValue(1) = 4 then  'Tone Sweep
        DlgEnable(0,2);  
        DlgEnable(0,3);   
        DlgEnable(0,4);   
        DlgEnable(1,5);  'Enable Tone Sweep stuff
        DlgEnable(1,6); 
        DlgEnable(1,7);
        DlgEnable(1,8);
        DlgEnable(0,10); 'Disable S2 speaker
        DlgEnable(0,13); 'Disable prop. catch trials
        DlgEnable(1,14); 'Enable dB level
        DlgEnable(0,15); 'Disable lever task
        checkLeverTaskVariable% := 0;  'don't check lever task variable
    endcase;
    
    if checkLeverTaskVariable% = 1 then
        if DlgValue(15) = 0 then  'if no lever task
            DlgEnable(0,10); 'Disable S2 speaker
            DlgEnable(0,13); 'Disable prop. catch trials
        else
            DlgEnable(1,10); 'Enable S2 speaker
            DlgEnable(1,13); 'Enable prop. catch trials
        endif;
    endif;
    
    'update tone sweep numbers
    if item% = 1 or item% = 6 or item% = 7 or item% = 8 then
        if DlgValue(1) <> 4 then
            recSearchToneSweepFreqList$ := "";
            'Update GUI
            DlgValue$(recSearchToneSweepFreqList%,recSearchToneSweepFreqList$);
    else
        'TODO:check High and Low Freq values before calling GetLogProgression (or make sure there is a valid FreqList)
            GetLogProgression(DlgValue(6), DlgValue(7), DlgValue(8)-1, recSearchToneSweepFreqList[]);   
            'GetLinearProgression(DlgValue(6), DlgValue(7), DlgValue(8)-1, recSearchToneSweepFreqList[]);   
            recSearchToneSweepFreqList$ := StringifyProgression2$(DlgValue(8), recSearchToneSweepFreqList[0:DlgValue(8)], inds%[],0);
            'Update GUI
            DlgValue$(recSearchToneSweepFreqList%,recSearchToneSweepFreqList$);
        endif;
    endif;
    
    return 1;
end

'===== End RecExpSearchDialogChanged =====
'
'



'
'
'===== RecExpFRADialog =====

'A dialog for the FRA experiment

func RecExpFRADialog%()
    var fiveInts%[5];
    var threeInts%[3];
    '    var astring$;
    var i%;
    var k%;
    var status% := 0;  
    var inds%[10];
    var checkOK% := 1;
    var j%;
    for j% := 0 to 9 do
        inds%[j%] := j%;
    next;
    
    
    ' Fetch parameters from registry    
    RecFRAGetParams();
    RecFRAExpListLoadGetParams(recFRAExpNameLoad$[],recFRAStimcalNameLoad$[],recFRATrialsNameLoad$[]);
    
    threeInts%[0] := recFRAS1Speaker%;
    threeInts%[1] := recFRAMinS1%;
    threeInts%[2] := recFRAVarS1%;

    fiveInts%[0] := recFRAFMSweepDur1%;
    fiveInts%[1] := recFRAFMSweepDur2%;
    fiveInts%[2] := recFRAFMSweepDur3%;
    fiveInts%[3] := recFRAFMSweepDur4%;
    fiveInts%[4] := recFRAFMSweepDur5%;

    ' Initial calculation of dB steps, Freq. steps
    GetLinearProgression(recRateLeveldBLow, recRateLeveldBHigh, recRateLeveldBNSteps%-1, recRateLeveldBList[]);
    GetLinearProgression(recFRATonedBLow, recFRATonedBHigh, recFRAdBNSteps%-1, recFRAdBList[]);
    GetLogProgression(recFRAToneFreqLow, recFRAToneFreqHigh, recFRAFreqNSteps%-1, recFRAFreqList[]);   
    ' Followed by initial stringification
    recRLList1$ := StringifyProgression2$(5, recRateLeveldBList[0:5], inds%[],1);
    recRLList2$ := StringifyProgression2$(5, recRateLeveldBList[5:5], inds%[],1);
    recFRAdBList1$ := StringifyProgression2$(5, recFRAdBList[0:5], inds%[],1);
    recFRAdBList2$ := StringifyProgression2$(5, recFRAdBList[5:5], inds%[],1);
    recFRAFreqList1$ := StringifyProgression2$(10, recFRAFreqList[0:10], inds%[],0);
    recFRAFreqList2$ := StringifyProgression2$(10, recFRAFreqList[10:10], inds%[],0);
    recFRAFreqList3$ := StringifyProgression2$(9, recFRAFreqList[20:9], inds%[],0);
    recFRAFreqList4$ := StringifyProgression2$(8, recFRAFreqList[29:8], inds%[],0);
    recFRAFreqList5$ := StringifyProgression2$(8, recFRAFreqList[37:8], inds%[],0);
    
    
    ' Generate the dialog    
    DlgCreate("Combined FRA/Rate-Level/Space Dialog",0,0,120,30);
    
    DlgGroup("S1 Stimuli",1,1,118,2);
    DlgInteger(1,6,1,16,22,2);
    DlgText("S1 (preferred) Speaker",2,2);
    DlgInteger(2,6,2,3,44,2);
    DlgText("Min S1 Stimuli",31,2);
    DlgInteger(3,6,0,5,66,2);
    DlgText("Var S1 Stimuli",53,2);
    
    
    DlgGroup("Noise (Rate-Level)",2,3,27,8);
    DlgInteger(4,6,1,50,22,4);  'Rate-Level, n repeats
    DlgText("# Noise repeats",3,4);
    DlgReal(5,6,0.001,100,22,6);  'Rate-Level, low dB
    DlgText("dB Level, Low",3,6);
    DlgReal(6,6,0.001,100,22,7);  'Rate-Level, high dB
    DlgText("dB Level, High",3,7);
    DlgText("List of Selected dB Levels:",3,8);
    recRLList1% := DlgText(recRLList1$,3,9,25);
    recRLList2% := DlgText(recRLList2$,3,10,25);
    
    DlgGroup("Tone Pips (FRA)",30,3,88,8);
    DlgInteger(7,6,1,5,47,4);  'Rate-Level, n repeats
    DlgText("# Tone repeats",31,4);
    DlgReal(8,6,0.001,100,47,6);  'FRA low dB
    DlgText("Lower Level, dB",31,6);
    DlgReal(9,6,0.001,50000,47,7);  'FRA high dB
    DlgText("Upper Level, dB",31,7);
    DlgText("List of Selected dB Levels:",31,8);
    recFRAdBList1% := DlgText(recFRAdBList1$,31,9,25);
    recFRAdBList2% := DlgText(recFRAdBList2$,31,10,25);
    DlgReal(10,6,0.001,50000,73,4);  'FRA low frequency
    DlgText("Lower Limit, Hz",59,4);
    DlgReal(11,6,0.001,50000,103,4);  'FRA high frequency
    DlgText("Upper Limit, Hz",89,4);
    DlgText("List of Selected Freqs (rounded to nearest Hz):",59,5);
    recFRAFreqList1% := DlgText(recFRAFreqList1$,59,6,58);  'must set width of text boxes or it is based on
    recFRAFreqList2% := DlgText(recFRAFreqList2$,59,7,58);  'original text and updates can cause some
    recFRAFreqList3% := DlgText(recFRAFreqList3$,59,8,58);  'values to be "invisible" - also done for dB
    recFRAFreqList4% := DlgText(recFRAFreqList4$,59,9,58);  'values above (tone and rate-level) but probably
    recFRAFreqList5% := DlgText(recFRAFreqList5$,59,10,58);  'not crucial there.
    
    DlgGroup("S1 FM Tones",2,11,116,3);
    DlgInteger(12,6,1,50,22,12);  'FM Tones, n repeats
    DlgText("# FM Tone repeats",3,12);
    DlgInteger(13,6,20,10000,47,12);  'FM Tone start
    DlgText("FM Tone Start Hz",31,12);
    DlgInteger(14,6,40,50000,72,12);  'FM Tone end
    DlgText("FM Tone End Hz",56,12);
    DlgText("FM Tone Durs ms",3,13);  'FM Tone durations - only one label
    DlgInteger(15,6,10,1000,22,13); 
    DlgInteger(16,6,10,1000,32,13);
    DlgInteger(17,6,10,1000,42,13);
    DlgInteger(18,6,10,1000,52,13);
    DlgInteger(19,6,10,1000,62,13);    

    DlgGroup("S1 AM Noise",2,14,116,2);
    DlgInteger(20,6,1,50,22,15);  'AM noise, n repeats
    DlgText("# AM Noise repeats",3,15);
    MTFrates[0] := 4;
    MTFrates[1] := 6;
    MTFrates[2] := 8;
    MTFrates[3] := 12;
    MTFrates[4] := 16;
    MTFrates[5] := 24;
    MTFrates[6] := 32;
    MTFrates[7] := 48;
    MTFrates[8] := 64;
    MTFrates[9] := 128;
    MTFrates[10] := 256;
'    astring$ := "MTFrates = "+ StringifyProgression2$(nMTFrates%,MTFrates[],inds%[],1);
    'DlgText(astring$,31,15); 
    DlgText("AM rates = 4,6,8,12,16,24,32,48,64,128,256",31,15); 'DlgText("AM rates = "+recMTFfreqList$,31,15); 'figure how to do this the correct way!!
    'printlog("MTFrates = %d\n", MTFrates[]);
    'printlog("length nMTFrates = %d\n", len(MTFrates[]));

    DlgGroup("S1 Bandpass Noise",2,16,116,2);
    DlgInteger(21,6,1,50,22,17);  'AM noise, n repeats
    DlgText("# BP Noise repeats",3,17);
    'DlgText("Bandpass noises blah blah blah",31,18); 

    DlgGroup("S2 Stimuli (Space)",1,21,118,2);
    DlgReal(22,6,0.001,100,26,22);  'S2 speaker dB level
    DlgText("S2 (FM and AM) dB level",3,22);
    DlgInteger(23,6,1,100,51,22);  'S2 # repeats (for Space tuning) - separate from rate-level!
    DlgText("# Space repeats",35,22);
    DlgCheck(24,"",89,22);  'Monkey does lever task
    DlgText("Monkey Does Lever Task",65,22);

    DlgAllow(0xffff, 0, RecExpFRADialogChanged%); 
    
    DlgGroup("Stimulus Selection",1,24,120,3);
    DlgCheck(25,"Load Stimuli?",2,25);
    DlgList(26,22,recFRAExpNameLoad$[],recFRANumExps%,24,26);
    recFRAText2% := DlgText("Select Exp't (Load Stim)",2,26);
    DlgButton(recFRAAddExpButton%, "  Add Experiment  ", RecFRAAddExp%,53,26);
    DlgButton(recFRADeleteExpButton%, "Delete Experiment ", RecFRADeleteExp%,73,26);

    DlgAllow(0xffff, 0, RecExpFRADialogChanged%); 
    
    ' Show the dialog. 
    i%:=DlgShow(threeInts%, 'S1 stimuli
                recRateLevelNRepeats%, recRateLeveldBLow, recRateLeveldBHigh, 'Noise (rate-level)
                recFRANRepeats%,recFRATonedBLow,recFRATonedBHigh,recFRAToneFreqLow,recFRAToneFreqHigh, 'Tone Pips (FRA)
                recFRAFMSweepRepeats%, recFRAFMSweepStart%, recFRAFMSweepEnd%, fiveInts%,  'S1 FM tones
                recS1AMnoiseReps%,'S1 AM Noise
                recBPnoiseReps%, 'S1 Bandpass Noise
                recFRAS2dBLevel, recSpaceNRepeats%, recFRAActive%, 'S2 Stimuli (space)
                recFRALoadStim%,recFRAExpIndexLoad%);'Stimulus Selection 

                printlog("Value is %d\n", recFRAExpIndexLoad%);

                recFRAS1Speaker% := threeInts%[0];
                recFRAMinS1% := threeInts%[1];
                recFRAVarS1% := threeInts%[2];

                recFRAFMSweepDur1% := fiveInts%[0];
                recFRAFMSweepDur2% := fiveInts%[1];
                recFRAFMSweepDur3% := fiveInts%[2];
                recFRAFMSweepDur4% := fiveInts%[3];
                recFRAFMSweepDur5% := fiveInts%[4];

    'make sure the dialog values are OK
    docase
    case recRateLeveldBLow = recRateLeveldBHigh then
        message("Low and High dB level for noise cannot be the same value!");
        checkOK% := 0;
    case recFRATonedBLow = recFRATonedBHigh then
        message("Low and High dB level for tone pips cannot be the same value!");
        checkOK% := 0;
    case recFRAToneFreqLow = recFRAToneFreqHigh then
        message("Low and High frequency for tone pips cannot be the same value!");
        checkOK% := 0;
    endcase
    
    ' If user hit OK then save parameters (and return 1). 
	if i% = 1 and checkOK% = 1 then
        ' Recalculate dB steps, Freq. steps based on dialog values
        GetLinearProgression(recRateLeveldBLow, recRateLeveldBHigh, recRateLeveldBNSteps%-1, recRateLeveldBList[]);
        GetLinearProgression(recFRATonedBLow, recFRATonedBHigh, recFRAdBNSteps%-1, recFRAdBList[]);
        GetLogProgression(recFRAToneFreqLow, recFRAToneFreqHigh, recFRAFreqNSteps%-1, recFRAFreqList[]); 
        'calculate BPnoise intervals
        recBPnoisesLOs%[0] := 400;
        recBPnoisesHIs%[0] := recBPnoisesLOs%[0]+recBPnoisesLOs%[0]/2;
        for k% := 1 to nBPnoises%-1 do
            recBPnoisesLOs%[k%] := recBPnoisesLOs%[k%-1]+recBPnoisesLOs%[k%-1]/4;
            recBPnoisesHIs%[k%] := recBPnoisesLOs%[k%]+recBPnoisesLOs%[k%]/2;
        next;
    
        'Save parameters
        RecFRASaveParams();
        
        'Reset dialog OK button text on Select dialog, and note which experiment to run
        DlgValue$(-1,"Run FRA");
        
        'There doesn't appear to be, at this time, a compelling reason to actually limit this
        'to the 16-speaker array.  Dominique is trying to run this, as a "practice" in the 
        'small booth which only has a 15-speaker array, and this appears to be causing all
        'sorts of problems when the 16-speaker array is assigned by force.  Since the code
        'that creates the FRA stimuli is flexible enough to use the number of speakers requested,
        'I **THINK** everything should be hunky-dory if we just let it run on the 15-speaker
        'array.  My suspicion is that since the 15-speaker array is not 360-degrees that it was
        'probably considered unsuitable for the FRA, and perhaps it still ought to be, but this
        'is just for "practice" and we should let it happen.  -jj 8/2/17
        'DlgValue(3,2);  'force NSpeakers to the 16-speaker array on the main dialog
        'DlgEnable(0,3); 'and don't let this value be changed
        
        recExpToRun% := recExpFRAButton%; 
        recExpSelectDialogAllowOK% := 1;  'Prepare to enable OK button
        recExpSelectDialogChanged%(-1);  'Enables "OK" button, -1 is sham input
        
        'assign Search-specific variables to experiment-wide variables (so we can keep separate defaults but only code once)
        recMinS1% := recFRAMinS1%;
        recVarS1% := recFRAVarS1%;
        recS1Speaker% := recFRAS1Speaker%;
        recActive% := recFRAActive%;
        recFixLED% := 1;
        recMatGenStim% := 1;  'Always generate stimuli for FRA
        
        'We might need to specify a number of trials here...I'm assuming yes, just as for Search.  However
        'for the FRA, there may be a specific number of trials - it appears that the number of stimuli is
        'fixed, with 45x10=450 tone pips at S1 speaker, 10x12=120 noise bursts at S1 speaker and 15x12=180
        'noise bursts at S2 speakers.  It is these S2 noise bursts that defines the number of trials: 180.
        'The trick will then be to get the 570 S1 stimuli spread out over the 180 S2 stimuli in a reasonable
        'fashion.  We'll probably have to hardcode the distributions of S1 length per trial and go from there.
        
        status% := 1;
    else
        status% := 1;
    endif
    
	return status%;
   
end;


'===== End RecExpFRADialog =====
'
'

'
'
'===== RecExpFRADialogChanged =====

' This function is initially called with a "0" input
func RecExpFRADialogChanged%(item%) 
    'Quickly build a list of indices that we need
    var inds%[10];
    var j%;
    for j% := 0 to 9 do
        inds%[j%] := j%;
    next;
    
    docase
    case item% = 2 or item% = 3 then  'Rate-level dB changed, update values
        'Update values in variables
        recRateLeveldBLow := DlgValue(2);
        recRateLeveldBHigh := DlgValue(3);
        'Recalculate linear progression, if values are not the same
        if recRateLeveldBLow <> recRateLeveldBHigh then
            GetLinearProgression(recRateLeveldBLow, recRateLeveldBHigh, recRateLeveldBNSteps%-1, recRateLeveldBList[]);
        endif;
        'Update strings
        recRLList1$ := StringifyProgression2$(5, recRateLeveldBList[0:5], inds%[],1);
        recRLList2$ := StringifyProgression2$(5, recRateLeveldBList[5:5], inds%[],1);
        'Update GUI
        DlgValue$(recRLList1%,recRLList1$);
        DlgValue$(recRLList2%,recRLList2$);
    case item% = 4 or item% = 5 then  'FRA tone dB changed, update values
        'Update values in variables
        recFRATonedBLow := DlgValue(4);
        recFRATonedBHigh := DlgValue(5);
        'Recalculate linear progression, if values are not the same
        if recFRATonedBLow <> recFRATonedBHigh then
            GetLinearProgression(recFRATonedBLow, recFRATonedBHigh, recFRAdBNSteps%-1, recFRAdBList[]);
        endif;
        'Update strings
        recFRAdBList1$ := StringifyProgression2$(5, recFRAdBList[0:5], inds%[],1);
        recFRAdBList2$ := StringifyProgression2$(5, recFRAdBList[5:5], inds%[],1);
        'Update GUI
        DlgValue$(recFRAdBList1%,recFRAdBList1$);
        DlgValue$(recFRAdBList2%,recFRAdBList2$);
    case item% = 6 or item% = 7 then  'FRA tone frequency changed, update values
        'Update values in variables
        recFRAToneFreqLow := DlgValue(6);
        recFRAToneFreqHigh := DlgValue(7);
        'Recalculate log progression
        if recFRAToneFreqLow <> recFRAToneFreqHigh then
            GetLogProgression(recFRAToneFreqLow, recFRAToneFreqHigh, recFRAFreqNSteps%-1, recFRAFreqList[]);
        endif;
        'Update strings
        recFRAFreqList1$ := StringifyProgression2$(10, recFRAFreqList[0:10], inds%[],0);
        recFRAFreqList2$ := StringifyProgression2$(10, recFRAFreqList[10:10], inds%[],0);
        recFRAFreqList3$ := StringifyProgression2$(9, recFRAFreqList[20:9], inds%[],0);
        recFRAFreqList4$ := StringifyProgression2$(8, recFRAFreqList[29:8], inds%[],0);
        recFRAFreqList5$ := StringifyProgression2$(8, recFRAFreqList[37:8], inds%[],0);
        'Update GUI
        DlgValue$(recFRAFreqList1%,recFRAFreqList1$);
        DlgValue$(recFRAFreqList2%,recFRAFreqList2$);
        DlgValue$(recFRAFreqList3%,recFRAFreqList3$);
        DlgValue$(recFRAFreqList4%,recFRAFreqList4$);
        DlgValue$(recFRAFreqList5%,recFRAFreqList5$);
'    case item% = 11 or item% = 12 or item% = 13 or item% = 22 then  'change number of S1 stimulus repeats
'        nS1% := (nTonePips%*recFRAdBNSteps%*recFRANRepeats%)+(recRateLevelNRepeats%*recRateLeveldBNSteps%)+(nFMSweeps%*recFRAFMSweepRepeats%);  'that's number of tone pips in FRA plus number of noise bursts in rate-level function
'        printlog("nS1% = %d\n", nS1%);
'        nS2% := (recNSpeakers%-1)*recSpaceNRepeats%;  'that's number of noises at speakers not in the S1 position
'        printlog("nS2% = %d\n", nS2%);

    endcase;
    
    return 1;
end

'===== End RecExpFRADialogChanged =====
'
'


'===== RecJoyTrainDialog ===== '*jao

func RecJoyTrainDialog%()
'**look at search dialog for important functional details!!!
    var i%; 'for DlgShow
    var status% := 0;
    var c1txt% := 3;
    var c1% := 35; 'not the smart way to do it..
    var initStr$[7];
    var s2% := 9;

    initStr$[0] := "Not Allowed";
    initStr$[1] := "Down";
    initStr$[2] := "Up";
    initStr$[3] := "Right";
    initStr$[4] := "Left";
    initStr$[5] := "X Axis";
    initStr$[6] := "Y Axis";

    ' Fetch parameters from registry    
    RecJoyTrainGetParams(); 'make this below!
    
    ' Generate the dialog
    DlgCreate("Joystick training dialog", 0,0, 50,16); '0,0=ctr of scrn; 50,16=size of dlg
    DlgCheck(1, "Give juice for hitting trial start window?");

    DlgGroup("Timing and Rewards",1,2,48,6); 'just text for now to tell ppl where to go to change things
    'i think i can actually set these here (basically copy from those dialogs and then assign those vars below
'    DlgText("Use Timing/Reward Dialog to set (can't do it here!):",2,3); 
       ' DlgText("* Hit Reward Duration,mL = amount of juice",3,4); 'msg: amount of juice --> update HIT REWARD in timing and reward dialog!
       ' DlgText("* Reward Increment on hits",3,5); 'msg: reward increment on hits --> update in Timing & Reward Dialog!
       ' DlgText("* Minimum Onset Delay = hold to get juice",3,6); 'msg: juice delay? --> Minimum onset delay in timing and reward dialog!
        DlgReal(2,4,0,3,c1%,3); DlgText("Hit Reward, mL",c1txt%,3); '#2=recHitRewardmL
        DlgReal(3,4,0,1,c1%,4); DlgText("Reward Increment on hits, mL",c1txt%,4); '#3=recHitRewardIncmL
        DlgReal(4,4,0,10,c1%,5); DlgText("Minimum Onset Delay, s",c1txt%,5); '#4=recMinOnsetDelay
        DlgText("* ??? to Increment Onset Delay",3,6);'**increment delay? --> set max delay (is there already a variable for this?)
        DlgText("* ??? to Set Max Onset Delay",3,7);'**increment delay? --> set max delay (is there already a variable for this?)

    DlgGroup("Joystick",1,s2%,48,6);
'    DlgText("Use Joystick/Lever Dialog to set (can't do it here!):",2,10); 
        'DlgText("* Trial Initiation Position",3,11); 'msg: set trial initiation position in Joystick Dialog!
        'DlgText("* Joystick Thresholds and Increments",3,12);  'msg: set joystick increments in Joystick Dialog --> joystick increments!
        DlgList(5,20,initStr$[],7,c1%-6,s2%+1); DlgText("Trial Initiation Position",c1txt%,s2%+1); 'recTrialInitPosition%
        DlgButton(2,"Joystick Thresholds",SetJoystickThresholdDialog%,2,s2%+2);
        DlgCheck(6,"Do Increments",2,s2%+3); 'recDoIncrements%
        DlgButton(3,"Joystick Increments",SetJoystickThresholdIncrementDialog%,2,s2%+4); 'recTrialResponsePosition1%
        DlgButton(4,"Joystick Limits",SetJoystickThresholdLimitDialog%,2,s2%+5); 'recTrialResponsePosition2%


    DlgAllow(0xffff, 0, RecExpJoyTrnDialogChanged%); 'no idea how this works, but i'm sure i need it!

    ' Show the dialog. 
i%:=DlgShow(recDoJoyTrain%, recHitRewardmL, recHitRewardIncmL, recMinOnsetDelay, recTrialInitPosition%, recDoIncrements%); 'DlgCheck(1... ??

    ' If user checked box and hit OK then save parameters (and return 1). 
	if i% = 1 then
        RecJoyTrainSaveParams(); 'hmm... do i need to do this??
        'Reset dialog OK button text on Select dialog, and note which experiment to run
        DlgEnable(1,3);  'make sure that the Nspeakers selection item is enabled on the main dialog
        DlgValue$(-1,"Run JoyTrain"); 'to enable OK button? see also ~line 1156 in RecRoom (RecExpSearchDialog) 
        recExpToRun% := recExpJoyTrnButton%;
        recExpSelectDialogAllowOK% := 1;  'Prepare to enable OK button
        recExpSelectDialogChanged%(-1);  'Enables "OK" button, -1 is sham input
    
        recActive% := 1;
    
        'assign JoyTrain-specific variables to experiment-wide variables here????
        'see lines 1163-1170 in RecRoom (RecExpSearchDialog) for examples of this (i think)
    
        'trial generation??? --> RecRoom do while 
        
        'jj is unsure of something.  It certainly seems that the recDoJoyTrain% checkbox is meant to be checked.
        'It seems it shouldn't be a checkbox, I think we should just use recExpToRun% := recExpJoyTrnButton% and forget recDoJoyTrain% (which is only checked once in GNGEngine)
        'But I'm working on other stuff right now and this is not a priority to understand.
        'When RecLab needs to use/change this, at least this note will be here to get me started.
    
        status% := 1;
    else
        status% := 1;
    endif
    
	return status%;


end; 'end func
'end RecJoyTrainDialog '*jao

'===== RecJoyTrnDialogChanged ===== '*jao

func RecExpJoyTrnDialogChanged%(item%)
'this is where dialog functions are enabled for JoyTrain dialog
'i dont understand how input and call to this func

'i actually don't need this ... YET!

    return 1;


end;
'end RecExpJoyTrnDialogChanged%() '*jao


'===== RecJoyTrainGetParams ===== '*jao

func RecJoyTrainGetParams()
	var key$;
    key$:="Reclab\\LeverJoystick";

    recDoJoyTrain%:= GetIntRegistryValue%(key$, "DoJoyTrain", recDoJoyTrain%);
    recMinOnsetDelay := GetFloatRegistryValue(key$, "MinOnsetDelay", recMinOnsetDelay);
    recHitRewardmL := GetFloatRegistryValue(key$, "HitRewardmL", recHitRewardmL);
	recHitRewardIncmL := GetFloatRegistryValue(key$, "HitRewardIncmL", recHitRewardIncmL);
    recMinOnsetDelay := GetFloatRegistryValue(key$, "MinOnsetDelay", recMinOnsetDelay);
    recTrialInitPosition% := GetFloatRegistryValue(key$, "TrialInitPosition", recTrialInitPosition%);
    recDoIncrements% := GetFloatRegistryValue(key$, "DoIncrements", recDoIncrements%);

    return;

end; 
'end  RecJoyTrainGetParams(); '*jao


'===== RecJoyTrainSaveParams ===== '*jao

func RecJoyTrainSaveParams()
	var key$;
    key$:="Reclab\\LeverJoystick";

    SetIntRegistryValue(key$, "DoJoyTrain", recDoJoyTrain%);
    SetFloatRegistryValue(key$, "MinOnsetDelay", recMinOnsetDelay);
    SetFloatRegistryValue(key$, "HitRewardmL", recHitRewardmL);   
    SetFloatRegistryValue(key$, "HitRewardIncmL", recHitRewardIncmL);    
    SetFloatRegistryValue(key$, "MinOnsetDelay", recMinOnsetDelay);
    SetFloatRegistryValue(key$, "TrialInitPosition", recTrialInitPosition%);
    SetFloatRegistryValue(key$, "DoIncrements", recDoIncrements%);
    
	return;

end; 
'end  RecJoyTrainSaveParams(); '*jao


'===== GenTrialsJoyTrain ===== '*jao

func GenTrialsJoyTrain%()
'**check out GenTrialsSearch%() !!!
' or can I just use GenTrialsSearch and avoid needing a new function? what would need to change??
' technically this program will never get to make a sound so it shouldn't matter right?
    var status% := 1;
    
    if recDoNotShuffle% = 0 then
        ShuffleList%(recTrialOrder%[0:recNTrials%]);  'create a randpermed version of recTrialOrder (only valid indices), but not for tone sweep
    endif;
    return status%;  'right now, it "can't" fail
end;
'end GenTrialsJoyTrain%() '*jao


'===== RecLongToneGetParams ===== 

func RecLongToneGetParams()
	var key$;
    key$:="Reclab\\Longtone";
    
    recLongToneSpeaker% := GetIntRegistryValue%(key$, "LongToneSpeaker", recLongToneSpeaker%);
    recLongToneDuration := GetFloatRegistryValue(key$, "LongToneDuration", recLongToneDuration);
    recLongToneFreq := GetFloatRegistryValue(key$, "LongToneFreq", recLongToneFreq);
    recLongToneBPLow := GetFloatRegistryValue(key$, "LongToneBPLow", recLongToneBPLow);
    recLongToneBPHigh := GetFloatRegistryValue(key$, "LongToneBPHigh", recLongToneBPHigh);
    recLongToneType% := GetIntRegistryValue%(key$, "LongToneType", recLongToneType%);
    recLongToneNRepeats% := GetIntRegistryValue%(key$, "LongToneNRepeats", recLongToneNRepeats%);
    recLongToneISI := GetFloatRegistryValue(key$, "LongToneISI", recLongToneISI);  
    recLongToneSilentDur := GetFloatRegistryValue(key$, "LongToneSilentDur", recLongToneSilentDur); 
    recLongToneTargetdB := GetFloatRegistryValue(key$, "LongToneTargetdB", recLongToneTargetdB);  
    recLongToneRewardProb := GetFloatRegistryValue(key$, "LongToneRewardProb", recLongToneRewardProb);
    
    
    return;

end; 
'end  RecLongToneGetParams(); 


'===== RecLongToneSaveParams ===== 

func RecLongToneSaveParams()
	var key$;
    key$:="Reclab\\Longtone";

    SetIntRegistryValue(key$, "LongToneSpeaker", recLongToneSpeaker%);
    SetFloatRegistryValue(key$, "LongToneDuration", recLongToneDuration);
    SetFloatRegistryValue(key$, "LongToneFreq", recLongToneFreq);
    SetFloatRegistryValue(key$, "LongToneBPLow", recLongToneBPLow);
    SetFloatRegistryValue(key$, "LongToneBPHigh", recLongToneBPHigh);
    SetIntRegistryValue(key$, "LongToneType", recLongToneType%);
    SetIntRegistryValue(key$, "LongToneNRepeats", recLongToneNRepeats%);
    SetFloatRegistryValue(key$, "LongToneISI", recLongToneISI);
    SetFloatRegistryValue(key$, "LongToneSilentDur", recLongToneSilentDur); 
    SetFloatRegistryValue(key$, "LongToneTargetdB", recLongToneTargetdB);
    SetFloatRegistryValue(key$, "LongToneRewardProb", recLongToneRewardProb);

	return;

end; 
'end  RecLongToneSaveParams(); 



'===== RecLongToneDialog ===== '-jj
func RecLongToneDialog%()
    var i%; 'for DlgShow
    var status% := 0;
    var longType$[3];
    
    longType$[0] := "Tone";
    longType$[1] := "Broadband Noise";
    longType$[2] := "Bandpass Noise";
    
    
    ' Fetch parameters from registry    
    RecLongToneGetParams();
    
    ' Generate the dialog
    DlgCreate("Long Tone Dialog");
    DlgList(1,17,longType$[],3);
    DlgReal(2,"Tone Frequency (Hz)",20,40000);
    DlgReal(3,"Low Freq Cutoff (Hz)",1,30000);
    DlgReal(4,"High Freq Cutoff (Hz)",2,100000);
    DlgInteger(5,"Speaker",1,16);
    DlgInteger(6,"Number of repeats per tone",1,8);  'We have to restrict this to 8 because of maximum variable size allowed by CED (have to hold all the damn long noises!)
    DlgReal(7,"ISI, seconds",1,100);
    DlgReal(8,"Silence trial, seconds",0.1,100);
    DlgReal(9,"Target dB",1,100);
    DlgReal(10,"Probability of reward",0,1);
    
    DlgAllow(0xffff, 0, RecLongToneDialogChanged%); 
    
    ' Show the dialog
    i% := DlgShow(recLongToneType%,recLongToneFreq,recLongToneBPLow,recLongToneBPHigh,recLongToneSpeaker%,recLongToneNRepeats%,recLongToneISI,recLongToneSilentDur,recLongToneTargetdB,recLongToneRewardProb);
  
    
    ' If user checked box and hit OK then save parameters (and return 1). 
	if i% = 1 then
        RecLongToneSaveParams();  
        
        if recLongToneType% = 1 then  'if we are doing broadband noise, set the values here so we don't have to "think" at the noise creation step
            recLongToneBPLow := -1;  'correct value for broadband noise
            recLongToneBPHigh := -1;
        endif;
        
        'Reset dialog OK button text on Select dialog, and note which experiment to run
        DlgEnable(1,3);  'make sure that the Nspeakers selection item is enabled on the main dialog
        DlgValue$(-1,"Run Long Tone"); 'to enable OK button? see also ~line 1156 in RecRoom (RecExpSearchDialog) 
        recExpToRun% := recExpLongToneButton%;
        recExpSelectDialogAllowOK% := 1;  'Prepare to enable OK button
        recExpSelectDialogChanged%(-1);  'Enables "OK" button, -1 is sham input
    
        status% := 1;
    else
        status% := 1;
    endif
    
	return status%;
    
end



func RecLongToneDialogChanged%(item%)
    
    docase
    case DlgValue(1) = 0 then  'if tone
        DlgEnable(1,2);  'Enable tone 
        DlgEnable(0,3);  'Disable BP low
        DlgEnable(0,4);  'Disable BP high
    case DlgValue(1) = 1 then  'if broadband noise
        DlgEnable(0,2);  'Disable tone 
        DlgEnable(0,3);  'Disable BP low
        DlgEnable(0,4);  'Disable BP high
    case DlgValue(1) = 2 then  'if bandpass noise
        DlgEnable(0,2);  'Disable tone 
        DlgEnable(1,3);  'Enable BP low
        DlgEnable(1,4);  'Enable BP high
    endcase

    return 1;


end;
'end RecELongToneDialogChanged%()



'===== RecAudiogramDialog ===== '-jj, all audiogram code

func RecAudiogramDialog%()
'**look at search dialog for important functional details!!!
    var i%; 'for DlgShow
    var status% := 0;
    
    var trwid% := 100;  'total dialog width, not sure what 'tr' means at this point, carried over
    var ewid% := 6;  'entry width
    var c1txt% := 2;  'column 1 text position
    var c1%;  'column 1 position
    c1% := c1txt%+22;
    var c2txt% := 36;
    var c2%;
    c2% := c2txt%+22;
    var c3txt% := 70;
    var c3%;
    c3% := c3txt%+22;
    
    'StringifyProgression2$ just needs a set of indices, they don't really do anything else
    var inds%[10];
    var j%;
    for j% := 0 to 9 do
        inds%[j%] := j%;
    next;
    var tempCount%;
    
    

    ' Fetch parameters from registry    
    RecAudiogramGetParams(); 
    
    ' Initial calculation of frequency steps
    if (recAudiogramToneFreqLow <> recAudiogramToneFreqHigh) and recAudiogramNFreqs% > 1 then
        GetLogProgression(recAudiogramToneFreqLow, recAudiogramToneFreqHigh, recAudiogramNFreqs%-1, recAudiogramFreqList[]); 
    else
        recAudiogramFreqList[0] := recAudiogramToneFreqLow;
    endif
        
    ' Followed by initial stringification, yikes.  Now loooooooong.
    tempCount% := recAudiogramNFreqs%;
    if tempCount% >= 10 then
        recAudiogramFreqList1$ := StringifyProgression2$(10, recAudiogramFreqList[0:10], inds%[],0);
    else
        recAudiogramFreqList1$ := StringifyProgression2$(tempCount%, recAudiogramFreqList[0:tempCount%], inds%[],0);
    endif;
    tempCount% := tempCount% - 10;
    docase
    case tempCount% <= 0 then
        recAudiogramFreqList2$ := "";
    case tempCount% >= 10 then
        recAudiogramFreqList2$ := StringifyProgression2$(10, recAudiogramFreqList[10:10], inds%[],0);
    else
        recAudiogramFreqList2$ := StringifyProgression2$(tempCount%, recAudiogramFreqList[10:tempCount%], inds%[],0);
    endcase;
    tempCount% := tempCount% - 10;
    docase
    case tempCount% <= 0 then
        recAudiogramFreqList3$ := "";
    case tempCount% >= 9 then
        recAudiogramFreqList3$ := StringifyProgression2$(9, recAudiogramFreqList[20:9], inds%[],0);
    else
        recAudiogramFreqList3$ := StringifyProgression2$(tempCount%, recAudiogramFreqList[20:tempCount%], inds%[],0);
    endcase;
    tempCount% := tempCount% - 9;
    docase
    case tempCount% <= 0 then
        recAudiogramFreqList4$ := "";
    case tempCount% >= 8 then
        recAudiogramFreqList4$ := StringifyProgression2$(8, recAudiogramFreqList[29:8], inds%[],0);
    else
        recAudiogramFreqList4$ := StringifyProgression2$(tempCount%, recAudiogramFreqList[29:tempCount%], inds%[],0);
    endcase;
    tempCount% := tempCount% - 8;
    docase
    case tempCount% <= 0 then
        recAudiogramFreqList5$ := "";
    case tempCount% >= 8 then
        recAudiogramFreqList5$ := StringifyProgression2$(8, recAudiogramFreqList[37:8], inds%[],0);
    else
        recAudiogramFreqList5$ := StringifyProgression2$(tempCount%, recAudiogramFreqList[37:tempCount%], inds%[],0);
    endcase;

    
    ' Generate the dialog
    DlgCreate("Audiogram dialog", 0,0,trwid%,19); '0,0=ctr of scrn; 50,16=size of dlg
    DlgGroup("Timing and Rewards",1,1,trwid%-2,4); 'just text for now to tell ppl where to go to change things
    DlgInteger(1,ewid%,1,16,c1%,2);  DlgText("S1 Speaker",c1txt%,2);
    DlgReal(2,ewid%,0,3,c2%,2); DlgText("Hit Reward, mL",c2txt%,2);
    
    DlgReal(3,ewid%,0,20,c1%,3); DlgText("Minimum Onset Delay, s",c1txt%,3);
    DlgReal(4,ewid%,0,20,c2%,3); DlgText("Variable Onset Delay, s",c2txt%,3);
    DlgReal(5,ewid%,0.5,10,c3%,3); DlgText("Response Window, s",c3txt%,3);
    
    DlgReal(6,ewid%,0.5,100,c1%,4); DlgText("Trial Initiation Window, s",c1txt%,4);
    DlgReal(7,ewid%,0,300,c2%,4); DlgText("False Alarm TO, s",c2txt%,4);
    '''Lazy monkey timeout excised!  Uncomment to reinstate!
'    DlgReal(8,ewid%,0,300,c3%,4); DlgText("Lazy Monkey TO, s",c3txt%,4);
    DlgReal(8,ewid%,0,300,c3%,4); DlgText("THIS DOES NOTHING, s",c3txt%,4);
    
    
    DlgGroup("Frequencies",1,5,trwid%-2,8);
    DlgInteger(9,ewid%,1,45,c1%,6); DlgText("# Frequenices",c1txt%,6);
    DlgReal(10,ewid%,0.001,40000,c2%,6);  DlgText("Minimum Frequency",c2txt%,6);
    DlgReal(11,ewid%,0.002,50000,c3%,6);  DlgText("Maximum Frequency",c3txt%,6);
    DlgText("List of Selected Freqs (rounded to nearest Hz):",c1txt%,7);
    recAudiogramFreqList1% := DlgText(recAudiogramFreqList1$,c1txt%,8,58);  'must set width of text boxes or it is based on
    recAudiogramFreqList2% := DlgText(recAudiogramFreqList2$,c1txt%,9,58);  'original text and updates can cause some
    recAudiogramFreqList3% := DlgText(recAudiogramFreqList3$,c1txt%,10,58);  'values to be "invisible" - also done for dB
    recAudiogramFreqList4% := DlgText(recAudiogramFreqList4$,c1txt%,11,58);  'values above (tone and rate-level) but probably
    recAudiogramFreqList5% := DlgText(recAudiogramFreqList5$,c1txt%,12,58);  'not crucial there.
    
    DlgGroup("Reversals and dB",1,13,trwid%-2,4);
    DlgInteger(12,ewid%,1,200,c1%,14);  DlgText("Number of Reversals",c1txt%,14);
    DlgCheck(13,"",c2%,14);  DlgText("Only Log Reversals",c2txt%,14);
    DlgReal(14,ewid%,.1,120,c1%,15);  DlgText("Start dB Level",c1txt%,15);
    DlgCheck(15,"",c2%,15);  DlgText("Initial Step is LOUDER",c2txt%,15);
    DlgReal(16,ewid%,.1,40,c1%,16);  DlgText("Initial dB Step",c1txt%,16);
    DlgReal(17,ewid%,.1,40,c2%,16);  DlgText("Louder dB Step",c2txt%,16);
    DlgReal(18,ewid%,.1,40,c3%,16);  DlgText("Quieter dB Step",c3txt%,16);
    


    DlgAllow(0xffff, 0, RecExpAudiogramDialogChanged%); 

    ' Show the dialog
    i% := DlgShow(recAudiogramS1Speaker%,recHitRewardmL,recMinOnsetDelay,recVarOnsetDelay,recResponseWindow,
                  recTrialInitWindow,recFalseAlarmTO,recLazyMonkeyTO,recAudiogramNFreqs%,recAudiogramToneFreqLow,
                  recAudiogramToneFreqHigh,recAudiogramNReversals%,recAudiogramOnlyLogReversals%,recAudiogramStartdB,
                  recAudiogramInitialDirection%,recAudiogramInitialdBStep,recAudiogramLouderdBStep,recAudiogramQuieterdBStep);  
     
    
    ' If user checked box and hit OK then save parameters (and return 1). 
	if i% = 1 then
        RecAudiogramSaveParams(); 
        
        'Assign fixation LED
        recFixLED% := 1;
        
        'Force experiment to be go/no-go (will still need to consult with Engine to make sure this will be OK but nothing else appears to be necessary in RecRoom)
        recIsGoNoGo% := 1;
        
        'Do not allow reward incrementing for audiogram
        recHitRewardIncmL := 0;
        
        'Assign S1 Speaker...note that other variables aren't assigned like this
        recS1Speaker% := recAudiogramS1Speaker%;
        
        'Reset dialog OK button text on Select dialog, and note which experiment to run
        DlgEnable(1,3);  'make sure that the Nspeakers selection item is enabled on the main dialog
        DlgValue$(-1,"Run Audiogram"); 'to enable OK button? see also ~line 1156 in RecRoom (RecExpSearchDialog) 
        recExpToRun% := recExpAudiogramButton%;
        recExpSelectDialogAllowOK% := 1;  'Prepare to enable OK button
        recExpSelectDialogChanged%(-1);  'Enables "OK" button, -1 is sham input
        
        recAudiogramCurrentdB := recAudiogramStartdB;
        recMatGenStim% := 1;  'Always generate stimuli for Audiogram
        recActive% := 1; 
    
        status% := 1;
    else
        status% := 1;
    endif
    
	return status%;


end; 'end func
'end RecAudiogramDialog 

'===== RecAudiogramDialogChanged ===== 

func RecExpAudiogramDialogChanged%(item%)
    
    'Quickly build a list of indices that we need
    var inds%[10];
    var j%;
    for j% := 0 to 9 do
        inds%[j%] := j%;
    next;
    var tempCount%;
    
    docase
    case item% = 9 or item% = 10 or item% = 11 then  'frequencies or # of frequencies changed, update values
        'Update values in variables
        recAudiogramNFreqs% := DlgValue(9);
        recAudiogramToneFreqLow := DlgValue(10);
        recAudiogramToneFreqHigh := DlgValue(11);
        'Recalculate log progression
        if (recAudiogramToneFreqLow <> recAudiogramToneFreqHigh) and recAudiogramNFreqs% > 1 then
            GetLogProgression(recAudiogramToneFreqLow, recAudiogramToneFreqHigh, recAudiogramNFreqs%-1, recAudiogramFreqList[]); 
        else
            recAudiogramFreqList[0] := recAudiogramToneFreqLow;
            DlgValue(9,1);
            recAudiogramNFreqs% := 1;
        endif
        'Update strings
        tempCount% := recAudiogramNFreqs%;
        if tempCount% >= 10 then
            recAudiogramFreqList1$ := StringifyProgression2$(10, recAudiogramFreqList[0:10], inds%[],0);
        else
            recAudiogramFreqList1$ := StringifyProgression2$(tempCount%, recAudiogramFreqList[0:tempCount%], inds%[],0);
        endif;
        tempCount% := tempCount% - 10;
        docase
        case tempCount% <= 0 then
            recAudiogramFreqList2$ := "";
        case tempCount% >= 10 then
            recAudiogramFreqList2$ := StringifyProgression2$(10, recAudiogramFreqList[10:10], inds%[],0);
        else
            recAudiogramFreqList2$ := StringifyProgression2$(tempCount%, recAudiogramFreqList[10:tempCount%], inds%[],0);
        endcase;
        tempCount% := tempCount% - 10;
        docase
        case tempCount% <= 0 then
            recAudiogramFreqList3$ := "";
        case tempCount% >= 9 then
            recAudiogramFreqList3$ := StringifyProgression2$(9, recAudiogramFreqList[20:9], inds%[],0);
        else
            recAudiogramFreqList3$ := StringifyProgression2$(tempCount%, recAudiogramFreqList[20:tempCount%], inds%[],0);
        endcase;
        tempCount% := tempCount% - 9;
        docase
        case tempCount% <= 0 then
            recAudiogramFreqList4$ := "";
        case tempCount% >= 8 then
            recAudiogramFreqList4$ := StringifyProgression2$(8, recAudiogramFreqList[29:8], inds%[],0);
        else
            recAudiogramFreqList4$ := StringifyProgression2$(tempCount%, recAudiogramFreqList[29:tempCount%], inds%[],0);
        endcase;
        tempCount% := tempCount% - 8;
        docase
        case tempCount% <= 0 then
            recAudiogramFreqList5$ := "";
        case tempCount% >= 8 then
            recAudiogramFreqList5$ := StringifyProgression2$(8, recAudiogramFreqList[37:8], inds%[],0);
        else
            recAudiogramFreqList5$ := StringifyProgression2$(tempCount%, recAudiogramFreqList[37:tempCount%], inds%[],0);
        endcase;
        'Update GUI
        DlgValue$(recAudiogramFreqList1%,recAudiogramFreqList1$);
        DlgValue$(recAudiogramFreqList2%,recAudiogramFreqList2$);
        DlgValue$(recAudiogramFreqList3%,recAudiogramFreqList3$);
        DlgValue$(recAudiogramFreqList4%,recAudiogramFreqList4$);
        DlgValue$(recAudiogramFreqList5%,recAudiogramFreqList5$);
        
    endcase;
    
    
    
    return 1;


end;
'end RecExpAudiogramDialogChanged%()


'===== RecAudiogramGetParams ===== 

func RecAudiogramGetParams()
	var key$;
    key$:="Reclab\\Audiogram";
    'for the audiogram we want to pull a few parameters that are going to override params from the standard
    'timing/reward dialog box, but not OVERWRITE them.  Audiogram will likely be done rarely and it will
    'have its own set of default values.
    
    recAudiogramS1Speaker% := GetIntRegistryValue%(key$, "AGSpeaker", recAudiogramS1Speaker%);
    recHitRewardmL := GetFloatRegistryValue(key$, "AGHitRewardmL", recHitRewardmL);
    recMinOnsetDelay := GetFloatRegistryValue(key$, "AGMinOnsetDelay", recMinOnsetDelay);
    recVarOnsetDelay := GetFloatRegistryValue(key$, "AGVarOnsetDelay", recVarOnsetDelay);
    recResponseWindow := GetFloatRegistryValue(key$, "AGResponseWindow", recResponseWindow);
    recTrialInitWindow := GetFloatRegistryValue(key$, "AGTrialInitWindow", recTrialInitWindow);
    recFalseAlarmTO := GetFloatRegistryValue(key$, "AGFalseAlarmTO", recFalseAlarmTO);
    recLazyMonkeyTO := GetFloatRegistryValue(key$, "AGLazyMonkeyTO", recLazyMonkeyTO);
    recAudiogramToneFreqLow := GetFloatRegistryValue(key$, "AGToneFreqLow", recAudiogramToneFreqLow);
    recAudiogramToneFreqHigh := GetFloatRegistryValue(key$, "AGToneFreqHigh", recAudiogramToneFreqHigh);
    recAudiogramNFreqs% := GetIntRegistryValue%(key$, "AGFreqNSteps", recAudiogramNFreqs%);
    recAudiogramNReversals% := GetIntRegistryValue%(key$, "AGNReversals", recAudiogramNReversals%);
    recAudiogramOnlyLogReversals% := GetIntRegistryValue%(key$, "AGOnlyLogReversals", recAudiogramOnlyLogReversals%);
    recAudiogramStartdB := GetFloatRegistryValue(key$, "AGStartdB", recAudiogramStartdB);
    recAudiogramInitialDirection% := GetIntRegistryValue%(key$, "AGInitialDirection", recAudiogramInitialDirection%);
    recAudiogramInitialdBStep := GetFloatRegistryValue(key$, "AGInitialdBStep", recAudiogramInitialdBStep);
    recAudiogramLouderdBStep := GetFloatRegistryValue(key$, "AGLouderdBStep", recAudiogramLouderdBStep);
    recAudiogramQuieterdBStep := GetFloatRegistryValue(key$, "AGQuieterdBStep", recAudiogramQuieterdBStep);

    return;

end; 
'end  RecAudiogramGetParams(); 


'===== RecAudiogramSaveParams ===== 

func RecAudiogramSaveParams()
	var key$;
    key$:="Reclab\\Audiogram";

    SetIntRegistryValue(key$, "AGSpeaker", recAudiogramS1Speaker%);
    SetFloatRegistryValue(key$, "AGHitRewardmL", recHitRewardmL);
    SetFloatRegistryValue(key$, "AGMinOnsetDelay", recMinOnsetDelay);
    SetFloatRegistryValue(key$, "AGVarOnsetDelay", recVarOnsetDelay);
    SetFloatRegistryValue(key$, "AGResponseWindow", recResponseWindow);
    SetFloatRegistryValue(key$, "AGTrialInitWindow", recTrialInitWindow);
    SetFloatRegistryValue(key$, "AGFalseAlarmTO", recFalseAlarmTO);
    SetFloatRegistryValue(key$, "AGLazyMonkeyTO", recLazyMonkeyTO);
    SetFloatRegistryValue(key$, "AGToneFreqLow", recAudiogramToneFreqLow);
    SetFloatRegistryValue(key$, "AGToneFreqHigh", recAudiogramToneFreqHigh);
    SetIntRegistryValue(key$, "AGFreqNSteps", recAudiogramNFreqs%);
    SetIntRegistryValue(key$, "AGNReversals", recAudiogramNReversals%);
    SetIntRegistryValue(key$, "AGOnlyLogReversals", recAudiogramOnlyLogReversals%);
    SetFloatRegistryValue(key$, "AGStartdB", recAudiogramStartdB);
    SetIntRegistryValue(key$, "AGInitialDirection", recAudiogramInitialDirection%);
    SetFloatRegistryValue(key$, "AGInitialdBStep", recAudiogramInitialdBStep);
    SetFloatRegistryValue(key$, "AGLouderdBStep", recAudiogramLouderdBStep);
    SetFloatRegistryValue(key$, "AGQuieterdBStep", recAudiogramQuieterdBStep);

    
	return;

end; 
'end  RecAudiogramSaveParams(); 














'
'
'===== RecExpAMDiscDialog =====

'A dialog for the AMDisc experiment

func RecExpAMDiscDialog%()
    
    var i%;
    var status% := 0;
    
    ' Fetch parameters from registry    
    RecAMDiscGetParams();
    RecAMDiscExpListLoadGetParams(recAMDiscExpNameLoad$[],recAMDiscStimcalNameLoad$[],recAMDiscTrialsNameLoad$[]);
    RecAMDiscExpListGenGetParams(recAMDiscExpNameGen$[],recAMDiscStimcalNameGen$[],recAMDiscTrialsNameGen$[]);
        
    
    ' Generate the dialog    
    DlgCreate("AM Discrimination Dialog",0,0,74,14);
    
    DlgGroup("Stimulus Selection",1,1,72,4);
    DlgCheck(1,"Create Stimuli?",2,2);
    DlgList(2,27,recAMDiscExpNameGen$[],recAMDiscNumExps%,24,3); 'For list box, set width and put in a DlgText
    recAMDiscText1% := DlgText("Select Exp't (Create Stim)",2,3);
    DlgList(3,27,recAMDiscExpNameLoad$[],recAMDiscNumExps%,24,4);
    recAMDiscText2% := DlgText("Select Exp't (Load Stim)",2,4);
    DlgButton(recAMDiscAddExpButton%, "  Add Experiment  ", RecAMDiscAddExp%,53,3);
    DlgButton(recAMDiscDeleteExpButton%, "Delete Experiment ", RecAMDiscDeleteExp%,53,4);
    
    DlgGroup("Variables",1,6,72,5);
    'DlgInteger(4,6,1,20,27,6);  'S1 speaker  'Removing S1 speaker as S1s will be determined by trials in trials file
    'DlgText("Preferred Speaker",8,6);
    DlgInteger(4,6,1,9,27,7);  'Min S1
    DlgText("Minimum S1 Presentations",2,7);
    DlgCheck(9,"Trial initiation reward?",46,7);
    'DlgReal(10,4,0,3,65,8); DlgText("Training Reward, mL",46,8);
    DlgCheck(10,"Trial Hold reward?",46,8);    

    DlgInteger(5,6,0,8,27,8);  'Var S1
    DlgText("Variable S1 Presentations",2,8);
    DlgReal(6,6,0,1,27,9);  'Proportion of catch trials
    DlgText("Proportion of Catch Trials",2,9);
    DlgText("(if catch trials are in trials file, set to 0)",2,10);
    DlgReal(7,6,0,100,65,9);  'dB level
    DlgText("dB Level",46,9);
    DlgInteger(8,6,1,100,65,10);  'Repeats
    DlgText("Repeats per stimulus",46,10);
    DlgCheck(11,"Passive task?",2,12);
    
    DlgAllow(0xffff, 0, RecExpAMDiscDialogChanged%);
    
    ' Show the dialog. 
    'i%:=DlgShow(recAMDiscMatGenStim%,recAMDiscExpIndexGen%,recAMDiscExpIndexLoad%,recAMDiscS1Speaker%,recAMDiscMinS1%,recAMDiscVarS1%,
    '            recAMDiscPropCatch,recAMDiscdBLevel,recAMDiscRepeatsPerStim%);  
    
    i%:=DlgShow(recAMDiscMatGenStim%,recAMDiscExpIndexGen%,recAMDiscExpIndexLoad%,recAMDiscMinS1%,recAMDiscVarS1%,
                recAMDiscPropCatch,recAMDiscdBLevel,recAMDiscRepeatsPerStim%, recAMDiscTrialInitReward%, recAMDiscTrialHoldReward%, recAMSPPassiveTask%);  'not setting recAMDiscS1Speaker% in this version

    'printlog("recTrainingRewardmL %f\n", recTrainingRewardmL);
    
    ' If user hit OK then save parameters (and return 1). 
	if i% = 1 then
        RecAMDiscSaveParams();
        if recAMDiscMinS1% + recAMDiscVarS1% <= recMaxStimPerTrial%-1 then
            'Reset dialog OK button text on Select dialog, and note which experiment to run
            DlgValue$(-1,"Run AM Disc");
            DlgEnable(1,3);  'make sure that the Nspeakers selection item is enabled on the main dialog
            recExpToRun% := recExpAMDiscButton%;
            recExpSelectDialogAllowOK% := 1;  'Prepare to enable OK button
            recExpSelectDialogChanged%(-1);  'Enables "OK" button, -1 is sham input
        
            'assign AM-Disc-specific variables to experiment-wide variables (so we can keep separate defaults but only code once)
            recS1Speaker% := recAMDiscS1Speaker%;
            recS2Speaker% := recAMDiscS1Speaker%;  'S2 is same as S1
            recMinS1% := recAMDiscMinS1%;
            recVarS1% := recAMDiscVarS1%;
            recPropCatch := recAMDiscPropCatch;  'Make sure we need this
            recDeltadBLevel := 65-recAMDiscdBLevel;
            recActive% := 1;   'Don't give an option, must be active
            recFixLED% := 1;
            recMatGenStim% := recAMDiscMatGenStim%;
            recTrialInitReward% := recAMDiscTrialInitReward%;
            recTrialHoldReward% := recAMDiscTrialHoldReward%;
        else
            message("The number of variable + constant S1s is greater than the maximum allowed number (%d)",recMaxStimPerTrial%-1);
            DlgValue$(-1,"OK");
            recExpSelectDialogAllowOK% := 0;  'Prepare to disable OK button
            recExpSelectDialogChanged%(-1);  'Enables "OK" button, -1 is sham input
        endif;   
        
'           'We might need to specify a number of trials here...I'm assuming yes.  Note that SEARCH runs until the
'           'user stops it, but this may be difficult to implement in practice - it would require fresh round(s) of
'           'trial list generation that don't happen for other experiment types.  Most likely the easiest way to do
'           'this is just to make a huge number of trials that the user won't exhaust, like 10,000 or something.        
        
        
        status% := 1;
    else
        status% := 1;
    endif
    
	return status%;
   
end;

'===== End RecExpAMDiscDialog =====
'
'




'
'
'===== RecExpAMDiscDialogChanged =====

func RecExpAMDiscDialogChanged%(item%) 
 
    docase
    case DlgValue(1) = 1 then
        DlgEnable(1,2);  'Enable use of generate list box
        DlgEnable(0,3);  'Disenable use of load list box
        DlgEnable(1,recAMDiscText1%);  'Enable use of generate list box
        DlgEnable(0,recAMDiscText2%);  'Disable use of load list box
    case DlgValue(1) = 0 then
        DlgEnable(0,2);  'Disenable use of generate list box
        DlgEnable(1,3);  'Enable use of load list box  
        DlgEnable(0,recAMDiscText1%);  'Enable use of generate list box
        DlgEnable(1,recAMDiscText2%);  'Disable use of load list box        
    endcase;
    
    return 1;
end

'===== End RecExpAMDiscDialogChanged =====
'
'


'
'
'===== RecExpSpaceDisDialog =====

'A dialog for the SpaceDis experiment

func RecExpSpaceDisDialog%()
    
    var i%;
    var status% := 0;
    
    ' Fetch parameters from registry    
    RecSpaceDisGetParams();
    RecSpaceDisExpListLoadGetParams(recSpaceDisExpNameLoad$[],recSpaceDisStimcalNameLoad$[],recSpaceDisTrialsNameLoad$[]);
    RecSpaceDisExpListGenGetParams(recSpaceDisExpNameGen$[],recSpaceDisStimcalNameGen$[],recSpaceDisTrialsNameGen$[]);
        
    
    ' Generate the dialog    
    DlgCreate("Space Discrimination Dialog",0,0,74,14);
    
    DlgGroup("Stimulus Selection",1,1,72,4);
    DlgCheck(1,"Create Stimuli?",2,2);
    DlgList(2,27,recSpaceDisExpNameGen$[],recSpaceDisNumExps%,24,3); 'For list box, set width and put in a DlgText
    recSpaceDisText1% := DlgText("Select Exp't (Create Stim)",2,3);
    DlgList(3,27,recSpaceDisExpNameLoad$[],recSpaceDisNumExps%,24,4);
    recSpaceDisText2% := DlgText("Select Exp't (Load Stim)",2,4);
    DlgButton(recSpaceDisAddExpButton%, "  Add Experiment  ", RecSpaceDisAddExp%,53,3);
    DlgButton(recSpaceDisDeleteExpButton%, "Delete Experiment ", RecSpaceDisDeleteExp%,53,4);
    
    DlgGroup("Variables",1,6,72,5);
    'DlgInteger(4,6,1,20,27,6);  'S1 speaker  'Removing S1 speaker as S1s will be determined by trials in trials file
    'DlgText("Preferred Speaker",8,6);
    DlgInteger(4,6,1,9,27,7);  'Min S1
    DlgText("Minimum S1 Presentations",2,7);
    DlgCheck(9,"Trial initiation reward?",46,7);
    'DlgReal(10,4,0,3,65,8); DlgText("Training Reward, mL",46,8); 
    DlgCheck(10,"Trial hold reward?",46,8);
    
    DlgInteger(5,6,0,8,27,8);  'Var S1
    DlgText("Variable S1 Presentations",2,8);
    DlgReal(6,6,0,1,27,9);  'Proportion of catch trials
    DlgText("Proportion of Catch Trials",2,9);
    DlgText("(if catch trials are in trials file, set to 0)",2,10);
    DlgReal(7,6,0,100,65,9);  'dB level
    DlgText("dB Level",46,9);
    DlgInteger(8,6,1,100,65,10);  'Repeats
    DlgText("Repeats per stimulus",46,10);
    DlgCheck(11,"Passive task?",2,12);
    
    DlgAllow(0xffff, 0, RecExpSpaceDisDialogChanged%);
    
    ' Show the dialog. 
    'i%:=DlgShow(recAMDiscMatGenStim%,recAMDiscExpIndexGen%,recAMDiscExpIndexLoad%,recAMDiscS1Speaker%,recAMDiscMinS1%,recAMDiscVarS1%,
    '            recAMDiscPropCatch,recAMDiscdBLevel,recAMDiscRepeatsPerStim%);  
    
    i%:=DlgShow(recSpaceDisMatGenStim%,recSpaceDisExpIndexGen%,recSpaceDisExpIndexLoad%,recSpaceDisMinS1%,recSpaceDisVarS1%,
                recSpaceDisPropCatch,recSpaceDisdBLevel,recSpaceDisRepeatsPerStim%, recSpaceDisTrialInitReward%, recSpaceDisTrialHoldReward%, recAMSPPassiveTask%);  'not setting recAMDiscS1Speaker% in this version

    'printlog("recTrainingRewardmL %f\n", recTrainingRewardmL);
    
    ' If user hit OK then save parameters (and return 1). 
	if i% = 1 then
        RecSpaceDisSaveParams();
        if recSpaceDisMinS1% + recSpaceDisVarS1% <= recMaxStimPerTrial%-1 then
            'Reset dialog OK button text on Select dialog, and note which experiment to run
            DlgValue$(-1,"Run Space Dis");
            DlgEnable(1,3);  'make sure that the Nspeakers selection item is enabled on the main dialog
            recExpToRun% := recExpSpaceDisButton%;
            recExpSelectDialogAllowOK% := 1;  'Prepare to enable OK button
            recExpSelectDialogChanged%(-1);  'Enables "OK" button, -1 is sham input
        
            'assign AM-Disc-specific variables to experiment-wide variables (so we can keep separate defaults but only code once)
'            recS1Speaker% := recSpaceDisS1Speaker%;
'            recS2Speaker% := recSpaceDisS1Speaker%;  'from AMDis
            recMinS1% := recSpaceDisMinS1%;
            recVarS1% := recSpaceDisVarS1%;
            recPropCatch := recSpaceDisPropCatch;  'Make sure we need this
            recDeltadBLevel := 65-recSpaceDisdBLevel;
            recActive% := 1;   'Don't give an option, must be active
            recFixLED% := 1;
            recMatGenStim% := recSpaceDisMatGenStim%;
            recTrialInitReward% := recSpaceDisTrialInitReward%;
            recTrialHoldReward% := recSpaceDisTrialHoldReward%;
        else
            message("The number of variable + constant S1s is greater than the maximum allowed number (%d)",recMaxStimPerTrial%-1);
            DlgValue$(-1,"OK");
            recExpSelectDialogAllowOK% := 0;  'Prepare to disable OK button
            recExpSelectDialogChanged%(-1);  'Enables "OK" button, -1 is sham input
        endif;   
        
'           'We might need to specify a number of trials here...I'm assuming yes.  Note that SEARCH runs until the
'           'user stops it, but this may be difficult to implement in practice - it would require fresh round(s) of
'           'trial list generation that don't happen for other experiment types.  Most likely the easiest way to do
'           'this is just to make a huge number of trials that the user won't exhaust, like 10,000 or something.        
        
        
        status% := 1;
    else
        status% := 1;
    endif
    
	return status%;
   
end;

'===== End RecExpSpaceDisDialog% =====
'
'




'
'
'===== RecExpSpaceDisDialogChanged =====

func RecExpSpaceDisDialogChanged%(item%) 
 
    docase
    case DlgValue(1) = 1 then
        DlgEnable(1,2);  'Enable use of generate list box
        DlgEnable(0,3);  'Disenable use of load list box
        DlgEnable(1,recSpaceDisText1%);  'Enable use of generate list box
        DlgEnable(0,recSpaceDisText2%);  'Disenable use of load list box
    case DlgValue(1) = 0 then
        DlgEnable(0,2);  'Disenable use of generate list box
        DlgEnable(1,3);  'Enable use of load list box  
        DlgEnable(0,recSpaceDisText1%);  'Enable use of generate list box
        DlgEnable(1,recSpaceDisText2%);  'Disenable use of load list box        
    endcase;
    
    return 1;
end

'===== End RecExpSpaceDisDialogChanged =====
'
'

'
'
'===== RecExpCueingDialog =====

'A dialog for the Cueing experiment

func RecExpCueingDialog%()
    
    var i%;
    var status% := 0;
    
    ' Fetch parameters from registry    
   
    
    ' Generate the dialog
    
    DlgCreate("Cueing Experiment Dialog", 25, 10);
    DlgCheck(1, "Is this a dummy dialog?");
    
    ' Show the dialog. 
    i%:=DlgShow(dummyVar%);
    
    ' If user hit OK then save parameters (and return 1). 
	if i% = 1 then
        recExpToRun% := recExpCueingButton%;
        
        status% := 1;
    else
        status% := 1;
    endif
    
	return status%;
   
end;

'===== End RecExpCueingDialog =====
'
'


'
'
'===== RecExpStereoDisDialog =====

'A dialog for the Stereo Distractor experiment(s?)

func RecExpStereoDisDialog%()
    
    var i%;
    var status% := 0;
    
    ' Fetch parameters from registry, forced choice  
    RecStereoDisGetParams();
    RecStereoDisExpListLoadGetParams(recStereoDisExpNameLoad$[],recStereoDisStimcalNameLoad$[],recStereoDisTrialsNameLoad$[],recStereoDisStimcalDistractorNameLoad$[]);
    RecStereoDisExpListGenGetParams(recStereoDisExpNameGen$[],recStereoDisStimNameGen$[],recStereoDisTrialsNameGen$[]);
    
    ' Fetch parameters from registry, GNG
    RecStereoDisGNGGetParams();
    RecStereoDisGNGExpListLoadGetParams(recStereoDisGNGExpNameLoad$[],recStereoDisGNGStimcalNameLoad$[],recStereoDisGNGTrialsNameLoad$[],recStereoDisGNGStimcalDistractorNameLoad$[]);
    RecStereoDisGNGExpListGenGetParams(recStereoDisGNGExpNameGen$[],recStereoDisGNGStimNameGen$[],recStereoDisGNGTrialsNameGen$[]);
    
    ' Generate the dialog    
    DlgCreate("Stereo Distractor Dialog",0,0,74,14);
    
    DlgCheck(1,"Do Forced Choice Experiment",2,1);
    DlgCheck(2,"Generate Stimuli",30,1);
    
    DlgGroup("Stimulus Selection, Forced Choice",1,2,72,3);
    DlgList(3,27,recStereoDisExpNameGen$[],recStereoDisNumExps%,24,3);
    DlgList(4,27,recStereoDisExpNameLoad$[],recStereoDisNumExps%,24,4);
    recAMDiscText1% := DlgText("Select Exp't (Gen Stim)",2,3);
    recAMDiscText2% := DlgText("Select Exp't (Load Stim)",2,4); 
    DlgButton(recExpStereoDisAddExpButton%, "   Add Experiment   ", RecStereoDisAddExp%,53,3);
    DlgButton(recExpStereoDisDeleteExpButton%, "Delete Experiment ", RecStereoDisDeleteExp%,53,4);
    
    DlgGroup("Stimulus Selection, Go/No-Go",1,5,72,3);
    DlgList(5,27,recStereoDisGNGExpNameGen$[],recStereoDisGNGNumExps%,24,6);
    DlgList(6,27,recStereoDisGNGExpNameLoad$[],recStereoDisGNGNumExps%,24,7);
    recAMDiscText3% := DlgText("Select Exp't (Gen Stim)",2,6); 
    recAMDiscText4% := DlgText("Select Exp't (Load Stim)",2,7); 
    DlgButton(recExpStereoDisGNGAddExpButton%, "   Add Experiment   ", RecStereoDisGNGAddExp%,53,6);
    DlgButton(recExpStereoDisGNGDeleteExpButton%, "Delete Experiment ", RecStereoDisGNGDeleteExp%,53,7);
    
    DlgInteger(7,"Repeats Per Stim",1,1000,18,9);
    DlgAllow(0xffff, 0, RecExpStereoDisDialogChanged%);   
    
    
    i%:=DlgShow(recStereoDisExpDoFC%,recStereoDisExpDoGen%,recStereoDisExpIndexGen%,recStereoDisExpIndexLoad%,recStereoDisGNGExpIndexGen%,recStereoDisGNGExpIndexLoad%,recStereoDisRepeatsPerStim%);   'Yes, that's it!

    
    ' If user hit OK then save parameters (and return 1). 
	if i% = 1 then
        'set the GNG indicator
        recStereoDisExpDoGNG% := 1-recStereoDisExpDoFC%;
        'set the load stimulus indicator
        recStereoDisExpDoLoad% := 1-recStereoDisExpDoGen%;
        
        RecStereoDisSaveParams();        
        RecStereoDisGNGSaveParams();
        
        DlgValue$(-1,"Run StereoDis"); 'to enable OK button? see also ~line 1156 in RecRoom (RecExpSearchDialog) 
        recExpToRun% := recExpStereoDisButton%;
        recExpSelectDialogAllowOK% := 1;  'Prepare to enable OK button
        recExpSelectDialogChanged%(-1);  'Enables "OK" button, -1 is sham input
            
        recAMSPPassiveTask% := 0;
        recActive% := 1;
        
        if recStereoDisExpDoGen% = 1 then
            recMatGenStim% := 1;
        else
            recMatGenStim% := 0;
        endif;
        
        if recStereoDisExpDoFC% = 1 then
            recIsGoNoGo% := 0;
        else
            recIsGoNoGo% := 1;
        endif;
    
        status% := 1;
    else
        status% := 1;
    endif
    
	return status%;
   
end;


'
'
'===== RecExpStereoDisDialogChanged =====

' This function is initially called with a "0" input
func RecExpStereoDisDialogChanged%(item%)
        
    docase
    case item% <= 2 and DlgValue(1) = 1 and DlgValue(2) = 1 then  'if we are running FC/Gen, disable GNG/Load buttons
        DlgEnable(1,3); 'Enable FC list selection (gen)
        DlgEnable(0,4); 'Disable FC list selection (load)
        DlgEnable(1,-recExpStereoDisAddExpButton%); 'Enable FC add button
        DlgEnable(1,-recExpStereoDisDeleteExpButton%); 'Enable FC delete button
        DlgEnable(0,5); 'Disable GNG list selection (gen)
        DlgEnable(0,6); 'Disable GNG list selection (load)
        DlgEnable(0,-recExpStereoDisGNGAddExpButton%); 'Disable GNG add button
        DlgEnable(0,-recExpStereoDisGNGDeleteExpButton%); 'Disable GNG delete button
        DlgEnable(1,recAMDiscText1%);  'Enable FC generate list text
        DlgEnable(0,recAMDiscText2%);  'Disable FC load list text
        DlgEnable(0,recAMDiscText3%);  'Disable GNG generate list text
        DlgEnable(0,recAMDiscText4%);  'Disable GNG load list text
    case item% <= 2 and DlgValue(1) = 0 and DlgValue(2) = 1 then 'if we are running GNG/Gen, disable FC/Load buttons
        DlgEnable(0,3); 'Disable FC list selection (gen)
        DlgEnable(0,4); 'Disable FC list selection (load)
        DlgEnable(0,-recExpStereoDisAddExpButton%); 'Disable FC add button
        DlgEnable(0,-recExpStereoDisDeleteExpButton%); 'Disable FC delete button
        DlgEnable(1,5); 'Enable GNG list selection (gen)
        DlgEnable(0,6); 'Disable GNG list selection (load)
        DlgEnable(1,-recExpStereoDisGNGAddExpButton%); 'Enable GNG add button
        DlgEnable(1,-recExpStereoDisGNGDeleteExpButton%); 'Enable GNG delete button
        DlgEnable(0,recAMDiscText1%);  'Disable FC generate list text
        DlgEnable(0,recAMDiscText2%);  'Disable FC load list text
        DlgEnable(1,recAMDiscText3%);  'Enable GNG generate list text
        DlgEnable(0,recAMDiscText4%);  'Disable GNG load list text
    case item% <= 2 and DlgValue(1) = 1 and DlgValue(2) = 0 then  'if we are running FC/Load, disable GNG/Gen buttons
        DlgEnable(0,3); 'Disable FC list selection (gen)
        DlgEnable(1,4); 'Enable FC list selection (load)
        DlgEnable(1,-recExpStereoDisAddExpButton%); 'Enable FC add button
        DlgEnable(1,-recExpStereoDisDeleteExpButton%); 'Enable FC delete button
        DlgEnable(0,5); 'Disable GNG list selection (gen)
        DlgEnable(0,6); 'Disable GNG list selection (load)
        DlgEnable(0,-recExpStereoDisGNGAddExpButton%); 'Disable GNG add button
        DlgEnable(0,-recExpStereoDisGNGDeleteExpButton%); 'Disable GNG delete button
        DlgEnable(0,recAMDiscText1%);  'Disable FC generate list text
        DlgEnable(1,recAMDiscText2%);  'Enable FC load list text
        DlgEnable(0,recAMDiscText3%);  'Disable GNG generate list text
        DlgEnable(0,recAMDiscText4%);  'Disable GNG load list text
    case item% <= 2 and DlgValue(1) = 0 and DlgValue(2) = 0 then 'if we are running GNG/Load, disable FC/Gen buttons
        DlgEnable(0,3); 'Disable FC list selection (gen)
        DlgEnable(0,4); 'Disable FC list selection (load)
        DlgEnable(0,-recExpStereoDisAddExpButton%); 'Disable FC add button
        DlgEnable(0,-recExpStereoDisDeleteExpButton%); 'Disable FC delete button
        DlgEnable(0,5); 'Disable GNG list selection (gen)
        DlgEnable(1,6); 'Enable GNG list selection (load)
        DlgEnable(1,-recExpStereoDisGNGAddExpButton%); 'Enable GNG add button
        DlgEnable(1,-recExpStereoDisGNGDeleteExpButton%); 'Enable GNG delete button
        DlgEnable(0,recAMDiscText1%);  'Disable FC generate list text
        DlgEnable(0,recAMDiscText2%);  'Disable FC load list text
        DlgEnable(0,recAMDiscText3%);  'Disable GNG generate list text
        DlgEnable(1,recAMDiscText4%);  'Enable GNG load list text
    endcase;
    
    return 1;
end

'===== End RecExpStereoDisDialogChanged =====
'
'



'
'
'===== RecExpTimingRewardDialog =====

'A dialog for Timing and Rewards

func RecExpTimingRewardDialog%()
    
    var i%;
    var dummy%;
    var status% := 0;
    'var trwid% := 42;
    var trwid% := 84;
    var intStr$[2];
    var c1%;
    c1% := trwid%-56;
    var c1txt% := 2;
    var c2%;
    c2% := trwid%-14;
    var c2txt%;
    c2txt% := trwid%-40;
    
    var rewardType$[6];
    rewardType$[0] := "Juice Only";
    rewardType$[1] := "Stimulation Only";
    rewardType$[2] := "Juice+Stim";
    rewardType$[3] := "Cycle J/Stim/J+Stim";
    rewardType$[4] := "Set probabilities";
    rewardType$[5] := "Juice + Stim(sometimes)";
    
    intStr$[0] := "Stop Sound";
    intStr$[1] := "Complete Sound";

    
    ' Fetch parameters from registry , only if not a runtime call
    if recRunTimeCall% = 0 then   
        RecTimingRewardGetParams();   'RecTimingRewardGetParams() is below 
    endif;
    
    'Set up container for reals so we can have more than 20 elements in the dialog
    var sevenReals[7];
    sevenReals[0] := recTrainingRewardmL;
    sevenReals[1] := recHitRewardmL;
    sevenReals[2] := recCRRewardmL;
    sevenReals[3] := recMaxHitRewardmL;
    sevenReals[4] := recMaxCRRewardmL;
    sevenReals[5] := recHitRewardIncmL;
    sevenReals[6] := recS1RewardIncmL;
    
    'This will tell us how much is neither juice nor Stimulation
    var pctBoth%;
    pctBoth% := 100 - recPctJuice% - recPctStimulation%;
    
    
    ' Because the Audiogram experiment reassigns some of the values from this dialog, if this
    ' dialog is selected AFTER the audiogram dialog is selected, disable "OK" and force audiogram
    ' dialog to be selected again.
    if recExpToRun% = recExpAudiogramButton% then
        DlgValue$(-1,"Reselect Audiogram"); 'to rename OK button 
        recExpSelectDialogAllowOK% := 0;  'Prepare to disable OK button
        recExpSelectDialogChanged%(-1);  'Disables "OK" button, -1 is sham input
        'I'd like to point out how cool this is.
    endif;
    
    
    ' Generate the dialog
    
    DlgCreate("Timing and Reward Dialog", 0, 0, trwid%, 22);
    DlgGroup("Timing Parameters",1,1,trwid%-2,4);
    DlgReal(1,12,0,10,c1%,2); DlgText("Minimum Onset Delay, s",c1txt%,2);
    DlgReal(2,12,0,10,c1%,3); DlgText("Variable Onset Delay, s",c1txt%,3);
    DlgReal(3,12,0,10,c1%,4); DlgText("ISI, s",c1txt%,4);
    DlgReal(4,12,0.5,100,c2%,2); DlgText("Trial Initiation Window, s",c2txt%,2);
    DlgReal(5,12,0.5,100,c2%,3); DlgText("Response Window, s",c2txt%,3);
  '  DlgReal(18,12,0,100,c2%,4); DlgText("Joystick Min Duration, s",c2txt%,4); 'this variable doesn't seem to be used anywhere; same as MinOnsetDelay ??
    
    DlgGroup("Time Outs, etc.",1,6,trwid%-2,4);
    '''Lazy monkey timeout excised!  Uncomment to reinstate!
'    DlgReal(6,12,0,300,c1%,9); DlgText("Lazy Monkey TO, s",c1txt%,9);
    DlgReal(6,12,0,300,c1%,9); DlgText("THIS DOES NOTHING, s",c1txt%,9);
    
    DlgReal(7,12,0,300,c1%,7); DlgText("Miss TO, s",c1txt%,7);
    DlgReal(8,12,0,300,c1%,8); DlgText("False Alarm TO, s",c1txt%,8);
    DlgCheck(18,"Do Miss Repeats?",c2txt%+8,7);
    DlgInteger(19,12,0,30,c2%,8); DlgText("Max # Miss Repeats", c2txt%,8);
    
    DlgGroup("Rewards",1,11,trwid%-2,7);
    DlgReal(9,12,0,3,c1%+20,12); DlgText("Training Reward, mL",c1txt%+20,12); 'recTrainingRewardmL
    DlgReal(10,12,0,3,c1%,13); DlgText("Hit Reward, mL",c1txt%,13);
    DlgReal(11,12,0,3,c2%,13); DlgText("CR Reward, mL",c2txt%,13);
    DlgReal(12,12,0,3,c1%,14); DlgText("Max Hit Reward, mL",c1txt%,14);
    DlgReal(13,12,0,3,c2%,14); DlgText("Max CR Reward, mL",c2txt%,14);
    DlgReal(14,12,0,1,c1%,15); DlgText("Reward Increment on hits, mL",c1txt%,15);
    DlgReal(15,12,0,1,c2%,15); DlgText("Reward Increment Per S1, mL",c2txt%,15);
    DlgList(20,19,rewardType$[],6,c1%-7,16); DlgText("Reward Type",c1txt%,16);
    DlgInteger(21,12,0,100,c1%-15,17); DlgText("Pct Juice",c1txt%,17);  'note that these are on a three-per line and use different values
    DlgInteger(22,12,0,100,c1%+15,17); DlgText("Pct Stimulation",c1%+1,17);
    DlgLabel(23,"Pct Juice+Stimulation = "+Str$(pctBoth%),c1%+29,17);
    DlgInteger(24,12,0,500,c2%,16); DlgText("Stim Delay rel. to Juice (ms)", c2txt%,16);
    
    DlgGroup("Interrupts",1,19,trwid%-2,2);
    DlgList(16,20,intStr$[],2,c1%-8,20); DlgText("On S1 Interrupt",c1txt%,20);
    DlgList(17,20,intStr$[],2,c2%-8,20); DlgText("On S2 Interrupt",c2txt%,20);
    
    DlgAllow(0xffff, 0, RecExpTimingRewardDialogChanged%);
    
    ' Show the dialog. 
'    i%:=DlgShow(recMinOnsetDelay,recVarOnsetDelay,recISI,recTrialInitWindow,recResponseWindow,recLazyMonkeyTO,recMissTO,recFalseAlarmTO,
'                recTrainingRewardmL,recHitRewardmL,recCRRewardmL,recMaxHitRewardmL,recMaxCRRewardmL,recHitRewardIncmL,
'                recS1RewardIncmL,recContinueSoundOnS1Interrupt%,recContinueSoundOnS2Interrupt%,recMissRepeats%, recMissRepeatsMax%, recRewardType%);',recMinJoystickRespTime);
    
    i%:=DlgShow(recMinOnsetDelay,recVarOnsetDelay,recISI,recTrialInitWindow,recResponseWindow,recLazyMonkeyTO,recMissTO,recFalseAlarmTO,
                sevenReals[],recContinueSoundOnS1Interrupt%,recContinueSoundOnS2Interrupt%,recMissRepeats%, recMissRepeatsMax%, 
                recRewardType%,recPctJuice%,recPctStimulation%,dummy%,recJuiceToStimDelay%);
    
    
    ' If user hit OK then save parameters (and return 1). 
	if i% = 1 then
        'unpack sevenReals
        recTrainingRewardmL := sevenReals[0];
        recHitRewardmL := sevenReals[1];
        recCRRewardmL := sevenReals[2];
        recMaxHitRewardmL := sevenReals[3];
        recMaxCRRewardmL := sevenReals[4];
        recHitRewardIncmL := sevenReals[5];
        recS1RewardIncmL := sevenReals[6];
        
        'make sure that probability values are valid
        if recRewardType% = 4 then
            if recPctJuice% + recPctStimulation% > 100 then
                message("The percentage of Juice + Stimulation is greater than 100!  Reverting to 'cycled' reward! \nPlease re-try dialog!");
                recRewardType% := 3;
            endif;
        endif;
        
        'set first reward type randomly if cycling (this will actually be cycled before the first trial, but it gets us a random start point
        'also, set reward type permanently if not changing
        docase
        case recRewardType% = 3 then
            recCurrentRewardType% := Floor(Rand(3,0));  'will give [0, 1, 2] for [juice, stim, both]
        case recRewardType% = 2 then 
            recCurrentRewardType% := 2;  'if juice + stim, set to juice + stim
        case recRewardType% = 1 then
            recCurrentRewardType% := 1;  'if only stim, set to stim
        case recRewardType% = 0 then
            recCurrentRewardType% := 0;  'if only juice, set to juice
        endcase;
        
        'set maximum number of electrodes allowed, based on whether we need stimulation ports
        'if recRewardType% > 0 then 'if stimulating
        '    maxTrodes% := 4;  'per Conor, Reclab will NOT be using multi-contact probes and stimulation together
        'else
        '    maxTrodes% := 28;  
        'endif;
        
        
        if recRunTimeCall% = 0 then 'only save parameters if it's a non-run-time call, run-time calls are often for late-session adjustments and shouldn't start the next session
            RecTimingRewardSaveParams();   'RecTimingRewardSaveParams() is below 
        endif;
        
        status% := 1;
    else
        status% := 1;
    endif
    
	return status%;
   
end;

'===== End RecExpTimingRewardDialog =====
'
'



'
'
'===== RecExpTimingRewardDialogChanged =====

' This function is initially called with a "0" input
func RecExpTimingRewardDialogChanged%(item%) 
    
'    docase
'    case DlgValue(20) = 4 then  'if setting probabilities of juice, etc.
'        DlgEnable(1,21); 'Enable juice probability
'        DlgEnable(1,22); 'Enable stim probability
'        DlgEnable(1,23); 'Enable juice+stim probability label
'    case DlgValue(20) = 5 then 'if setting juice + stim, but it's always juice
'        DlgEnable(0,21); 'Disable juice probability
'        DlgEnable(1,22); 'Enable stim probability
'        DlgEnable(0,23); 'Disable juice+stim probability label
'    else
'        DlgEnable(0,21); 'Disable juice probability
'        DlgEnable(0,22); 'Disable stim probability
'        DlgEnable(0,23); 'Disable juice+stim probability label
'    endcase;
'    
'    if DlgValue(20) = 0 then 'if only juice
'        DlgEnable(0,24); 'Disable stim delay
'    else
'        DlgEnable(1,24); 'Enable stim delay
'    endif;
    
    DlgEnable(0,20); 'Disable stimulation reward
    DlgEnable(0,21); 'Disable juice pct
    DlgEnable(0,22); 'Disable stim pct
    DlgEnable(0,23); 'Disable label
    DlgEnable(0,24); 'Disable stim delay
    
    
    'update value in text label
    if item% = 21 or item% = 22 then
        printlog("val should be %s\n",Str$(100-DlgValue(21)-DlgValue(22)));
        DlgValue$(23,"Pct Juice+Stimulation = "+Str$(100-DlgValue(21)-DlgValue(22)));
    endif;
    
    return 1;
end

'===== End RecExpTimingRewardDialogChanged =====
'
'








'
'
'===== RecTimingRewardGetParams =====

'Fetch Timing/Reward parameters from the registry
proc RecTimingRewardGetParams()
	var key$;
    key$:="Reclab\\TimingRewardParam";

    recMinOnsetDelay := GetFloatRegistryValue(key$, "MinOnsetDelay", recMinOnsetDelay);
    recVarOnsetDelay := GetFloatRegistryValue(key$, "VarOnsetDelay", recVarOnsetDelay);
    recISI := GetFloatRegistryValue(key$, "ISI", recISI);
    recTrialInitWindow := GetFloatRegistryValue(key$, "TrialInitWindow", recTrialInitWindow);
    recResponseWindow := GetFloatRegistryValue(key$, "ResponseWindow", recResponseWindow);
    recLazyMonkeyTO := GetFloatRegistryValue(key$, "LazyMonkeyTO", recLazyMonkeyTO);
    recMissTO := GetFloatRegistryValue(key$, "MissTO", recMissTO);
    recFalseAlarmTO := GetFloatRegistryValue(key$, "FalseAlarmTO", recFalseAlarmTO);
    recInterruptTO := GetFloatRegistryValue(key$, "InterruptTO", recInterruptTO);
    recTrainingRewardmL := GetFloatRegistryValue(key$, "TrainingRewardmL", recTrainingRewardmL);
    recHitRewardmL := GetFloatRegistryValue(key$, "HitRewardmL", recHitRewardmL);
    recCRRewardmL := GetFloatRegistryValue(key$, "CRRewardmL", recCRRewardmL);
    recMaxHitRewardmL := GetFloatRegistryValue(key$, "MaxHitRewardmL", recMaxHitRewardmL);
    recMaxCRRewardmL := GetFloatRegistryValue(key$, "MaxCRRewardmL", recMaxCRRewardmL);
    recHitRewardIncmL := GetFloatRegistryValue(key$, "HitRewardIncmL", recHitRewardIncmL);
    recS1RewardIncmL := GetFloatRegistryValue(key$, "S1RewardIncmL", recS1RewardIncmL);
    recMinJoystickRespTime := GetFloatRegistryValue(key$, "MinJoystickRespTime", recMinJoystickRespTime);
    recContinueSoundOnS1Interrupt% := GetIntRegistryValue%(key$, "ContinueSoundOnS1Interrupt", recContinueSoundOnS1Interrupt%);
    recContinueSoundOnS2Interrupt% := GetIntRegistryValue%(key$, "ContinueSoundOnS2Interrupt", recContinueSoundOnS2Interrupt%);
    recMissRepeats% := GetIntRegistryValue%(key$, "MissRepeats", recMissRepeats%);
    recMissRepeatsMax% := GetIntRegistryValue%(key$, "MissRepeatsMax", recMissRepeatsMax%);
    recRewardType% := GetIntRegistryValue%(key$, "RewardType", recRewardType%);
    recPctJuice% := GetIntRegistryValue%(key$, "PctJuice", recPctJuice%);
    recPctStimulation% := GetIntRegistryValue%(key$, "PctStimulation", recPctStimulation%);
    recJuiceToStimDelay% := GetIntRegistryValue%(key$, "JuiceToStimDelay", recJuiceToStimDelay%);
    
    
	return;
end

'===== End RecTimingRewardGetParams =====
'
'



'
'
'===== RecTimingRewardSaveParams =====

'Save Timing/Reward parameters to the registry
proc RecTimingRewardSaveParams()

	var key$;
    key$:="Reclab\\TimingRewardParam";

    SetFloatRegistryValue(key$, "MinOnsetDelay", recMinOnsetDelay);
    SetFloatRegistryValue(key$, "VarOnsetDelay", recVarOnsetDelay);
    SetFloatRegistryValue(key$, "ISI", recISI);
    SetFloatRegistryValue(key$, "TrialInitWindow", recTrialInitWindow);
    SetFloatRegistryValue(key$, "ResponseWindow", recResponseWindow);
    SetFloatRegistryValue(key$, "LazyMonkeyTO", recLazyMonkeyTO);
    SetFloatRegistryValue(key$, "MissTO", recMissTO);
    SetFloatRegistryValue(key$, "FalseAlarmTO", recFalseAlarmTO);
    SetFloatRegistryValue(key$, "InterruptTO", recInterruptTO);
    SetFloatRegistryValue(key$, "TrainingRewardmL", recTrainingRewardmL);
    SetFloatRegistryValue(key$, "HitRewardmL", recHitRewardmL);
    SetFloatRegistryValue(key$, "CRRewardmL", recCRRewardmL);
    SetFloatRegistryValue(key$, "MaxHitRewardmL", recMaxHitRewardmL);
    SetFloatRegistryValue(key$, "MaxCRRewardmL", recMaxCRRewardmL);
    SetFloatRegistryValue(key$, "HitRewardIncmL", recHitRewardIncmL);
    SetFloatRegistryValue(key$, "S1RewardIncmL", recS1RewardIncmL); 
    SetFloatRegistryValue(key$, "MinJoystickRespTime", recMinJoystickRespTime);
    SetIntRegistryValue(key$, "ContinueSoundOnS1Interrupt", recContinueSoundOnS1Interrupt%);
    SetIntRegistryValue(key$, "ContinueSoundOnS2Interrupt", recContinueSoundOnS2Interrupt%);
    SetIntRegistryValue(key$, "MissRepeats", recMissRepeats%);
    SetIntRegistryValue(key$, "MissRepeatsMax", recMissRepeatsMax%);
    SetIntRegistryValue(key$, "RewardType", recRewardType%);
    SetIntRegistryValue(key$, "PctJuice", recPctJuice%);
    SetIntRegistryValue(key$, "PctStimulation", recPctStimulation%);
    SetIntRegistryValue(key$, "JuiceToStimDelay", recJuiceToStimDelay%);
    
	return;
end

'===== End RecTimingRewardSaveParams =====
'
'



'
'
'===== RecLeverJoystickDialog =====

'A dialog for Lever/Joystick settings

func RecExpLeverJoystickDialog%()
    
    var i%;
    var status% := 0;
    var trwid% := 45;
    var joyStr$[2];
    var initStr$[7];
    var resp1Str$[7];
    var resp2Str$[8];
    var c1%;
    c1% := trwid%-15;
    var c1txt% := 2;
    var nxax%;
    var nyax%;
    
    'This variable will allow us to set limits in a threshold subfunction based on whether or not
    'incrementing is happening, must set this to 0 before exiting function
    incrementDialogItem% := 5;
    
    joyStr$[0] := "Lever";
    joyStr$[1] := "Joystick";
    
    initStr$[0] := "Not Allowed";
    initStr$[1] := "Down";
    initStr$[2] := "Up";
    initStr$[3] := "Right";
    initStr$[4] := "Left";
    initStr$[5] := "X Axis";
    initStr$[6] := "Y Axis";
    
    resp1Str$[0] := "Center";
    resp1Str$[1] := "Down";
    resp1Str$[2] := "Up";
    resp1Str$[3] := "Right";
    resp1Str$[4] := "Left";
    resp1Str$[5] := "X Axis";
    resp1Str$[6] := "Y Axis";
    
    resp2Str$[0] := "Center";
    resp2Str$[1] := "Down";
    resp2Str$[2] := "Up";
    resp2Str$[3] := "Right";
    resp2Str$[4] := "Left";
    resp2Str$[5] := "X Axis";
    resp2Str$[6] := "Y Axis";
    resp2Str$[7] := "None";
    
    
    ' Fetch parameters from registry
    RecLeverJoystickGetParams();   'RecLeverJoystickGetParams() is below    
    
    
    ' Generate the dialog
    
    DlgCreate("Joystick/Lever Dialog", 0, 0, trwid%, 11);
    DlgList(1,20,joyStr$[],2,c1%-6,1); DlgText("Response Device",c1txt%,1);
    DlgList(2,20,initStr$[],7,c1%-6,2); DlgText("Trial Initiation Position",c1txt%,2);
    DlgCheck(6,"Expt is Go/No-Go",2,3);
    DlgList(3,20,resp1Str$[],7,c1%-6,4); DlgText("Response 1 (S2) Position",c1txt%,4);
    DlgList(4,20,resp2Str$[],8,c1%-6,5); DlgText("Response 2 (S1) Position",c1txt%,5);
    DlgButton(2,"Joystick Thresholds",SetJoystickThresholdDialog%,2,6);
    DlgCheck(5,"Do Increments",2,7);
    DlgButton(3,"Joystick Increments",SetJoystickThresholdIncrementDialog%,2,8);
    DlgButton(4,"Joystick Limits",SetJoystickThresholdLimitDialog%,2,9);
    
    'set dialog changed function
    DlgAllow(0xffff, 0, RecExpLeverJoystickDialogChanged%);
    
    ' Show the dialog. 
    i%:=DlgShow(recUseJoystick%,recTrialInitPosition%,recTrialResponsePosition1%,recTrialResponsePosition2%,recDoIncrements%,recIsGoNoGo%);
    
    ' If user hit OK then save parameters (and return 1). 
	if i% = 1 then
        RecExpSelectDialogChanged%(0); 'this might work?  Yep!  This changes the button label on the main dialog, if necessary
        
        'here's an attempt at being clever and saving some time
        'the following three DOCASES just tally up the number of times a certain position (e.g. "up", "left")
        'is called for in the three boxes.  Many results of 2 or lower are legal; any result of 3 or higher
        'is illegal; any result of 0 is illegal in forced choice.
        docase
        case recTrialInitPosition% = 3 or recTrialInitPosition% = 4 then 'left OR right
            nxax% := nxax% + 1;
        case recTrialInitPosition% = 1 or recTrialInitPosition% = 2 then 'up OR down
            nyax% := nyax% +1;
        case recTrialInitPosition% = 5 then 'both x-axis used
            nxax% := nxax% +2;  
        case recTrialInitPosition% = 6 then 'both y-axis used
            nyax% := nyax% +2;
        endcase
        
        docase
        case recTrialResponsePosition1% = 3 or recTrialResponsePosition1% = 4 then 'left OR right
            nxax% := nxax% + 1;
        case recTrialResponsePosition1% = 1 or recTrialResponsePosition1% = 2 then 'up OR down 
            nyax% := nyax% +1;
        case recTrialResponsePosition1% = 5 then 'both x-axis used
            nxax% := nxax% +2;  
        case recTrialResponsePosition1% = 6 then 'both y-axis used
            nyax% := nyax% +2;
        endcase
        
        docase
        case recTrialResponsePosition2% = 3 or recTrialResponsePosition2% = 4 then 'left OR right
            nxax% := nxax% + 1;
        case recTrialResponsePosition2% = 1 or recTrialResponsePosition2% = 2 then 'up OR down
            nyax% := nyax% +1;
        case recTrialResponsePosition2% = 5 then 'both x-axis used
            nxax% := nxax% +2;  
        case recTrialResponsePosition2% = 6 then 'both y-axis used
            nyax% := nyax% +2;
        endcase
        
        docase
        case recIsGoNoGo% = 0 and recTrialResponsePosition2% = 7 then
            message("Error - Response Position 2 cannot be 'None' for Forced Choice");
            RecExpLeverJoystickDialog%();  'call recursively - you can eat your soup right out of the ash trays if you wanna, it's OK, they're clean!
            status% := 1
        case nyax% > 2 or nxax% > 2 then
            message("Error - Init/resp1/resp2 positions cannot coincide!");
            RecExpLeverJoystickDialog%();  'call recursively - you can eat your soup right out of the ash trays if you wanna, it's OK, they're clean!
            status% := 1;
        case recIsGoNoGo% = 0 and (nyax% = 0 or nxax% = 0) then
            message("Error - Forced choice positions can't be on a line (think about it)!");
            'Note that if the origin were allowed to be somewhere other than the center (which it's not)
            'then the trial init position COULD be the center (currently can't be) and then this case
            'would no longer apply
            RecExpLeverJoystickDialog%();  'call recursively - you can eat your soup right out of the ash trays if you wanna, it's OK, they're clean!
            status% := 1;
        case recTrialInitPosition% = 0 then
            message("Error - You selected 'Not Allowed', you turd!");
            RecExpLeverJoystickDialog%();  'call recursively - you can eat your soup right out of the ash trays if you wanna, it's OK, they're clean!
            status% := 1
        case recTrialInitPosition% = recTrialResponsePosition1% or recTrialInitPosition% = recTrialResponsePosition2% or recTrialResponsePosition1% = recTrialResponsePosition2% then
            message("Error - Init/resp1/resp2 positions cannot coincide!");
            RecExpLeverJoystickDialog%();  'call recursively - you can eat your soup right out of the ash trays if you wanna, it's OK, they're clean!
            status% := 1;
        else
            RecLeverJoystickSaveParams();  
            'apply the changed values to the voltage versions of the variables            
            GetJoystickDegreesInVoltage(joystickVoltageConversionFactor);  
            status% := 1;
        endcase;
        
'This is an older version, using very simple rules        
'        'set incrementing variables, start by zeroing everything, then add change what is needed
'        'The current increment/decrement rules are as follows: 
'        'Increment on completion of a correct trial (H/CR)
'        'Decrement on Lazy Monkey Timeout for non-initiation of trial
'        'Do Not adjust on Lazy Monkey Timeout for non-return to center
'        'Do Not adjust in any other circumstance
'        doIncUp% := 0;
'        doIncDown% := 0;
'        doIncLeft% := 0;
'        doIncRight% := 0;
'        if recDoIncrements% = 1 then
'            'right now, only the init position can be set, this will require more thought if response position
'            'can be set in the future
'            if recTrialInitPosition% = 1 or recTrialInitPosition% = 6 then
'                doIncDown% := 1;
'            endif;
'            if recTrialInitPosition% = 2 or recTrialInitPosition% = 6 then
'                doIncUp% := 1;
'            endif;
'            if recTrialInitPosition% = 3 or recTrialInitPosition% = 5 then
'                doIncRight% := 1;
'            endif;
'            if recTrialInitPosition% = 4 or recTrialInitPosition% = 5 then
'                doIncLeft% := 1;
'            endif;            
'        endif;
        
        'Set incrementing variables, start by zeroing everything then change what is needed
        '[0] = up, [1] = down, [2] = left, [3] = right
        'The current increment/decerement rules are as follows:
        'Increment trial initiation direction on successful trial initiation
        'Decrement trial initiation direction on failed trial initiation
        'Increment S2 response direction on Hit
        'Decrement S2 response direction on Passive Miss (nothing on Active Miss)
        'Increment S1 response direction on CR
        'Decrement S1 response direction on Passive FA (nothing on Active FA)
        ArrConst(doIncTrialInit%[],0);
        ArrConst(doDecTrialInit%[],0);
        ArrConst(doIncHit%[],0);
        ArrConst(doDecPassiveMiss%[],0);
        ArrConst(doIncCR%[],0);
        ArrConst(doDecPassiveFA%[],0);
        if recDoIncrements% = 1 then
            docase
            case recTrialInitPosition% = 1 then
                doIncTrialInit%[1] := 1;
                doDecTrialInit%[1] := -1;
            case recTrialInitPosition% = 2 then
                doIncTrialInit%[0] := 1;
                doDecTrialInit%[0] := -1;
            case recTrialInitPosition% = 3 then
                doIncTrialInit%[3] := 1;
                doDecTrialInit%[3] := -1;
            case recTrialInitPosition% = 4 then
                doIncTrialInit%[2] := 1;
                doDecTrialInit%[2] := -1;
            case recTrialInitPosition% = 5 then
                doIncTrialInit%[2] := 1;
                doDecTrialInit%[2] := -1;
                doIncTrialInit%[3] := 1;
                doDecTrialInit%[3] := -1;    
            case recTrialInitPosition% = 6 then
                doIncTrialInit%[0] := 1;
                doDecTrialInit%[0] := -1;
                doIncTrialInit%[1] := 1;
                doDecTrialInit%[1] := -1;
            endcase
            'Note that because there is no logical to inc/dec a return to center (it just conflicts with
            'the trial initiation inc/dec), these docases are structured exactly the same as the trial init one above
            'This is S2 response direction
            docase
            case recTrialResponsePosition1% = 1 then
                doIncHit%[1] := 1;
                doDecPassiveMiss%[1] := -1;
            case recTrialResponsePosition1% = 2 then
                doIncHit%[0] := 1;
                doDecPassiveMiss%[0] := -1;
            case recTrialResponsePosition1% = 3 then
                doIncHit%[3] := 1;
                doDecPassiveMiss%[3] := -1;
            case recTrialResponsePosition1% = 4 then
                doIncHit%[2] := 1;
                doDecPassiveMiss%[2] := -1;
            case recTrialResponsePosition1% = 5 then
                doIncHit%[2] := 1;
                doDecPassiveMiss%[2] := -1;
                doIncHit%[3] := 1;
                doDecPassiveMiss%[3] := -1;    
            case recTrialResponsePosition1% = 6 then
                doIncHit%[0] := 1;
                doDecPassiveMiss%[0] := -1;
                doIncHit%[1] := 1;
                doDecPassiveMiss%[1] := -1;
            endcase    
            'This is S1 response direction
            docase
            case recTrialResponsePosition2% = 1 then
                doIncCR%[1] := 1;
                doDecPassiveFA%[1] := -1;
            case recTrialResponsePosition2% = 2 then
                doIncCR%[0] := 1;
                doDecPassiveFA%[0] := -1;
            case recTrialResponsePosition2% = 3 then
                doIncCR%[3] := 1;
                doDecPassiveFA%[3] := -1;
            case recTrialResponsePosition2% = 4 then
                doIncCR%[2] := 1;
                doDecPassiveFA%[2] := -1;
            case recTrialResponsePosition2% = 5 then
                doIncCR%[2] := 1;
                doDecPassiveFA%[2] := -1;
                doIncCR%[3] := 1;
                doDecPassiveFA%[3] := -1;    
            case recTrialResponsePosition2% = 6 then
                doIncCR%[0] := 1;
                doDecPassiveFA%[0] := -1;
                doIncCR%[1] := 1;
                doDecPassiveFA%[1] := -1;
            endcase    
                
                
        endif;
        
        
    else
        status% := 1;
    endif
    
    incrementDialogItem% := 0;  'must set to 0 on exit
    
        
	return status%;
   
end;

'===== End RecLeverJoystickDialog =====
'
'




'
'
'===== RecExpLeverJoystickDialogChanged =====

' This function is initially called with a "0" input
func RecExpLeverJoystickDialogChanged%(item%) 
    
    if DlgValue(1) = 0 then  'if we're using the lever, disable the init position, etc.
        DlgEnable(0,2);
        DlgEnable(0,3);
        DlgEnable(0,4);
        DlgEnable(0,5);
        DlgValue(6,1);
        DlgEnable(0,6);
        DlgEnable(0,-2);  'this is the threshold dialog button
        
    else
        DlgEnable(1,2); 'if we're using the joystick, enbable the init position, etc.
        DlgEnable(1,3);
        DlgEnable(1,4);
        DlgEnable(1,5);
        DlgEnable(1,6);
        DlgEnable(1,-2);  'this is the threshold dialog button
    endif;
    
    if DlgValue(5) = 1 and DlgValue(1) = 1 then
        DlgEnable(1,-3);  'this is the threshold increment dialog button
        DlgEnable(1,-4);  'this is the threshold limit dialog button
    else
        DlgEnable(0,-3);  'this is the threshold increment dialog button
        DlgEnable(0,-4);  'this is the threshold limit dialog button
    endif
    
    
    if DlgValue(6) = 1 then  'if it's go/no-go
        'DlgEnable(1,2); 'if we're using the joystick, enbable the init position, etc. 'what will this do???
        DlgValue(3,0); 'set the response position 1 to "center"
        DlgValue(4,7); 'set the response position 2 to "none"
        DlgEnable(0,3); 'and disable these
        DlgEnable(0,4);
    else
        DlgEnable(1,3); 'enable these
        DlgEnable(1,4);
    endif;
    
    
    return 1;
end

'===== End RecExpLeverJoystickDialogChanged =====
'
'





'
'
'===== RecLeverJoystickGetParams =====

'Fetch Lever/Joystick parameters from the registry
proc RecLeverJoystickGetParams()
	var key$;
    key$:="Reclab\\LeverJoystick";

    recUseJoystick% := GetIntRegistryValue%(key$, "UseJoystick", recUseJoystick%);
    recIsGoNoGo% := GetIntRegistryValue%(key$, "IsGoNoGo", recIsGoNoGo%);
    recTrialInitPosition% := GetIntRegistryValue%(key$, "TrialInitPosition", recTrialInitPosition%);
    recTrialResponsePosition1% := GetIntRegistryValue%(key$, "TrialResponsePosition1", recTrialResponsePosition1%);
    recTrialResponsePosition2% := GetIntRegistryValue%(key$, "TrialResponsePosition2", recTrialResponsePosition2%);
    recDoIncrements% := GetIntRegistryValue%(key$, "DoIncrements", recDoIncrements%);
    
    
	return;
end

'===== End RecJoystickLeverGetParams =====
'
'



'
'
'===== RecLeverJoystickSaveParams =====

'Save Lever/Joystick parameters to the registry
proc RecLeverJoystickSaveParams()

	var key$;
    key$:="Reclab\\LeverJoystick";
    
    SetIntRegistryValue(key$, "UseJoystick", recUseJoystick%);
    SetIntRegistryValue(key$, "IsGoNoGo", recIsGoNoGo%);
    SetIntRegistryValue(key$, "TrialInitPosition", recTrialInitPosition%);
    SetIntRegistryValue(key$, "TrialResponsePosition1", recTrialResponsePosition1%);
    SetIntRegistryValue(key$, "TrialResponsePosition2", recTrialResponsePosition2%);
    SetIntRegistryValue(key$, "DoIncrements", recDoIncrements%);
    
	return;
end

'===== End RecLeverJoystickSaveParams =====
'
'





'
'
'===== GetLinearProgression =====

' Get a linear progression from xmin to xmax, through nsteps%. Assumed that vec[] has enough room!
Proc GetLinearProgression(xmin, xmax, nsteps%, vec[])
	var stepsize;
	var v;
	var i%:= 0;
	stepsize := (xmax -xmin)/nsteps%;
	for v := xmin to xmax+stepsize/2 step stepsize do
		'PrintLog("Value=" + str$(v) + "\n");
		vec[i%] := v;
		i% := i% + 1;
	next;
end;

'===== End GetLinearProgression =====
'
'




'
'
'===== GetLogProgression =====

' Get a log progression from xmin to xmax, through nsteps%. Assumed that vec[] has enough room!
Proc GetLogProgression(xmin, xmax, nsteps%, &vec[])
	var stepsize;
	var v;
	var i%:= 0;
	stepsize := (Ln(xmax) - Ln(xmin))/nsteps%;
	for v := Ln(xmin) to Ln(xmax)+stepsize/2 step stepsize do
		'PrintLog("Value[" + str$(i%) + "]=" + str$(Exp(v)) + "\n");
		vec[i%] := Exp(v);
		i% := i% + 1;
	next;
end;

'===== End GetLogProgression =====
'
'




'
'
'===== StringifyProgression2 =====

' Put a vector of numbers into a comma separated string
' Note that this version produces numbers rounded to nearest tenth, has space instead of comma separator
func StringifyProgression2$(n%, vec[], ind%[], rnd%)
	var s$;
	var i%;
	for i% := 0 to n%-1 do
		if i% > 0 then 
			s$ += " ";
		endif
        if rnd% = 0 then
            s$ += str$(round(vec[ind%[i%]]));   'Cannot use below method to round to whole number, alternate method is obvious
        else
            s$ += str$(vec[ind%[i%]],0,-rnd%);  'will round with rnd% digits after the decimal
        endif;
    next
	return s$;
end;

'===== End StringifyProgression2 =====
'
'




'===== RecFRAAddExp =====

'This is a dialog that comes up to allow adding "experiments" to the AMDisc dialog
'Please note that in order to reset the list box in the calling dialog, we have to actually
'CLOSE the calling dialog and reopen it.  That's gotta be manual.
func RecFRAAddExp%()
    
    var i%;
    var j%;
    var k%;
    var status% := 0;
    var createMode%;
    var mystr$;
    var mystr2$;
    var mystr3$;
    
    createMode% := 0;
    
    
    
    ' Fetch parameters from registry    
    
    
    ' Generate the dialog
    
    DlgCreate("Cueing Experiment ADD Dialog", 62, 10);
    DlgString(1,40,100,"a-zA-Z0-9",26,1);
    DlgText("Name of New Experiment",2,1);
    if createMode% = 0 then
        DlgButton(recSelectStimFileButton%,   "Select Stim/Cal File", RecSelectStimFile%,2,2);
    else
        DlgButton(recSelectStimFileButton%,   "  Select Stim File  ", RecSelectStimFile%,2,2);
    endif;
    DlgButton(recSelectTrialsFileButton%, " Select Trials File ", RecSelectTrialsFile%,2,3);
    DlgString(2,40,200,"",26,2);  'for visual confirmation of selected stim file
    DlgString(3,40,200,"",26,3);  'for visual confirmation of selected trials file
    
    ' Show the dialog. 
    i%:=DlgShow(mystr$,mystr2$,mystr3$);
    
    ' If user hit OK then add new experiment 
	if i% = 1 then
        if createMode% = 0 then 
            'reload parameters
            RecFRAExpListLoadGetParams(recFRAExpNameLoad$[],recFRAStimcalNameLoad$[],recFRATrialsNameLoad$[]);
            'find first empty slot
            j% := 0;
            k% := -1;
            while j% < recFRANumExps% do
                if recFRAExpNameLoad$[j%] = "" then
                    k% := j%;  'k% holds index of first empty slot
                    j% := recFRANumExps%;
                endif;
                j%+=1;
            wend
            'Return if all slots are full
            if k% = -1 then
                Message("All " + Str$(recFRANumExps%) + " slots are full!  You must delete an experiment!");
                return 1;
            endif;
            'Otherwise place values 
            recFRAExpNameLoad$[k%] := mystr$;
            recFRAStimcalNameLoad$[k%] := mystr2$;
            recFRATrialsNameLoad$[k%] := mystr3$;
            'And save them
            RecFRAExpListLoadSaveParams(recFRAExpNameLoad$[],recFRAStimcalNameLoad$[],recFRATrialsNameLoad$[]);
            status% := 0;  'close the calling dialog - necessary to refresh list in AMDisDialog
        endif;
    else
        status% := 1;
    endif
    
	return status%;

end;

'===== End RecFRAAddExp =====
'
'



'
'
'===== RecFRADeleteExp =====

'This is a dialog that comes up to allow deleting "experiments" from the AMDisc dialog
func RecFRADeleteExp%()

    var i%;
    var j%;
    var status% := 0;
    var createMode%;
    var mystr$[recFRANumExps%];
    var mystr1$[recFRANumExps%];
    var mystr2$[recFRANumExps%];
    
    var sli%;
    
    createMode% := 0;
    
    
    
    ' Fetch parameters from registry    
    if createMode% = 0 then 
        'fetch parameters
        RecFRAExpListLoadGetParams(mystr$[],mystr1$[],mystr2$[]);
    else
        RecFRAExpListGenGetParams(mystr$[],mystr1$[],mystr2$[]);
    endif;
    
    
    ' Generate the dialog
    
    DlgCreate("Cueing Experiment DELETE Dialog", 62, 10);
    DlgText("Select Experiment to Delete",2,1);
    DlgList(1,27,mystr$,recFRANumExps%,28,1);

    ' Show the dialog. 
    i%:=DlgShow(sli%);
    
    ' If user hit OK then save parameters (and return 1). 
	if i% = 1 then
        'Remove experiment that has been selected and move everything up one
        if sli% < recFRANumExps%-1 then  'Without this "if", would crash if asked to remove final entry
            for j% := sli% to recFRANumExps%-2 do
                mystr$[j%] := mystr$[j%+1];
                mystr1$[j%] := mystr1$[j%+1];
                mystr2$[j%] := mystr2$[j%+1];
            next;
        endif;
        'Clear the final experiment slot, this is the only part to execute if asked to remove final entry
        mystr$[recFRANumExps%-1] := "";
        mystr1$[recFRANumExps%-1] := "";
        mystr2$[recFRANumExps%-1] := "";
        
        'Save the new values
        if createMode% = 0 then 
            RecFRAExpListLoadSaveParams(mystr$[],mystr1$[],mystr2$[]);
        else
            RecFRAExpListGenSaveParams(mystr$[],mystr1$[],mystr2$[]);
        endif;
        
        status% := 0;  'Close the calling dialog
    else
        status% := 1;
    endif
    
	return status%;
    
end;

'===== End RecFRADeleteExp =====

'
'
'===== RecAMDiscAddExp =====

'This is a dialog that comes up to allow adding "experiments" to the AMDisc dialog
'Please note that in order to reset the list box in the calling dialog, we have to actually
'CLOSE the calling dialog and reopen it.  That's gotta be manual.
func RecAMDiscAddExp%()
    
    var i%;
    var j%;
    var k%;
    var status% := 0;
    var createMode%;
    var mystr$;
    var mystr2$;
    var mystr3$;
    
    if DlgValue(1) = 1 then
        createMode% := 1;
    else
        createMode% := 0;
    endif;
    
    
    ' Fetch parameters from registry    
    
    
    ' Generate the dialog
    
    DlgCreate("Cueing Experiment ADD Dialog", 62, 10);
    DlgString(1,40,100,"a-zA-Z0-9",26,1);
    DlgText("Name of New Experiment",2,1);
    if createMode% = 0 then
        DlgButton(recSelectStimFileButton%,   "Select Stim/Cal File", RecSelectStimFile%,2,2);
    else
        DlgButton(recSelectStimFileButton%,   "  Select Stim File  ", RecSelectStimFile%,2,2);
    endif;
    DlgButton(recSelectTrialsFileButton%, " Select Trials File ", RecSelectTrialsFile%,2,3);
    DlgString(2,40,200,"",26,2);  'for visual confirmation of selected stim file
    DlgString(3,40,200,"",26,3);  'for visual confirmation of selected trials file
    
    ' Show the dialog. 
    i%:=DlgShow(mystr$,mystr2$,mystr3$);
    
    ' If user hit OK then add new experiment 
	if i% = 1 then
        if createMode% = 0 then 
            'reload parameters
            RecAMDiscExpListLoadGetParams(recAMDiscExpNameLoad$[],recAMDiscStimcalNameLoad$[],recAMDiscTrialsNameLoad$[]);
            'find first empty slot
            j% := 0;
            k% := -1;
            while j% < recAMDiscNumExps% do
                if recAMDiscExpNameLoad$[j%] = "" then
                    k% := j%;  'k% holds index of first empty slot
                    j% := recAMDiscNumExps%;
                endif;
                j%+=1;
            wend
            'Return if all slots are full
            if k% = -1 then
                Message("All " + Str$(recAMDiscNumExps%) + " slots are full!  You must delete an experiment!");
                return 1;
            endif;
            'Otherwise place values 
            recAMDiscExpNameLoad$[k%] := mystr$;
            recAMDiscStimcalNameLoad$[k%] := mystr2$;
            recAMDiscTrialsNameLoad$[k%] := mystr3$;
            'And save them
            RecAMDiscExpListLoadSaveParams(recAMDiscExpNameLoad$[],recAMDiscStimcalNameLoad$[],recAMDiscTrialsNameLoad$[]);
            status% := 0;  'close the calling dialog - necessary to refresh list in AMDisDialog
        else
            'reload parameters
            RecAMDiscExpListGenGetParams(recAMDiscExpNameGen$[],recAMDiscStimcalNameGen$[],recAMDiscTrialsNameGen$[]);
            'find first empty slot
            j% := 0;
            k% := -1;
            while j% < recAMDiscNumExps% do
                if recAMDiscExpNameGen$[j%] = "" then
                    k% := j%;  'k% holds index of first empty slot
                    j% := recAMDiscNumExps%;
                endif;
                j%+=1;
            wend
            'Return if all slots are full
            if k% = -1 then
                Message("All " + Str$(recAMDiscNumExps%) + " slots are full!  You must delete an experiment!");
                return 1;
            endif;
            'Otherwise place values 
            recAMDiscExpNameGen$[k%] := mystr$;
            recAMDiscStimcalNameGen$[k%] := mystr2$;
            recAMDiscTrialsNameGen$[k%] := mystr3$;
            'And save them
            RecAMDiscExpListGenSaveParams(recAMDiscExpNameGen$[],recAMDiscStimcalNameGen$[],recAMDiscTrialsNameGen$[]);
            status% := 0;  'close the calling dialog
        endif;
    else
        status% := 1;
    endif
    
	return status%;

end;

'===== End RecAMDiscAddExp =====
'
'



'
'
'===== RecAMDiscDeleteExp =====

'This is a dialog that comes up to allow deleting "experiments" from the AMDisc dialog
func RecAMDiscDeleteExp%()

    var i%;
    var j%;
    var status% := 0;
    var createMode%;
    var mystr$[recAMDiscNumExps%];
    var mystr1$[recAMDiscNumExps%];
    var mystr2$[recAMDiscNumExps%];
    
    var sli%;
    
    if DlgValue(1) = 1 then
        createMode% := 1;
    else
        createMode% := 0;
    endif;
    
    
    ' Fetch parameters from registry    
    if createMode% = 0 then 
        'fetch parameters
        RecAMDiscExpListLoadGetParams(mystr$[],mystr1$[],mystr2$[]);
    else
        RecAMDiscExpListGenGetParams(mystr$[],mystr1$[],mystr2$[]);
    endif;
    
    
    ' Generate the dialog
    
    DlgCreate("Cueing Experiment DELETE Dialog", 62, 10);
    DlgText("Select Experiment to Delete",2,1);
    DlgList(1,27,mystr$,recAMDiscNumExps%,28,1);

    ' Show the dialog. 
    i%:=DlgShow(sli%);
    
    ' If user hit OK then save parameters (and return 1). 
	if i% = 1 then
        'Remove experiment that has been selected and move everything up one
        if sli% < recAMDiscNumExps%-1 then  'Without this "if", would crash if asked to remove final entry
            for j% := sli% to recAMDiscNumExps%-2 do
                mystr$[j%] := mystr$[j%+1];
                mystr1$[j%] := mystr1$[j%+1];
                mystr2$[j%] := mystr2$[j%+1];
            next;
        endif;
        'Clear the final experiment slot, this is the only part to execute if asked to remove final entry
        mystr$[recAMDiscNumExps%-1] := "";
        mystr1$[recAMDiscNumExps%-1] := "";
        mystr2$[recAMDiscNumExps%-1] := "";
        
        'Save the new values
        if createMode% = 0 then 
            RecAMDiscExpListLoadSaveParams(mystr$[],mystr1$[],mystr2$[]);
        else
            RecAMDiscExpListGenSaveParams(mystr$[],mystr1$[],mystr2$[]);
        endif;
        
        status% := 0;  'Close the calling dialog
    else
        status% := 1;
    endif
    
	return status%;
    
end;

'===== End RecAMDiscDeleteExp =====
'
'

'
'
'===== RecSpaceDisAddExp =====

'This is a dialog that comes up to allow adding "experiments" to the SpaceDis dialog
'Please note that in order to reset the list box in the calling dialog, we have to actually
'CLOSE the calling dialog and reopen it.  That's gotta be manual.
func RecSpaceDisAddExp%()
    
    var i%;
    var j%;
    var k%;
    var status% := 0;
    var createMode%;
    var mystr$;
    var mystr2$;
    var mystr3$;
    
    if DlgValue(1) = 1 then
        createMode% := 1;
    else
        createMode% := 0;
    endif;
    
    
    ' Fetch parameters from registry    
    
    
    ' Generate the dialog
    
    DlgCreate("Cueing Experiment ADD Dialog", 62, 10);
    DlgString(1,40,100,"a-zA-Z0-9",26,1);
    DlgText("Name of New Experiment",2,1);
    if createMode% = 0 then
        DlgButton(recSelectStimFileButton%,   "Select Stim/Cal File", RecSelectStimFile%,2,2);
    else
        DlgButton(recSelectStimFileButton%,   "  Select Stim File  ", RecSelectStimFile%,2,2);
    endif;
    DlgButton(recSelectTrialsFileButton%, " Select Trials File ", RecSelectTrialsFile%,2,3);
    DlgString(2,40,200,"",26,2);  'for visual confirmation of selected stim file
    DlgString(3,40,200,"",26,3);  'for visual confirmation of selected trials file
    
    ' Show the dialog. 
    i%:=DlgShow(mystr$,mystr2$,mystr3$);
    
    ' If user hit OK then add new experiment 
	if i% = 1 then
        if createMode% = 0 then 
            'reload parameters
            RecSpaceDisExpListLoadGetParams(recSpaceDisExpNameLoad$[],recSpaceDisStimcalNameLoad$[],recSpaceDisTrialsNameLoad$[]);
            'find first empty slot
            j% := 0;
            k% := -1;
            while j% < recSpaceDisNumExps% do
                if recSpaceDisExpNameLoad$[j%] = "" then
                    k% := j%;  'k% holds index of first empty slot
                    j% := recSpaceDisNumExps%;
                endif;
                j%+=1;
            wend
            'Return if all slots are full
            if k% = -1 then
                Message("All " + Str$(recSpaceDisNumExps%) + " slots are full!  You must delete an experiment!");
                return 1;
            endif;
            'Otherwise place values 
            recSpaceDisExpNameLoad$[k%] := mystr$;
            recSpaceDisStimcalNameLoad$[k%] := mystr2$;
            recSpaceDisTrialsNameLoad$[k%] := mystr3$;
            'And save them
            RecSpaceDisExpListLoadSaveParams(recSpaceDisExpNameLoad$[],recSpaceDisStimcalNameLoad$[],recSpaceDisTrialsNameLoad$[]);
            status% := 0;  'close the calling dialog - necessary to refresh list in AMDisDialog
        else
            'reload parameters
            RecSpaceDisExpListGenGetParams(recSpaceDisExpNameGen$[],recSpaceDisStimcalNameGen$[],recSpaceDisTrialsNameGen$[]);
            'find first empty slot
            j% := 0;
            k% := -1;
            while j% < recSpaceDisNumExps% do
                if recSpaceDisExpNameGen$[j%] = "" then
                    k% := j%;  'k% holds index of first empty slot
                    j% := recSpaceDisNumExps%;
                endif;
                j%+=1;
            wend
            'Return if all slots are full
            if k% = -1 then
                Message("All " + Str$(recSpaceDisNumExps%) + " slots are full!  You must delete an experiment!");
                return 1;
            endif;
            'Otherwise place values 
            recSpaceDisExpNameGen$[k%] := mystr$;
            recSpaceDisStimcalNameGen$[k%] := mystr2$;
            recSpaceDisTrialsNameGen$[k%] := mystr3$;
            'And save them
            RecSpaceDisExpListGenSaveParams(recSpaceDisExpNameGen$[],recSpaceDisStimcalNameGen$[],recSpaceDisTrialsNameGen$[]);
            status% := 0;  'close the calling dialog
        endif;
    else
        status% := 1;
    endif
    
	return status%;

end;

'===== End RecSpaceDisAddExp =====
'
'



'
'
'===== RecSpaceDisDeleteExp =====

'This is a dialog that comes up to allow deleting "experiments" from the SpaceDis dialog
func RecSpaceDisDeleteExp%()

    var i%;
    var j%;
    var status% := 0;
    var createMode%;
    var mystr$[recSpaceDisNumExps%];
    var mystr1$[recSpaceDisNumExps%];
    var mystr2$[recSpaceDisNumExps%];
    
    var sli%;
    
    if DlgValue(1) = 1 then
        createMode% := 1;
    else
        createMode% := 0;
    endif;
    
    
    ' Fetch parameters from registry    
    if createMode% = 0 then 
        'fetch parameters
        RecSpaceDisExpListLoadGetParams(mystr$[],mystr1$[],mystr2$[]);
    else
        RecSpaceDisExpListGenGetParams(mystr$[],mystr1$[],mystr2$[]);
    endif;
    
    
    ' Generate the dialog
    
    DlgCreate("Cueing Experiment DELETE Dialog", 62, 10);
    DlgText("Select Experiment to Delete",2,1);
    DlgList(1,27,mystr$,recSpaceDisNumExps%,28,1);

    ' Show the dialog. 
    i%:=DlgShow(sli%);
    
    ' If user hit OK then save parameters (and return 1). 
	if i% = 1 then
        'Remove experiment that has been selected and move everything up one
        if sli% < recSpaceDisNumExps%-1 then  'Without this "if", would crash if asked to remove final entry
            for j% := sli% to recSpaceDisNumExps%-2 do
                mystr$[j%] := mystr$[j%+1];
                mystr1$[j%] := mystr1$[j%+1];
                mystr2$[j%] := mystr2$[j%+1];
            next;
        endif;
        'Clear the final experiment slot, this is the only part to execute if asked to remove final entry
        mystr$[recSpaceDisNumExps%-1] := "";
        mystr1$[recSpaceDisNumExps%-1] := "";
        mystr2$[recSpaceDisNumExps%-1] := "";
        
        'Save the new values
        if createMode% = 0 then 
            RecSpaceDisExpListLoadSaveParams(mystr$[],mystr1$[],mystr2$[]);
        else
            RecSpaceDisExpListGenSaveParams(mystr$[],mystr1$[],mystr2$[]);
        endif;
        
        status% := 0;  'Close the calling dialog
    else
        status% := 1;
    endif
    
	return status%;
    
end;

'===== End RecSpaceDisDeleteExp =====
'
'



'
'
'===== RecStereoDisAddExp =====

'This is a dialog that comes up to allow adding "experiments" to the StereoDis dialog
'Please note that in order to reset the list box in the calling dialog, we have to actually
'CLOSE the calling dialog and reopen it.  That's gotta be manual.
func RecStereoDisAddExp%()
    
    var i%;
    var j%;
    var k%;
    var status% := 0;
    var mystr$;
    var mystr2$;
    var mystr3$;
    var mystr4$;
    var createMode%;
    
    if DlgValue(2) = 1 then
        createMode% := 1;  'generate stimuli
    else
        createMode% := 0;  'load stimuli
    endif;
    
    ' Fetch parameters from registry    
    
    
    ' Generate the dialog
    
    DlgCreate("Stereo Distractor Experiment ADD Dialog", 62, 10);
    DlgString(1,40,100,"a-zA-Z0-9",26,1);
    DlgText("Name of New Experiment",2,1);
    if createMode% = 0 then
        DlgButton(recSelectStimFileButton%,   "S1/S2 Stim/Cal File", RecSelectStimFile%,2,2);
    else
        DlgButton(recSelectStimFileButton%,   "S1/S2 Stim File", RecSelectStimFile%,2,2);
    endif
    DlgString(2,40,200,"",26,2);  'for visual confirmation of selected stim file
    DlgButton(recSelectTrialsFileButton%, "    Trials File   ", RecSelectTrialsFile%,2,3);
    DlgString(3,40,200,"",26,3);  'for visual confirmation of selected trials file
    if createMode% = 0 then
        DlgButton(recSelectStimDistractorFileButton%,   "Distractor Stim/Cal File", RecSelectStimFile2%,2,4);
        DlgString(4,40,200,"",26,4);  'for visual confirmation of selected distractor stim file
    endif
    
    
    ' Show the dialog. 
    if createMode% = 0 then
        i%:=DlgShow(mystr$,mystr2$,mystr3$,mystr4$);
    else
        i%:=DlgShow(mystr$,mystr2$,mystr3$);
    endif
    
    
    ' If user hit OK then add new experiment 
	if i% = 1 then
        'reload parameters
        if createMode% = 0 then
            RecStereoDisExpListLoadGetParams(recStereoDisExpNameLoad$[],recStereoDisStimcalNameLoad$[],recStereoDisTrialsNameLoad$[],recStereoDisStimcalDistractorNameLoad$[]);
            'find first empty slot
            j% := 0;
            k% := -1;
            while j% < recStereoDisNumExps% do
                if recStereoDisExpNameLoad$[j%] = "" then
                    k% := j%;  'k% holds index of first empty slot
                    j% := recStereoDisNumExps%;
                endif;
                j%+=1;
            wend
            'Return if all slots are full
            if k% = -1 then
                Message("All " + Str$(recStereoDisNumExps%) + " slots are full!  You must delete an experiment!");
                return 1;
            endif;
            'Otherwise place values 
            recStereoDisExpNameLoad$[k%] := mystr$;
            recStereoDisStimcalNameLoad$[k%] := mystr2$;
            recStereoDisTrialsNameLoad$[k%] := mystr3$;
            recStereoDisStimcalDistractorNameLoad$[k%] := mystr4$;
            'And save them
            RecStereoDisExpListLoadSaveParams(recStereoDisExpNameLoad$[],recStereoDisStimcalNameLoad$[],recStereoDisTrialsNameLoad$[],recStereoDisStimcalDistractorNameLoad$[]);
        else
            RecStereoDisExpListGenGetParams(recStereoDisExpNameGen$[],recStereoDisStimNameGen$[],recStereoDisTrialsNameGen$[]);
            'find first empty slot
            j% := 0;
            k% := -1;
            while j% < recStereoDisNumExps% do
                if recStereoDisExpNameGen$[j%] = "" then
                    k% := j%;  'k% holds index of first empty slot
                    j% := recStereoDisNumExps%;
                endif;
                j%+=1;
            wend
            'Return if all slots are full
            if k% = -1 then
                Message("All " + Str$(recStereoDisNumExps%) + " slots are full!  You must delete an experiment!");
                return 1;
            endif;
            'Otherwise place values 
            recStereoDisExpNameGen$[k%] := mystr$;
            recStereoDisStimNameGen$[k%] := mystr2$;
            recStereoDisTrialsNameGen$[k%] := mystr3$;
            'And save them
            RecStereoDisExpListGenSaveParams(recStereoDisExpNameGen$[],recStereoDisStimNameGen$[],recStereoDisTrialsNameGen$[]);
        endif;
        
        status% := 0;  'close the calling dialog - necessary to refresh list in StereoDisDialog
    else
        status% := 1;
    endif
    
	return status%;

end;

'===== End RecStereoDisAddExp =====
'
'



'
'
'===== RecStereoDisDeleteExp =====

'This is a dialog that comes up to allow deleting "experiments" from the AMDisc dialog
func RecStereoDisDeleteExp%()

    var i%;
    var j%;
    var status% := 0;
    var mystr$[recStereoDisNumExps%];
    var mystr2$[recStereoDisNumExps%];
    var mystr3$[recStereoDisNumExps%];
    var mystr4$[recStereoDisNumExps%];
    var sli%;
    var createMode%;
    
    if DlgValue(2) = 1 then
        createMode% := 1;  'generate stimuli
    else
        createMode% := 0;  'load stimuli
    endif;
    
    ' Fetch parameters from registry  
    if createMode% = 0 then
        RecStereoDisExpListLoadGetParams(mystr$[],mystr2$[],mystr3$[],mystr4$[]);
    else
        RecStereoDisExpListGenGetParams(mystr$[],mystr2$[],mystr3$[]);
    endif;
    
    
    ' Generate the dialog
    
    DlgCreate("Cueing Experiment DELETE Dialog", 62, 10);
    DlgText("Select Experiment to Delete",2,1);
    DlgList(1,27,mystr$,recStereoDisNumExps%,28,1);

    ' Show the dialog. 
    i%:=DlgShow(sli%);
    
    ' If user hit OK then save parameters (and return 1). 
	if i% = 1 then
        'Remove experiment that has been selected and move everything up one
        if createMode% = 0 then
            if sli% < recStereoDisNumExps%-1 then  'Without this "if", would crash if asked to remove final entry
                for j% := sli% to recStereoDisNumExps%-2 do
                    mystr$[j%] := mystr$[j%+1];
                    mystr2$[j%] := mystr2$[j%+1];
                    mystr3$[j%] := mystr3$[j%+1];
                    mystr4$[j%] := mystr4$[j%+1];
                next;
            endif;
            'Clear the final experiment slot, this is the only part to execute if asked to remove final entry
            mystr$[recStereoDisNumExps%-1] := "";
            mystr2$[recStereoDisNumExps%-1] := "";
            mystr3$[recStereoDisNumExps%-1] := "";
            mystr4$[recStereoDisNumExps%-1] := "";
            
            'Save the new values
            RecStereoDisExpListLoadSaveParams(mystr$[],mystr2$[],mystr3$[],mystr4$[]);
        else
            if sli% < recStereoDisNumExps%-1 then  'Without this "if", would crash if asked to remove final entry
                for j% := sli% to recStereoDisNumExps%-2 do
                    mystr$[j%] := mystr$[j%+1];
                    mystr2$[j%] := mystr2$[j%+1];
                    mystr3$[j%] := mystr3$[j%+1];
                next;
            endif;
            'Clear the final experiment slot, this is the only part to execute if asked to remove final entry
            mystr$[recStereoDisNumExps%-1] := "";
            mystr2$[recStereoDisNumExps%-1] := "";
            mystr3$[recStereoDisNumExps%-1] := "";
            
            'Save the new values
            RecStereoDisExpListGenSaveParams(mystr$[],mystr2$[],mystr3$[]);
        endif;
        
        
        status% := 0;  'Close the calling dialog
    else
        status% := 1;
    endif
    
	return status%;
    
end;

'===== End RecStereoDisDeleteExp =====
'
'




'
'
'===== RecStereoDisGNGAddExp =====

'This is a dialog that comes up to allow adding "experiments" to the StereoDis dialog
'Please note that in order to reset the list box in the calling dialog, we have to actually
'CLOSE the calling dialog and reopen it.  That's gotta be manual.
func RecStereoDisGNGAddExp%()
    
    var i%;
    var j%;
    var k%;
    var status% := 0;
    var mystr$;
    var mystr2$;
    var mystr3$;
    var mystr4$;
    var createMode%;
    
    if DlgValue(2) = 1 then
        createMode% := 1;  'generate stimuli
    else
        createMode% := 0;  'load stimuli
    endif;
    
    ' Fetch parameters from registry    
    
    
    ' Generate the dialog
    
    DlgCreate("Stereo Distractor Experiment ADD Dialog", 62, 10);
    DlgString(1,40,100,"a-zA-Z0-9",26,1);
    DlgText("Name of New Experiment",2,1);
    if createMode% = 0 then
        DlgButton(recSelectStimFileButton%,   "S1/S2 Stim/Cal File", RecSelectStimFile%,2,2);
    else
        DlgButton(recSelectStimFileButton%,   "S1/S2 Stim File", RecSelectStimFile%,2,2);
    endif;
    DlgString(2,40,200,"",26,2);  'for visual confirmation of selected stim file
    DlgButton(recSelectTrialsFileButton%, "    Trials File   ", RecSelectTrialsFile%,2,3);
    DlgString(3,40,200,"",26,3);  'for visual confirmation of selected trials file
    if createMode% = 0 then
        DlgButton(recSelectStimDistractorFileButton%,   "Distractor Stim/Cal File", RecSelectStimFile2%,2,4);
        DlgString(4,40,200,"",26,4);  'for visual confirmation of selected distractor stim file
    endif;
    
    ' Show the dialog. 
    if createMode% = 0 then
        i%:=DlgShow(mystr$,mystr2$,mystr3$,mystr4$);
    else
        i%:=DlgShow(mystr$,mystr2$,mystr3$);
    endif;
    
    
    ' If user hit OK then add new experiment 
	if i% = 1 then
        'reload parameters
        if createMode% = 0 then
            RecStereoDisGNGExpListLoadGetParams(recStereoDisGNGExpNameLoad$[],recStereoDisGNGStimcalNameLoad$[],recStereoDisGNGTrialsNameLoad$[],recStereoDisGNGStimcalDistractorNameLoad$[]);
            'find first empty slot
            j% := 0;
            k% := -1;
            while j% < recStereoDisGNGNumExps% do
                if recStereoDisGNGExpNameLoad$[j%] = "" then
                    k% := j%;  'k% holds index of first empty slot
                    j% := recStereoDisGNGNumExps%;
                endif;
                j%+=1;
            wend
            'Return if all slots are full
            if k% = -1 then
                Message("All " + Str$(recStereoDisGNGNumExps%) + " slots are full!  You must delete an experiment!");
                return 1;
            endif;
            'Otherwise place values 
            recStereoDisGNGExpNameLoad$[k%] := mystr$;
            recStereoDisGNGStimcalNameLoad$[k%] := mystr2$;
            recStereoDisGNGTrialsNameLoad$[k%] := mystr3$;
            recStereoDisGNGStimcalDistractorNameLoad$[k%] := mystr4$;
            'And save them
            RecStereoDisGNGExpListLoadSaveParams(recStereoDisGNGExpNameLoad$[],recStereoDisGNGStimcalNameLoad$[],recStereoDisGNGTrialsNameLoad$[],recStereoDisGNGStimcalDistractorNameLoad$[]);
        else
            RecStereoDisGNGExpListGenGetParams(recStereoDisGNGExpNameGen$[],recStereoDisGNGStimNameGen$[],recStereoDisGNGTrialsNameGen$[]);
            'find first empty slot
            j% := 0;
            k% := -1;
            while j% < recStereoDisGNGNumExps% do
                if recStereoDisGNGExpNameGen$[j%] = "" then
                    k% := j%;  'k% holds index of first empty slot
                    j% := recStereoDisGNGNumExps%;
                endif;
                j%+=1;
            wend
            'Return if all slots are full
            if k% = -1 then
                Message("All " + Str$(recStereoDisGNGNumExps%) + " slots are full!  You must delete an experiment!");
                return 1;
            endif;
            'Otherwise place values 
            recStereoDisGNGExpNameGen$[k%] := mystr$;
            recStereoDisGNGStimNameGen$[k%] := mystr2$;
            recStereoDisGNGTrialsNameGen$[k%] := mystr3$;
            'And save them
            RecStereoDisGNGExpListGenSaveParams(recStereoDisGNGExpNameGen$[],recStereoDisGNGStimNameGen$[],recStereoDisGNGTrialsNameGen$[]);
        endif;
        
        
        status% := 0;  'close the calling dialog - necessary to refresh list in StereoDisDialog
    else
        status% := 1;
    endif
    
	return status%;

end;

'===== End RecStereoDisGNGAddExp =====
'
'



'
'
'===== RecStereoDisGNGDeleteExp =====

'This is a dialog that comes up to allow deleting "experiments" from the AMDisc dialog
func RecStereoDisGNGDeleteExp%()

    var i%;
    var j%;
    var status% := 0;
    var mystr$[recStereoDisGNGNumExps%];
    var mystr1$[recStereoDisGNGNumExps%];
    var mystr2$[recStereoDisGNGNumExps%];
    var mystr3$[recStereoDisGNGNumExps%];
    
    var sli%;

    
    ' Fetch parameters from registry     
    RecStereoDisGNGExpListLoadGetParams(mystr$[],mystr1$[],mystr2$[],mystr3$[]);
    
    
    ' Generate the dialog
    
    DlgCreate("Cueing Experiment DELETE Dialog", 62, 10);
    DlgText("Select Experiment to Delete",2,1);
    DlgList(1,27,mystr$,recStereoDisGNGNumExps%,28,1);

    ' Show the dialog. 
    i%:=DlgShow(sli%);
    
    ' If user hit OK then save parameters (and return 1). 
	if i% = 1 then
        'Remove experiment that has been selected and move everything up one
        if sli% < recStereoDisGNGNumExps%-1 then  'Without this "if", would crash if asked to remove final entry
            for j% := sli% to recStereoDisGNGNumExps%-2 do
                mystr$[j%] := mystr$[j%+1];
                mystr1$[j%] := mystr1$[j%+1];
                mystr2$[j%] := mystr2$[j%+1];
                mystr3$[j%] := mystr3$[j%+1];
            next;
        endif;
        'Clear the final experiment slot, this is the only part to execute if asked to remove final entry
        mystr$[recStereoDisGNGNumExps%-1] := "";
        mystr1$[recStereoDisGNGNumExps%-1] := "";
        mystr2$[recStereoDisGNGNumExps%-1] := "";
        mystr3$[recStereoDisGNGNumExps%-1] := "";
        
        'Save the new values
        RecStereoDisGNGExpListLoadSaveParams(mystr$[],mystr1$[],mystr2$[],mystr3$[]);
        
        status% := 0;  'Close the calling dialog
    else
        status% := 1;
    endif
    
	return status%;
    
end;

'===== End RecStereoDisGNGDeleteExp =====
'
'






'
'
'===== RecSelectStimFile =====

func RecSelectStimFile%()

    var status% := 1;
    var direc$;
    var fh0%;
    
    direc$ := FilePath$();  'get current directory
    fh0%:=FileOpen(direc$+"*.txt",1,0,"Please select a stimulus file");  'Find a stim file
    direc$ := FileName$(0);  'Get full path of selected file
    FileClose(fh0%);  'Just close the file, we're not using it
    DlgValue$(2,direc$);  'Place filename into dialog item 2 of calling dialog
	return status%;  'return 1 so calling dialog doesn't close
    
end;

'===== End RecSelectStimFile =====
'
'


'
'
'===== RecSelectStimFile2 =====

func RecSelectStimFile2%()

    var status% := 1;
    var direc$;
    var fh0%;
    
    direc$ := FilePath$();  'get current directory
    fh0%:=FileOpen(direc$+"*.txt",1,0,"Please select a stimulus file");  'Find a stim file
    direc$ := FileName$(0);  'Get full path of selected file
    FileClose(fh0%);  'Just close the file, we're not using it
    DlgValue$(4,direc$);  'Place filename into dialog item 2 of calling dialog
	return status%;  'return 1 so calling dialog doesn't close
    
end;

'===== End RecSelectStimFile =====
'
'



'
'
'===== RecSelectTrialsFile =====

func RecSelectTrialsFile%()

    var status% := 1;
    var direc$;
    var fh0%;
    
    direc$ := FilePath$();  'get current directory
    fh0%:=FileOpen(direc$+"*.txt",1,0,"Please select a trials file");  'Find a trials file
    direc$ := FileName$(0);  'Get full path of selected file
    FileClose(fh0%);  'Just close the file, we're not using it
    DlgValue$(3,direc$);  'Place filename into dialog item 3 of calling dialog

	return status%;  'return 1 so calling dialog doesn't close
    
end;

'===== End RecSelectSTrialsFile =====
'
'




'
'
'===== RecAMDiscExpListLoadGetParams =====

'Fetch experiment lists from the registry for AMDisc, loading stim, experiments
proc RecAMDiscExpListLoadGetParams(&expName$[],&stimcalName$[],&trialsName$[])
	var key$;
    var i%;
    key$:="Reclab\\AMDiscExpListLoadParam";
    
    for i% := 0 to recAMDiscNumExps%-1 do
        expName$[i%] := GetStringRegistryValue$(key$, "ExpName"+Str$(i%), expName$[i%]);
        stimcalName$[i%] := GetStringRegistryValue$(key$, "StimcalName"+Str$(i%), stimcalName$[i%]);
        trialsName$[i%] := GetStringRegistryValue$(key$, "TrialsName"+Str$(i%), trialsName$[i%]);
    next;
     
	return;
end

'===== End RecAMDiscExpListLoadGetParams =====
'
'




'
'
'===== RecAMDiscExpListGenGetParams =====

'Fetch experiment lists from the registry for AMDisc, generating stim, experiments
proc RecAMDiscExpListGenGetParams(&expName$[],&stimcalName$[],&trialsName$[])
	var key$;
    var i%;
    key$:="Reclab\\AMDiscExpListGenParam";
    
    for i% := 0 to recAMDiscNumExps%-1 do
        expName$[i%] := GetStringRegistryValue$(key$, "ExpName"+Str$(i%), expName$[i%]);
        stimcalName$[i%] := GetStringRegistryValue$(key$, "StimcalName"+Str$(i%), stimcalName$[i%]);
        trialsName$[i%] := GetStringRegistryValue$(key$, "TrialsName"+Str$(i%), trialsName$[i%]);
    next;
	
	return;
end

'===== End RecAMDiscExpListGenGetParams =====
'
'





'
'
'===== RecAMDiscExpListLoadSaveParams =====

'Save experiment lists to the registry for AMDisc, loading stim, experiments
proc RecAMDiscExpListLoadSaveParams(expName$[],stimcalName$[],trialsName$[])
	var key$;
    var i%;
    key$:="Reclab\\AMDiscExpListLoadParam";
    
    for i% := 0 to recAMDiscNumExps%-1 do
        SetStringRegistryValue(key$, "ExpName"+Str$(i%), expName$[i%]);
        SetStringRegistryValue(key$, "StimcalName"+Str$(i%), stimcalName$[i%]);
        SetStringRegistryValue(key$, "TrialsName"+Str$(i%), trialsName$[i%]);
    next;
     
	return;
end

'===== End RecAMDiscExpListLoadSaveParams =====
'
'




'
'
'===== RecAMDiscExpListGenSaveParams =====

'Save experiment lists to the registry for AMDisc, loading stim, experiments
proc RecAMDiscExpListGenSaveParams(expName$[],stimcalName$[],trialsName$[])
	var key$;
    var i%;
    key$:="Reclab\\AMDiscExpListGenParam";
    
    for i% := 0 to recAMDiscNumExps%-1 do
        SetStringRegistryValue(key$, "ExpName"+Str$(i%), expName$[i%]);
        SetStringRegistryValue(key$, "StimcalName"+Str$(i%), stimcalName$[i%]);
        SetStringRegistryValue(key$, "TrialsName"+Str$(i%), trialsName$[i%]);
    next;
     
	return;
end

'===== End RecAMDiscExpListGenSaveParams =====
'
'




'
'
'===== RecFRAExpListLoadGetParams =====

'Fetch experiment lists from the registry for AMDisc, loading stim, experiments
proc RecFRAExpListLoadGetParams(&expName$[],&stimcalName$[],&trialsName$[])
	var key$;
    var i%;
    key$:="Reclab\\FRAExpListLoadParam";
    
    'Note that the file locations for StimCal and Trials files are not the normal default path
    'Note that this really doesn't seem like a sensible thing to do, given that the function that
    'selects the file location via the GUI saves a full-path, not partial-path location in the variable
    'that is being saved in the registry.  This path concatenation should probably be done away with
    'ASARP, with the caveat that apparently all the currently defined FRA experiments will have to be
    're-done in the dialog box.
    for i% := 0 to recFRANumExps%-1 do
        expName$[i%] := GetStringRegistryValue$(key$, "ExpName"+Str$(i%), expName$[i%]);
        stimcalName$[i%] := GetStringRegistryValue$(key$, "StimcalName"+Str$(i%), stimcalName$[i%]);
        trialsName$[i%] := GetStringRegistryValue$(key$, "TrialsName"+Str$(i%), trialsName$[i%]);
    next;

    PrintLog("RecFRAExpListLoadGetParams\n");
     
	return;
end

'===== End RecFRAExpListLoadGetParams =====
'
'


'
'
'===== RecFRAExpListGenGetParams =====

'Fetch experiment lists from the registry for FRA, generating stim, experiments
proc RecFRAExpListGenGetParams(&expName$[],&stimcalName$[],&trialsName$[])
	var key$;
    var i%;
    key$:="Reclab\\FRAExpListGenParam";
    
    for i% := 0 to recFRANumExps%-1 do
        expName$[i%] := GetStringRegistryValue$(key$, "ExpName"+Str$(i%), expName$[i%]);
        stimcalName$[i%] := GetStringRegistryValue$(key$, "StimcalName"+Str$(i%), stimcalName$[i%]);
        trialsName$[i%] := GetStringRegistryValue$(key$, "TrialsName"+Str$(i%), trialsName$[i%]);
    next;
	
	return;
end

'===== End RecFRAExpListGenGetParams =====
'
'





'
'
'===== RecFRAExpListLoadSaveParams =====

'Save experiment lists to the registry for AMDisc, loading stim, experiments
proc RecFRAExpListLoadSaveParams(expName$[],stimcalName$[],trialsName$[])
	var key$;
    var i%;
    key$:="Reclab\\FRAExpListLoadParam";
    
    for i% := 0 to recFRANumExps%-1 do
        SetStringRegistryValue(key$, "ExpName"+Str$(i%), expName$[i%]);
        SetStringRegistryValue(key$, "StimcalName"+Str$(i%), stimcalName$[i%]);
        SetStringRegistryValue(key$, "TrialsName"+Str$(i%), trialsName$[i%]);
    next;
     
	return;
end

'===== End RecFRAExpListLoadSaveParams =====
'
'




'
'
'===== RecFRAExpListGenSaveParams =====

'Save experiment lists to the registry for AMDisc, loading stim, experiments
proc RecFRAExpListGenSaveParams(expName$[],stimcalName$[],trialsName$[])
	var key$;
    var i%;
    key$:="Reclab\\FRAExpListGenParam";
    
    for i% := 0 to recFRANumExps%-1 do
        SetStringRegistryValue(key$, "ExpName"+Str$(i%), expName$[i%]);
        SetStringRegistryValue(key$, "StimcalName"+Str$(i%), stimcalName$[i%]);
        SetStringRegistryValue(key$, "TrialsName"+Str$(i%), trialsName$[i%]);
    next;
     
	return;
end

'===== End RecFRAExpListGenSaveParams =====
'
'


'
'
'===== RecSpaceDisExpListLoadGetParams =====

'Fetch experiment lists from the registry for SpaceDis, loading stim, experiments
proc RecSpaceDisExpListLoadGetParams(&expName$[],&stimcalName$[],&trialsName$[])
	var key$;
    var i%;
    key$:="Reclab\\SpaceDisExpListLoadParam";
    
    for i% := 0 to recSpaceDisNumExps%-1 do
        expName$[i%] := GetStringRegistryValue$(key$, "ExpName"+Str$(i%), expName$[i%]);
        stimcalName$[i%] := GetStringRegistryValue$(key$, "StimcalName"+Str$(i%), stimcalName$[i%]);
        trialsName$[i%] := GetStringRegistryValue$(key$, "TrialsName"+Str$(i%), trialsName$[i%]);
    next;
     
	return;
end

'===== End RecSpaceDisExpListLoadGetParams =====
'
'




'
'
'===== RecSpaceDisExpListGenGetParams =====

'Fetch experiment lists from the registry for SpaceDis, generating stim, experiments
proc RecSpaceDisExpListGenGetParams(&expName$[],&stimcalName$[],&trialsName$[])
	var key$;
    var i%;
    key$:="Reclab\\SpaceDisExpListGenParam";
    
    for i% := 0 to recSpaceDisNumExps%-1 do
        expName$[i%] := GetStringRegistryValue$(key$, "ExpName"+Str$(i%), expName$[i%]);
        stimcalName$[i%] := GetStringRegistryValue$(key$, "StimcalName"+Str$(i%), stimcalName$[i%]);
        trialsName$[i%] := GetStringRegistryValue$(key$, "TrialsName"+Str$(i%), trialsName$[i%]);
    next;
     
	return;
end

'===== End RecSpaceDisExpListGenGetParams =====
'
'





'
'
'===== RecSpaceDisExpListLoadSaveParams =====

'Save experiment lists to the registry for SpaceDis, loading stim, experiments
proc RecSpaceDisExpListLoadSaveParams(expName$[],stimcalName$[],trialsName$[])
	var key$;
    var i%;
    key$:="Reclab\\SpaceDisExpListLoadParam";
    
    for i% := 0 to recSpaceDisNumExps%-1 do
        SetStringRegistryValue(key$, "ExpName"+Str$(i%), expName$[i%]);
        SetStringRegistryValue(key$, "StimcalName"+Str$(i%), stimcalName$[i%]);
        SetStringRegistryValue(key$, "TrialsName"+Str$(i%), trialsName$[i%]);
    next;
     
	return;
end

'===== End RecSpaceDisExpListLoadSaveParams =====
'
'




'
'
'===== RecSpaceDisExpListGenSaveParams =====

'Save experiment lists to the registry for SpaceDis, loading stim, experiments
proc RecSpaceDisExpListGenSaveParams(expName$[],stimcalName$[],trialsName$[])
	var key$;
    var i%;
    key$:="Reclab\\SpaceDisExpListGenParam";
    
    for i% := 0 to recSpaceDisNumExps%-1 do
        SetStringRegistryValue(key$, "ExpName"+Str$(i%), expName$[i%]);
        SetStringRegistryValue(key$, "StimcalName"+Str$(i%), stimcalName$[i%]);
        SetStringRegistryValue(key$, "TrialsName"+Str$(i%), trialsName$[i%]);
    next;
     
	return;
end

'===== End RecSpaceDisExpListGenSaveParams =====
'
'


'
'
'===== RecStereoDisExpListLoadGetParams =====

'Fetch experiment lists from the registry for StereoDis, loading stim, experiments
proc RecStereoDisExpListLoadGetParams(&expName$[],&stimcalName$[],&trialsName$[],&stimcalDistName$[])
	var key$;
    var i%;
    key$:="Reclab\\HumanFCExpListLoadParam";  'renamed experiment from HumanFC to StereoDis, just keep old name for registry, it's easier
    
    for i% := 0 to recStereoDisNumExps%-1 do
        expName$[i%] := GetStringRegistryValue$(key$, "ExpName"+Str$(i%), expName$[i%]);
        stimcalName$[i%] := GetStringRegistryValue$(key$, "StimcalName"+Str$(i%), stimcalName$[i%]);
        stimcalDistName$[i%] := GetStringRegistryValue$(key$, "StimcalDistName"+Str$(i%), stimcalDistName$[i%]);
        trialsName$[i%] := GetStringRegistryValue$(key$, "TrialsName"+Str$(i%), trialsName$[i%]);
    next;
     
	return;
end

'===== End RecStereoDisExpListLoadGetParams =====
'
'

'
'
'===== RecStereoDisExpListLoadSaveParams =====

'Save experiment lists to the registry for StereoDis, loading stim, experiments
proc RecStereoDisExpListLoadSaveParams(expName$[],stimcalName$[],trialsName$[],stimcalDistName$[])
	var key$;
    var i%;
    key$:="Reclab\\HumanFCExpListLoadParam";  'renamed experiment from HumanFC to StereoDis, just keep old name for registry, it's easier
    
    for i% := 0 to recStereoDisNumExps%-1 do
        SetStringRegistryValue(key$, "ExpName"+Str$(i%), expName$[i%]);
        SetStringRegistryValue(key$, "StimcalName"+Str$(i%), stimcalName$[i%]);
        SetStringRegistryValue(key$, "StimcalDistName"+Str$(i%), stimcalDistName$[i%]);
        SetStringRegistryValue(key$, "TrialsName"+Str$(i%), trialsName$[i%]);
    next;
     
	return;
end

'===== End RecStereoDisExpListLoadSaveParams =====
'
'



'
'
'===== RecStereoDisExpListGenGetParams =====

'Fetch experiment lists from the registry for StereoDis, loading stim, experiments
proc RecStereoDisExpListGenGetParams(&expName$[],&stimName$[],&trialsName$[])
	var key$;
    var i%;
    key$:="Reclab\\HumanFCExpListGenParam";  'renamed experiment from HumanFC to StereoDis, just keep old name for registry, it's easier
    
    for i% := 0 to recStereoDisNumExps%-1 do
        expName$[i%] := GetStringRegistryValue$(key$, "ExpName"+Str$(i%), expName$[i%]);
        stimName$[i%] := GetStringRegistryValue$(key$, "StimName"+Str$(i%), stimName$[i%]);
        trialsName$[i%] := GetStringRegistryValue$(key$, "TrialsName"+Str$(i%), trialsName$[i%]);
    next;
     
	return;
end

'===== End RecStereoDisExpListGenGetParams =====
'
'

'
'
'===== RecStereoDisExpListGenSaveParams =====

'Save experiment lists to the registry for StereoDis, loading stim, experiments
proc RecStereoDisExpListGenSaveParams(expName$[],stimName$[],trialsName$[])
	var key$;
    var i%;
    key$:="Reclab\\HumanFCExpListGenParam";  'renamed experiment from HumanFC to StereoDis, just keep old name for registry, it's easier
    
    for i% := 0 to recStereoDisNumExps%-1 do
        SetStringRegistryValue(key$, "ExpName"+Str$(i%), expName$[i%]);
        SetStringRegistryValue(key$, "StimName"+Str$(i%), stimName$[i%]);
        SetStringRegistryValue(key$, "TrialsName"+Str$(i%), trialsName$[i%]);
    next;
     
	return;
end

'===== End RecStereoDisExpListGenSaveParams =====
'
'





'
'
'===== RecStereoDisGNGExpListLoadGetParams =====

'Fetch experiment lists from the registry for StereoDis, loading stim, experiments
proc RecStereoDisGNGExpListLoadGetParams(&expName$[],&stimcalName$[],&trialsName$[],&stimcalDistName$[])
	var key$;
    var i%;
    key$:="Reclab\\StereoDisExpListLoadParam";  
    
    for i% := 0 to recStereoDisNumExps%-1 do
        expName$[i%] := GetStringRegistryValue$(key$, "ExpName"+Str$(i%), expName$[i%]);
        stimcalName$[i%] := GetStringRegistryValue$(key$, "StimcalName"+Str$(i%), stimcalName$[i%]);
        stimcalDistName$[i%] := GetStringRegistryValue$(key$, "StimcalDistName"+Str$(i%), stimcalDistName$[i%]);
        trialsName$[i%] := GetStringRegistryValue$(key$, "TrialsName"+Str$(i%), trialsName$[i%]);
    next;
     
	return;
end

'===== End RecStereoDisGNGExpListLoadGetParams =====
'
'

'
'
'===== RecStereoDisGNGExpListLoadSaveParams =====

'Save experiment lists to the registry for StereoDis, loading stim, experiments
proc RecStereoDisGNGExpListLoadSaveParams(expName$[],stimcalName$[],trialsName$[],stimcalDistName$[])
	var key$;
    var i%;
    key$:="Reclab\\StereoDisExpListLoadParam";  
    
    for i% := 0 to recStereoDisNumExps%-1 do
        SetStringRegistryValue(key$, "ExpName"+Str$(i%), expName$[i%]);
        SetStringRegistryValue(key$, "StimcalName"+Str$(i%), stimcalName$[i%]);
        SetStringRegistryValue(key$, "StimcalDistName"+Str$(i%), stimcalDistName$[i%]);
        SetStringRegistryValue(key$, "TrialsName"+Str$(i%), trialsName$[i%]);
    next;
     
	return;
end

'===== End RecStereoDisGNGExpListLoadSaveParams =====
'
'



'
'
'===== RecStereoDisGNGExpListGenGetParams =====

'Fetch experiment lists from the registry for StereoDis, loading stim, experiments
proc RecStereoDisGNGExpListGenGetParams(&expName$[],&stimName$[],&trialsName$[])
	var key$;
    var i%;
    key$:="Reclab\\StereoDisExpListGenParam";  
    
    for i% := 0 to recStereoDisNumExps%-1 do
        expName$[i%] := GetStringRegistryValue$(key$, "ExpName"+Str$(i%), expName$[i%]);
        stimName$[i%] := GetStringRegistryValue$(key$, "StimName"+Str$(i%), stimName$[i%]);
        trialsName$[i%] := GetStringRegistryValue$(key$, "TrialsName"+Str$(i%), trialsName$[i%]);
    next;
     
	return;
end

'===== End RecStereoDisGNGExpListGenGetParams =====
'
'

'
'
'===== RecStereoDisGNGExpListGenSaveParams =====

'Save experiment lists to the registry for StereoDis, loading stim, experiments
proc RecStereoDisGNGExpListGenSaveParams(expName$[],stimName$[],trialsName$[])
	var key$;
    var i%;
    key$:="Reclab\\StereoDisExpListGenParam";  
    
    for i% := 0 to recStereoDisNumExps%-1 do
        SetStringRegistryValue(key$, "ExpName"+Str$(i%), expName$[i%]);
        SetStringRegistryValue(key$, "StimName"+Str$(i%), stimName$[i%]);
        SetStringRegistryValue(key$, "TrialsName"+Str$(i%), trialsName$[i%]);
    next;
     
	return;
end

'===== End RecStereoDisGNGExpListGenSaveParams =====
'
'




'
'
'===== RecVerifyInputFile =====
'RecVerifyInputFile is a function that opens up a potential input file and does some standard checks
'to make sure that it doesn't have any glaring mistakes that would make things go crashy.
'Notably, it makes sure that each line has the same number of fields and that each column is either
'consistently numeric or stringic.
'For now it returns the number of columns read, without regard to whether there are strings/numbers in
'any particular location.  As of now, the number of columns should be diagnostic of what type of file is
'being read, but this may change in the future.
'Updated to return a sensible error if file is not found! 4/8/2019 -jj
func RecVerifyInputFile%(fileIn$)
    
    var fh0%;
    var numRead%;
    var readLine$[50];  'maximum of 50 fields read
    var temp$;
    var keepGoing% := 1;
    var loopedOnce%;
    var lineLength%;
    var expectStr%[50];
    var i%;
    var nCh%;  'number of characters
    var lineCount%;
    
    'FileOpen will open a file dialog if the file-to-open is an empty string.  But it would be complicated to
    'determine the name of any file selected (should be some way to get it from fh0%, but...), communicate the
    'name back out for the actual read, and most importantly log the name of the file used.  If a registry entry
    'is blank it's probably best to just inform the user and try again - this will push them to fix the registry.
    if fileIn$ = "" then
        printlog("Requested input file name is blank!  This probably is the result of an empty registry entry.  Starting over!\n");
        message("Starting over!|Requested input file name is blank!");
        return -1;
    endif;
    
    'printlog("opening file %s \n", fileIn$);
    fh0%:=FileOpen(fileIn$,8,0);
    
    'Check for existence of file - nonexistence had previously thrown a "file does not have header line" error...!
    docase
    case fh0% = -1518 then
        printlog("File %s does not exist!  Failure to read!\n",fileIn$);
        message("Starting over!|File %s does not exist!",fileIn$);
        return -1;
    case fh0% < 0 then
        printlog("Unknown error in opening file %s!  Failure to read!\n",fileIn$);
        printlog("Error may be: %s\n",Error$(fh0%));
        message("Starting over!|Unknown error in opening file %s, check log for further details!",fileIn$);
        return -1;
    endcase
    
    
    'readsetup(""," ","","","	");
    readsetup(""," "+Chr$(9),"","","	");  'Making tab -- Chr$(9) -- a soft separator, so extra tabs for lining up rows will be skipped
    
    'check for obligatory header line
    numRead% := read(readLine$[0:49]);
    temp$ := readLine$[0];
        'printlog("reading in... %d %s \n", numRead%, temp$);
    docase
    case temp$ = "S1" then
        printlog("File %s appears to be a Trial file\n",fileIn$);
    case temp$ = "File Location" or temp$ = "File location" then  'this lower version should not be standard, but...
        printlog("File %s appears to be a Stim/Cal file\n",fileIn$);
    case temp$ = "Dur" then
        printlog("File %s appears to be a Tone/Noise/AM generation file\n",fileIn$);
    else
        printlog("File %s does not appear to have a header line!  Failure to read!\n",fileIn$);
        message("Starting over!|File %s does not appear to have a header line!",fileIn$);
        return -1;
    endcase
    
    
    while keepGoing% do
        'Read the next line in the file, return line and number of fields read
        numRead% := read(readLine$[0:49]);
        lineCount% += 1;
        
        'On first time through, determine number of fields read and string/nonstring
        'pattern of the first line - all subsequent lines should match
        docase
        case loopedOnce% = 0 then
            lineLength% := numRead%;
            for i% := 0 to numRead%-1 do
                val(readLine$[i%],nCh%);  'nCh% will be 0 if no number is read
                if nCh% = 0 then
                    expectStr%[i%] := 0;
                else
                    expectStr%[i%] := 1;
                endif;
            next;
            loopedOnce% := 1;  'don't do this step again
        case numRead% >= 0 then
            if numRead% <> lineLength% then
                message("Expected line length is "+str$(lineLength%)+" but on line "+str$(lineCount%)+" length is "+str$(numRead%));
                printlog("Expected line length is "+str$(lineLength%)+" but on line "+str$(lineCount%)+" length is "+str$(numRead%)+"\n");
                fileclose();  'close fh0%, the currently open file
                return -1;
            endif;
            for i% := 0 to numRead%-1 do
                val(readLine$[i%],nCh%);  'nCh% will be 0 if no number is read
                if nCh% > 1 then 'nCh% will be 1 if any number is read
                    nCh% := 1;
                endif;
                if expectStr%[i%] <> nCh% then
                    message("String/number mismatch in column "+str$(i%+1)+" of line "+str$(lineCount%));
                    printlog("String/number mismatch in column "+str$(i%+1)+" of line "+str$(lineCount%)+"\n");
                    fileclose();  'close fh0%, the currently open file
                    return -1;
                endif;
            next;
        case numRead%<0 then
            keepGoing% := 0;   
        endcase;    
    wend;    
    
    fileclose();  'close fh0%, the currently open file
    
    printlog("Successfully read file %s, contained %d lines with %d columns!\n",fileIn$,lineCount%-1,lineLength%);
    
    return lineLength%;    '6: "trials" file
                           '9: "trials" file, includes a "distractor" stimulus
                           '10: generate "stim" file
                           '15: "calibration" file, 15-speaker array
                           '16: "calibration" file, 16-speaker array
                           '17: load "stim/cal" file 15-speaker array
                           '18: load "stim/cal" file 16-speaker array
                           '22: "trials" file, for distractor GNG experiment
                           '31: "calibration" file, both 15-speaker AND 16-speaker array
                           '33: load "stim/cal" file both 15-speaker AND 16-speaker array
end

'===== End RecVerifyInputFile =====
'
'




'
'
'===== RecLoadTrialsFile =====
func RecLoadTrialsFile%(fileLoc$,&totalTrials%)
    
    
    var status%;
    var lineCount%;
    var keepGoing% := 1;
    var numRead%;
    var readLine$[7];
    var fh0%;
    
    status% := 0;  'begin with "failure", change to success if success
    
    printlog("Loading Trial File: %s\n",fileLoc$);
    
    'First, make sure the file won't barf on us
    numRead% := RecVerifyInputFile%(fileLoc$);
    if numRead% <> 6 then
        if numRead% = -1 then
            message("Starting over!|Failure to read trials file!");
        else
            message("Starting over!|Incorrect number of fields in trials file (expected 6 fields, got "+Str$(numRead%)+")!");
        endif
        return status%;  'returns failure
    endif;
        
    'Then read the file
    fh0%:=FileOpen(fileLoc$,8,0);
    
    'readsetup(""," ","","","	");
    readsetup(""," "+Chr$(9),"","","	");  'Making tab -- Chr$(9) -- a soft separator, so extra tabs for lining up rows will be skipped
    
    'Skip past the header line
    numRead% := read(readLine$[0:7]);
    
    while keepGoing% do
        'Read the next line in the file, return line and number of fields read
        numRead% := read(readLine$[0:7]);  'reading as many as seven lines as a check - if seven successfully read, something is wrong with the file
        lineCount% += 1;
        
        'Place values into global variables
        docase
        case numRead% = 6 then
            recTrialS1%[lineCount%-1] := val(readLine$[0]);
            recTrialS2%[lineCount%-1] := val(readLine$[1]);
            recTrialS1Spkr%[lineCount%-1] := val(readLine$[2]);
            recTrialS2Spkr%[lineCount%-1] := val(readLine$[3]);
            recTrialS1DeltadB[lineCount%-1] := val(readLine$[4]);
            recTrialS2DeltadB[lineCount%-1] := val(readLine$[5]);
        case numRead%<0 then
            keepGoing% := 0;
            totalTrials% := lineCount%-1;  'set to return the number of lines read, this will be useful
            status% := 1;  'not sure that will work with the other logic
        else
            message("Starting over!|Failure to successfully read file with six fields despite initial check!");
            keepGoing% := 0;
        endcase;    
    wend;    
    
    fileclose();  'close fh0%, the currently open file
    
    'Just some debugging code, correct read is verified
'    printlog("Column 1 was %d\n",recTrialS1%[]);
'    printlog("Column 2 was %d\n",recTrialS2%[]);
'    printlog("Column 3 was %d\n",recTrialS1Spkr%[]);
'    printlog("Column 4 was %d\n",recTrialS2Spkr%[]);
'    printlog("Column 5 was %f\n",recTrialS1DeltadB[]);
'    printlog("Column 6 was %f\n",recTrialS2DeltadB[]);
    
    return status%;
    
end
'===== End RecLoadTrialsFile =====
'
'



'
'
'===== RecLoadTrialsFile9 =====
func RecLoadTrialsFile9%(fileLoc$,&totalTrials%)
    'a 9-column version of RecLoadTrialsFile, includes distractor stimulus
    
    
    var status%;
    var lineCount%;
    var keepGoing% := 1;
    var numRead%;
    var readLine$[10];
    var fh0%;
    
    status% := 0;  'begin with "failure", change to success if success
    
    printlog("Loading Trial File: %s\n",fileLoc$);
    
    'First, make sure the file won't barf on us
    numRead% := RecVerifyInputFile%(fileLoc$);
    if numRead% <> 9 then
        if numRead% = -1 then
            message("Starting over!|Failure to read trials file!");
        else
            message("Starting over!|Incorrect number of fields in trials file (expected 9 fields, got "+Str$(numRead%)+")!");
        endif
        return status%;  'returns failure
    endif;
        
    'Then read the file
    fh0%:=FileOpen(fileLoc$,8,0);
    
    'readsetup(""," ","","","	");
    readsetup(""," "+Chr$(9),"","","	");  'Making tab -- Chr$(9) -- a soft separator, so extra tabs for lining up rows will be skipped
    
    'Skip past the header line
    numRead% := read(readLine$[0:7]);
    
    while keepGoing% do
        'Read the next line in the file, return line and number of fields read
        numRead% := read(readLine$[0:10]);  'reading as many as ten lines as a check - if ten successfully read, something is wrong with the file
        lineCount% += 1;
        
        'Place values into global variables
        docase
        case numRead% = 9 then
            recTrialS1%[lineCount%-1] := val(readLine$[0]);
            recTrialS2%[lineCount%-1] := val(readLine$[1]);
            recTrialDistractor%[lineCount%-1][1] := val(readLine$[2]);  'loading into index 1, index 0 will remain zeros as there is no distractor for S1
            recTrialS1Spkr%[lineCount%-1] := val(readLine$[3]);
            recTrialS2Spkr%[lineCount%-1] := val(readLine$[4]);
            recTrialDistractorSpkr%[lineCount%-1][0] := val(readLine$[5]);  'here, loading a "dummy" value into index 0, should not be used but putting it in just in case as 0 is not a legal speaker value
            recTrialDistractorSpkr%[lineCount%-1][1] := val(readLine$[5]);
            recTrialS1DeltadB[lineCount%-1] := val(readLine$[6]);
            recTrialS2DeltadB[lineCount%-1] := val(readLine$[7]);
            recTrialDistractorDeltadB[lineCount%-1][1] := val(readLine$[8]);  'loading into index 1, index 0 will remain zeros as there is no distractor for S1
        case numRead%<0 then
            keepGoing% := 0;
            totalTrials% := lineCount%-1;  'set to return the number of lines read, this will be useful
            status% := 1;  'not sure that will work with the other logic
        else
            message("Starting over!|Failure to successfully read file with nine fields despite initial check!");
            keepGoing% := 0;
        endcase;    
    wend;    
    
    fileclose();  'close fh0%, the currently open file
    
    return status%;
    
end
'===== End RecLoadTrialsFile9 =====
'
'


'
'
'===== RecLoadTrialsFile22 =====
func RecLoadTrialsFile22%(fileLoc$,&totalTrials%)
    'a 22-column version of RecLoadTrialsFile, includes distractor stimulus
    
    
    var status%;
    var lineCount%;
    var keepGoing% := 1;
    var numRead%;
    var readLine$[23];
    var fh0%;
    var tempDist%;
    var tempDistSpkr%;
    var tempDistddB;
    
    status% := 0;  'begin with "failure", change to success if success
    
    printlog("Loading Trial File: %s\n",fileLoc$);
    
    'First, make sure the file won't barf on us
    numRead% := RecVerifyInputFile%(fileLoc$);
    if numRead% <> 22 then
        if numRead% = -1 then
            message("Starting over!|Failure to read trials file!");
        else
            message("Starting over!|Incorrect number of fields in trials file (expected 22 fields, got "+Str$(numRead%)+")!");
        endif
        return status%;  'returns failure
    endif;
        
    'Then read the file
    fh0%:=FileOpen(fileLoc$,8,0);
    
    'readsetup(""," ","","","	");
    readsetup(""," "+Chr$(9),"","","	");  'Making tab -- Chr$(9) -- a soft separator, so extra tabs for lining up rows will be skipped
    
    'Skip past the header line
    numRead% := read(readLine$[0:7]);
    
    while keepGoing% do
        'Read the next line in the file, return line and number of fields read
        numRead% := read(readLine$[0:23]);  'reading as many as 23 lines as a check - if 23 successfully read, something is wrong with the file
        lineCount% += 1;
        
        'Place values into global variables
        docase
        case numRead% = 22 then
            'read in the first ten values, have to hold the final distractor values in temp, will place at end later
            recTrialS1%[lineCount%-1] := val(readLine$[0]);
            recTrialS2%[lineCount%-1] := val(readLine$[1]);
            'recTrialDistractor%[lineCount%-1] := val(readLine$[2]);
            tempDist% := val(readLine$[2]);  'Hold this in temp, because we don't know how many S1.ns we have yet
            recTrialS1Spkr%[lineCount%-1] := val(readLine$[3]);
            recTrialS2Spkr%[lineCount%-1] := val(readLine$[4]);
            'recTrialDistractorSpkr%[lineCount%-1] := val(readLine$[5]);
            tempDistSpkr% := val(readLine$[5]);  'Hold this in temp, because we don't know how many S1.ns we have yet
            recTrialS1DeltadB[lineCount%-1] := val(readLine$[6]);
            recTrialS2DeltadB[lineCount%-1] := val(readLine$[7]);
            'recTrialDistractorDeltadB[lineCount%-1] := val(readLine$[8]);
            tempDistddB := val(readLine$[8]);  'Hold this in temp, because we don't know how many S1.ns we have yet
            recTrialNumS1ns%[lineCount%-1] := val(readLine$[9]);  'The S1 "counts" as an S1.n, so this will be between 1-5
            
            'read in the variable distractors
            recTrialDistractor%[lineCount%-1][1] := val(readLine$[10]);  'Do not fill recTrialDistractor%[xxx][0], no distractor for first S1
            recTrialDistractor%[lineCount%-1][2] := val(readLine$[11]);
            recTrialDistractor%[lineCount%-1][3] := val(readLine$[12]);
            recTrialDistractor%[lineCount%-1][4] := val(readLine$[13]);
            
            recTrialDistractorSpkr%[lineCount%-1][1] := val(readLine$[14]);
            recTrialDistractorSpkr%[lineCount%-1][2] := val(readLine$[15]);
            recTrialDistractorSpkr%[lineCount%-1][3] := val(readLine$[16]);
            recTrialDistractorSpkr%[lineCount%-1][4] := val(readLine$[17]);
            
            recTrialDistractorDeltadB[lineCount%-1][1] := val(readLine$[18]);
            recTrialDistractorDeltadB[lineCount%-1][2] := val(readLine$[19]);
            recTrialDistractorDeltadB[lineCount%-1][3] := val(readLine$[20]);
            recTrialDistractorDeltadB[lineCount%-1][4] := val(readLine$[21]);
            
            'copy final distractor into correct location, may overwrite "-1"s
            recTrialDistractor%[lineCount%-1][recTrialNumS1ns%[lineCount%-1]] := tempDist%;
            recTrialDistractorSpkr%[lineCount%-1][recTrialNumS1ns%[lineCount%-1]] := tempDistSpkr%;
            recTrialDistractorSpkr%[lineCount%-1][0] := recTrialDistractorSpkr%[lineCount%-1][1]; 'Put a legal value (next distractor speaker) into index 0, should not be used, but just in case
            recTrialDistractorDeltadB[lineCount%-1][recTrialNumS1ns%[lineCount%-1]] := tempDistddB;
            
        case numRead%<0 then
            keepGoing% := 0;
            totalTrials% := lineCount%-1;  'set to return the number of lines read, this will be useful
            status% := 1;  'not sure that will work with the other logic
        else
            printlog("Number of fields read is %d\n",numRead%);
            message("Starting over!|Failure to successfully read file with 22 fields despite initial check!");
            keepGoing% := 0;
        endcase;    
    wend;    
    
    fileclose();  'close fh0%, the currently open file
    
    return status%;
    
end
'===== End RecLoadTrialsFile22 =====
'
'





'
'
'===== RecLoadStimCalFile =====
func RecLoadStimCalFile%(fileLoc$,nSpk%,&recTotalStim%)
    

    var status%;
    var lineCount%;
    var keepGoing% := 1;
    var numRead%;
    var readLine$[34];
    var fh0%;
    var i%;
    
    status% := 0;  'begin with "failure", change to success if success
    
    printlog("Loading Stim/Cal File: %s\n",fileLoc$);
    
        
    'First, make sure the file won't barf on us
    numRead% := RecVerifyInputFile%(fileLoc$);
    if numRead% <> nSpk%+2 then
        if numRead% = -1 then
            message("Starting over!|Failure to read Stim/Cal file!");
        else
            message("Starting over!|Incorrect number of fields in Stim/Cal file (expected "+Str$(nSpk%+2)+" fields, got "+Str$(numRead%)+")!");
        endif
        return status%;  'returns failure
    endif;
        
    'Then read the file
    fh0%:=FileOpen(fileLoc$,8,0);
    
    'readsetup(""," ","","","	");
    readsetup(""," "+Chr$(9),"","","	");  'Making tab -- Chr$(9) -- a soft separator, so extra tabs for lining up rows will be skipped
    
    'Skip past the header line
    numRead% := read(readLine$[0:34]);
    
    while keepGoing% do
        'Read the next line in the file, return line and number of fields read
        numRead% := read(readLine$[0:34]);  'reading as many as 34 lines as a check - if 34 successfully read, something is wrong with the file
        lineCount% += 1;
        
        'Place values into global variables
        docase
        case numRead% = nSpk%+2 then
            recTrialLoadLoc$[lineCount%-1] := readLine$[0];  'Disk location of files to load, stim/cal file
            recTrialDur[lineCount%-1] := val(readLine$[1]);  'Trial duration
            for i% := 0 to nSpk%-1 do
                recTrialStimCal[lineCount%-1][i%] := val(readLine$[i%+2]);  'Calibration values per speaker
            next; 
        case numRead%<0 then 'quit at end of file
            keepGoing% := 0;
            lineCount% -= 1;  'Decrement to get correct count on EOF
            status% := 1;
        else
            message("Starting over!|Failure to successfully read file with "+Str$(nSpk%+2)+" fields despite initial check!");
            printlog("Failure to successfully read file with %d fields despite initial check!\n",nSpk%+2);
            keepGoing% := 0;
        endcase;    
    wend;    
    
    fileclose();  'close fh0%, the currently open file
    
    recTotalStim% := lineCount%;
    
    'Just some debugging code, correct read is verified
'    printlog("Column 1 was %s\n",recTrialLoadLoc$[]);
'    printlog("Column 2 was %f\n",recTrialDur[]);
'    printlog("Column 3 was %f\n",recTrialStimCal[][0]);
'    printlog("Column 4 was %f\n",recTrialStimCal[][1]);
'    printlog("Column 5 was %f\n",recTrialStimCal[][2]);
'    printlog("Column 6 was %f\n",recTrialStimCal[][3]);
'    printlog("Column 7 was %f\n",recTrialStimCal[][4]);
'    printlog("Column 8 was %f\n",recTrialStimCal[][5]);
'    printlog("Column 9 was %f\n",recTrialStimCal[][6]);
'    printlog("Column 10 was %f\n",recTrialStimCal[][7]);
'    printlog("Column 11 was %f\n",recTrialStimCal[][8]);
'    printlog("Column 12 was %f\n",recTrialStimCal[][9]);
'    printlog("Column 13 was %f\n",recTrialStimCal[][10]);
'    printlog("Column 14 was %f\n",recTrialStimCal[][11]);
'    printlog("Column 15 was %f\n",recTrialStimCal[][12]);
'    printlog("Column 16 was %f\n",recTrialStimCal[][13]);
'    printlog("Column 17 was %f\n",recTrialStimCal[][14]);
'    printlog("Column 18 was %f\n",recTrialStimCal[][15]);
'    printlog("Column 19 was %f\n",recTrialStimCal[][16]);
    
    return status%;
    
end
'===== End RecLoadStimCalFile =====
'
'



'
'
'===== RecLoadStimCalMFCarrierFile =====
func RecLoadStimCalMFCarrierFile%(fileLoc$,nSpk%,&recTotalStim%)
'These files by definition have two additional columns, Modulation Frequency and Carrier Type$, following Duration column   

    var status%;
    var lineCount%;
    var keepGoing% := 1;
    var numRead%;
    var readLine$[34];
    var fh0%;
    var i%;
    
    status% := 0;  'begin with "failure", change to success if success
    
    printlog("Loading Stim/Cal w/MF&Carrier File: %s\n",fileLoc$);
        
    'First, make sure the file won't barf on us
    numRead% := RecVerifyInputFile%(fileLoc$);
    if numRead% <> nSpk%+4 then
        if numRead% = -1 then
            message("Starting over!|Failure to read Stim/Cal file!");
        else
            message("Starting over!|Incorrect number of fields in Stim/Cal file (expected "+Str$(nSpk%+2)+" fields, got "+Str$(numRead%)+")!");
        endif
        return status%;  'returns failure
    endif;
        
    'Then read the file
    fh0%:=FileOpen(fileLoc$,8,0);
    
    'readsetup(""," ","","","	");
    readsetup(""," "+Chr$(9),"","","	");  'Making tab -- Chr$(9) -- a soft separator, so extra tabs for lining up rows will be skipped
    
    'Skip past the header line
    numRead% := read(readLine$[0:34]);
    
    while keepGoing% do
        'Read the next line in the file, return line and number of fields read
        numRead% := read(readLine$[0:34]);  'reading as many as 34 lines as a check - if 34 successfully read, something is wrong with the file
        lineCount% += 1;
        
        'Place values into global variables
        docase
        case numRead% = nSpk%+4 then
            recTrialLoadLoc$[lineCount%-1] := readLine$[0];  'Disk location of files to load, stim/cal file
            recTrialDur[lineCount%-1] := val(readLine$[1]);  'Trial duration
            recTrialMF[lineCount%-1] := val(readLine$[2]);   'Modulation frequency
            recTrialCarrier$[lineCount%-1] := readLine$[3];  'Carrier type
            for i% := 0 to nSpk%-1 do
                recTrialStimCal[lineCount%-1][i%] := val(readLine$[i%+4]);  'Calibration values per speaker
            next; 
        case numRead%<0 then 'quit at end of file
            keepGoing% := 0;
            lineCount% -= 1;  'Decrement to get correct count on EOF
            status% := 1;
        else
            message("Starting over!|Failure to successfully read file with "+Str$(nSpk%+2)+" fields despite initial check!");
            printlog("Failure to successfully read file with %d fields despite initial check!\n",nSpk%+2);
            keepGoing% := 0;
        endcase;    
    wend;    
    
    fileclose();  'close fh0%, the currently open file
    
    recTotalStim% := lineCount%;
    
    return status%;
    
end
'===== End RecLoadStimCalMFCarrierFile =====
'
'



'
'
'===== RecLoadStimCalDistractorFile =====
func RecLoadStimCalDistractorFile%(fileLoc$,nSpk%,&recTotalStim%)
'These files by definition have two additional columns, Modulation Frequency and Carrier Type$, following Duration column

    var status%;
    var lineCount%;
    var keepGoing% := 1;
    var numRead%;
    var readLine$[34];
    var fh0%;
    var i%;
    
    status% := 0;  'begin with "failure", change to success if success
    
    printlog("Loading Distractor Stim/Cal w/MF&Carrier File: %s\n",fileLoc$);
        
    'First, make sure the file won't barf on us
    numRead% := RecVerifyInputFile%(fileLoc$);
    if numRead% <> nSpk%+4 then  'here there are four extra columns, file location$, duration, MF, carrier type$
        if numRead% = -1 then
            message("Starting over!|Failure to read Stim/Cal file!");
        else
            message("Starting over!|Incorrect number of fields in Stim/Cal file (expected "+Str$(nSpk%+2)+" fields, got "+Str$(numRead%)+")!");
        endif
        return status%;  'returns failure
    endif;
        
    'Then read the file
    fh0%:=FileOpen(fileLoc$,8,0);
    
    'readsetup(""," ","","","	");
    readsetup(""," "+Chr$(9),"","","	");  'Making tab -- Chr$(9) -- a soft separator, so extra tabs for lining up rows will be skipped
    
    'Skip past the header line
    numRead% := read(readLine$[0:34]);
    
    while keepGoing% do
        'Read the next line in the file, return line and number of fields read
        numRead% := read(readLine$[0:34]);  'reading as many as 34 lines as a check - if 34 successfully read, something is wrong with the file
        lineCount% += 1;
        
        'Place values into global variables
        docase
        case numRead% = nSpk%+4 then
            recTrialLoadLocDistractor$[lineCount%-1] := readLine$[0];  'Disk location of files to load, stim/cal file
            recTrialDurDistractor[lineCount%-1] := val(readLine$[1]);  'Trial duration
            recTrialMFDistractor[lineCount%-1] := val(readLine$[2]);   'Modulation frequency
            recTrialCarrierDistractor$[lineCount%-1] := readLine$[3];  'Carrier type
            for i% := 0 to nSpk%-1 do
                recTrialStimCalDistractor[lineCount%-1][i%] := val(readLine$[i%+4]);  'Calibration values per speaker
            next; 
        case numRead%<0 then 'quit at end of file
            keepGoing% := 0;
            lineCount% -= 1;  'Decrement to get correct count on EOF
            status% := 1;
        else
            message("Starting over!|Failure to successfully read file with "+Str$(nSpk%+2)+" fields despite initial check!");
            printlog("Failure to successfully read file with %d fields despite initial check!\n",nSpk%+2);
            keepGoing% := 0;
        endcase;    
    wend;    
    
    fileclose();  'close fh0%, the currently open file
    
    recTotalStim% := lineCount%;
    
    return status%;
    
end
'===== End RecLoadStimCalDistractorFile =====
'
'





'
'
'===== RecLoadStimFile =====
func RecLoadStimFile%(fileLoc$,&recTotalStim%)
    

    var status%;
    var lineCount%;
    var keepGoing% := 1;
    var numRead%;
    var readLine$[12];
    var fh0%;
    
    status% := 0;  'begin with "failure", change to success if success
    
    printlog("Loading Stim File: %s\n",fileLoc$);

    'First, make sure the file won't barf on us
    numRead% := RecVerifyInputFile%(fileLoc$);
    PrintLog("numRead is: %d \n", numRead%);
    if numRead% <> 11 then 'is this supposed to be 10 or 11? ~jao
        if numRead% = -1 then
            message("Starting over!|Failure to read Tone/Noise/AM generation file!");
        else
            message("Starting over!|Incorrect number of fields in Tone/Noise/AM generation file (expected 10 fields, got "+Str$(numRead%)+")!");
        endif
        return status%;  'returns failure
    endif;
        
    'Then read the file
    fh0%:=FileOpen(fileLoc$,8,0);
    
    'readsetup(""," ","","","	");
    readsetup(""," "+Chr$(9),"","","	");  'Making tab -- Chr$(9) -- a soft separator, so extra tabs for lining up rows will be skipped
    
    'Skip past the header line
    numRead% := read(readLine$[0:12]);
    
    while keepGoing% do
        'Read the next line in the file, return line and number of fields read
        numRead% := read(readLine$[0:12]);  'reading as many as 12 lines as a check - if 12 successfully read, something is wrong with the file
        lineCount% += 1;
        
        'Place values into global variables
        docase
        case numRead% = 11 then
            recTrialDur[lineCount%-1] := val(readLine$[0]);                'Trial duration
            recTrialGenLowpassHz[lineCount%-1] := val(readLine$[1]);       'A list of lowpass values - if -1, no lowpass, same as highpass means tone
            recTrialGenHighpassHz[lineCount%-1] := val(readLine$[2]);      'Same as above, highpass
            recTrialGenIsSweep%[linecount%-1] := val(readLine$[3]);        'Determines if FM sweep is present
            recTrialGenAMFreqHz[lineCount%-1] := val(readLine$[4]);        'A list of AM frequency values, if 0 no AM
            recTrialGenAMDepthPct[lineCount%-1] := val(readLine$[5]);      'A list of AM depth values in percent, if 0 no depth
            recTrialGenAMPhaseDeg[lineCount%-1] := val(readLine$[6]);      'A list of AM phases, 0 = AM starts low, 90 = AM starts middle and rising, 180 = AM starts high, 270 = AM starts middle, falling
            recTrialGenTonePhaseDeg[lineCount%-1] := val(readLine$[7]);    'A list of tone phases, 0 = tone starts middle, rising (sine phase), 90 = tone starts high (cosine phase), note different than AM phase, only used for tone, not noise
            recTrialGenGauss%[lineCount%-1] := val(readLine$[8]);          'If 1 create Gaussian noise, if 0 create uniform noise
            recTrialGenRampMS[lineCount%-1] := val(readLine$[9]);          'Duration in ms of front/back ramp, ramp is 1-Cos^2
            recTrialGenSeed%[lineCount%-1] := val(readLine$[10]);          'Seed for random number generator, 0 = unspecified, will make own random number
            recTrialMF[lineCount%-1] := recTrialGenAMFreqHz[lineCount%-1]; 'For whatever reason, this value is used in GenTrialsStereoDis%(), and other than adding this I don't have to change it to make it work for generating stims
        case numRead%<0 then  'quit on end of file
            keepGoing% := 0;
            lineCount% -= 1;  'Decrement to get correct count on EOF
            status% := 1;
        else
            message("Starting over!|Failure to successfully read file with 10 fields despite initial check!");
            keepGoing% := 0;
        endcase;    
    wend;    
    
    fileclose();  'close fh0%, the currently open file
    
    recTotalStim% := lineCount%;
    
    'Just some debugging code, correct read is verified
'    printlog("Column 1 was %f\n",recTrialDur[]);
'    printlog("Column 2 was %f\n",recTrialGenLowpassHz[]);
'    printlog("Column 3 was %f\n",recTrialGenHighpassHz[]);
'    printlog("Column 4 was %f\n",recTrialGenIsSweep%[]);
'    printlog("Column 5 was %f\n",recTrialGenAMFreqHz[]);
'    printlog("Column 6 was %f\n",recTrialGenAMDepthPct[]);
'    printlog("Column 7 was %f\n",recTrialGenAMPhaseDeg[]);
'    printlog("Column 8 was %f\n",recTrialGenTonePhaseDeg[]);
'    printlog("Column 9 was %d\n",recTrialGenGauss%[]);
'    printlog("Column 10 was %f\n",recTrialGenRampMS[]);
'    printlog("Column 11 was %d\n",recTrialGenSeed%[]);
    
    return status%;
    
end
'===== End RecLoadStimFile =====
'
'




'
'
'===== NameThatStimulus =====
func NameThatStimulus$(n%)
    'a function that looks at the parameters of a generated stimulus and writes a name for it
    'useful for putting something logical into a SampleText 
    'the ramp duration is NOT reported as it's probably never relevant; obviously it would be an easy add
    'The one thing to keep in mind here is that when it says 450HzLo with no Hi, that's 450-Inf highpass noise
    'and when it says 450HzHi with no Lo, that's 0-450 Hz lowpass noise
    var name$;
    var dur$;   'easy, do this for everything
    var freq$;  'this is the complicated one, can be tone, noise, BP, tone includes tone phase if not 0
    var am$;    'includes AM phase if not 0
    var seed$;  'seed for noise
    var amphse$;'for am phase, if necessary
    
    'Duration is easy
    dur$ := str$(recTrialDur[n%]) + "ms";
    
    'Freq is a pain, also construct seed info here, but write seed at the end of the string 
    docase
    case recSearchStimType% = 3 then 'if it's a click, just say that and move on
        dur$ := "click";  'Technically, dur will be listed as 200 ms, but that's not really correct
    case recTrialGenLowpassHz[n%] < 0 and recTrialGenHighpassHz[n%] < 0 then 'noise
        if recTrialGenGauss%[n%] = 1 then 'Gaussian noise
            freq$ := "_GaussNoise";
        else 'uniform noise
            freq$ := "_UniformNoise";
        endif;
        'PrintLog("recStimCount% = %d \n", recStimCount%); '*jao debugging
        'Not sure what jao was debugging, but there was an issue here in identifying the correct random seed.  
        'recStimCount% indexes the ordinal of stimuli in each trial, but the stimuli are not necessarily played
        'in numeric order.  In some cases (e.g. Search) there is only one stimulus in the PWAs but multiple
        'repeats of that stimulus.  In those cases only the random seed on the first stimulus was being accurately 
        'reported, after that it was being reported as "0".  Still have to debug this, but I *think* it should
        'give the right value.  I'm not sure how to test this for multiple PWAs.  In fact, I don't think ANY scenario
        'uses multiple PWAs AND generated random noise.  OK, until now.
        seed$ := "_Seed" + str$(recCurrRandomSeed%[recPWAList%[recStimCount%][recTrialOrder%[recCurrentTrial%-1]]],1,10);  'use 10 significant digits (should be 9 max from Clockseed on Matlab, 11 overflows CED anyway)
    case recTrialGenLowpassHz[n%] = recTrialGenHighpassHz[n%] then 'tone
        if recTrialGenTonePhaseDeg[n%] = 0 then 'standard, don't note phase
            freq$ := "_" + str$(recTrialGenLowpassHz[n%]) + "Hz";
        else 'note non-standard phase
            freq$ := "_" + str$(recTrialGenLowpassHz[n%]) + "Hz_" + str$(recTrialGenTonePhaseDeg[n%]) + "DegTonePhase";
        endif;
    case recTrialGenLowpassHz[n%] < 0 then 'lowpass
        if recTrialGenGauss%[n%] = 1 then 'Gaussian noise
            freq$ := "_GaussNoise_" + str$(recTrialGenHighpassHz[n%]) + "HzHi";
        else 'uniform noise
            freq$ := "_UniformNoise_" + str$(recTrialGenHighpassHz[n%]) + "HzHi";
        endif;
        seed$ := "_Seed" + str$(recCurrRandomSeed%[recPWAList%[recStimCount%][recTrialOrder%[recCurrentTrial%-1]]],1,10);  'use 10 significant digits (should be 9 max from Clockseed on Matlab, 11 overflows CED anyway)
    case recTrialGenHighpassHz[n%] < 0 then 'highpass
        if recTrialGenGauss%[n%] = 1 then 'Gaussian noise
            freq$ := "_GaussNoise_" + str$(recTrialGenLowpassHz[n%]) + "HzLo";
        else 'uniform noise
            freq$ := "_UniformNoise_" + str$(recTrialGenLowpassHz[n%]) + "HzLo";
        endif;
        seed$ := "_Seed" + str$(recCurrRandomSeed%[recPWAList%[recStimCount%][recTrialOrder%[recCurrentTrial%-1]]],1,10);  'use 10 significant digits (should be 9 max from Clockseed on Matlab, 11 overflows CED anyway)
    case recTrialGenIsSweep%[n%] = 0 then 'bandpass
        if recTrialGenGauss%[n%] = 1 then 'Gaussian noise
            freq$ := "_GaussNoise_" + str$(recTrialGenLowpassHz[n%]) + "HzLo_" + str$(recTrialGenHighpassHz[n%]) + "HzHi";
        else 'uniform noise
            freq$ := "_UniformNoise_" + str$(recTrialGenLowpassHz[n%]) + "HzLo_" + str$(recTrialGenHighpassHz[n%]) + "HzHi";
        endif;
        seed$ := "_Seed" + str$(recCurrRandomSeed%[recPWAList%[recStimCount%][recTrialOrder%[recCurrentTrial%-1]]],1,10);  'use 10 significant digits (should be 9 max from Clockseed on Matlab, 11 overflows CED anyway)
    else 'FM sweep
        if recTrialGenTonePhaseDeg[n%] = 0 then 'standard, don't note phase
            freq$ := "_FMSweep_start" + str$(recTrialGenLowpassHz[n%]) + "Hz_end" +  str$(recTrialGenHighpassHz[n%]) + "Hz";
        else 'note non-standard phase
            freq$ := "_FMSweep_start" + str$(recTrialGenLowpassHz[n%]) + "Hz_end" +  str$(recTrialGenHighpassHz[n%]) + "Hz_" + str$(recTrialGenTonePhaseDeg[n%]) + "DegTonePhase";
        endif;
    endcase;
            
    'AM is pretty easy  
    'first get the phase, if any
    if recTrialGenAMPhaseDeg[n%] > 0 then
        amphse$ := "_" + str$(recTrialGenAMPhaseDeg[n%]) + "DegAmPhase";
    endif;
    
    if recTrialGenAMFreqHz[n%] > 0 then
        am$ := "_" + str$(recTrialGenAMFreqHz[n%]) + "AMHz_" + str$(recTrialGenAMDepthPct[n%]) + "AMDepth";
    endif;
    
    name$ := dur$ + freq$ + am$ + amphse$ + seed$;
    
    if recExpToRun% = recExpFRAButton% and recFRALoadStim% = 1 then
        name$ := "(stim is loaded, can't autoname)";
    endif;    
    
    return name$;
    
end
'===== End NameThatStimulus =====
'
'


'
'
'===== NameThatStimulusStereoDis =====
func NameThatStimulusStereoDis$(n%,stim%,PWAind%)
    'a function that looks at the parameters of a generated stimulus and writes a name for it
    'useful for putting something logical into a SampleText 
    'StereoDis (and presumably any generated stereo experiment) needs a 2-D seed list, just adding a
    'new function rather than having to give dummy inputs to all the other calls
    'the ramp duration is NOT reported as it's probably never relevant; obviously it would be an easy add
    'The one thing to keep in mind here is that when it says 450HzLo with no Hi, that's 450-Inf highpass noise
    'and when it says 450HzHi with no Lo, that's 0-450 Hz lowpass noise
    var name$;
    var dur$;   'easy, do this for everything
    var freq$;  'this is the complicated one, can be tone, noise, BP, tone includes tone phase if not 0
    var am$;    'includes AM phase if not 0
    var seed$;  'seed for noise
    var amphse$;'for am phase, if necessary
    
    'Duration is easy
    dur$ := str$(recTrialDur[n%]) + "ms";
    
    'Freq is a pain, also construct seed info here, but write seed at the end of the string 
    docase
    case recSearchStimType% = 3 then 'if it's a click, just say that and move on
        dur$ := "click";  'Technically, dur will be listed as 200 ms, but that's not really correct
    case recTrialGenLowpassHz[n%] < 0 and recTrialGenHighpassHz[n%] < 0 then 'noise
        if recTrialGenGauss%[n%] = 1 then 'Gaussian noise
            freq$ := "_GaussNoise";
        else 'uniform noise
            freq$ := "_UniformNoise";
        endif;
        'PrintLog("recStimCount% = %d \n", recStimCount%); '*jao debugging
        'Not sure what jao was debugging, but there was an issue here in identifying the correct random seed.  
        'recStimCount% indexes the ordinal of stimuli in each trial, but the stimuli are not necessarily played
        'in numeric order.  In some cases (e.g. Search) there is only one stimulus in the PWAs but multiple
        'repeats of that stimulus.  In those cases only the random seed on the first stimulus was being accurately 
        'reported, after that it was being reported as "0".  Still have to debug this, but I *think* it should
        'give the right value.  I'm not sure how to test this for multiple PWAs.  In fact, I don't think ANY scenario
        'uses multiple PWAs AND generated random noise.  OK, until now.
        seed$ := "_Seed" + str$(recStereoDisSeedList%[stim%][PWAInd%],1,10);  'use 10 significant digits (should be 9 max from Clockseed on Matlab, 11 overflows CED anyway)
    case recTrialGenLowpassHz[n%] = recTrialGenHighpassHz[n%] then 'tone
        if recTrialGenTonePhaseDeg[n%] = 0 then 'standard, don't note phase
            freq$ := "_" + str$(recTrialGenLowpassHz[n%]) + "Hz";
        else 'note non-standard phase
            freq$ := "_" + str$(recTrialGenLowpassHz[n%]) + "Hz_" + str$(recTrialGenTonePhaseDeg[n%]) + "DegTonePhase";
        endif;
    case recTrialGenLowpassHz[n%] < 0 then 'lowpass
        if recTrialGenGauss%[n%] = 1 then 'Gaussian noise
            freq$ := "_GaussNoise_" + str$(recTrialGenHighpassHz[n%]) + "HzHi";
        else 'uniform noise
            freq$ := "_UniformNoise_" + str$(recTrialGenHighpassHz[n%]) + "HzHi";
        endif;
        seed$ := "_Seed" + str$(recStereoDisSeedList%[stim%][PWAInd%],1,10);  'use 10 significant digits (should be 9 max from Clockseed on Matlab, 11 overflows CED anyway)
    case recTrialGenHighpassHz[n%] < 0 then 'highpass
        if recTrialGenGauss%[n%] = 1 then 'Gaussian noise
            freq$ := "_GaussNoise_" + str$(recTrialGenLowpassHz[n%]) + "HzLo";
        else 'uniform noise
            freq$ := "_UniformNoise_" + str$(recTrialGenLowpassHz[n%]) + "HzLo";
        endif;
        seed$ := "_Seed" + str$(recStereoDisSeedList%[stim%][PWAInd%],1,10);  'use 10 significant digits (should be 9 max from Clockseed on Matlab, 11 overflows CED anyway)
    case recTrialGenIsSweep%[n%] = 0 then 'bandpass
        if recTrialGenGauss%[n%] = 1 then 'Gaussian noise
            freq$ := "_GaussNoise_" + str$(recTrialGenLowpassHz[n%]) + "HzLo_" + str$(recTrialGenHighpassHz[n%]) + "HzHi";
        else 'uniform noise
            freq$ := "_UniformNoise_" + str$(recTrialGenLowpassHz[n%]) + "HzLo_" + str$(recTrialGenHighpassHz[n%]) + "HzHi";
        endif;
        seed$ := "_Seed" + str$(recStereoDisSeedList%[stim%][PWAInd%],1,10);  'use 10 significant digits (should be 9 max from Clockseed on Matlab, 11 overflows CED anyway)
    else 'FM sweep
        if recTrialGenTonePhaseDeg[n%] = 0 then 'standard, don't note phase
            freq$ := "_FMSweep_start" + str$(recTrialGenLowpassHz[n%]) + "Hz_end" +  str$(recTrialGenHighpassHz[n%]) + "Hz";
        else 'note non-standard phase
            freq$ := "_FMSweep_start" + str$(recTrialGenLowpassHz[n%]) + "Hz_end" +  str$(recTrialGenHighpassHz[n%]) + "Hz_" + str$(recTrialGenTonePhaseDeg[n%]) + "DegTonePhase";
        endif;
    endcase;
            
    'AM is pretty easy  
    'first get the phase, if any
    if recTrialGenAMPhaseDeg[n%] > 0 then
        amphse$ := "_" + str$(recTrialGenAMPhaseDeg[n%]) + "DegAmPhase";
    endif;
    
    if recTrialGenAMFreqHz[n%] > 0 then
        am$ := "_" + str$(recTrialGenAMFreqHz[n%]) + "AMHz_" + str$(recTrialGenAMDepthPct[n%]) + "AMDepth";
    endif;
    
    name$ := dur$ + freq$ + am$ + amphse$ + seed$;
    
    if recExpToRun% = recExpFRAButton% and recFRALoadStim% = 1 then
        name$ := "(stim is loaded, can't autoname)";
    endif;    
    
    return name$;
    
end
'===== End NameThatStimulusStereoDis =====
'
'




'
'
'===== GenTrialsSearch =====
func GenTrialsSearch%()
    'At this point, the GenTrialsXXX functions are not in triallistgen.s2s.  Most of this is due to concerns about
    'the global variables needed.
    var i%;
    var j%;
    var status% := 1;
    var nS%;  'number of S1 stimuli 
    var nRS%; 'number of repeats for speaker sweep
    var nR%;  'number of repeats, for tone sweep 
    var nT%;  'number of tones, for tone sweep
    var nCyc%;  'number of cycles per "trial" if there are more than 20 individual tones in a tone sweep 
    var currTone%;  'current tone (PWA), if there are more than 20 individual tones in a tone sweep
    var nSpkr%; '# speakers in current array (needed or is this already a global?)
    var nCycS%;  'number of cycles per "trial" for speaker sweep 
    var currSpkr%;  'current speaker (PWA), for speaker sweep
    var speakerSweepList%[recNSpeakers%*recSearchToneSweepRepeats%];
    
    nR% := recSearchToneSweepRepeats%;  'shorthand
    nT% := recSearchToneSweepNSteps%;  'shorthand again
    nRS% := recSearchSpeakerSweepRepeats%;
    
    nSpkr% := recNSpeakers%; 'shorthand again. speaker sweep! '10 for debugging purposes
    if recDebug% > 0 then
        nSpkr% := 10; '10 for debugging purposes to equal recMaxTrial
    endif;
    currSpkr% := 1; 'start with speaker 1
    
    'Tone sweeps have to be different!  No S2 for those.
    for i% := 0 to recNTrials%-1 do
        nS% := recMinS1% + Floor(Rand(recVarS1%+1,0));  'using Floor with an offset of 1 because the range of Rand is 0 -> .999... 
        recTrialOrder%[i%] := i%;  'set initial trial order
        docase
        case recSearchStimType% = 4 and (nT%*nR% <= recMaxStimPerTrial%) then 'for tone sweeps, simple version where all trials are identical
            for j% := 0 to nT%-1 do  'for each tone in the tone sweep
                recStimList%[j%][i%] := j%;  'fill Stim list with indices of the sweep tones, from low to high (freqs already set by dialog box)
                arrconst(recPWAList%[j%*nR%:nR%][i%],j%);  'fill PWA list with nR% copies of tone
                'PrintLog("recPWAList is now: d% \n", recPWAList%); 'temprary! for dbugging
                
            next;
            arrconst(recSpeakerList%[0:nT%][i%],recS1Speaker%);  'only one speaker
            recNUniqueStims%[i%] := nT%;
            arrconst(recDeltadBList[0:nT%*nR%][i%],recDeltadBLevel);  'do not set any delta dB, may change if Gregg wants roving
            recTrialTerminalIndex%[i%] := (nT%*nR%)-1;  'it's an index, subtract 1
            recTrialTerminalIsS2%[i%] := 0;  'last stimulus is not an S2
            
        case recSearchStimType% = 4 and (nT%*nR% > recMaxStimPerTrial%) then 'complicated version of tone sweeps, if there are more than 20 tones in a sweep
            for j% := 0 to nT%-1 do  'for each tone in the tone sweep
                recStimList%[j%][i%] := j%;  'fill Stim list with indices of the sweep tones, from low to high (freqs already set by dialog box)
            next; 
            arrconst(recSpeakerList%[0:nT%][i%],recS1Speaker%);  'only one speaker            
            recNUniqueStims%[i%] := nT%;
            
            nCyc% := floor(recMaxStimPerTrial%/nR%);  'divide max stims by number of repeats to see how many repeats can fit
            for j% := 0 to nCyc%-1 do
                arrconst(recPWAList%[j%*nR%:nR%][i%],currTone%);  'fill PWA list with nR% copies of tone
                currTone% += 1;
                if currTone% = nT% then  'wrap currTone% when necessary
                    currTone% := 0;
                endif;
            next;
            arrconst(recDeltadBList[0:nCyc%*nR%][i%],recDeltadBLevel);  'do not set any delta dB, may change if Gregg wants roving
            recTrialTerminalIndex%[i%] := (nCyc%*nR%)-1;  'it's an index, subtract 1
            recTrialTerminalIsS2%[i%] := 0;  'last stimulus is not an S2
            
        case recSearchStimType% = 5 then 'speaker sweep with broadband noise
            'this is the do all speakers in one trial method (as in tone sweep)
            '        for j% := 1 to nSpkr% do  'for each Speaker
            '            ArrConst(speakerSweepList%[j%-1][i%],j%);  'fill Speaker list with speaker #
            '            PrintLog("recSpeakerList is now: %d \n", recSpeakerList%);
            ''            arrconst(recPWAList%[j%*nR%:nR%][i%],j%);  'fill PWA list with nR% copies of noise (hijack tone repeats variable for now)
            ''            'PrintLog("recPWAList is now: %d \n", recPWAList%);
            '        next;
            recStimList%[0][i%] := 0;  'Set first value in recStimList% to zero, there is only one stimulus        
            recNUniqueStims%[i%] := 1; 'only 1 b/c all noise        
            'this is the one speaker per trial method:
            ArrConst(recSpeakerList%[0:nRS%][i%], currSpkr%);
            '       PrintLog("recSpeakerList%[0:nR%][i%] = %d \n", recSpeakerList%[0:nR%][i%]);
            currSpkr% +=1; 'increment speaker number for next trial   
            if currSpkr% > nSpkr% then  'reset to 1 if last speaker in array
                currSpkr% := 1;
            endif;
            
            arrconst(recPWAList%[0:nRS%][i%],0);  'Fill recPWAList% with zeros = the PWAs we will play
            arrconst(recDeltadBList[0:nRS%][i%],recDeltadBLevel);  'do not set any delta dB, may change if Gregg wants roving
            '        arrconst(recDeltadBList[0:nSpkr%*nR%][i%],recDeltadBLevel);  'do not set any delta dB, may change if Gregg wants roving
            recTrialTerminalIndex%[i%] := nRS%-1;  'it's an index, subtract 1
            'recTrialTerminalIndex%[i%] := (nSpkr%*nR%)-1;  'it's an index, subtract 1
            recTrialTerminalIsS2%[i%] := 0;  'last stimulus is not an S2
            
        case (recActive% = 0 or recPropCatch >= Rand()) and recSearchStimType% < 5 then  'if passive or catch, do not put in an S2
            recStimList%[0][i%] := 0;  'Set first value in recStimList% to zero, there is only one stimulus
            recSpeakerList%[0][i%] := recS1Speaker%;  'Set speaker for the only stimulus
            recNUniqueStims%[i%] := 1;  'only one unique stimulus
            arrconst(recPWAList%[0:nS%][i%],0);  'Fill recPWAList% with zeros = the PWAs we will play
            arrconst(recDeltadBList[0:nS%][i%],recDeltadBLevel);  'do not set any delta dB, may change if Gregg wants roving
            recTrialTerminalIndex%[i%] := nS%-1;  'it's an index, subtract 1
            recTrialTerminalIsS2%[i%] := 0;  'last stimulus is not an S2
            'printlog("Nontarget/Catch trial, recTrialTerminalIndex% is %d\n",recTrialTerminalIndex%[i%]);
            
            
        else 'put in an S2
            recStimList%[0][i%] := 0;  'Set first value in recStimList% to zero, there is only one stimulus
            recStimList%[1][i%] := 0;  'Set second value in recStimList% to zero, there is only one stimulus
            recSpeakerList%[0][i%] := recS1Speaker%;  'Set speaker for the S1
            recSpeakerList%[1][i%] := recS2Speaker%;  'Set speaker for the S2
            recNUniqueStims%[i%] := 2;  'two unique stimuli (due to calib on different speaker), fill two PWAs
            arrconst(recPWAList%[0:nS%][i%],0);  'Fill recPWAList% with zeros = the PWAs we will play
            recPWAList%[nS%][i%] := 1;  'And fill the final slot in the PWA list with 1, the S2 stimulus
            arrconst(recDeltadBList[0:nS%+1][i%],recDeltadBLevel);  'do not set any delta dB, may change if Gregg wants roving
            recTrialTerminalIndex%[i%] := nS%;  'it's an index, subtract 1 ( = nS%+1-1)
            'printlog("Target trial, recTrialTerminalIndex% is %d\n",recTrialTerminalIndex%[i%]);
            recTrialTerminalIsS2%[i%] := 1;  'last stimulus is an S2
            
        endcase;        
    next; 
    if recSearchStimType% < 4 then 'We refuse to shuffle tone sweeps and speaker sweeps (as of 1/8/20, this is the ONLY situation where we ignore the shuffle variable)
        if recDoNotShuffle% = 0 then
            ShuffleList%(recTrialOrder%[0:recNTrials%]);  'create a randpermed version of recTrialOrder (only valid indices), but not for tone sweep or speaker sweep
        endif;
    else
        recDoNotShuffle% := 1;  'if we are refusing to shuffle, at least let's keep that knowledge for later in the code
    endif;
    return status%;  'right now, it "can't" fail
end
'===== End GenTrialsSearch =====
'
'




'
'
'===== GenTrialsAudiogram =====
func GenTrialsAudiogram%()
    'this should be relatively simple, we're just making one trial for each tone, the staircase will be handled by the idle loop    
    var i%;
    var status% := 1;
    
    recNTrials% := recAudiogramNFreqs%;  'one trial for each tone
    recTrainingRewardmL := 0;  'hard code training reward to OFF
    recTrialInitReward% := 0;  'hard code init reward to OFF -  this actually won't matter unless somebody goes through the AMDisc/SpaceDis dialogs first
    
    'recAudiogramNFreqs%,recAudiogramToneFreqLow,recAudiogramToneFreqHigh,recAudiogramFreqList[]  'values are already calculated  
    
    'loop through each trial
    for i% := 0 to recNTrials%-1 do
        
        'set initial trial order, for now this will not be changed
        recTrialOrder%[i%] := i%;     
        
        'set stim list, speaker list, etc.
        recStimList%[0][i%] := i%;  'fill stim list with indices from 0 to n-1, we will do trials in order
        recSpeakerList%[0][i%] := recS1Speaker%;  'Set speaker for the S1
        recNUniqueStims%[i%] := 1;  'one unique stimulus, fill one PWA
        recPWAList%[0][i%] := 0;  'we will use PWA 0
        recDeltadBList[0][i%] := 0;  'do not set any delta dB, may change if Gregg wants roving
        recTrialTerminalIndex%[i%] := 0;
        recTrialTerminalIsS2%[i%] := 1;  'last stimulus is an S2 
        
        'write parameters for the generated stimulus
        recTrialDur[i%] := 200;  'Jackie says always 200 ms for audiogram
        recTrialGenRampMS[i%] := 2;  'short ramp
        recTrialGenAMFreqHz[i%] := 0;
        recTrialGenAMDepthPct[i%] := 0;
        recTrialGenAMPhaseDeg[i%] := 0;
        recTrialGenTonePhaseDeg[i%] := 0;
        recTrialGenGauss%[i%] := 0;  
        recTrialGenSeed%[i%] := 0; 
        recTrialGenLowpassHz[i%] := recAudiogramFreqList[i%];
        recTrialGenHighpassHz[i%] := recAudiogramFreqList[i%];
        recTrialGenIsSweep%[i%] := 0;       
              
    next; 
    
    return status%;  'right now, it "can't" fail
end
'===== End GenTrialsAudiogram =====
'
'









'
'
'===== GenTrialsFRA =====
func GenTrialsFRA%()
    var status% := 1;
    var nTonePips%;
    const nFMSweeps%:=10;  'this really can't change
    var i%;
    var j%;
    var k%;
    var numS1perTrial%[recMaxTrial%];
    var nS1%;
    var nS2%;
    var temp;            'Stuff for mod function...sure wish CED had one
    var t;               '(and the floating point crapola...ugh)
    var i;               'Also for mod
    var ind%;            'this too
    var whichS1StimInd%[recMaxStimPerTrial%*recMaxTrial%];  'S1 stimuli only vary in stimulus ID
    var whichS1DeltadB[recMaxStimPerTrial%*recMaxTrial%];        'and dB level
    var S1Shuffle%[recMaxStimPerTrial%*recMaxTrial%];       'for shuffling S1s
    var whichS2Speaker%[recMaxTrial%];  'only one S2 per trial, so this is big enough
    var count%;
    
    '===== Create Stimuli =====
    
    'For creating stimuli, there will be only one noise stimulus and a ton of tone pips/FM, so we'll
    'put the noise stimulus in position 0 of the stimuli variables
    nTonePips% := recFRAFreqNSteps%;
    
    'Set trial generation variables for the noise burst, both S2 and rate-level will use this stimulus, but at different speakers
    recTrialDur[0] := 200;
    recTrialGenRampMS[0] := 2;  'short ramp
    recTrialGenAMFreqHz[0] := 0;
    recTrialGenAMDepthPct[0] := 0;
    recTrialGenAMPhaseDeg[0] := 0;
    recTrialGenTonePhaseDeg[0] := 0;
    recTrialGenGauss%[0] := 1;  'use gaussian noise
    recTrialGenSeed%[0] := 0;  'This makes it unfrozen, need to make sure we're recording the seed
    recTrialGenLowpassHz[0] := -1;
    recTrialGenHighpassHz[0] := -1;
    recTrialGenIsSweep%[0] := 0;
'        printlog("stim index = 0\t"); ' check stim! 
'        printlog("Rate-level (noise)\n");
'    'Fill whichS1StimInd%[] and whichS1DeltadB[] for the rate-level noises
    count% := 0;  'reset, though it's the first time used
    for i% := 0 to recRateLeveldBNSteps%-1 do
        for j% := 0 to recRateLevelNRepeats%-1 do
            whichS1StimInd%[count%] := 0;  'always is stimulus 0
            whichS1DeltadB[count%] := 65-recRateLeveldBList[i%];  'delta dB is additional atten, default stims will play at 65
'                printlog("count = %d\t", count%); ' check stimlist! 
'                printlog("Rate-level %d\n", whichS1DeltadB[count%]);
            count% += 1;        
        next;
    next;
    
    
    'Set trial generation variables for the tone pips
    'Also fill whichS1StimInd%[] and whichS1DeltadB[] for the tone pips
    'A lot of this COULD be "ArrConst"ed, but since we have to loop anyway, why clutter the code?
    for i% := 1 to nTonePips% do
        recTrialDur[i%] := 50;
        recTrialGenRampMS[i%] := 2;  'short ramp
        recTrialGenAMFreqHz[i%] := 0;
        recTrialGenAMDepthPct[i%] := 0;
        recTrialGenAMPhaseDeg[i%] := 0;
        recTrialGenTonePhaseDeg[i%] := 0;
        recTrialGenGauss%[i%] := 0;  
        recTrialGenSeed%[i%] := 0; 
        recTrialGenLowpassHz[i%] := recFRAFreqList[i%-1];
        recTrialGenHighpassHz[i%] := recFRAFreqList[i%-1];
        recTrialGenIsSweep%[i%] := 0;
        for j% := 0 to recFRAdBNSteps%-1 do
            for k% := 0 to recFRANRepeats%-1 do  'recFRANRepeats% will probably be 1, that's OK as for i% := 0 to 0 executes once as expected
                whichS1StimInd%[count%] := i%;  'i% holds the stim index of the current tone
                whichS1DeltadB[count%] := 65-recFRAdBList[j%];  'recFRAdBList[j%] holds the dB of the current tone, delta dB is additional atten, default stims will play at 65
'                printlog("count = %d\t", count%); ' check stimlist! 
'                printlog("Tone pip: %d\n", whichS1DeltadB[count%]);
                count% += 1;
            next;
        next;
'        printlog("stim index = %d\t", i%); ' check stim! 
'        printlog("Tone pip: %d\n", recFRAFreqList[i%-1]);
    next;

    
    'Set trial generation variables for the FM sweeps...
    'Also fill whichS1StimInd%[] and whichS1DeltadB[] for the FM sweeps
    'Fill FMSweepDur%[]
    recFRAFMSweepDur%[0] := recFRAFMSweepDur1%;
    recFRAFMSweepDur%[1] := recFRAFMSweepDur2%;
    recFRAFMSweepDur%[2] := recFRAFMSweepDur3%;
    recFRAFMSweepDur%[3] := recFRAFMSweepDur4%;
    recFRAFMSweepDur%[4] := recFRAFMSweepDur5%;
    recFRAFMSweep%[0] := recFRAFMSweepStart%;  'low end of sweep, will reverse as well
    recFRAFMSweep%[1] := recFRAFMSweepEnd%; 'high end of sweep, will reverse as well
    for i% := 1 to nFMSweeps% do
        'Set values that are constant
        recTrialGenRampMS[i%+nTonePips%] := 2;  'short ramp
        recTrialGenAMFreqHz[i%+nTonePips%] := 0;
        recTrialGenAMDepthPct[i%+nTonePips%] := 0;
        recTrialGenAMPhaseDeg[i%+nTonePips%] := 0;
        recTrialGenTonePhaseDeg[i%+nTonePips%] := 0;
        recTrialGenGauss%[i%+nTonePips%] := 0;  
        recTrialGenSeed%[i%+nTonePips%] := 0;
        'Set duration, different for different sweeps
        i := i%-1;
        t := frac(i/(nFMSweeps%/2));
        temp := (nFMSweeps%/2)*t;
        ind% := round(temp);  'gets mod of i%,5...stupid, stupid floating point stuff kills it without these steps
        recTrialDur[i%+nTonePips%] := recFRAFMSweepDur%[ind%];  'gets duration based on mod result
        'Set direction of sweep
        ind% := floor(i/(nFMSweeps%/2));
        recTrialGenLowpassHz[i%+nTonePips%] := recFRAFMSweep%[ind%];  'if mod is 0, goes 500-20000...
        recTrialGenHighpassHz[i%+nTonePips%] := recFRAFMSweep%[1-ind%];  '...if mod is 1, goes 20000-500
        recTrialGenIsSweep%[i%+nTonePips%] := 1;
        for j% := 0 to recFRAFMSweepRepeats%-1 do
            whichS1StimInd%[count%] := i%+nTonePips%;  'i%+nTonePips% holds the stim index of the current FM sweep
            whichS1DeltadB[count%] := 65-recFRAS2dBLevel;  'recFRAS2dBLevel holds the dB of the tone sweeps as well as the S2s, delta dB is additional atten, default stims will play at 65
'                printlog("count = %d\t", count%); ' check stimlist! 
'                printlog("FMsweeps: %d\n", recTrialDur[i%+nTonePips%]);
            count% += 1;
        next;
'        printlog("stim index = %d\t", i%+nTonePips%); ' check stim! 
'        printlog("FM sweep: %d\n", recFRAFMSweep%[ind%]);
   next;

'Set trial variables for AMnoise...
for i% := 0 to nMTFrates%-1 do
    'AM Noise generation variables - same as AMdisc
    j% := i%+nTonePips%+nFMSweeps%+1; 'use j% now as trial index instead of i%
    recTrialDur[j%] := 500;
    recTrialGenRampMS[j%] := 5;  
    recTrialGenAMFreqHz[j%] := MTFrates[i%];
    recTrialGenAMDepthPct[j%] := 100; '100% depth
    recTrialGenAMPhaseDeg[j%] := 0;
    recTrialGenTonePhaseDeg[j%] := 0;
    recTrialGenGauss%[j%] := 1;  'use gaussian noise
    recTrialGenSeed%[j%] := 0;  'This makes it unfrozen, need to make sure we're recording the seed
    recTrialGenLowpassHz[j%] := -1;
    recTrialGenHighpassHz[j%] := -1;
    recTrialGenIsSweep%[j%] := 0;
    for k% := 1 to recS1AMnoiseReps% do
        'fill repeats & increment count...
        whichS1StimInd%[count%] := j%;  'j% holds the stim index of the current AM
        whichS1DeltadB[count%] := 0;  'default stims will play at 65
'                printlog("count = %d\t", count%); ' check stimlist! 
'                printlog("AM noise: %d\n", MTFrates[i%]);
        count% += 1;
    next;
'    printlog("stim index = %d\t", j%); ' check stim! this is going to be a long list
'    printlog("AM noise: this rate = %d\t", MTFrates[i%]);
'    printlog("AM noise: duration = %d\n", recTrialDur[j%]);
next;

'Adding bandpass noise!
for i% := 0 to nBPnoises%-1 do
    'BP noise generations variables
    j% := i%+nTonePips%+nFMSweeps%+nMTFrates%+1;
    recTrialDur[j%] := 200;
    recTrialGenRampMS[j%] := 2;  'short ramp
    recTrialGenAMFreqHz[j%] := 0;
    recTrialGenAMDepthPct[j%] := 0;
    recTrialGenAMPhaseDeg[j%] := 0;
    recTrialGenTonePhaseDeg[j%] := 0;
    recTrialGenGauss%[j%] := 1;  'use gaussian noise
    recTrialGenSeed%[j%] := 0;  'This makes it unfrozen, need to make sure we're recording the seed
    recTrialGenLowpassHz[j%] := recBPnoisesLOs%[i%];
    recTrialGenHighpassHz[j%] := recBPnoisesHIs%[i%];
    recTrialGenIsSweep%[0] := 0;
    for k% := 1 to recBPnoiseReps% do
        'fill repeats & increment count...
        whichS1StimInd%[count%] := j%;  'j% holds the stim index of the current BP
        whichS1DeltadB[count%] := 0;  'default stims will play at 65
        count% += 1;
    next;
next;    
    
    'Fill an S1Shuffle variable with the indices of S1 trials
    for i% := 0 to count%-2 do  'count-2 because it is incremented one last time above and not decremented
        S1Shuffle%[i%] := i%;
    next;
    'And shuffle it
    if recDoNotShuffle% = 0 then
        ShuffleList%(S1Shuffle%[0:count%]);  'create a randpermed version (only valid indices)
    endif;
    
    
    
    ' ===== Create Trials =====
    '#S1s = number of tone pips in FRA plus number of noise bursts in rate-level function + number of AM noises in MTFs
    nS1% := (nTonePips%*recFRAdBNSteps%*recFRANRepeats%)+(recRateLevelNRepeats%*recRateLeveldBNSteps%)+(nFMSweeps%*recFRAFMSweepRepeats%)+(nMTFrates%*recS1AMnoiseReps%)+(nBPnoises%*recBPnoiseReps%);  
    printlog("nS1% = %d\n", nS1%);
    nS2% := (recNSpeakers%-1)*recSpaceNRepeats%;  'that's number of noises at speakers not in the S1 position
    printlog("nS2% = %d\n", nS2%);
    recNTrials% := nS2%;  'Set global Ntrials
    'Average is (now) 3.833 S1 per S2
    DealNumberOfS1s%(nS1%,nS2%,recMinS1%,recMinS1%+recFRAVarS1%-1,numS1perTrial%[]);  'this is OK
    
    
    'Fill whichS2Speaker%[] with the speaker indices we will be using
    'At this point I realize there's no indication whether speaker number is expected to start at 0 or 1.  Guessing 1.
    count% := 0;  'reset
    for i% := 1 to recNSpeakers% do  'this is right, we go through all speakers
        if i% <> recS1Speaker% then  'don't use the S1 speaker of course
            for j% := 1 to recSpaceNRepeats% do 'recRateLevelNRepeats% do - separated from S2-Space count!
                whichS2Speaker%[count%] := i%;
                count% += 1;
            next;
        endif;
    next;
    'And shuffle it (actually, I believe this is be unnecessary because the S1s ARE shuffled and the trial order is later shuffled)
    if recDoNotShuffle% = 0 then
        ShuffleList%(whichS2Speaker%[0:count%]);  'create a randpermed version (only valid indices)
    endif;
    
    
    'Fill recStimList[][] etc. for each trial, end at an S2 every time
    count% := 0;
    for i% := 0 to nS2%-1 do  'for each trial
        recTrialOrder%[i%] := i%;  'Just randomize this after the loop
        recTrialTerminalIndex%[i%]  := numS1perTrial%[i%];  'not "+1" due to 0-based indexing
        recTrialTerminalIsS2%[i%] := 1;  'all trials have a terminal S2 
        'fill the S1 information
        for j% := 0 to numS1perTrial%[i%]-1 do
            recStimList%[j%][i%] := whichS1StimInd%[S1Shuffle%[count%]]; 'this is stimulus index, all stims considered "unique" 
            recDeltadBList[j%][i%] := whichS1DeltadB[S1Shuffle%[count%]];  'And dB
            recPWAList%[j%][i%] := j%;  'this is PWA to play, just PWA in order
            recSpeakerList%[j%][i%] := recS1Speaker%;  'This is the "main" speaker
            count% += 1;
        next;
        'and now we're ready for the S2
        'Note that j% gets incremented one last time to trigger the "exit" of the loop, and thus is now
        'the correct index to use.  However, since this bothers the crap out of me, I'm explicitly setting it.
        j% := numS1perTrial%[i%];  'because of zero-based indexing, the number of S1s is the index of the S2
        recStimList%[j%][i%] := 0;  'this is stimulus index, S2 stimulus is noise, which is 0 
        recDeltadBList[j%][i%] := 65-recFRAS2dBLevel;  'Delta dB (additional atten) for S2 stimuli, default stims will play at 65
        recPWAList%[j%][i%] := j%;  'this is PWA to play, just play in order
        recSpeakerList%[j%][i%] := whichS2Speaker%[i%];
        'And finally the number of unique stims - all stims are treated as unique (i.e. loaded into their own PWA) even if they're technically "not"
        recNUniqueStims%[i%] := j%+1;  'j% is index of final stimulus, so number of stims (all unique) is +1
    next;
    'Randomize the list order
    if recDoNotShuffle% = 0 then
        ShuffleList%(recTrialOrder%[0:nS2%]);
    endif;
    
    return status%;
end
'===== End GenTrialsFRA =====
'
'






'
'
'===== GenTrialsFRALoad =====
func GenTrialsFRALoad%()
    var status% := 1;
    var i%;
    var j%;
    var count% := 0;
    var rewardInt% := 5;
    var miniTrialOrder%[recTotalTrials%];
    var RepeatsPerStim% := 1;
    var randNum := 0;
    var randInt%;
    var randInt2%;
    var rewardArray%[80];
    var rewardIndex%;
    
    ' ===== Create Trials =====
    recNTrials% := (recTotalTrials%*RepeatsPerStim%);  'Set global Ntrials
    

    for i% := 0 to recTotalTrials%-1 do ' 1. populate miniTrialOrder%
        miniTrialOrder%[i%] := i%;
    next;    

    for i% := 0 to recTotalTrials% do    '2. save values into rec2StimList, rec2SpeakerList, rec2DeltadBList
        rec2StimList%[i%][0] := RecTrialS1%[i%];  
        rec2StimList%[i%][1] := RecTrialS2%[i%];  
                                                  
    
        rec2SpeakerList%[i%][0] := RecTrialS1Spkr%[i%];
        rec2SpeakerList%[i%][1] := RecTrialS2Spkr%[i%];
    
        rec2DeltadBList[i%][0] := recTrialS1DeltadB[i%];
        rec2DeltadBList[i%][1] := recTrialS2DeltadB[i%];
    next;

    for i% := 0 to recFRARepeatsPerStim%-1 do '3. Fill recTrialOrder. go through each RepeatPerStim and...
        
        if recDoNotShuffle% = 0 then
            ShuffleList%(miniTrialOrder%);      'shuffle the miniTrialOrder
        endif;
    
        for j% := 0 to recTotalTrials%-1 do   'load this "chunk" of the order into the RecTrialOrder
            recTrialOrder%[count%] := miniTrialOrder%[j%];
            count% += 1;                    'increment count to the next spot in RecTrialOrder to fill
        next;
    next;
    
    'REWARDS - first clear the recFRAReward array
    for i% := 0 to recMaxTrial%-1 do
            recFRAReward%[i%] := 0;
    next;
    
    
    'generate trials that are rewarded
    'Make an array with the exact number of each interval that fits in 996 trials.
    for i% := 0 to 79 do
        docase
        case i% <= 13 then
            rewardArray%[i%] := 10;
        case i% >= 14 and i% <= 27 then
            rewardArray%[i%] := 11;
        case i% >= 28 and i% <= 40 then
            rewardArray%[i%] := 12;
        case i% >= 41 and i% <= 53 then
            rewardArray%[i%] := 13;
        case i% >= 54 and i% <= 66 then
            rewardArray%[i%] := 14;
        case i% >= 67 then
            rewardArray%[i%] := 15;
        endcase
    next; 
    
    if recDoNotShuffle% = 0 then
        ShuffleList%(rewardArray%[]); 'shuffle it
    endif;

    rewardIndex% := rewardArray%[0]; 'index of first trial to be rewarded
    recFRAReward%[rewardIndex%-1] := 1; 'change to 1 in array to indicate it will be rewarded

    for i% := 0 to 78 do
        rewardIndex% += rewardArray%[i%];   'add the next interval to rewardIndex to determine the next trial to be rewarded
        recFRAReward%[rewardIndex%] := 1;
    next;
        
    return status%;
end
'===== End GenTrialsFRALoad =====
'
'



'===== GenTrialsDis =====
'modeled off of GenTrialsFRA... 
'a generic trial gen function for discrimination experiments (AMDis and SpaceDis), takes recExpToRun% as input to figure out what to do
func GenTrialsDis%(recExpToRun%)
    var status% := 1;
    var i%;
    var j%;
    var k%;
    var trialrep%;
    var numS1perTrial%;
    var nS1%;
    var nS2%;
    var RepeatsPerStim%;
    var responseTrial%; '1 if hit/miss, 0 if catch
    const dBrove% := 5; 'Rand(dBrove%,0) = 0,1,2,3,4 dB ; set to 0 to turn roving off
    
    'global vars set up in RecLoadTrialsFile: 
    '            recTrialS1%
    '            recTrialS2%
    '            recTrialS1Spkr%
    '            recTrialS2Spkr%
    '            recTrialS1DeltadB
    '            recTrialS2DeltadB
    
    'get Expt specific vars
    docase
    case recExpToRun% = recExpAMDiscButton% then
        RepeatsPerStim% := recAMDiscRepeatsPerStim%;  
    case recExpToRun% = recExpSpaceDisButton% then    
        RepeatsPerStim% := recSpaceDisRepeatsPerStim%;  
    endcase
    
    ' ===== Create Trials =====
    recNTrials% := (recTotalTrials%*RepeatsPerStim%);  'Set global Ntrials
    nS1% := recNTrials%;
    nS2% := recNTrials%;
    
    'Fill recStimList[][] etc. for each trial, 
    k% := 0; 'trial index counter, should increment to total recNTrials%-1
    for trialrep% := 0 to RepeatsPerStim%-1 do 'for number of trial repetitions  
        for i% := 0 to recTotalTrials%-1 do  'for each trial type in input table, so,i%=line# in stim table
            
            recTrialOrder%[k%] := k%;  'Just randomize this after the loop
            'printlog("k is %d and recTrialOrder is now %d\n",k%,recTrialOrder%);'[0][k%]); 
            'determine how many S1 repeats to do this time:
            numS1perTrial% := recMinS1%+Floor(Rand(recVarS1%+1,0)); 'how it's done in GenTrialsSearch%().. not sure why it's not: Rand({recVarS1%,1})
            'printlog("numS1perTrial is %d for trial number %d\n",numS1perTrial%,k%);
            recTrialTerminalIndex%[k%]  := numS1perTrial%;  'not "+1" due to 0-based indexing *jao: i have no idea what this means!       
            
            'what kind of trial is this?  ***this is probably the only part that will change for SPACE!
            docase  
            case recIsGoNoGo% = 1 and recExpToRun% = recExpAMDiscButton% then 'gonogo
                if recTrialS1%[i%]<>recTrialS2%[i%] then 'case this bitch to separate up/down trials
                    responseTrial% := 1;  'trial is hit/miss (has terminal S2) --> up OR down
                    'printlog("this is a CHANGE trial, S1 = %d and S2 = %d\n",recTrialS1%[i%],recTrialS2%[i%]);
                else 'they're the same
                    responseTrial% := 0;  'trial is catch (no terminal S2?? ...DONT THINK THIS IS CORRECT) 
                    'printlog("this is a CATCH trial, S1 = %d and S2 = %d\n",recTrialS1%[i%],recTrialS2%[i%]);
                endif
                recTrialTerminalIsS2%[k%] := responseTrial%; 'wait, how does this work for up/down? 'I HAVE NO IDEA HOW THIS SHOULD WORK! HELP!     
            case recIsGoNoGo% = 0 and recExpToRun% = recExpAMDiscButton% then 'up/down forced choice
                docase
                case recTrialS2%[i%] < recTrialS1%[i%]  then 
                    'LO trial
                    'printlog("this is a DOWN trial, S1 = %d and S2 = %d\n",recTrialS1%[i%],recTrialS2%[i%]);
                    recTrialTerminalIsS2%[k%] := 2; 'S2-LO --> StimComplete in RecGoNoGoEng *jao
                case recTrialS2%[i%] > recTrialS1%[i%] then
                    'HI trial
                    'printlog("this is a UP trial, S1 = %d and S2 = %d\n",recTrialS1%[i%],recTrialS2%[i%]);
                    recTrialTerminalIsS2%[k%] := 1; 'S2-HI --> StimComplete in RecGoNoGoEng *jao
                case recTrialS2%[i%] = recTrialS1%[i%] then
                    'catch trial --> to be rewarded 50% of the time; trials used to determine HI/LO;UP/DOWN bias
                    ' printlog("this is a SAME trial, S1 = %d and S2 = %d\n",recTrialS1%[i%],recTrialS2%[i%]);
                endcase;
                'NOW DO SPACE TRIALS!
            case recIsGoNoGo% = 1 and recExpToRun% = recExpSpaceDisButton% then 'gonogo
                if recTrialS1Spkr%[i%]<>recTrialS2Spkr%[i%] then 'case this bitch to separate up/down trials
                    responseTrial% := 1;  'trial is hit/miss (has terminal S2) --> up OR down
                    'printlog("this is a CHANGE trial, S1 = %d and S2 = %d\n",recTrialS1%[i%],recTrialS2%[i%]);
                else 'they're the same
                    responseTrial% := 0;  'trial is catch 
                    'printlog("this is a CATCH trial, S1 = %d and S2 = %d\n",recTrialS1%[i%],recTrialS2%[i%]);
                endif
                recTrialTerminalIsS2%[k%] := responseTrial%; 'wait, how does this work for up/down? 'I HAVE NO IDEA HOW THIS SHOULD WORK! HELP!     
            case recIsGoNoGo% = 0 and recExpToRun% = recExpSpaceDisButton% then 'up/down forced choice
                docase
                case recTrialS2Spkr%[i%] < recTrialS1Spkr%[i%]  then 
                    'LO trial (Left or CounterClockwise)
                    'printlog("this is a DOWN trial, S1 = %d and S2 = %d\n",recTrialS1%[i%],recTrialS2%[i%]);
                    recTrialTerminalIsS2%[k%] := 2; 'S2-LO --> StimComplete in RecGoNoGoEng *jao
                case recTrialS2Spkr%[i%] > recTrialS1Spkr%[i%] then
                    'HI trial (Right or Clockwise)
                    'printlog("this is a UP trial, S1 = %d and S2 = %d\n",recTrialS1%[i%],recTrialS2%[i%]);
                    recTrialTerminalIsS2%[k%] := 1; 'S2-HI --> StimComplete in RecGoNoGoEng *jao
                case recTrialS2Spkr%[i%] = recTrialS1Spkr%[i%] then
                    'catch trial --> to be rewarded 50% of the time; trials used to determine HI/LO;UP/DOWN bias
                    'recTrialTerminalIsS2%[k%] := 0; 'is this right? works without it tho...???
                    ' printlog("this is a SAME trial, S1 = %d and S2 = %d\n",recTrialS1%[i%],recTrialS2%[i%]);
                endcase;
            else
                printlog("something is fucked. recIsGoNoGo% has not been set= %d or case recExpToRun% was not passed in \n",recIsGoNoGo%);
            endcase; 
            
            'fill the S1 information (for how ever many S1 repeats there are)
            for j% := 0 to numS1perTrial%-1 do
                recStimList%[j%][k%] := recTrialS1%[i%]; 'this is stimulus index, all stims considered "unique" (?)
                recSpeakerList%[j%][k%] := recTrialS1Spkr%[i%];  'And speaker
                'recDeltadBList[j%][k%] := recTrialS1DeltadB[i%];  'And dB 'this is the value from the input tables
                recDeltadBList[j%][k%] := recDeltadBLevel+Rand(dBrove%,0); 'this is the value from the GUI - use this instead! (different for each monkey)
                recPWAList%[j%][k%] := j%;  'this is PWA to play, just PWA in order
            next;
            
            'and now we're ready for the S2
            'Note that j% gets incremented one last time to trigger the "exit" of the loop, and thus is now
            'the correct index to use.  However, since this bothers the crap out of me, I'm explicitly setting it.
            j% := numS1perTrial%;  'because of zero-based indexing, the number of S1s is the index of the S2
            recStimList%[j%][k%] := recTrialS2%[i%];  'S2 stimulus for this trial
            recSpeakerList%[j%][k%] := recTrialS2Spkr%[i%]; 'S2 speaker
            'recDeltadBList[j%][k%] := recTrialS2DeltadB[i%];  'Delta dB (additional atten) for S2 stimuli, default stims will play at 65
            recDeltadBList[j%][k%] := recDeltadBLevel+Rand(dBrove%,0); 'value from GUI, use this intead (different for each monkey)
            recPWAList%[j%][k%] := j%;  'this is PWA to play, just play in order
            
            'And finally the number of unique stims - all stims are treated as unique (i.e. loaded into their own PWA) even if they're technically "not"
            recNUniqueStims%[k%] := j%+1;  'j% is index of final stimulus, so number of stims (all unique) is +1
            
            k% +=1; 'increment trial counter
        next; 'end loop (i) through trial types in stim file  
    next; 'end trialrep for 
    
    'Randomize the list order
    'printlog("recTrialOrder% before shuffling %d\n",recTrialOrder%);'[0][k%]);
    if recDoNotShuffle% = 0 then
        ShuffleList%(recTrialOrder%[0:nS2%]);
    endif;
    
    docase 'for printlogging..
    case recExpToRun% = recExpAMDiscButton% then
        printlog("AMDis trials generated and shuffled successfully! recTrialOrder = %d\n",recTrialOrder%);'[0][k%]);  
    case recExpToRun% = recExpSpaceDisButton% then    
        printlog("SpaceDis trials generated and shuffled successfully! recTrialOrder = %d\n",recTrialOrder%);'[0][k%]);  
    endcase
    
    return status%;
end
'===== End GenTrialsDis =====
'
'




'
'
'===== GenTrialsStereoDis =====
func GenTrialsStereoDis%()
    var status% := 1;
    var i%;
    var j%;
    var count% := 0;
    var rewardInt% := 5;
    var miniTrialOrder%[recTotalTrials%];
    var randNum := 0;
    var randInt%;
    var randInt2%;
    var rewardArray%[80];
    var rewardIndex%;
    
    ' ===== Create Trials =====
    recNTrials% := (recTotalTrials%*recStereoDisRepeatsPerStim%);  'Set global Ntrials

    for i% := 0 to recTotalTrials%-1 do    
        miniTrialOrder%[i%] := i%;  ' 1. populate miniTrialOrder%, etc.
        recTrialTerminalIndex%[i%] := 1;  'For this experiment, every trial has exactly one S1 and one S2, so zero-based terminal index is 1
        recPWAList%[0][i%] := 0;  'this is PWA to play, just use PWAs in order
        recPWAList%[1][i%] := 1;  '(recPWAList%[][] is a more meaningful variable for things like search where PWAs get pre-loaded and we bounce through them, we use it here for convenience)
        
        recStimList%[0][i%] := RecTrialS1%[i%];  '2. save values into recStimList, recSpeakerList, recDeltadBList
        recStimList%[1][i%] := RecTrialS2%[i%];  'and distractor versions as well
        recDistractorStimList%[1][i%] := recTrialDistractor%[i%][1];  'changed this to 2-D to accommodate GNG
        
        recSpeakerList%[0][i%] := RecTrialS1Spkr%[i%];
        recSpeakerList%[1][i%] := RecTrialS2Spkr%[i%];
        recDistractorSpeakerList%[0][i%] := recTrialDistractorSpkr%[i%][1];  'Should not be read, but just in case needs to be a legal speaker
        recDistractorSpeakerList%[1][i%] := recTrialDistractorSpkr%[i%][1];  'changed this to 2-D to accommodate GNG
    
        recDeltadBList[0][i%] := recTrialS1DeltadB[i%];
        recDeltadBList[1][i%] := recTrialS2DeltadB[i%];
        recDistractorDeltadBList[1][i%] := recTrialDistractorDeltadB[i%][1];  'changed this to 2-D to accommodate GNG
        
        docase
        case recTrialMF[RecTrialS1%[i%]] > recTrialMF[RecTrialS2%[i%]]  then 
            'LO trial
            recTrialTerminalIsS2%[i%] := 2; 'S2-LO --> use in StimComplete in RecGoNoGoEng 
        case recTrialMF[RecTrialS1%[i%]] < recTrialMF[RecTrialS2%[i%]] then
            'HI trial
            recTrialTerminalIsS2%[i%] := 1; 'S2-HI --> use in StimComplete in RecGoNoGoEng 
        case recTrialS2%[i%] = recTrialS1%[i%] or recTrialMF[RecTrialS1%[i%]] = recTrialMF[RecTrialS2%[i%]] then
            'catch trial
            recTrialTerminalIsS2%[i%] := 0;  'S2 = S1
        endcase;
        
    next;

    for i% := 0 to recStereoDisRepeatsPerStim%-1 do '3. Fill recTrialOrder. go through each RepeatPerStim and...
        
        if recDoNotShuffle% = 0 then
            ShuffleList%(miniTrialOrder%);      'shuffle the miniTrialOrder
        endif;
    
        for j% := 0 to recTotalTrials%-1 do   'load this "chunk" of the order into the RecTrialOrder
            recTrialOrder%[count%] := miniTrialOrder%[j%];
            count% += 1;                    'increment count to the next spot in RecTrialOrder to fill
        next;
    next;
        
    return status%;
end
'===== End GenTrialsStereoDis =====
'
'


'
'
'===== GenTrialsStereoDisGNG =====
func GenTrialsStereoDisGNG%()
    var status% := 1;
    var i%;
    var j%;
    var count% := 0;
    var rewardInt% := 5;
    var miniTrialOrder%[recTotalTrials%];
    var randNum := 0;
    var randInt%;
    var randInt2%;
    var rewardArray%[80];
    var rewardIndex%;
    
    ' ===== Create Trials =====
    recNTrials% := (recTotalTrials%*recStereoDisRepeatsPerStim%);  'Set global Ntrials

    for i% := 0 to recTotalTrials%-1 do    
        miniTrialOrder%[i%] := i%;  ' 1. populate miniTrialOrder%, etc.
        recTrialTerminalIndex%[i%] := recTrialNumS1ns%[i%];  'For this experiment, there are a variable number of S1.ns, if number of S1.ns is 2, then third stimulus is terminal (index = 2)
        
        for j% := 0 to recTrialTerminalIndex%[i%] do
        
            recPWAList%[j%][i%] := j%;  'this is PWA to play, just use PWAs in order
            '(recPWAList%[][] is a more meaningful variable for things like search where PWAs get pre-loaded and we bounce through them, we use it here for convenience)
            
            '2. save values into rec2StimList, rec2SpeakerList, rec2DeltadBList
            if j% < recTrialTerminalIndex%[i%] then
                recStimList%[j%][i%] := RecTrialS1%[i%];  'Stim will be S1 except on terminal index
                recSpeakerList%[j%][i%] := RecTrialS1Spkr%[i%];  'Same thing for speaker
                recDeltadBList[j%][i%] := recTrialS1DeltadB[i%];  'Same thing for delta dB
            else
                recStimList%[j%][i%] := RecTrialS2%[i%];  'Stim will be S2 on terminal index
                recSpeakerList%[j%][i%] := RecTrialS2Spkr%[i%];  'Same thing for speaker
                recDeltadBList[j%][i%] := recTrialS2DeltadB[i%];  'Same thing for delta dB
            endif;
            
            recDistractorStimList%[j%][i%] := recTrialDistractor%[i%][j%];  'changed this to 2-D to accommodate GNG
            recDistractorSpeakerList%[j%][i%] := recTrialDistractorSpkr%[i%][j%];  'changed this to 2-D to accommodate GNG
            recDistractorDeltadBList[j%][i%] := recTrialDistractorDeltadB[i%][j%];  'changed this to 2-D to accommodate GNG
            
        next;
        
        docase
        case recTrialMF[RecTrialS1%[i%]] > recTrialMF[RecTrialS2%[i%]]  then 
            'LO trial
            recTrialTerminalIsS2%[i%] := 2; 'S2-LO --> use in StimComplete in RecGoNoGoEng 
        case recTrialMF[RecTrialS1%[i%]] < recTrialMF[RecTrialS2%[i%]] then
            'HI trial
            recTrialTerminalIsS2%[i%] := 1; 'S2-HI --> use in StimComplete in RecGoNoGoEng 
        case recTrialS2%[i%] = recTrialS1%[i%] then  'if it is the same stimulus it is the same MF
            'catch trial
            recTrialTerminalIsS2%[i%] := 0;  'S2 = S1
        endcase;
            
    next;

    for i% := 0 to recStereoDisRepeatsPerStim%-1 do '3. Fill recTrialOrder. go through each RepeatPerStim and...
        
        if recDoNotShuffle% = 0 then
            ShuffleList%(miniTrialOrder%);      'shuffle the miniTrialOrder
        endif;
    
        for j% := 0 to recTotalTrials%-1 do   'load this "chunk" of the order into the RecTrialOrder
            recTrialOrder%[count%] := miniTrialOrder%[j%];
            count% += 1;                    'increment count to the next spot in RecTrialOrder to fill
        next;
    next;
        
    return status%;
end
'===== End GenTrialsStereoDisGNG =====
'
'


'
'
'===== GenTrialsLongTone =====
func GenTrialsLongTone%()
    var status% := 1;
    var i%;
    var j%;
    var count%;
    
    'Hard coding durations to be 0.1, 1, 10, 100, now using CONSTs to allow us to make arrays ahead of time to hold many of these
    LongDurs[0] := LongDur0 - 0.020;
    LongDurs[1] := LongDur1 - 0.020;
    LongDurs[2] := LongDur2 - 0.020;
    LongDurs[3] := LongDur3 - 0.020;
    LongDurs[4] := recLongToneSilentDur;
    
    'Note that the noise is hardcoded in PrepareLongNoise to be Gaussian as that is what is used elsewhere
    
    recNTrials% := recLongToneNRepeats%*nLongTones%;
    
    if recNTrials% > recMaxTrial% then
        message("The maximum number of trials is " + Str$(recMaxTrial%) + " but " + Str$(recNTrials%) + " trials were requested!");
        return 0;
    endif;
    
    'for i% := 0 to nLongTones%-1 do
    '    for j% := 0 to recLongToneNRepeats%-1 do
    '        'recLongToneDurationList[count%] := LongDurs[i%];  
    '        recLongToneDurationIndex%[count%] := i%;
    '        count% += 1;
    '    next
    'next
    '
    'if recDoNotShuffle% = 0 then
    '    'ShuffleList(recLongToneDurationList[0:recNTrials%]);  'create a randpermed version of recLongToneDurationList (only valid indices)
    '    ShuffleList%(recLongToneDurationIndex%[0:recNTrials%]);  'create a randpermed version of recLongToneDurationIndex% (only valid indices)   
    'endif;
    
    'Use Usrey randomization to get blocked random - note that the values going into recLongToneDurationList[] are not correct and will be overwritten - just need a variable the right size here
    GetRepeatedParameterProgression%(nLongTones%, recLongToneNRepeats%, recLongToneDurationList[], recLongToneDurationIndex%[], 1, nLongTones%, 0, 1-recDoNotShuffle%);
    
    
    for i% := 0 to recNTrials%-1 do
        recLongToneDurationList[i%] := LongDurs[recLongToneDurationIndex%[i%]];
    next
    
    'Sanity check passed!
    'printlog("Long tone durations are: %f\n",recLongToneDurationList[]);
    'halt;
    
    return status%;
end
'===== End GenTrialsLongTone =====
'
'





'
'
'===== ConvertmLToSeconds =====
func ConvertmLToSeconds(mL)
    var sec;
    if mL <= 0.417 then
        sec := (mL + 0.072)/13; 'The relationships in this function have been painstakingly calculated for the
    else                        'Recanzone juicer on the left-hand booth.  The relationship between TDT reward time
        sec := (mL - 0.24)/4.7; 'and output is best described by two linear functions which intersect at a delivery
    endif                       'of 0.417 mL (which corresponds to 0.0376 seconds of requested reward.
    return sec;                 'If this script is used on another booth or the juicer is changed, the function will 
end                             'need to be recalculated.


'===== RecLEDReminderDialog =====

'A dialog for the Cueing experiment

func RecLEDReminderDialog%()
    
    var i%;
    var status% := 0;
    var exptext$;
    var expcolor$;
    var shite%;

docase
    case recExpToRun% = recExpAMDiscButton% then
        exptext$ := "AMDis";
        expcolor$ := "RED";
    case recExpToRun% = recExpSpaceDisButton% then    
        exptext$ := "Space Dis";
        expcolor$ := "YELLOW";
    case recExpToRun% = recExpSearchButton% then
        exptext$ := "Search";
        expcolor$ := "GREEN";
    case recExpToRun% = recExpFRAButton% then
        exptext$ := "FRA";
        expcolor$ := "GREEN";
    case recExpToRun% = recExpJoyTrnButton% then 
        exptext$ := "JoyTrain";
        expcolor$ := "RED";
    case recExpToRun% = recExpCueingButton% then
        exptext$ := "Cueing";
        expcolor$ := "RED or YELLOW";
    case recExpToRun% = recExpAudiogramButton% then 
        exptext$ := "Audiogram";
        expcolor$ := "GREEN";
endcase

    ' Generate the dialog
    DlgCreate("LED Switch Reminder!");', 25, 10);
    DlgText("You are running " + exptext$ + "!", 3,1);
    DlgText("LED color is " + expcolor$, 5,2);
    DlgText("***check the speaker cable too! ***",1,4);

    ' Show the dialog. 
    i%:=DlgShow(shite%);
    
    ' If user hit OK then return 1. 
	if i% = 1 then
        status% := 1;
    else
        status% := 1; 'force this to OK anyway
    endif
    
	return status%;
   
end;

'===== End RecLEDReminderDialog =====
'
'



'===== GetDrivePath$ =====
' moved to filesystemvars.s2s 12-11-2018 djs
