'RecRoom - the outer shell script which allows you to run the entire gambit of Recanzone lab CED experiments
'Barring a fatal error, once this script is started the user will be redirected to the experiment selection dialog
'after every experiment is complete; spike shapes definitions will carry across experiments; ultimate closure of
'this script will be done from the experiment selection dialog

'this is a comment

'
'
'Begin #include Files which do not depend on global variables
'================================================================================================

' Unless noted #include files do not execute code and are not order-dependent
#include "LogUtilities.s2s"  'for non-time-specific logging, time-specific logging included in RECGEN
#include "matlab.s2s"
#include "recfuncs.s2s"
#include "RegistryUtils.s2s"
#include "extract_space_functions.s2s"
#include "filesystemvars.s2s"
#include "triallistgen.s2s"


'================================================================================================
'End #include Files
'
'


'
'
'Begin Global Variables
'================================================================================================

'Variables which will be used throughout the RecRoom Suite
if 1 then  'this IF is just to fold away the variables

'Debugging variables
var recMatlabIsPresent%:=1;         'Is Matlab present? Default to 1 (yes), default will apply after debug period
var recTDTIsPresent%:=1;            'Is TDT present? Default to 1 (yes), default will apply after debug period
var recCEDIsPresent%:=1;            'Is CED 1401 present? Default to 1 (yes), default will apply after debug period
var matlabOpenSuccess%:=-1;         'Was Matlab opened successfully?  Default to -1 (no matlab open)
var recCalibIsPresent%:=1;          'Is the calibration file present?  Default to 1 (yes), default will apply after debug period    
var recDebug%:=1;                   'Write debug log statements? 
var recSoundRecording%;             'Record sound output?
var dummyVar%;                      'For placeholder GUIs, just lets me have a checkbox setting SOMETHING
var recUseLiteMemory%;

    
'Experiment variables
var recCurrentlySampling%:=0;       'If 1, indicates that sampling is currently already started - don't start it again!
var recMonkPrefix$;                 'String to hold monkey prefix, used in naming files - bit of a misnomer, will be used as complete file name    
var blockTag$;                      'filename suffix used to denote new experiments or blocks (a,b,c,d,...) - added to MonkPrefix and Date to create filename
const recPrintLog$ := "recPrintLog"; 'an autosave printlog for BSOD debugging and whatever else might be useful. date & time printed on each call

    
'Determine which drive has the CED stuff on it - it's different on different machines
var recDrivePath$;
    recDrivePath$ := GetDrivePath$();
    printlog("Drive path is %s\n",recDrivePath$);
if recDrivePath$ = "quit" then
    halt;
endif;    
    
var recFileSaveLoc$;    
recFileSaveLoc$  := recDrivePath$ + "Data\\";       'Have to set this...  
var recCalibLoc$;    
recCalibLoc$ := recDrivePath$ + "Data\\Calib\\";           'Have to set this too...
const recFileSaveLocKershaw$  := "E:\\Core Grant\\reclab2017\\testTextFiles\\";       'Have to set this...  
const recCalibLocKershaw$ := "E:\\Core Grant\\reclab2017\\testTextFiles\\";           'Have to set this too...   
var recNElectrodes%:=-1;            'Number of electrodes in use, determines number of channels recorded, start invalid on first run
var recNBAKs%;                      'Number of BAKs to record from, event channels
var recExpToRun%;                   'Integer holding which experiment to run - corresponds to dialog button value
var recLastExpRun%;                 'Holds last value of recExpToRun to suppress LEDReminderDialog in certain cases    
var recReadyToQuit%;                'Set this variable to 1 to escape the experiment loop
var recDeltadBLevel;                'Set dB level --> was "recdBLevel", changed to deltadB (atten from default of 65) to work with recDeltadBList
var recActive%;                     'Is experiment active or passive
var recFixLED%;                     'Use fixation LED?
var recMatGenStim%;                 'If 1, stim are to be generated by Matlab, if 0, read from file
var recUse2PWAs%:=0;                'In general, do not use two PWAs, some experiments use two
var recDoRove%:=0;                  'Do we rove the stimuli?
var recRovedB:=0;                   'How much roving, in dB +/- (not range, but +/-recRovedB)
var recSearchLoaded%;               'Allows PWAs to be loaded only once for SEARCH, since each trial is identical
var trialsOK%;                      'If 1, successfully loaded trials file
var stimOK%;                        'If 1, successfully loaded stim or stim/cal file
var calibOK%;                       'If 1, successfully loaded calibration file
var recPlayRateHzDefault:=100000;   'Set default stimulus play rate to 100 kHz  
var recPlayRateHzCurrent;    
const recMaxStimLengthSec:=10.0;    'Set maximum length of each individual stimulus, in seconds (was 4.0, may need to be 10 for DMR, will that work?)
var recThisStimLengthSec;           'Let's allow the user to make this smaller, which will make loads MUCH faster    
const recDAC0% := 0;                'Set output channel to DAC 0, don't let this change
const recDAC1% := 1;    
var recExptText$ := "";             'text that describes this expt, for a SampleText
var recRunTimeCall%;                'will be 1 if dialog box is called during run time
var recWhichDialogCalled%;          'lets us know which dialog to call   
var recLogThisResult% := 1;         'by default, log every result, Audiogram (perhaps other exps later) will update this on a trial-by-trial basis and only log what is requested
    
'Speaker variables
const recMaxSpeaker%:=31;           'Maximum number of simultaneous speakers (31 is not currently implemented)
var recS1Speaker%;                  'Speaker on which S1 plays
var recS2Speaker%;                  'Speaker on which S2 plays
var recNSpeakers%;                  'How many speakers are there in the array (usually 15 or 16)  
var arrayPA4ID%;                    'What is the PA4 ID for the PA4 connected to the array?    
var standalonePA4ID%;               'What is the PA4 ID for the PA4 connected to the standalone speaker?    
    
'Trial list generation variables
const recMaxStim%:=5000;            'Maximum number of stimuli, 1000 is probably overlarge, nope not if you do the "designate each AM individually for trial file ease"
const recMaxStimPerTrial%:=30;      'Holds the max number of stimuli per trial, this can exceed recMaxPWA% but only if there are at most recMaxPWA% unique stimuli
const recMaxPWA%:=10;               'Holds the maximum number of Play Wave Areas *don't change this! *jao 
const recMaxParallelPWA%:=2;        'Holds the maximum number of parallel PWAs    
const recMaxTrial%:=5000;           'Maximum number of trial TYPES, 5000 is probably overlarge again, but there is the problem of long Search stretches
const recMaxDistractor%:=6;         'Maximum number of distractors (= max number of S1.ns in distractor expt.), currently index 0 will remain empty as the true S1 has no distractor    
var recTotalStim%;                  'Total number of stimuli specified in Stim or Stim/Cal file
var recTotalDistractorStim%;        'Total number of stimuli specified in distractor version of Stim/Cal file    
var recMinS1%;                      'Minimum number of S1s
var recVarS1%;                      'Variable number of S1s
var recPropCatch;                   'Proportion of catch trials
var recTrialLoadLoc$[recMaxStim%];            'Disk location of files to load, stim/cal file
var recTrialLoadLocDistractor$[recMaxStim%];  'Disk location of files to load, stim/cal file, distractors
var recTrialLoadName$[recMaxStim%];           'Name of loaded files, from stim/cal file, with path and extension stripped  
var recTrialStimDur[recMaxStim%];             'Duration of each stimulus, in ms, stim/cal OR stim file
var recTrialDurDistractor[recMaxStim%];       'Duration of each stimulus, in ms, stim/cal OR stim file, distractors
var recTrialNumS1ns%[recMaxStim%];            'Number of S1.n stimuli on each trial, used for two-speaker distractor scenarios    
var recTrialMF[recMaxStim%];                  'Modulation frequency of each stimulus    
var recTrialMFDistractor[recMaxStim%];        'Modulation frequency of each stimulus, distractors
var recTrialMF2[recMaxStim%];                 'Modulation frequency of second plateau of each stimulus, AM/FM stim only    
var recTrialSweepGap[recMaxStim%];            'Sweep-Gap duration, in ms, for AM/FM stim only    
var recTrialSweepIntensity[recMaxStim%];      'Sweep Intensity (0-1), for AM/FM stim only
var recTrialCarrier$[recMaxStim%];            'Carrier type of each stimulus
var recTrialCarrierDistractor$[recMaxStim%];  'Carrier type of each stimulus, distractors 
var recTrialStimCal[recMaxStim%][recMaxSpeaker%];    'A calibration matrix, used for stim/cal when loading
var recTrialStimCalDistractor[recMaxStim%][recMaxSpeaker%];    'A calibration matrix, used for stim/cal when loading, distractors
var recTrialGenLowpassHz[recMaxStim%];               'A list of lowpass values - if -1, no lowpass, same as highpass means tone
var recTrialGenHighpassHz[recMaxStim%];              'Same as above, highpass
var recTrialGenIsSweep[recMaxStim%];                 'If 1, Lo/Hi Hz values will correspond to FM sweep instead of BP noise limits, changed long-time int variable to float to accommodate reversing FM tones
var recTrialGenAMFreqHz[recMaxStim%];                'A list of AM frequency values, if 0 no AM
var recTrialGenAMDepthPct[recMaxStim%];              'A list of AM depth values in percent, if 0 no depth
var recTrialGenAMPhaseDeg[recMaxStim%];              'A list of AM phases, 0 = AM starts low, 90 = AM starts middle and rising, 180 = AM starts high, 270 = AM starts middle, falling
var recTrialGenTonePhaseDeg[recMaxStim%];            'A list of tone phases, 0 = tone starts middle, rising (sine phase), 90 = tone starts high (cosine phase), note different than AM phase, only used for tone, not noise
var recTrialGenGauss%[recMaxStim%];                  'If 1 create Gaussian noise, if 0 create uniform noise
var recTrialGenRampMS[recMaxStim%];                  'Duration in ms of front/back ramp, ramp is 1-Cos^2
var recTrialGenSeed%[recMaxStim%];                   'Seed for random number generator, 0 = unspecified, will make own random number
                                                         'Please note that the concept of using the RNG to get a seed for the RNG is hilarious, but not redundant in this case.
var recStimPresent%[recMaxStim%];                    'A list of stimuli present, so we can ensure there are no stimuli requested that aren't defined      
var recStimSetDiff%[recMaxStim%];                    'To hold any stimuli that are not defined, is way oversized   
var recStimSetDiff2%[recMaxStim%];                   'To hold any stimuli that are not defined, is way oversized, #2
var nd%, nd2%;                                       'To hold number of stimuli that are not defined    
    
    
var recGeneratedAtten[recMaxPWA%];  'for calibration of generated stims  
    
var recTrialS1%[recMaxTrial%];                'Index corresponding to S1 stimulus (index to recTrialLoadLoc$ or recTrialGen...)
var recTrialS2%[recMaxTrial%];                'Index corresponding to S2 stimulus
var recTrialS1Spkr%[recMaxTrial%];            'Index corresponding to S1 speaker
var recTrialS2Spkr%[recMaxTrial%];            'Index corresponding to S2 speaker
var recTrialS1DeltadB[recMaxTrial%];          'Allows a single trial's S1 to be different from default intensity
var recTrialS2DeltadB[recMaxTrial%];          'Allows a single trial's S2 to be different from default intensity   
var recTrialDistractor%[recMaxTrial%][recMaxDistractor%];        'Index corresponding to distractor stimulus 
var recTrialDistractorSpkr%[recMaxTrial%][recMaxDistractor%];    'Index corresponding to distractor speaker
var recTrialDistractorDeltadB[recMaxTrial%][recMaxDistractor%];  'Allows a single trial's distractor to be different from default intensity     
    
var recPlayPoints%;                 'Holds the number of points to play for each stimulus    
var recPointsPlayed%;               'Allows us to stop the sound once the stimulus is over and the PWA is spitting out zeros    
   
    
'Trial list variables
var recPWAList%[recMaxStimPerTrial%][recMaxTrial%];     'Holds indices to which PWA to use on each trial, and therefore also indexes recStimList%[][]    
var recStimList%[recMaxStimPerTrial%][recMaxTrial%];    'A list of unique stim/speaker combos on each trial
var recTrialTerminalIndex%[recMaxTrial%];               'For each trial, holds indices to which row of recPWAList%[][] holds the final stimulus
var recTrialTerminalIsS2%[recMaxTrial%];                'For each trial, if 1 trial is target (Hit/miss), if 0 trial is catch (CR/FA)
var recTotalTrials%;                                    'Holds the number of trials in the trials file, will not necessarily be the same as recNTrials% due to repeats    
var recNTrials%;                                        'Holds the total number of trials
var recNUniqueStims%[recMaxTrial%];                     'Holds the number of unique stims on each trial, for loading PWAs
var recSpeakerList%[recMaxStimPerTrial%][recMaxTrial%];          'Same as recStimList%[][], but holds speaker number
'var recAttenList%[recMaxStimPerTrial%][recMaxTrial%];   'Same as recStimList%[][], but holds CALIBRATING attenuation FROM A FILE, currently disabled
var recDeltadBList[recMaxStimPerTrial%][recMaxTrial%];  'Same as recPWAList%[][], but holds TRIAL-BASED attenuation (experimentally relevant)   
var recTrialOrder%[recMaxTrial%];                       'Holds order in which trials should be presented
var recCurrentTrial%;                                   'Holds current trial in ordinal sequence, will be used to index recTrialOrder%[]    
var recCurrRandomSeed%[recMaxPWA%];                     'Holds the random seeds used to generate each trial, only done on a trial-by-trial basis    
var recStimCount%;                                      'Counter for current recMaxStimPerTrial%   
var recLongToneDurationList[recMaxTrial%];              'Holds the duration of each long tone
var recLongToneDurationIndex%[recMaxTrial%];            'Holds the index of the duration, useful for triggering correct PWA, when necessary 
    
'FRA-specific trial list variables
var rec2StimList%[recMaxTrial%][2]; 'first dimension: trial number, second dimension: DAC0 stimuli, DAC1 stimuli)    
var rec2SpeakerList%[recMaxTrial%][2]; 'same format as 2stimlist
var rec2DeltadBList[recMaxTrial%][2];
var recCharReward%[recMaxTrial%];    
    
    
'Stereo Distractor specific trial list variables
var recDistractorStimList%[recMaxStimPerTrial%][recMaxTrial%];  'to accomodate StereoDis GNG, we hypothetically allow multiple S1s, so first dimension is maxStimPerTrial
var recDistractorSpeakerList%[recMaxStimPerTrial%][recMaxTrial%];
var recDistractorDeltadBList[recMaxStimPerTrial%][recMaxTrial%];  
var recStereoDisGeneratedAttenList[recMaxStimPerTrial%][recMaxPWA%];
var recStereoDisSeedList%[recMaxStimPerTrial%][recMaxPWA%];    
    
    
'Timing Parameters
var recMinOnsetDelay;               'Minimum time between monkey's lever press and stimulus onset (or, time between *trials* for non-Char. passive), seconds
var recVarOnsetDelay;               'Variable time added to recMinOnsetDelay, seconds
var recISI;                         'Interstimulus interval (including time between stimuli in Characterization, a *trial* in Char. ends at the reward), seconds
var recISIVariable;                 'Variable time added to interstimulus interval, seconds
var recTrialInitWindow;             'Allowable time for monkey to initiate trial before TO, seconds
var recResponseWindow;              'Allowable time for monkey to respond to target, seconds
var recMinJoystickRespTime;         'Minimum time required for a joystick move to be considered real, seconds

'Time-Outs
var recLazyMonkeyTO;                'Duration of time-out for not working, seconds
var recMissTO;                      'Duration of time-out for miss, seconds
var recFalseAlarmTO;                'Duration of time-out for false alarms, seconds
var recInterruptTO;
var recMissRepeats%;                'Whether to repeat missed trials '*jao
var recMissRepeatsMax%;             'Max # times to repeat missed trials
var recMissRepeatsCounter% := 0;    'Initialize consective miss repeat counter to 0 (this might be useful for staircase training later)
    
'Joystick variables    
var recUseJoystick%;                'Do we use the joystick, 1 = yes, 0 = no
var recIsGoNoGo%;                   'Is experiment go/no-go, 1 = yes, 0 = no, forced choice (two alternative)    
var recTrialInitPosition%:=1;       'Joystick trial initiation position; 0/1/2/3/4/5/6 = center/down/up/right/left/x/y, default to down
var recTrialResponsePosition1%;     'Joystick position of response 1, same values as init above
var recTrialResponsePosition2%:=7;  'Joystick position of response 2, 0/1/2/3/4/5/6/7, where 7 = no second response position, default to no second response position
var recDoIncrements%;   
var recDoJoyTrain%; '*jao
var recCheckGNGSandbox%;            'If StereoDis or OneStimDiscrim are active, make sure that any subsequent Joystick/Lever call respects that GNG/FC selection  
    
'Reward durations, etc.
var recTrainingRewardDur;           'Duration of training reward, seconds
var recHitRewardDur;                'Duration of hit reward, seconds
var recCRRewardDur;                 'Duration of correct rejection reward, seconds
'var recMaxHitRewardDur;             'Max duration of hit reward, seconds
'var recMaxCRRewardDur;              'Max duration of CR reward, seconds
var recInitRewardmL;                'Volume of init training reward, milliliters
var recHoldRewardmL;                'Volume of "hold" training reward, milliliters
var recHitRewardmL;                 'Volume of hit reward, milliliters
var recCRRewardmL;                  'Volume of correct rejection reward, milliliters
var recMaxHitRewardmL;              'Max volume of hit reward, milliliters
var recMaxCRRewardmL;               'Max volume of CR reward, milliliters
var recRewardMs%;                   'Temp variable, used for duration of any reward, conversion to milliseconds
var recRewardMs;                    'float version    
'var recHitRewardInc;                'Reward increment per hit, seconds (both hit and CR rewards, will stop at max, will reset on miss/FA)
'var recS1RewardInc;                 'Reward increment per S1 stimulus, seconds (additional reward on each trial per S1)
var recHitRewardIncmL;              'Reward increment per hit, milliliters (both hit and CR rewards, will stop at max, will reset on miss/FA)
var recS1RewardIncmL;               'Reward increment per S1 stimulus, milliliters (additional reward on each trial per S1)
var lastHitReward; 'holds last hit reward given so that it can be incremented
var thisHitReward; 'initialize to base level
var recRewardType%;                 '0 = juice, 1 = Stimulation, 2 = cycle through on error, 3 = select via probability on error
var recJuiceWaterBooth%;            '0 = water/small booth, 1 = juice/small booth, 2 = water/big booth, 3 = juice/big booth
var recInitialJuiceVolumemL;        'How many mL did we start with in the bottle?
var recCurrentJuiceVolumemL;        'How many mL do we believe is in the bottle now?
var recCurrentRewardType%;          'Type of reward this trial, 0 = juice, 1 = stim, 2 = both
var recPctJuice%;                   'percentage of time variable reward will be juice    
var recPctStimulation%;             'percentage of time variable reward will be a Stimulation    
var recJuiceToStimDelay%;           'ms delay between (nominal) juice reward and stimulation reward, can attempt to deliver both at "same" time
var recChangeRewardType% := 1;      'Do we change reward type before this trial?  Do change on first trial, or after error    
var recTurnOffReward%;              'Do we turn off the reward?    
    
'Interrupts
var recContinueSoundOnS1Interrupt%; 'If 0, stop sound on S1 interrupt, otherwise continue
var recContinueSoundOnS2Interrupt%; 'If 0, stop sound on S2 interrupt, otherwise continue
    
'House Light
var recHouseLight%;                 'If 0, no house light. If 1, house light all expt. If 2 house light turns off during any timeout    
    
'Utility variables
var iglob%;                         'General looping variable, global scope
var fhglob%;                        'General file handle variable, global scope
var tempglob%;                      'General temporary variable, global scope 
var statement$;                     'Holds statments to evaluate in Matlab
var result%;
var type1401%;  'the type of the 1401 detected: 0=standard 1401, 1=1401plus, 2=micro1401, 3=Power1401, 4=Micro1401 mk II, 5=Power1401 mk II, 6=Micro1401-3, 7=Power1401-3 and 3A, 8=Micro1401-4
var recXYWindowView%;              ' View variable for XY window
var recDataWindowView%;            ' View variable for data window    
    
' channel numbers ***and window handles***??
' there are 1-32 max # electrodes on our probe, so reserve these channel numbers for electrodes and don't use them elsewhere
' as far as I can tell, channel numbers are arbitrary (as opposed to Ports#s), so use channel #s 40 and up for non-electrodes
const configEyeXChannel% := 28;       ' Channel for eye tracking (X, not yet used)
const configEyeYChannel% := 29;       ' Channel for eye tracking (Y, not yet used)
const recLeverChannel% := 33;         ' Channel for behavioral lever recording
const configJoyXChannel% := 34;       ' Channel for JoystickX
const configJoyYChannel% := 35;       ' Channel for JoystickY
const audioOutputCopyChannel% := 36;  ' Audio output should be tee'd and input to ADC port 2 
const recBAK1Channel% := 37;             ' First BAK
const recBAK2Channel% := 38;             ' Second BAK

'electrode channel, port & number variables (because you cant make a const array)
const maxTrodes% := 21; 'Can record 24 ADCs, but three are taken by JoyX/JoyY/AudioCopy
var recTrodePosition%[maxTrodes%];
var recTrodeChannel%[maxTrodes%];
var recTrodePort%[maxTrodes%];
var recWMChannel%[maxTrodes%];
'var maxTrodesThisExpt% := 4;  'if we are stimulating, we need two ports to monitor the stimulation, this reduces the number of ports available for electrodes

' ports
const recLeverPort% := 1;    'Event port
const recBAK1Port% := 0;        'Event port
const recBAK2Port% := 1;        'Event port  --  Note that recLeverPort% and BAK2Port conflict for now.  It is anticipated that there should not be recording+lever until late 2020
const configJoyXPort% := 0;  'A2D port 
const configJoyYPort% := 1;  'A2D port
'const configEyeXPort% := 2;  'A2D port  'not yet implemented
'const configEyeYPort% := 3;  'A2D port

' memory channels
var recMemChanLeverDebounce%;

' For Joystick
var joystickXOffset; 'use registry  
var joystickYOffset;
var joyview%;
var joyThreshChannel%[8];
var joydatachan%;
var LastPos%;
var JoystickReadOnce%;
var LeverCodes%[4]; 
var XPos%;
var YPos%;
var XTime;
var YTime;
var inOrigin%;
var RespDevice%;
var inTrialInit%;
var inResponse1%;
var inResponse2%;
var TrialResponse%;
var ResponseTime;
var OffAxis%;
var XJoy;
var YJoy;
var doIncUp%;
var doIncDown%;
var doIncLeft%;
var doIncRight%;
var doIncTrialInit%[4];  'indicates which channels to increment on succesful trial init
var doDecTrialInit%[4];  'indicates which channels to decrement on failed trial init
var doIncHit%[4];  'indicates which channels to increment on succesful hit
var doIncCR%[4];  'indicates which channels to increment on succesful CR
var doDecNoRespS2H%[4];  'indicates which channels to decrement on NR to S2H (no decrement on resp to S2L)
var doDecNoRespS2L%[4];  'indicates which channels to decrement on NR to S2L (no decrement on resp to S2H)    
    
    
var SecPerSample;                          '     
var startingNewExpt%;  'only used with joystick, marks beginning of experiment so that joystick events in the past are "forgotten"    
    
var recLeverState%;
var recLeverTime;   'this is the time of the most recent lever EVENT - one that we are going to record as a hit, etc.
var recLastLever;   'this is the time of the most recent lever change - whether we plan to record it or not
var recPreciseTrialTime;
var recLeverCodes%[4];    
var doBallistic%:=0;   'Are we doing ballistic trials?  (GNG only, no release of lever after nontarg trials)
var ballisticOn%:=0;   'Allows ballistic to be set on/off on a trial-by-trial basis, only if doBallistic% is 1 
    
endif;
'================================================================================================
'End Global Variables
'
'




'
'
'Begin #include Files which DO depend on global variables
'================================================================================================

#include "RecJoystickFuncs.s2s"
#include "RecRoomDialogs.s2s"  'the various dialogs have become far, far too bulky and we have 
                               'got to move them out; it will hopefully be far easier to find and
                               'deal with dialog stuff in one script and with RecRoom stuff in
                               'another script - how do you find stuff in 11000+ lines of code???


'================================================================================================
'End #include Files that DO depend on global variables
'
'







'
'
'Begin Code Execution
'================================================================================================



'Run initial dialog to determine presence of Matlab/TDT/1401
'This dialog will be disabled once testing is complete, but the remainder of calls below it should remain
if RecDebugDialog%() <> 1 then   
    LogError("NoState", "RecDebugDialog% was cancelled!");
    halt;
endif;

'Open RecLog, use "Kershaw" location (now "Seager", but directory is the same) in lobby, RecLab location in RecLab
'(Minor Note: This used to happen before the RecDebugDialog, but now comes after since RecDebug% isn't filled yet)
if recDebug% = 2 then
    recLog% := FileOpen(recFileSaveLocKershaw$+recPrintLog$+".txt",8,3); 'open recLog, create if DNE (first time called)
    printlog("RecLog location is %s\n",recFileSaveLocKershaw$+recPrintLog$+".txt");
else
    recLog% := FileOpen(recFileSaveLoc$+recPrintLog$+".txt",8,3); 'open recLog, create if DNE (first time called)
    printlog("RecLog location is %s\n",recFileSaveLoc$+recPrintLog$+".txt");
endif;
view(recLog%).print("\nrunning RecRoom"+Date$(2,2,3,3,"-")+" "+Time$(1,3)+"\n");


'After the initial Debug dialog (where we allow setting of the longest long noise/tone now), set various MaxPoint values based on the sampling rate
'const recMaxPoints% := recPlayRateHzDefault*recMaxStimLengthSec;  'Holds the maximum number of points in a stimulus 
const recMaxPoints% := recPlayRateHzDefault*recThisStimLengthSec;  'Holds the maximum number of points in a stimulus
'const recMaxLongNoiseBPPoints% := recPlayRateHzDefault*100;
'const recMaxLongNoisePoints% := recPlayRateHzDefault;   'Not doing multiplication by seconds because seconds is by definition 1. (??)
const LongPoints0% := LongDur0*recPlayRateHzDefault;
const LongPoints1% := LongDur1*recPlayRateHzDefault;
const LongPoints2% := LongDur2*recPlayRateHzDefault;
const LongPoints3% := LongDur3*recPlayRateHzDefault;
var recStimTransfer%[recMaxPoints%]; 'Will be used for loading, transferring stims
var rec2StimTransfer%[recMaxPoints%][2]; 'Will be used for loading, transferring stims (2-dim PWA!!)    
'var recStimTransferLongNoiseOW%[recMaxLongNoisePoints%];  
'var recStimTransferLongNoiseBP%[recMaxLongNoiseBPPoints%];    
var recStimTransferLongNoise%[LongPoints3%];
var recLongNoise3%[8][LongPoints3%];   'variables to hold long noises
var recLongNoise2%[8][LongPoints2%];    
var recLongNoise1%[8][LongPoints1%];
var recLongNoise0%[8][LongPoints0%];    
var recLongNoiseAtten[8][nLongTones%];                       'variables to hold long noise attenuation    
var recLongNoiseSeed[8][nLongTones%];                        'variables to hold long noise attenuation 

'Set LongDurs, which is used in initializing PWAs, for all experiments now that all experiments initialize all PWAs
LongDurs[0] := LongDur0 - 0.020;
LongDurs[1] := LongDur1 - 0.020;
LongDurs[2] := LongDur2 - 0.020;
LongDurs[3] := LongDur3 - 0.020;
'LongDurs[4] := recLongToneSilentDur;  'We do not know this value yet, as it is set in a later dialog box.
LongDurs[4] := recLongToneSilentPWASize;  'We will reset this later in the Long Tone dialog box, for now just make a big PWA

LongDursAllocate[0] := LongDurs[0];
LongDursAllocate[1] := LongDurs[1];
LongDursAllocate[2] := LongDurs[2];
LongDursAllocate[3] := LongDurs[3];
LongDursAllocate[4] := LongDurs[4];

'Include files that depend on above constants!
'#include "RecGoNoGoEngine.s2s"
#include "RecEngine.s2s"

'Open a Matlab instantiation, if present
if recMatlabIsPresent% = 1 then 
    ToolbarText("Opening Matlab, this could take up to 30 seconds");
    matlabOpenSuccess% := OpenMatlab%();
    if matlabOpenSuccess% < 0 then
        LogInfo("Open Matlab FAILED!");
        view(recLog%).print("ERROR: Open Matlab failed, quitting!\n");
        halt;
    endif;
    ToolbarText("");
else
    LogInfo("Client is in testing mode. Bypassing Matlab initialization.");
endif


'Initialize TDT, if present
if recTDTIsPresent% = 1 then
    ToolbarText("Initializing TDT, this could take up to 5 seconds");    
    if RecInitTDT%() < 0 then  'RecInitTDT%() is in recfuncs
        LogInfo("Init TDT FAILED!");
        view(recLog%).print("ERROR: Init TDT failed, quitting!\n");
        CloseMatlab(matlabOpenSuccess%);  'close Matlab if it is open and we are quitting
        halt;
    endif
    ToolbarText("");
else
    LogInfo("Client is in testing mode. Bypassing TDT initialization.");
endif


'Note absence of CED 1401 if necessary
if recCEDIsPresent% = 0 then
    LogInfo("Client is in testing mode. CED 1401 is not present.");
else
    type1401% := U1401Open(0);  'Open comms to first available 1401 (we only have one 1401 per rig) and get type of 1401 - needed to interpret PlayWaveStatus$ return
    U1401Close();  'Close comms to the 1401
    printlog("1401 type is %d\n",type1401%);
endif



'Open experiment selection dialog, and run the experiment
while recReadyToQuit% = 0 do  
    
    RecTimingRewardGetParams();  'get default timing and reward parameters
    
    if recCEDIsPresent% = 2 then
        recCEDIsPresent% := 1;  'If we have temporarily changed this (selected unready experiment), reset
    endif
    
    'Reset trial variables - if we are handing off, we can potentially have carry over, this hopefully covers it
    ArrConst(recTrialLoadLoc$[],"");
    ArrConst(recTrialLoadLocDistractor$[],"");
    ArrConst(recTrialStimDur[],0);
    ArrConst(recTrialDurDistractor[],0);
    ArrConst(recTrialNumS1ns%[],0);
    ArrConst(recTrialMF[],0);  
    ArrConst(recTrialMFDistractor[],0);
    ArrConst(recTrialMF2[],0); 
    ArrConst(recTrialSweepGap[],0);   
    ArrConst(recTrialSweepIntensity[],1);  'Interestingly, this is so far the ONLY variable that is initialized with ones!
    ArrConst(recTrialCarrier$[],"");
    ArrConst(recTrialCarrierDistractor$[],"");
    ArrConst(recTrialStimCal[][],0);
    ArrConst(recTrialStimCalDistractor[][],0);
    ArrConst(recTrialGenLowpassHz[],0);
    ArrConst(recTrialGenHighpassHz[],0);
    ArrConst(recTrialGenIsSweep[],0);
    ArrConst(recTrialGenAMFreqHz[],0);
    ArrConst(recTrialGenAMDepthPct[],0);
    ArrConst(recTrialGenAMPhaseDeg[],0);
    ArrConst(recTrialGenTonePhaseDeg[],0);
    ArrConst(recTrialGenGauss%[],0);
    ArrConst(recTrialGenRampMS[],0);
    ArrConst(recTrialGenSeed%[],0);
    ArrConst(recGeneratedAtten[],0); 
    ArrConst(recTrialS1%[],0);
    ArrConst(recTrialS2%[],0);
    ArrConst(recTrialS1Spkr%[],0);
    ArrConst(recTrialS2Spkr%[],0);
    ArrConst(recTrialS1DeltadB[],0);
    ArrConst(recTrialS2DeltadB[],0);
    ArrConst(recTrialDistractor%[][],0);
    ArrConst(recTrialDistractorSpkr%[][],0);
    ArrConst(recTrialDistractorDeltadB[][],0);   
    recPlayPoints% := 0;   
    recPointsPlayed% := 0;   
    ArrConst(recPWAList%[][],0);
    ArrConst(recStimList%[][],0);
    ArrConst(recTrialTerminalIndex%[],0);
    ArrConst(recTrialTerminalIsS2%[],0);
    recTotalTrials% := 0;
    recNTrials% := 0;
    ArrConst(recNUniqueStims%[],0);
    ArrConst(recSpeakerList%[][],0);
    ArrConst(recDeltadBList[][],0);
    ArrConst(recTrialOrder%[],0);
    recCurrentTrial% := 0;   
    ArrConst(recCurrRandomSeed%[],0);
    recStimCount% := 0;
    ArrConst(recLongToneDurationList[],0);
    ArrConst(recLongToneDurationIndex%[],0);
    ArrConst(rec2StimList%[][],0); 
    ArrConst(rec2SpeakerList%[][],0);
    ArrConst(rec2DeltadBList[][],0);
    ArrConst(recCharReward%[],0);    
    ArrConst(recDistractorStimList%[][],0);
    ArrConst(recDistractorSpeakerList%[][],0);
    ArrConst(recDistractorDeltadBList[][],0);  
    ArrConst(recStereoDisGeneratedAttenList[][],0);
    ArrConst(recStereoDisSeedList%[][],0); 
    
    
    'Open experiment selection dialog, load appropriate trials file, stim or stim/cal file, calibration file
    if RecExpSelectDialog%() = 1 then  'run dialog, branch on run/cancel result
        view(recLog%).print("RecRoom: RecExpSelectDialog() = 1\n");    
        view(recLog%).print("RecRoom: Are Stimuli Shuffled? = %d\n",recShuffle%);
        view(recLog%).print("RecRoom: Is Reward On? = %d\n",1-recTurnOffReward%);
        
        if recExpToRun% <> recLastExpRun% then
            RecLEDReminderDialog%(); 'call LED color switch reminder dialog before proceeding
            view(recLog%).print("RecRoom: RecLEDReminderDialog()\n");    
        else 
            view(recLog%).print("RecRoom: Repeat Expt! RecLEDReminderDialog skipped\n");    
        endif; 

        calibOK% := -1;  'logic is different for calibOK% because EvalMatlabStatement returns 0/-1 (success/failure)
        trialsOK% := 0;  'reset
        stimOK% := 0;  'reset
                
        'Load stim/cal file, trials file.
        'For generated stimuli, load calibration file to Matlab here
        docase
        case recExpToRun% = recExpLongToneButton% then 
            recExptText$ := "Running Long Tone "; 
            trialsOK% := 2;  'Short circuit, no trials file to load
            stimOK% := 1;  'Short circuit, no stim file to load
            'Load calibration file into Matlab's workspace
            'The file specified must contain a cell array named "calib" with recNSpeakers% cells inside
            'We will eventually pass a structure (syntax: AFFT(1,thisSpkr%) or AFilt(1,thisSpkr%)) to
            'Matlab when generating stimuli.  Reclab_Panstim will do the rest
            'I'm not sure the filter coefficient version is the best method - looks like the FFT version will be best
            if recMatlabIsPresent% = 1 and recCalibIsPresent% = 1 then
                statement$ := "load('" + recCalibLoc$ + "Array" + Str$(recNSpeakers%) + ".mat');";
                calibOK% := EvalMatlabStatement%(statement$);
                printlog("Matlab statement for load is: %s\n",statement$);
                printlog("CalibOK is %d where 0 is OK and -1 is not OK\n",calibOK%);
            else
                message("Either no Matlab or no calib, we will have to guess the correct attenuation!");
                'let it go forward
                calibOK% := 0; 
            endif;

        case recExpToRun% = recExpSearchButton% then  'For Search, all stimuli are generated
            recExptText$ := "Running Search " + recExptText$ + " ";  'the Search dialog puts a stimulus type in recExptText$ before we get here, this is the only expt that does that (thus far)
            trialsOK% := 2;  'Short circuit, no trials file to load
            stimOK% := 1;  'Short circuit, no stim file to load
            'Load calibration file into Matlab's workspace
            'The file specified must contain a cell array named "calib" with recNSpeakers% cells inside
            'We will eventually pass a structure (syntax: AFFT(1,thisSpkr%) or AFilt(1,thisSpkr%)) to
            'Matlab when generating stimuli.  Reclab_Panstim will do the rest
            'I'm not sure the filter coefficient version is the best method - looks like the FFT version will be best
            if recMatlabIsPresent% = 1 then
                if recCalibIsPresent% = 1 then
                    statement$ := "load('" + recCalibLoc$ + "Array" + Str$(recNSpeakers%) + ".mat');";
                    calibOK% := EvalMatlabStatement%(statement$);
                else
                    printlog("Calibration is not present, stimuli will be uncalibrated!\n");
                    calibOK% := 0;
                endif;
            else
                message("Matlab is not open, but you have selected a scenario that requires Matlab!");
                if recCEDIsPresent% = 0 then  'if both are not present, this must be a testing scenario - let it go forward
                    calibOK% := 0; 
                endif;
            endif;
            
        case recExpToRun% = recExpCharButton% and recCharLoadStim% = 0 then  'FRA generated, use values from dialog
            recExptText$ := "Running FRA (*gen) ";  '* means it's really an FRA characterization, not possibly SigNoise, will be fixed at Matlab level
            trialsOK% := 2;  'Short circuit, no trials file to load
            stimOK% := 1;  'Short circuit, no stim file to load
            'Load calibration file into Matlab's workspace, same details as above in Search
            if recMatlabIsPresent% = 1 then
                if recCalibIsPresent% = 1 then
                    statement$ := "load('" + recCalibLoc$ + "Array" + Str$(recNSpeakers%) + ".mat');";
                    calibOK% := EvalMatlabStatement%(statement$);
                else
                    printlog("Calibration is not present, stimuli will be uncalibrated!\n");
                    calibOK% := 0;
                endif;    
            else
                message("Matlab is not open, but you have selected a scenario that requires Matlab!");
                if recCEDIsPresent% = 0 then  'if both are not present, this must be a testing scenario - let it go forward
                    calibOK% := 0; 
                endif;
            endif;
            
        case recExpToRun% = recExpCharButton% and recCharLoadStim% = 1 then  'FRA loading stimuli from input table (now excludes SigNoise)
            recExptText$ := "Running FRA (*load) ";  '* means it's really an FRA characterization, not possibly SigNoise, will be fixed at Matlab level
            'Get stimfile and trials file lists
            RecCharExpListLoadFRAGetParams(recCharExpNameLoadFRA$[],recCharStimcalFileLoadFRA$[],recCharTrialsFileLoadFRA$[]);
            recSelectedStimFile$ := recCharStimcalFileLoadFRA$[recCharExpIndexLoadFRA%];  'var already declared but not used - need to print it to BehOutput*****
            recSelectedTrialsFile$ := recCharTrialsFileLoadFRA$[recCharExpIndexLoadFRA%]; 'ditto. for BehOutput
            'Load trials file, stim/cal file
            trialsOK% := RecLoadTrialsFile6ColOr3Col%(recSelectedTrialsFile$,recTotalTrials%);  'Well, on second thought, some old FRA files might be 6-column with zeroes in the S2 columns, don't break if trying to load one
            'trialsOK% := RecLoadTrialsFile3Col%(recSelectedTrialsFile$,recTotalTrials%);  'This should not have an S2 speaker, a three-column file
            if trialsOK% = 1 then  'Don't bother with loading Stim/Cal file if trials file is bad
                stimOK% := RecLoadStimCalFile%(recSelectedStimFile$,recNSpeakers%,recTotalStim%);
            endif;
            calibOK% := 0;  'Short circuit, this means OK.
            
        case recExpToRun% = recExpCharButton% and recCharLoadStim% = 2 then  'SigNoise loading stimuli from input table (broken off from FRA)
            recExptText$ := "Running SigNoise (load) ";
            'Get stimfile and trials file lists
            RecCharExpListLoadSigNoiseGetParams(recCharExpNameLoadSigNoise$[],recCharStimcalFileLoadSigNoise$[],recCharTrialsFileLoadSigNoise$[]);
            recSelectedStimFile$ := recCharStimcalFileLoadSigNoise$[recCharExpIndexLoadSigNoise%];  'var already declared but not used - need to print it to BehOutput*****
            recSelectedTrialsFile$ := recCharTrialsFileLoadSigNoise$[recCharExpIndexLoadSigNoise%]; 'ditto. for BehOutput
            'Load trials file, stim/cal file
            'trialsOK% := RecLoadTrialsFile6ColOr3Col%(recSelectedTrialsFile$,recTotalTrials%);
            trialsOK% := RecLoadTrialsFile%(recSelectedTrialsFile$,recTotalTrials%);  'This should have an S1 and an S2 speaker, a six-column file
            if trialsOK% = 1 then  'Don't bother with loading Stim/Cal file if trials file is bad
                stimOK% := RecLoadStimCalFile%(recSelectedStimFile$,recNSpeakers%,recTotalStim%);
            endif;
            calibOK% := 0;  'Short circuit, this means OK.
            
        case recExpToRun% = recExpCharButton% and recCharLoadStim% = 3 then  'FRA generating stimuli using trial/stim file
            recExptText$ := "Running FRA (*gen) ";  '* means it's really an FRA characterization, not possibly SigNoise, will be fixed at Matlab level
            'Get stimfile and trials file lists
            RecCharExpListGenFRAGetParams(recCharExpNameGenFRA$[],recCharStimFileGenFRA$[],recCharTrialsFileGenFRA$[]);
            recSelectedStimFile$ := recCharStimFileGenFRA$[recCharExpIndexGenFRA%];  'var already declared but not used - need to print it to BehOutput*****
            recSelectedTrialsFile$ := recCharTrialsFileGenFRA$[recCharExpIndexGenFRA%]; 'ditto. for BehOutput
            'Load trials file, stim file
            trialsOK% := RecLoadTrialsFile3Col%(recSelectedTrialsFile$,recTotalTrials%);  'This should not have an S2 speaker, a three-column file
            if trialsOK% = 1 then  'Don't bother with loading Stim file if trials file is bad
                stimOK% := RecLoadStimFile%(recSelectedStimFile$,recTotalStim%);
            endif;
            'Load calibration file into Matlab's workspace, same details as above in Search
            if recMatlabIsPresent% = 1 then
                if recCalibIsPresent% = 1 then
                    statement$ := "load('" + recCalibLoc$ + "Array" + Str$(recNSpeakers%) + ".mat');";
                    calibOK% := EvalMatlabStatement%(statement$);
                else
                    printlog("Calibration is not present, stimuli will be uncalibrated!\n");
                    calibOK% := 0;
                endif;    
            else
                message("Matlab is not open, but you have selected a scenario that requires Matlab!");
                if recCEDIsPresent% = 0 then  'if both are not present, this must be a testing scenario - let it go forward
                    calibOK% := 0; 
                endif;
            endif;
            
        case recExpToRun% = recExpCharButton% and recCharLoadStim% = 4 then  'SigNoise generating stimuli using trial/stim file
            recExptText$ := "Running SigNoise (gen) ";
            'Get stimfile and trials file lists
            RecCharExpListGenSigNoiseGetParams(recCharExpNameGenSigNoise$[],recCharStimFileGenSigNoise$[],recCharTrialsFileGenSigNoise$[]);
            recSelectedStimFile$ := recCharStimFileGenSigNoise$[recCharExpIndexGenSigNoise%];  'var already declared but not used - need to print it to BehOutput*****
            recSelectedTrialsFile$ := recCharTrialsFileGenSigNoise$[recCharExpIndexGenSigNoise%]; 'ditto. for BehOutput
            'Load trials file, stim file
            trialsOK% := RecLoadTrialsFile%(recSelectedTrialsFile$,recTotalTrials%);  'This should have an S1 and an S2 speaker, a six-column file
            if trialsOK% = 1 then  'Don't bother with loading Stim file if trials file is bad
                stimOK% := RecLoadStimFile%(recSelectedStimFile$,recTotalStim%);
            endif;
            'Load calibration file into Matlab's workspace, same details as above in Search
            if recMatlabIsPresent% = 1 then
                if recCalibIsPresent% = 1 then
                    statement$ := "load('" + recCalibLoc$ + "Standalone.mat');"; 
                    calibOK% := EvalMatlabStatement%(statement$);
                    'standalone is in 'AFFT', move to 'stAFFT' - no, it is now in stAFFT
                    if calibOK% = 0 then
                        'statement$ := "stAFFT = AFFT;";
                        calibOK% := EvalMatlabStatement%(statement$);
                        'Only load array calibration if the standalone load/rename was successful
                        if calibOK% = 0 then
                            'Then load array into AFFT as expected
                            statement$ := "load('" + recCalibLoc$ + "Array" + Str$(recNSpeakers%) + ".mat');";
                            calibOK% := EvalMatlabStatement%(statement$);
                        endif;
                    endif;
                else
                    printlog("Calibration is not present, stimuli will be uncalibrated!\n");
                    calibOK% := 0;
                endif;    
            else
                message("Matlab is not open, but you have selected a scenario that requires Matlab!");
                if recCEDIsPresent% = 0 then  'if both are not present, this must be a testing scenario - let it go forward
                    calibOK% := 0; 
                endif;
            endif;
            
        case recExpToRun% = recExpCharButton% and recCharLoadStim% = 5 then  'Arbitrary stimuli loading from input table
            'Get stimfile and trials file lists
            RecCharExpListLoadArbStimGetParams(recCharExpNameLoadArbStim$[],recCharStimcalFileLoadArbStim$[],recCharTrialsFileLoadArbStim$[],recCharExpPrefixLoadArbStim$[]);
            recSelectedStimFile$ := recCharStimcalFileLoadArbStim$[recCharExpIndexLoadArbStim%];  'var already declared but not used - need to print it to BehOutput*****
            recSelectedTrialsFile$ := recCharTrialsFileLoadArbStim$[recCharExpIndexLoadArbStim%]; 'ditto. for BehOutput
            recSelectedPrefix$ := recCharExpPrefixLoadArbStim$[recCharExpIndexLoadArbStim%];  'ditto, for sampletext
            if recSelectedPrefix$ = "" then
                recExptText$ := "Running ArbStim (load) ";
            else
                recExptText$ := "Running " + recSelectedPrefix$ + " (load) ";
            endif
            'Load trials file, stim/cal file
            'trialsOK% := RecLoadTrialsFile6ColOr3Col%(recSelectedTrialsFile$,recTotalTrials%);  
            trialsOK% := RecLoadTrialsFile3Col%(recSelectedTrialsFile$,recTotalTrials%);  'This should not have an S2 speaker, a three-column file
            if trialsOK% = 1 then  'Don't bother with loading Stim/Cal file if trials file is bad
                stimOK% := RecLoadStimCalFile%(recSelectedStimFile$,recNSpeakers%,recTotalStim%);
            endif;
            calibOK% := 0;  'Short circuit, this means OK.
            
            
        case recExpToRun% = recExpJoyTrnButton% then '*jao
            recExptText$ := "Running Joy Train ";
            trialsOK% := 2;  'Short circuit, no trials file to load
            stimOK% := 1;  'Short circuit, no stim file to load
            'Load calibration file into Matlab's workspace, same details as above in Search
            if recMatlabIsPresent% = 1 then
                if recCalibIsPresent% = 1 then
                    statement$ := "load('" + recCalibLoc$ + "Array" + Str$(recNSpeakers%) + ".mat');";
                    calibOK% := EvalMatlabStatement%(statement$);
                else
                    printlog("Calibration is not present, stimuli will be uncalibrated!\n");
                    calibOK% := 0;
                endif;
            else
                message("Matlab is not open, but you have selected a scenario that requires Matlab!");
                if recCEDIsPresent% = 0 then  'if both are not present, this must be a testing scenario - let it go forward
                    calibOK% := 0; 
                endif;
            endif; '*jao            
            
        case recExpToRun% = recExpAMDiscButton% and recMatGenStim% = 0 then  'Loading stims
            recExptText$ := "Running AMDisc (load) "; 
            'Get stimfile and trials file lists
            RecAMDiscExpListLoadGetParams(recAMDiscExpNameLoad$[],recAMDiscStimcalNameLoad$[],recAMDiscTrialsNameLoad$[]);
            'Load trials file, stim/cal file
            trialsOK% := RecLoadTrialsFile%(recAMDiscTrialsNameLoad$[recAMDiscExpIndexLoad%],recTotalTrials%);
            if trialsOK% = 1 then  'Don't bother with loading Stim/Cal file if trials file is bad
                stimOK% := RecLoadStimCalFile%(recAMDiscStimcalNameLoad$[recAMDiscExpIndexLoad%],recNSpeakers%,recTotalStim%);
            endif;
            recSelectedStimFile$ := recAMDiscStimcalNameLoad$[recAMDiscExpIndexLoad%];  'var already declared but not used - need to print it to BehOutput*****
            recSelectedTrialsFile$ := recAMDiscTrialsNameLoad$[recAMDiscExpIndexLoad%]; 'ditto. for BehOutput
                
            calibOK% := 0;  'Short circuit, this means OK.
                    
        case recExpToRun% = recExpAMDiscButton% and recMatGenStim% = 1 then  'Generating stims
            recExptText$ := "Running AMDisc (gen) "; 
            'Get stimfile and trials file lists
            RecAMDiscExpListGenGetParams(recAMDiscExpNameGen$[],recAMDiscStimcalNameGen$[],recAMDiscTrialsNameGen$[]);
            'Load trials file, stim file, cal file
            trialsOK% := RecLoadTrialsFile%(recAMDiscTrialsNameGen$[recAMDiscExpIndexGen%],recTotalTrials%);
            if trialsOK% = 1 then  'Don't bother with loading Stim file if trials file is bad
                stimOK% := RecLoadStimFile%(recAMDiscStimcalNameGen$[recAMDiscExpIndexGen%],recTotalStim%);
            endif;
            recSelectedStimFile$ := recAMDiscStimcalNameGen$[recAMDiscExpIndexGen%];  'var already declared but not used - need to print it to BehOutput*****
            recSelectedTrialsFile$ := recAMDiscTrialsNameGen$[recAMDiscExpIndexGen%]; 'ditto. for BehOutput
                
            if stimOK% = 1 then  'Don't bother with loading Calib file if trials or stim file is bad
                'Load calibration file into Matlab's workspace, same details as above in Search
                if recMatlabIsPresent% = 1 then
                    if recCalibIsPresent% = 1 then 
                        statement$ := "load('" + recCalibLoc$ + "Array" + Str$(recNSpeakers%) + ".mat');";
                        calibOK% := EvalMatlabStatement%(statement$);
                    else
                        printlog("Calibration is not present, stimuli will be uncalibrated!\n");
                        calibOK% := 0;
                    endif;
                else
                    message("Matlab is not open, but you have selected a scenario that requires Matlab!");
                endif;
            endif;
            
        case recExpToRun% = recExpSpaceDisButton% and recMatGenStim% = 0 then  'Loading stims
            recExptText$ := "Running SpaceDis (load) "; 
            'Get stimfile and trials file lists
            RecSpaceDisExpListLoadGetParams(recSpaceDisExpNameLoad$[],recSpaceDisStimcalNameLoad$[],recSpaceDisTrialsNameLoad$[]);
            'Load trials file, stim/cal file
            trialsOK% := RecLoadTrialsFile%(recSpaceDisTrialsNameLoad$[recSpaceDisExpIndexLoad%],recTotalTrials%);
            if trialsOK% = 1 then  'Don't bother with loading Stim/Cal file if trials file is bad
                stimOK% := RecLoadStimCalFile%(recSpaceDisStimcalNameLoad$[recSpaceDisExpIndexLoad%],recNSpeakers%,recTotalStim%);
            endif;
            recSelectedStimFile$ := recSpaceDisStimcalNameLoad$[recSpaceDisExpIndexLoad%];  'var already declared but not used - need to print it to BehOutput*****
            recSelectedTrialsFile$ := recSpaceDisTrialsNameLoad$[recSpaceDisExpIndexLoad%]; 'ditto. for BehOutput
                
            calibOK% := 0;  'Short circuit, this means OK.
                    
        case recExpToRun% = recExpSpaceDisButton% and recMatGenStim% = 1 then  'Generating stims
            recExptText$ := "Running SpaceDis (gen) "; 
            'Get stimfile and trials file lists
            RecSpaceDisExpListGenGetParams(recSpaceDisExpNameGen$[],recSpaceDisStimcalNameGen$[],recSpaceDisTrialsNameGen$[]);
            'Load trials file, stim file, cal file
            trialsOK% := RecLoadTrialsFile%(recSpaceDisTrialsNameGen$[recSpaceDisExpIndexGen%],recTotalTrials%);
            if trialsOK% = 1 then  'Don't bother with loading Stim file if trials file is bad
                stimOK% := RecLoadStimFile%(recSpaceDisStimcalNameGen$[recSpaceDisExpIndexGen%],recTotalStim%);
            endif;
            recSelectedStimFile$ := recSpaceDisStimcalNameGen$[recSpaceDisExpIndexGen%];  'var already declared but not used - need to print it to BehOutput*****
            recSelectedTrialsFile$ := recSpaceDisTrialsNameGen$[recSpaceDisExpIndexGen%]; 'ditto. for BehOutput
                
            if stimOK% = 1 then  'Don't bother with loading Calib file if trials or stim file is bad
                'Load calibration file into Matlab's workspace, same details as above in Search
                if recMatlabIsPresent% = 1 then
                    if recCalibIsPresent% = 1 then 
                        statement$ := "load('" + recCalibLoc$ + "Array" + Str$(recNSpeakers%) + ".mat');";
                        calibOK% := EvalMatlabStatement%(statement$);
                    else
                        printlog("Calibration is not present, stimuli will be uncalibrated!\n");
                        calibOK% := 0;
                    endif;
                else
                    message("Matlab is not open, but you have selected a scenario that requires Matlab!");
                endif;
            endif;
            
            
        case recExpToRun% = recExpOneStimDiscrimButton% and recMatGenStim% = 0 and recIsGoNoGo% = 0 then  'Loading stims, FC
            if recOneStimDiscrimExptLabel$ <> "Generic" then  'this syntax IS legal for case-sensitive match
                recExptText$ := "Running " + recOneStimDiscrimExptLabel$ + " (load) ";  'no FC label
            else                
                recExptText$ := "Running OneStimDiscrim (load) "; 'no FC label
            endif
            'Get stimfile and trials file lists
            RecOneStimDiscrimExpListLoadGetParams(recOneStimDiscrimExpNameLoad$[],recOneStimDiscrimStimcalNameLoad$[],recOneStimDiscrimTrialsNameLoad$[]);
            'Load trials file, stim/cal file
            trialsOK% := RecLoadTrialsFile3Col%(recOneStimDiscrimTrialsNameLoad$[recOneStimDiscrimExpIndexLoad%],recTotalTrials%);
            if trialsOK% = 1 then  'Don't bother with loading Stim/Cal file if trials file is bad
                stimOK% := RecLoadStimCalFile%(recOneStimDiscrimStimcalNameLoad$[recOneStimDiscrimExpIndexLoad%],recNSpeakers%,recTotalStim%);
            endif;
            recSelectedStimFile$ := recOneStimDiscrimStimcalNameLoad$[recOneStimDiscrimExpIndexLoad%];  'var already declared but not used - need to print it to BehOutput*****
            recSelectedTrialsFile$ := recOneStimDiscrimTrialsNameLoad$[recOneStimDiscrimExpIndexLoad%]; 'ditto. for BehOutput
                
            calibOK% := 0;  'Short circuit, this means OK.
                    
        case recExpToRun% = recExpOneStimDiscrimButton% and recMatGenStim% = 1 and recIsGoNoGo% = 0 then  'Generating stims, FC
            if recOneStimDiscrimExptLabel$ <> "Generic" then  'this syntax IS legal for case-sensitive match
                recExptText$ := "Running " + recOneStimDiscrimExptLabel$ + " (gen) ";  'no FC label
            else                
                recExptText$ := "Running OneStimDiscrim (gen) "; 'no FC label
            endif 
            'Get stimfile and trials file lists
            RecOneStimDiscrimExpListGenGetParams(recOneStimDiscrimExpNameGen$[],recOneStimDiscrimStimNameGen$[],recOneStimDiscrimTrialsNameGen$[]);
            'Load trials file, stim file, cal file
            trialsOK% := RecLoadTrialsFile3Col%(recOneStimDiscrimTrialsNameGen$[recOneStimDiscrimExpIndexGen%],recTotalTrials%);
            if trialsOK% = 1 then  'Don't bother with loading Stim file if trials file is bad
                stimOK% := RecLoadStimFile%(recOneStimDiscrimStimNameGen$[recOneStimDiscrimExpIndexGen%],recTotalStim%);
            endif;
            recSelectedStimFile$ := recOneStimDiscrimStimNameGen$[recOneStimDiscrimExpIndexGen%];  'var already declared but not used - need to print it to BehOutput*****
            recSelectedTrialsFile$ := recOneStimDiscrimTrialsNameGen$[recOneStimDiscrimExpIndexGen%]; 'ditto. for BehOutput
                
            if stimOK% = 1 then  'Don't bother with loading Calib file if trials or stim file is bad
                'Load calibration file into Matlab's workspace, same details as above in Search
                if recMatlabIsPresent% = 1 then
                    if recCalibIsPresent% = 1 then 
                        statement$ := "load('" + recCalibLoc$ + "Array" + Str$(recNSpeakers%) + ".mat');";
                        calibOK% := EvalMatlabStatement%(statement$);
                    else
                        printlog("Calibration is not present, stimuli will be uncalibrated!\n");
                        calibOK% := 0;
                    endif;
                else
                    message("Matlab is not open, but you have selected a scenario that requires Matlab!");
                endif;
            endif;   
            
        case recExpToRun% = recExpOneStimDiscrimButton% and recMatGenStim% = 0 and recIsGoNoGo% = 1 then  'Loading stims, GNG
            if recOneStimDiscrimExptLabel$ <> "Generic" then  'this syntax IS legal for case-sensitive match
                recExptText$ := "Running " + recOneStimDiscrimExptLabel$ + " GNG (load) ";  'add GNG label
            else                
                recExptText$ := "Running OneStimDiscrim GNG (load) "; 'add GNG label
            endif
            'Get stimfile and trials file lists
            RecOneStimDiscrimGNGExpListLoadGetParams(recOneStimDiscrimGNGExpNameLoad$[],recOneStimDiscrimGNGStimcalNameLoad$[],recOneStimDiscrimGNGTrialsNameLoad$[]);
            'Load trials file, stim/cal file
            trialsOK% := RecLoadTrialsFile3Col%(recOneStimDiscrimGNGTrialsNameLoad$[recOneStimDiscrimGNGExpIndexLoad%],recTotalTrials%);
            if trialsOK% = 1 then  'Don't bother with loading Stim/Cal file if trials file is bad
                stimOK% := RecLoadStimCalFile%(recOneStimDiscrimGNGStimcalNameLoad$[recOneStimDiscrimGNGExpIndexLoad%],recNSpeakers%,recTotalStim%);
            endif;
            recSelectedStimFile$ := recOneStimDiscrimGNGStimcalNameLoad$[recOneStimDiscrimGNGExpIndexLoad%];  'var already declared but not used - need to print it to BehOutput*****
            recSelectedTrialsFile$ := recOneStimDiscrimGNGTrialsNameLoad$[recOneStimDiscrimGNGExpIndexLoad%]; 'ditto. for BehOutput
                
            calibOK% := 0;  'Short circuit, this means OK.
                    
        case recExpToRun% = recExpOneStimDiscrimButton% and recMatGenStim% = 1 and recIsGoNoGo% = 1 then  'Generating stims, GNG
            if recOneStimDiscrimExptLabel$ <> "Generic" then  'this syntax IS legal for case-sensitive match
                recExptText$ := "Running " + recOneStimDiscrimExptLabel$ + " GNG (gen) ";  'add GNG label
            else                
                recExptText$ := "Running OneStimDiscrim GNG (gen) "; 'add GNG label
            endif 
            'Get stimfile and trials file lists
            RecOneStimDiscrimGNGExpListGenGetParams(recOneStimDiscrimGNGExpNameGen$[],recOneStimDiscrimGNGStimNameGen$[],recOneStimDiscrimGNGTrialsNameGen$[]);
            'Load trials file, stim file, cal file
            trialsOK% := RecLoadTrialsFile3Col%(recOneStimDiscrimGNGTrialsNameGen$[recOneStimDiscrimGNGExpIndexGen%],recTotalTrials%);
            if trialsOK% = 1 then  'Don't bother with loading Stim file if trials file is bad
                stimOK% := RecLoadStimFile%(recOneStimDiscrimGNGStimNameGen$[recOneStimDiscrimGNGExpIndexGen%],recTotalStim%);
            endif;
            recSelectedStimFile$ := recOneStimDiscrimGNGStimNameGen$[recOneStimDiscrimGNGExpIndexGen%];  'var already declared but not used - need to print it to BehOutput*****
            recSelectedTrialsFile$ := recOneStimDiscrimGNGTrialsNameGen$[recOneStimDiscrimGNGExpIndexGen%]; 'ditto. for BehOutput
                
            if stimOK% = 1 then  'Don't bother with loading Calib file if trials or stim file is bad
                'Load calibration file into Matlab's workspace, same details as above in Search
                if recMatlabIsPresent% = 1 then
                    if recCalibIsPresent% = 1 then 
                        statement$ := "load('" + recCalibLoc$ + "Array" + Str$(recNSpeakers%) + ".mat');";
                        calibOK% := EvalMatlabStatement%(statement$);
                    else
                        printlog("Calibration is not present, stimuli will be uncalibrated!\n");
                        calibOK% := 0;
                    endif;
                else
                    message("Matlab is not open, but you have selected a scenario that requires Matlab!");
                endif;
            endif;             
            
            
            
        case recExpToRun% = recExpCueingButton% and recMatGenStim% = 0 then  'Loading stims
            recExptText$ := "Running Cueing (load) "; 
            'Not Yet Implemented
            'Copy from load version of AM Disc when cueing is ready
            calibOK% := 0;  'Short circuit, this means OK.
            
        case recExpToRun% = recExpCueingButton% and recMatGenStim% = 1 then  'Generating stims
            recExptText$ := "Running Cueing (gen) "; '+ recExptText$???
            'Not Yet Implemented
            'Copy from generate version of AM Disc when cueing is ready
            'Load calibration file into Matlab's workspace, same details as above in Search
            if recMatlabIsPresent% = 1 then
                if recCalibIsPresent% = 1 then
                    statement$ := "load('" + recCalibLoc$ + "Array" + Str$(recNSpeakers%) + ".mat');";
                    calibOK% := EvalMatlabStatement%(statement$);
                else
                    printlog("Calibration is not present, stimuli will be uncalibrated!\n");
                    calibOK% := 0;
                endif;
            else
                message("Matlab is not open, but you have selected a scenario that requires Matlab!");
            endif;
            
        case recExpToRun% = recExpAudiogramButton% then  'For Audiogram, all stimuli are generated
            
            recExptText$ := "Running Audiogram ";  
            trialsOK% := 2;  'Short circuit, no trials file to load
            stimOK% := 1;  'Short circuit, no stim file to load
            
            'The following two settings are obligatory for Audiogram - these had been set in Audiogram dialog but subsequent calls of Timing/Reward were counterfeiting them.
            'Hmm, Timing/Reward certainly does not do that anymore...but Joystick/Lever might
            recIsGoNoGo% := 1;  'Force experiment to be go/no-go 
            recHitRewardIncmL := 0;  'Do not allow reward incrementing for audiogram
            
            'Also, set this explicitly every time, OK for first run, but on subsequent runs, has to be reset
            recAudiogramStartNewTrial% := 1;
            
            'Load calibration file into Matlab's workspace, same details as above in Search
            if recMatlabIsPresent% = 1 then
                if recCalibIsPresent% = 1 then
                    statement$ := "load('" + recCalibLoc$ + "Array" + Str$(recNSpeakers%) + ".mat');";
                    calibOK% := EvalMatlabStatement%(statement$);
                else
                    printlog("Calibration is not present, stimuli will be uncalibrated!\n");
                    calibOK% := 0;
                endif;    
            else
                message("Matlab is not open, but you have selected a scenario that requires Matlab!");
                if recCEDIsPresent% = 0 then  'if both are not present, this must be a testing scenario - let it go forward
                    calibOK% := 0; 
                endif;
            endif;
            
        case recExpToRun% = recExpStereoDisButton% and recStereoDisExpDoFC% = 1 and recStereoDisExpDoLoad% = 1 then  'For Stereo Distractor, FC, loading stimuli
            recExptText$ := "Running StereoDisFC (load) "; 
            message("Stereo Distractor FC LOADING stims is not fully vetted, exiting!");
            halt;
            
            'Get stimfile and trials file lists
            RecStereoDisExpListLoadGetParams(recStereoDisExpNameLoad$[],recStereoDisStimcalNameLoad$[],recStereoDisTrialsNameLoad$[],recStereoDisStimcalDistractorNameLoad$[]);
            'Load trials file, stim/cal file
            trialsOK% := RecLoadTrialsFile9%(recStereoDisTrialsNameLoad$[recStereoDisExpIndexLoad%],recTotalTrials%);
            if trialsOK% = 1 then  'Don't bother with loading Stim/Cal file if trials file is bad
                stimOK% := RecLoadStimCalDistractorFile%(recStereoDisStimcalDistractorNameLoad$[recStereoDisExpIndexLoad%],recNSpeakers%,recTotalDistractorStim%);
                if stimOK% = 1 then  'Don't bother with loading S1/S2 Stim/Cal file if distractor one is bad
                    stimOK% := RecLoadStimCalMFCarrierFile%(recStereoDisStimcalNameLoad$[recStereoDisExpIndexLoad%],1,recTotalStim%);  'here, there is only 1 S1/S2 speaker, at least for now
                else
                    stimOK% := -1;  'This is an indicator that the distractor file read failed, as opposed to S1/S2
                endif;
            endif;
            recSelectedStimFile$ := recStereoDisStimcalNameLoad$[recStereoDisExpIndexLoad%];  'var already declared but not used - need to print it to BehOutput*****
            recSelectedStimDistractorFile$ := recStereoDisStimcalDistractorNameLoad$[recStereoDisExpIndexLoad%];  'var already declared but not used - need to print it to BehOutput*****
            recSelectedTrialsFile$ := recStereoDisTrialsNameLoad$[recStereoDisExpIndexLoad%]; 'ditto. for BehOutput
                
            calibOK% := 0;  'Short circuit, this means OK.
            
        case recExpToRun% = recExpStereoDisButton% and recStereoDisExpDoFC% = 1 and recStereoDisExpDoGen% = 1 then  'For Stereo Distractor, FC, generating stimuli
            recExptText$ := "Running StereoDisFC (gen) "; 
            
            'Get stimfile and trials file lists
            RecStereoDisExpListGenGetParams(recStereoDisExpNameGen$[],recStereoDisStimNameGen$[],recStereoDisTrialsNameGen$[]);
            'Load trials file, stim file
            trialsOK% := RecLoadTrialsFile9%(recStereoDisTrialsNameGen$[recStereoDisExpIndexGen%],recTotalTrials%);
            if trialsOK% = 1 then  'Don't bother with loading Stim file if trials file is bad
                stimOK% := RecLoadStimFile%(recStereoDisStimNameGen$[recStereoDisExpIndexGen%],recTotalStim%);
            endif;
            recSelectedStimFile$ := recStereoDisStimNameGen$[recStereoDisExpIndexGen%];  'var already declared but not used - need to print it to BehOutput*****
            recSelectedTrialsFile$ := recStereoDisTrialsNameGen$[recStereoDisExpIndexGen%]; 'ditto. for BehOutput
            
            'Load calibration file into Matlab's workspace, same details as above in Search
            if recMatlabIsPresent% = 1 then
                if recCalibIsPresent% = 1 then
                    statement$ := "load('" + recCalibLoc$ + "Standalone.mat');"; 
                    calibOK% := EvalMatlabStatement%(statement$);
                    'standalone is in 'AFFT', move to 'stAFFT' - no, it is now in stAFFT
                    if calibOK% = 0 then
                        'statement$ := "stAFFT = AFFT;";
                        calibOK% := EvalMatlabStatement%(statement$);
                        'Only load array calibration if the standalone load/rename was successful
                        if calibOK% = 0 then
                            'Then load array into AFFT as expected
                            statement$ := "load('" + recCalibLoc$ + "Array" + Str$(recNSpeakers%) + ".mat');";
                            calibOK% := EvalMatlabStatement%(statement$);
                        endif;
                    endif;
                else
                    printlog("Calibration is not present, stimuli will be uncalibrated!\n");
                    calibOK% := 0;
                endif;    
            else
                message("Matlab is not open, but you have selected a scenario that requires Matlab!");
                if recCEDIsPresent% = 0 then  'if both are not present, this must be a testing scenario - let it go forward
                    calibOK% := 0; 
                endif;
            endif; 
            
        case recExpToRun% = recExpStereoDisButton% and recStereoDisExpDoGNG% = 1 and recStereoDisExpDoLoad% = 1 then  'For Stereo Distractor, GNG, loading stimuli
            recExptText$ := "Running StereoDisGNG (load) "; 
            message("Stereo Distractor GNG loading stims is not fully vetted, exiting!");
            halt;
            
            'Get stimfile and trials file lists
            RecStereoDisGNGExpListLoadGetParams(recStereoDisGNGExpNameLoad$[],recStereoDisGNGStimcalNameLoad$[],recStereoDisGNGTrialsNameLoad$[],recStereoDisGNGStimcalDistractorNameLoad$[]);
            'Load trials file, stim/cal file
            trialsOK% := RecLoadTrialsFile22%(recStereoDisGNGTrialsNameLoad$[recStereoDisGNGExpIndexLoad%],recTotalTrials%);
            if trialsOK% = 1 then  'Don't bother with loading Stim/Cal file if trials file is bad
                stimOK% := RecLoadStimCalDistractorFile%(recStereoDisGNGStimcalDistractorNameLoad$[recStereoDisGNGExpIndexLoad%],recNSpeakers%,recTotalDistractorStim%);
                if stimOK% = 1 then  'Don't bother with loading S1/S2 Stim/Cal file if distractor one is bad
                    stimOK% := RecLoadStimCalMFCarrierFile%(recStereoDisGNGStimcalNameLoad$[recStereoDisGNGExpIndexLoad%],1,recTotalStim%);  'here, there is only 1 S1/S2 speaker, at least for now
                else
                    stimOK% := -1;  'This is an indicator that the distractor file read failed, as opposed to S1/S2
                endif;
            endif;
            recSelectedStimFile$ := recStereoDisGNGStimcalNameLoad$[recStereoDisGNGExpIndexLoad%];  'var already declared but not used - need to print it to BehOutput*****
            recSelectedStimDistractorFile$ := recStereoDisGNGStimcalDistractorNameLoad$[recStereoDisGNGExpIndexLoad%];  'var already declared but not used - need to print it to BehOutput*****
            recSelectedTrialsFile$ := recStereoDisGNGTrialsNameLoad$[recStereoDisGNGExpIndexLoad%]; 'ditto. for BehOutput
                
            calibOK% := 0;  'Short circuit, this means OK.            
            
        case recExpToRun% = recExpStereoDisButton% and recStereoDisExpDoGNG% = 1 and recStereoDisExpDoGen% = 1 then  'For Stereo Distractor, GNG, generating stimuli
            'Not fully vetted!
            message("Stereo Distractor GNG generating stims is not fully vetted, exiting!");
            halt;
            trialsOK% := -1;  'short circuit the rest, go back to exp. selection dialog
            
'            recExptText$ := "Running StereoDisGNG (gen) "; 
'            
'            'Get stimfile and trials file lists
'            RecStereoDisGNGExpListGenGetParams(recStereoDisGNGExpNameGen$[],recStereoDisGNGStimNameGen$[],recStereoDisGNGTrialsNameGen$[]);
'            'Load trials file, stim file
'            'trialsOK% := RecLoadTrialsFile22%(recStereoDisGNGTrialsNameLoad$[recStereoDisGNGExpIndexLoad%],recTotalTrials%);
'            trialsOK% := RecLoadTrialsFile9%(recStereoDisGNGTrialsNameGen$[recStereoDisGNGExpIndexGen%],recTotalTrials%);
'            if trialsOK% = 1 then  'Don't bother with loading Stim/Cal file if trials file is bad
'                stimOK% := RecLoadStimFile%(recStereoDisGNGStimNameGen$[recStereoDisGNGExpIndexGen%],recTotalStim%);
'            endif;
'            recSelectedStimFile$ := recStereoDisGNGStimNameGen$[recStereoDisGNGExpIndexGen%];  'var already declared but not used - need to print it to BehOutput*****
'            recSelectedTrialsFile$ := recStereoDisGNGTrialsNameGen$[recStereoDisGNGExpIndexGen%]; 'ditto. for BehOutput
'                
'            calibOK% := 0;  'Short circuit, this means OK. 
            
        endcase;
        
        
        'Explicitly zero out the Do PSTH variable if not running Search, PSTH only to be created for Search
        if recExpToRun% <> recExpSearchButton% then
            recSearchDoPSTH% := 0;
        endif;
        
        
        calibOK% += 1;  'Just getting this into my "standard" 1-is-OK, 0-is-not-OK schema.
        
        'Verify trial/speaker numbers and stimuli if the trials/stim files check out, otherwise jump back to original dialog
        'This IF will not run on experiments that don't have a trials file (e.g. SEARCH, FRA)
        if trialsOK% = 1 and stimOK% = 1 and calibOK% = 1 then
            
            'Make sure that the trials file does not specify stimuli that are not present in the Stim or Stim/Cal file
            'if loading, stimulus indices are sequential only, use old scheme
            if recMatGenStim% = 0 then  
                if max(recTrialS1%[max(recTrialS1%)],recTrialS2%[max(recTrialS2%)]) <= recTotalStim% then
                    printlog("All stimuli in trials file are accounted for in Stim/Cal file!\n");
                else
                    printlog("Maximum stimulus in trials file is %d but not only %d stimuli are specified in Stim/Cal file!\n",max(recTrialS1%[max(recTrialS1%)],recTrialS2%[max(recTrialS2%)]),recTotalStim%);
                    message("Starting Over!|Trials File specifies illegal stimulus number!");
                    trialsOK% := -1;
                endif;
            else  'For new 12-column stimulus files (generating), stimulus number is not necessarily sequential
                nd% := ArrSetDiff%(recTrialS1%[],recStimPresent%[],recStimSetDiff%[]);
                nd2% := ArrSetDiff%(recTrialS2%[],recStimPresent%[],recStimSetDiff2%[]);
                docase    
                case nd% > 0 then
                    printlog("The following stimulus indices were found in the Trials file but not in the Stim file!  %d\n",recStimSetDiff%[0:nd%]);
                    message("Starting Over!|Trials File specifies illegal stimulus number!");
                    trialsOK% := -1;
                case recTrialS2%[max(recTrialS2%)] > 0 and nd2% > 0 then 
                    printlog("The following stimulus indices were found in the Trials file but not in the Stim file!  %d\n",recStimSetDiff2%[0:nd2%]);
                    message("Starting Over!|Trials File specifies illegal stimulus number!");
                    trialsOK% := -1;
                else
                    printlog("All stimuli in trials file are accounted for in Stim file!\n");
                endcase
            endif
            
            
            
            'Make sure that the trials file does not specify more speakers than are present in the selected speaker array
            'Use recTrialStimDur[], recTrialS1Spkr%[], recTrialS2Spkr%[]
            var tempSpeakerCount%;
            if recExpToRun% = recExpStereoDisButton% then  'For this experiment, the arrays are "switched", the S1/S2 stimuli are on the standalone speaker and the distractors are on the array
                tempSpeakerCount% := 1;
            else
                tempSpeakerCount% := recNSpeakers%;
            endif;
            if max(recTrialS1Spkr%[max(recTrialS1Spkr%)],recTrialS2Spkr%[max(recTrialS2Spkr%)]) <= tempSpeakerCount% then
                printlog("All speakers in trials file are present in array!\n");
            else
                printlog("Maximum speaker in trials file is %d but there are only %d speakers in the specified speaker array!\n",max(recTrialS1Spkr%[max(recTrialS1Spkr%)],recTrialS2Spkr%[max(recTrialS2Spkr%)]),tempSpeakerCount%);
                message("Starting Over!|Trials File specifies illegal speaker number!");
                trialsOK% := -1;
            endif;
            
            'Additional checks for StereoDis experiment
            'Make sure that the trials file does not specify more distractor stimuli than are present in the Distractor Stim or Stim/Cal file
            'Do the same for speakers and the speaker array
            'This is only relevant for the "load" version of StereoDis, as the "gen" version has distractors defined in the same stim file as S1/S2 stimuli
            if recExpToRun% = recExpStereoDisButton% and recStereoDisExpDoLoad% = 1 then
                var tempmax%[recMaxDistractor%];
                var iLoop%;
                
                'Can't max a 2-d array, have to loop to get max of each column                
                for iLoop% := 0 to recMaxDistractor%-1 do
                    tempmax%[iLoop%] := recTrialDistractor%[max(recTrialDistractor%[][iLoop%])][iLoop%];
                next

                if tempmax%[max(tempmax%)] <= recTotalDistractorStim% then
                    printlog("All distractor stimuli in trials file are accounted for in Distractor Stim or Stim/Cal file!\n");
                else
                    printlog("Maximum distractor stimulus in trials file is %d but not only %d stimuli are specified in Distractor Stim or Stim/Cal file!\n",tempmax%[max(tempmax%)],recTotalDistractorStim%);
                    message("Starting Over!|Trials File specifies illegal stimulus number!");
                    trialsOK% := -1;
                endif;
                
                'same thing for speaker
                ArrConst(tempmax%[],0);  'reset variable
                for iLoop% := 0 to recMaxDistractor%-1 do
                    tempmax%[iLoop%] := recTrialDistractorSpkr%[max(recTrialDistractorSpkr%[][iLoop%])][iLoop%];
                next
                if tempmax%[max(tempmax%)] <= recNSpeakers% then
                    printlog("All distractor speakers in trials file are present in array!\n");
                else
                    printlog("Maximum distractor speaker in trials file is %d but there are only %d speakers in the specified speaker array!\n",tempmax%[max(tempmax%)],recNSpeakers%);
                    message("Starting Over!|Trials File specifies illegal speaker number!");
                    trialsOK% := -1;
                endif;
            endif;
            
            'Make sure that all the stimuli in the Stim file actually exist, if loading
            if recMatGenStim% = 0 then
                tempglob% := 0;
                for iglob%:=0 to recTotalStim%-1 do
                    if tempglob% = 0 then  'this is because we can't break - and we don't want like 100 messages if all 100 stims don't exist
                        fhglob%:=fileopen(recTrialLoadLoc$[iglob%],9,0);
                        if fhglob%<0 then
                            message("Warning Message | Failed to load at least one stimulus waveform!");
                            printlog("Stim waveform %s failed to load!\n",recTrialLoadLoc$[iglob%]);
                            trialsOK% := -1;
                            'Can't BREAK prior to Spike2 v. 7.0!
                            tempglob% := 1;
                        endif;
                        fileclose();  'Close fhglob%, currently open file
                    endif;
                next;
                if recExpToRun% = recExpStereoDisButton% then  'Check distractors too
                    tempglob% := 0;
                    for iglob%:=0 to recTotalDistractorStim%-1 do
                        if tempglob% = 0 then  'this is because we can't break - and we don't want like 100 messages if all 100 stims don't exist
                            fhglob%:=fileopen(recTrialLoadLocDistractor$[iglob%],9,0);
                            if fhglob%<0 then
                                message("Warning Message | Failed to load at least one distractor stimulus waveform!");
                                printlog("Stim waveform %s failed to load!\n",recTrialLoadLocDistractor$[iglob%]);
                                trialsOK% := -1;
                                'Can't BREAK prior to Spike2 v. 7.0!
                                tempglob% := 1;
                            endif;
                            fileclose();  'Close fhglob%, currently open file
                        endif;
                    next;
                endif;
            endif;
        endif;
        
        
        'Only run the remainder of the experiment if the trials/stim files check out, otherwise jump back to original dialog
        docase
        case trialsOK% = -1 then
            'do nothing, error is already noted above
                        
        case trialsOK% = 0 then
            message("Failed to load trials file!");
            
        case stimOK% = 0 then
            message("Failed to load stim/stimcal file!");
            
        case stimOK% = -1 then
            message("Failed to load distractor stim/stimcal file!");    
            
        case calibOK% = 0 then
            message("Failed to load calibration file to Matlab workspace!");
            
        else
        
            'Run experiment-specific trial list generation
            'Do this prior to running the experiment for all exps
            'Note that recNTrials% will need to be set in all cases; it will need to be arbitrarily huge for Search
            docase 
            case recExpToRun% = recExpLongToneButton% then
                'do Trial List Generation stuff!
                result% := GenTrialsLongTone%();  'Generate trials for Long Tone.  Return result of 1 if OK, 0 if not.  Not sure how it's not OK.
            case recExpToRun% = recExpSearchButton% then
                'do Trial List Generation stuff!
                recSearchLoaded% := 0;  'reset variable to allow PWAs to be loaded only once for SEARCH
                recNTrials% := recMaxTrial%;  'Allow Search to run until experimenter stops it or the variable runs out
                if recDebug% > 0 then
                    recNTrials% := 10; 'testing
                endif;
                result% := GenTrialsSearch%();  'Generate trials for search.  Return result of 1 if OK, 0 if not.
                'recTrialOrder is set in GenTrialsSearch% because it should not be random for tone sweeps
                'note that recTrialOrder will then have to be set for EACH GenTrialsX%() call
                
                'message("SEARCH is not yet implemented!|I GUESS YOU WERE FOOLED!");  'debug placeholder
                
            case recExpToRun% = recExpCharButton% and recCharLoadStim% = 0 then
                'do Trial List Generation stuff!
                result% := GenTrialsFRAFromDialog%();  'Generate trials for FRA.  Return result of 1 if OK, 0 if not.
                
            case recExpToRun% = recExpCharButton% and (recCharLoadStim% = 2  or recCharLoadStim% = 4) then
                'do Trial List Generation stuff!   This fills variables for parallel PWAs
                result% := GenTrialsCharParallel%();  'Generate trials for, well, basically SigNoise (load) and SigNoise (gen) for now. Return result of 1 if OK, 0 if not.
                
            case recExpToRun% = recExpCharButton% and (recCharLoadStim% = 1 or recCharLoadStim% = 3 or recCharLoadStim% = 5) then
                'do Trial List Generation stuff!  This fills single-sound variables
                result% := GenTrialsCharSingle%();  'Generate trials for FRA (load), FRA (gen), and arbitrary stimulus load.  Return result of 1 if OK, 0 if not.    
                
            case recExpToRun% = recExpJoyTrnButton% then '*jao
                'do Trial List Generation stuff!
                recSearchLoaded% := 0;  'reset variable to allow PWAs to be loaded only once for SEARCH, or JoyTrain, because all the trials are the same!
                recNTrials% := recMaxTrial%;  'Allow Search to run until experimenter stops it or the variable runs out
                if recDebug% > 0 then
                    recNTrials% := 10; 'testing
                endif;
                result% := GenTrialsJoyTrain%();  'Generate trials for JoyTrain
                '*jao
                
            case recExpToRun% = recExpAMDiscButton% then
                'do Trial List Generation stuff!
                result% := GenTrialsDis%(recExpAMDiscButton%);  'Generate trials for AMDis   '*jao
                'message("AM DISC is not yet implemented!|I GUESS YOU WERE FOOLED!");  'debug placeholder
                
            case recExpToRun% = RecExpSpaceDisButton% then
                'do Trial List Generation stuff!
                printlog("attempting to do run Space dis, calling GenTrialsSpaceDis%()... \n"); '*jao
                result% := GenTrialsDis%(RecExpSpaceDisButton%);  'Generate trials for AMDis   '*jao
                
            case recExpToRun% = recExpCueingButton% then
                'do Trial List Generation stuff!
                message("CUEING is not yet implemented!|I GUESS YOU WERE FOOLED!");  'debug placeholder
                if recCEDIsPresent% = 1 then
                    recCEDIsPresent% := 2;  'Don't allow the GNGEngine to run, we will just run the Experiment Selection dialog again
                endif
                
            case recExpToRun% = recExpAudiogramButton% then
                'do Trial List Generation stuff!
                'message("AUDIOGRAM is not yet implemented!|I GUESS YOU WERE FOOLED!");  'debug placeholder
                result% := GenTrialsAudiogram%();  'Generate trials for Audiogram.  Return result of 1 if OK, 0 if not.
                
            case recExpToRun% = recExpStereoDisButton%  and recStereoDisExpDoFC% = 1 and recStereoDisExpDoLoad% = 1 then  'not implemented, but will exit before here
                'do Trial List Generation stuff!
                result% := GenTrialsStereoDis%();  'Generate trials for StereoDis.  Return result of 1 if OK, 0 if not.
                recUse2PWAs% := 1;
                
            case recExpToRun% = recExpStereoDisButton%  and recStereoDisExpDoGNG% = 1 and recStereoDisExpDoLoad% = 1 then  'not implemented, but will exit before here
                'do Trial List Generation stuff!
                result% := GenTrialsStereoDisGNG%();  'Generate trials for StereoDis.  Return result of 1 if OK, 0 if not. 
                recUse2PWAs% := 1;
                
            case recExpToRun% = recExpStereoDisButton%  and recStereoDisExpDoFC% = 1 and recStereoDisExpDoGen% = 1 then
                'do Trial List Generation stuff!
                result% := GenTrialsStereoDis%();  'Generate trials for StereoDis.  Return result of 1 if OK, 0 if not.
                recUse2PWAs% := 1;
                
            case recExpToRun% = recExpStereoDisButton%  and recStereoDisExpDoGNG% = 1 and recStereoDisExpDoGen% = 1 then  'not implemented, but will exit before here
                'do Trial List Generation stuff!
                'result% := GenTrialsStereoDisGNG%();  'Generate trials for StereoDis.  Return result of 1 if OK, 0 if not. 
                message("GNG StereoDis, generating stimuli is not yet implemented!|I GUESS YOU WERE FOOLED!");  'debug placeholder
                'recUse2PWAs% := 1;
                if recCEDIsPresent% = 1 then
                    recCEDIsPresent% := 2;  'Don't allow the GNGEngine to run, we will just run the Experiment Selection dialog again
                endif
                
            case recExpToRun% = recExpOneStimDiscrimButton%  and recOneStimDiscrimExpDoLoad% = 1 then 
                'do Trial List Generation stuff!
                result% := GenTrialsOneStimDiscrim%();  'Generate trials for OneStimDiscrim.  Return result of 1 if OK, 0 if not.
                
            case recExpToRun% = recExpOneStimDiscrimButton%  and recOneStimDiscrimExpDoGen% = 1 then
                'do Trial List Generation stuff!
                result% := GenTrialsOneStimDiscrim%();  'Generate trials for OneStimDiscrim.  Return result of 1 if OK, 0 if not.
                   
                
            endcase            
            recLastExpRun% := recExpToRun%; 'i think this should go here; remember the experiment that was just run for the next time around
            'Run presentation engine if CED is present or we are debugging
            if recCEDIsPresent% = 1 or recDebug% > 0 then
                'view(recLog%).print("About to call RunGoNoGoEngine%().\n");    
                'recReadyToQuit% := RunGoNoGoEngine%();  'will return 1 on fatal error
                view(recLog%).print("About to call RunEngine%().\n");    
                recReadyToQuit% := RunEngine%();  'will return 1 on fatal error
            endif;
            
            'Upon completion of engine, re-open experiment selection dialog (unless TDT error has occurred)
            'but on TDT error set recReadyToQuit% to 1
            'I don't think there's a lot of clean-up for the TDT.  Matlab clean-up is below, before the Halt
            
        endcase;
        
        
    else
        recReadyToQuit% := 1;  'If "Quit" is pressed on Experiment Selection dialog, then quit! 
    endif;
wend;

'If quit has been pressed on the experiment selection dialog, make sure sampling is stopped
' Stop sampling....
if recCEDIsPresent% >= 1 and recCurrentlySampling% = 1 then
    SafeSampleKey("K");  'Kill reward, just in case
    var retVal%;
    retval% := SampleStop();
    printlog("SampleStop returned %d\n",retVal%);
    view(recLog%).print("SampleStop returned %d\n",retVal%);
    if retVal% < 0 then
        printlog("Samplestop error is %s\n",Error$(retVal%));
        view(recLog%).print("Samplestop error is %s\n",Error$(retVal%));
    endif;
    
    View(recDataWindowView%);  'Explicitly set view
'    FileSaveAs(recFileSaveLoc$ + recMonkPrefix$ + ".smr", -1); 'Save data file automagically 
    FileSaveAs(recFileSaveLoc$ + recMonkPrefix$ + "_"+ Date$(2,2,3,3,"-")+ blockTag$ + ".smrx", -1); 'NEW FORMAT! add date automagically! 

endif;

CloseMatlab(matlabOpenSuccess%);  'close Matlab if it is open and we are quitting
fileclose(recLog%); 'close recLog!
halt;  'And get out of here!

'================================================================================================
'End Code Execution
'
'



'
'
'Local subfunctions
'================================================================================================







'===== GenTrialsJoyTrain ===== '*jao

func GenTrialsJoyTrain%()
'**check out GenTrialsSearch%() !!!
' or can I just use GenTrialsSearch and avoid needing a new function? what would need to change??
' technically this program will never get to make a sound so it shouldn't matter right?
    var status% := 1;
    
    if recShuffle% = 1 then
        ShuffleList%(recTrialOrder%[0:recNTrials%]);  'create a randpermed version of recTrialOrder (only valid indices), but not for tone sweep
    endif;
    return status%;  'right now, it "can't" fail
end;
'end GenTrialsJoyTrain%() '*jao



'
'
'===== GetLinearProgression =====

' Get a linear progression from xmin to xmax, through nsteps%. Assumed that vec[] has enough room!
Proc GetLinearProgression(xmin, xmax, nsteps%, vec[])
	var stepsize;
	var v;
	var i%:= 0;
	stepsize := (xmax -xmin)/nsteps%;
	for v := xmin to xmax+stepsize/2 step stepsize do
		'PrintLog("Value=" + str$(v) + "\n");
		vec[i%] := v;
		i% := i% + 1;
	next;
end;

'===== End GetLinearProgression =====
'
'




'
'
'===== GetLogProgression =====

' Get a log progression from xmin to xmax, through nsteps%. Assumed that vec[] has enough room!
Proc GetLogProgression(xmin, xmax, nsteps%, &vec[])
	var stepsize;
	var v;
	var i%:= 0;
	stepsize := (Ln(xmax) - Ln(xmin))/nsteps%;
	for v := Ln(xmin) to Ln(xmax)+stepsize/2 step stepsize do
		'PrintLog("Value[" + str$(i%) + "]=" + str$(Exp(v)) + "\n");
		vec[i%] := Exp(v);
		i% := i% + 1;
	next;
end;

'===== End GetLogProgression =====
'
'




'
'
'===== StringifyProgression2 =====

' Put a vector of numbers into a string
' Note that this version produces numbers rounded to nearest tenth, has space instead of comma separator
func StringifyProgression2$(n%, vec[], ind%[], rnd%)
	var s$;
	var i%;
	for i% := 0 to n%-1 do
		if i% > 0 then 
			s$ += " ";
		endif
        if rnd% = 0 then
            s$ += str$(round(vec[ind%[i%]]));   'Cannot use below method to round to whole number, alternate method is obvious
        else
            s$ += str$(vec[ind%[i%]],0,-rnd%);  'will round with rnd% digits after the decimal
        endif;
    next
	return s$;
end;

'===== End StringifyProgression2 =====
'
'



'
'
'===== RecSelectStimFile =====

func RecSelectStimFile%()

    var status% := 1;
    var direc$;
    var fh0%;
    
    direc$ := FilePath$();  'get current directory
    fh0%:=FileOpen(direc$+"*.txt",1,0,"Please select a stimulus file");  'Find a stim file
    direc$ := FileName$(0);  'Get full path of selected file
    FileClose(fh0%);  'Just close the file, we're not using it
    DlgValue$(2,direc$);  'Place filename into dialog item 2 of calling dialog
	return status%;  'return 1 so calling dialog doesn't close
    
end;

'===== End RecSelectStimFile =====
'
'


'
'
'===== RecSelectStimFile2 =====

func RecSelectStimFile2%()

    var status% := 1;
    var direc$;
    var fh0%;
    
    direc$ := FilePath$();  'get current directory
    fh0%:=FileOpen(direc$+"*.txt",1,0,"Please select a stimulus file");  'Find a stim file
    direc$ := FileName$(0);  'Get full path of selected file
    FileClose(fh0%);  'Just close the file, we're not using it
    DlgValue$(4,direc$);  'Place filename into dialog item 2 of calling dialog
	return status%;  'return 1 so calling dialog doesn't close
    
end;

'===== End RecSelectStimFile =====
'
'



'
'
'===== RecSelectTrialsFile =====

func RecSelectTrialsFile%()

    var status% := 1;
    var direc$;
    var fh0%;
    
    direc$ := FilePath$();  'get current directory
    fh0%:=FileOpen(direc$+"*.txt",1,0,"Please select a trials file");  'Find a trials file
    direc$ := FileName$(0);  'Get full path of selected file
    FileClose(fh0%);  'Just close the file, we're not using it
    DlgValue$(3,direc$);  'Place filename into dialog item 3 of calling dialog

	return status%;  'return 1 so calling dialog doesn't close
    
end;

'===== End RecSelectSTrialsFile =====
'
'



'
'
'===== RecVerifyInputFile =====
'RecVerifyInputFile is a function that opens up a potential input file and does some standard checks
'to make sure that it doesn't have any glaring mistakes that would make things go crashy.
'Notably, it makes sure that each line has the same number of fields and that each column is either
'consistently numeric or stringic.
'For now it returns the number of columns read, without regard to whether there are strings/numbers in
'any particular location.  As of now, the number of columns should be diagnostic of what type of file is
'being read, but this may change in the future.
'Updated to return a sensible error if file is not found! 4/8/2019 -jj
func RecVerifyInputFile%(fileIn$)
    
    var fh0%;
    var numRead%;
    var readLine$[50];  'maximum of 50 fields read
    var temp$;
    var keepGoing% := 1;
    var loopedOnce%;
    var lineLength%;
    var expectStr%[50];
    var i%;
    var nCh%;  'number of characters
    var lineCount%;
    
    'FileOpen will open a file dialog if the file-to-open is an empty string.  But it would be complicated to
    'determine the name of any file selected (should be some way to get it from fh0%, but...), communicate the
    'name back out for the actual read, and most importantly log the name of the file used.  If a registry entry
    'is blank it's probably best to just inform the user and try again - this will push them to fix the registry.
    if fileIn$ = "" then
        printlog("Requested input file name is blank!  This probably is the result of an empty registry entry.  Starting over!\n");
        message("Starting over!|Requested input file name is blank!");
        return -1;
    endif;
    
    'printlog("opening file %s \n", fileIn$);
    fh0%:=FileOpen(fileIn$,8,0);
    
    'Check for existence of file - nonexistence had previously thrown a "file does not have header line" error...!
    docase
    case fh0% = -1518 then
        printlog("File %s does not exist!  Failure to read!\n",fileIn$);
        message("Starting over!|File %s does not exist!",fileIn$);
        return -1;
    case fh0% < 0 then
        printlog("Unknown error in opening file %s!  Failure to read!\n",fileIn$);
        printlog("Error may be: %s\n",Error$(fh0%));
        message("Starting over!|Unknown error in opening file %s, check log for further details!",fileIn$);
        return -1;
    endcase
    
    
    'readsetup(""," ","","","	");
    readsetup(""," "+Chr$(9),"","","	");  'Making tab -- Chr$(9) -- a soft separator, so extra tabs for lining up rows will be skipped
    
    'check for obligatory header line
    numRead% := read(readLine$[0:49]);
    temp$ := readLine$[0];
        'printlog("reading in... %d %s \n", numRead%, temp$);
    docase
    case temp$ = "S1" then
        printlog("File %s appears to be a Trial file\n",fileIn$);
    case temp$ = "File Location" or temp$ = "File location" then  'this lower version should not be standard, but...
        printlog("File %s appears to be a Stim/Cal file\n",fileIn$);
    case temp$ = "Dur" then
        printlog("File %s appears to be a Tone/Noise/AM generation file\n",fileIn$);
    case temp$ = "DurMS" then
        printlog("File %s appears to be a Stimulus file\n",fileIn$);
    case temp$ = "Index" then
        printlog("File %s appears to be a Stimulus file with index column\n",fileIn$);
    else
        printlog("File %s does not appear to have a header line!  Failure to read!\n",fileIn$);
        message("Starting over!|File %s does not appear to have a header line!",fileIn$);
        return -1;
    endcase
    
    
    while keepGoing% do
        'Read the next line in the file, return line and number of fields read
        numRead% := read(readLine$[0:49]);
        lineCount% += 1;
        
        'On first time through, determine number of fields read and string/nonstring
        'pattern of the first line - all subsequent lines should match
        docase
        case loopedOnce% = 0 then
            lineLength% := numRead%;
            for i% := 0 to numRead%-1 do
                val(readLine$[i%],nCh%);  'nCh% will be 0 if no number is read
                if nCh% = 0 then
                    expectStr%[i%] := 0;
                else
                    expectStr%[i%] := 1;
                endif;
            next;
            loopedOnce% := 1;  'don't do this step again
        case numRead% >= 0 then
            if numRead% <> lineLength% then
                message("Expected line length is "+str$(lineLength%)+" but on line "+str$(lineCount%)+" length is "+str$(numRead%));
                printlog("Expected line length is "+str$(lineLength%)+" but on line "+str$(lineCount%)+" length is "+str$(numRead%)+"\n");
                fileclose();  'close fh0%, the currently open file
                return -1;
            endif;
            for i% := 0 to numRead%-1 do
                val(readLine$[i%],nCh%);  'nCh% will be 0 if no number is read
                if nCh% > 1 then 'nCh% will be 1 if any number is read
                    nCh% := 1;
                endif;
                if expectStr%[i%] <> nCh% then
                    message("String/number mismatch in column "+str$(i%+1)+" of line "+str$(lineCount%));
                    printlog("String/number mismatch in column "+str$(i%+1)+" of line "+str$(lineCount%)+"\n");
                    fileclose();  'close fh0%, the currently open file
                    return -1;
                endif;
            next;
        case numRead%<0 then
            keepGoing% := 0;   
        endcase;    
    wend;    
    
    fileclose();  'close fh0%, the currently open file
    
    printlog("Successfully read file %s, contained %d lines with %d columns!\n",fileIn$,lineCount%-1,lineLength%);
    
    return lineLength%;    '3: "trials" file, S1 only, used for FRA/Characterization
                           '6: "trials" file, standard S1/S2
                           '9: "trials" file, includes a "distractor" stimulus
                           '11: generate "stim" file
                           '12: generate "stim" file with row ("Stimulus") numbers
                           '15: "calibration" file, 15-speaker array
                           '16: "calibration" file, 16-speaker array
                           '17: load "stim/cal" file 15-speaker array
                           '18: load "stim/cal" file 16-speaker array
                           '22: "trials" file, for distractor GNG experiment
                           '31: "calibration" file, both 15-speaker AND 16-speaker array
                           '33: load "stim/cal" file both 15-speaker AND 16-speaker array
end

'===== End RecVerifyInputFile =====
'
'




'
'
'===== RecLoadTrialsFile =====
func RecLoadTrialsFile%(fileLoc$,&totalTrials%)
    
    
    var status%;
    var lineCount%;
    var keepGoing% := 1;
    var numRead%;
    var readLine$[7];
    var fh0%;
    
    status% := 0;  'begin with "failure", change to success if success
    
    printlog("Loading Trial File: %s\n",fileLoc$);
    
    'First, make sure the file won't barf on us
    numRead% := RecVerifyInputFile%(fileLoc$);
    if numRead% <> 6 then
        if numRead% = -1 then
            message("Starting over!|Failure to read trials file!");
        else
            message("Starting over!|Incorrect number of fields in trials file (expected 6 fields, got "+Str$(numRead%)+")!");
        endif
        return status%;  'returns failure
    endif;
        
    'Then read the file
    fh0%:=FileOpen(fileLoc$,8,0);
    
    'readsetup(""," ","","","	");
    readsetup(""," "+Chr$(9),"","","	");  'Making tab -- Chr$(9) -- a soft separator, so extra tabs for lining up rows will be skipped
    
    'Skip past the header line
    numRead% := read(readLine$[0:7]);
    
    while keepGoing% do
        'Read the next line in the file, return line and number of fields read
        numRead% := read(readLine$[0:7]);  'reading as many as seven lines as a check - if seven successfully read, something is wrong with the file
        lineCount% += 1;
        
        'Place values into global variables
        docase
        case numRead% = 6 then
            recTrialS1%[lineCount%-1] := val(readLine$[0]);
            recTrialS2%[lineCount%-1] := val(readLine$[1]);
            recTrialS1Spkr%[lineCount%-1] := val(readLine$[2]);
            recTrialS2Spkr%[lineCount%-1] := val(readLine$[3]);
            recTrialS1DeltadB[lineCount%-1] := val(readLine$[4]);
            recTrialS2DeltadB[lineCount%-1] := val(readLine$[5]);
        case numRead%<0 then
            keepGoing% := 0;
            totalTrials% := lineCount%-1;  'set to return the number of lines read, this will be useful
            status% := 1;  'not sure that will work with the other logic
        else
            message("Starting over!|Failure to successfully read file with six fields despite initial check!");
            keepGoing% := 0;
        endcase;    
    wend;    
    
    fileclose();  'close fh0%, the currently open file
    
    'Just some debugging code, correct read is verified
'    printlog("Column 1 was %d\n",recTrialS1%[]);
'    printlog("Column 2 was %d\n",recTrialS2%[]);
'    printlog("Column 3 was %d\n",recTrialS1Spkr%[]);
'    printlog("Column 4 was %d\n",recTrialS2Spkr%[]);
'    printlog("Column 5 was %f\n",recTrialS1DeltadB[]);
'    printlog("Column 6 was %f\n",recTrialS2DeltadB[]);
    
    return status%;
    
end
'===== End RecLoadTrialsFile =====
'
'



'
'
'===== RecLoadTrialsFile3Col =====
func RecLoadTrialsFile3Col%(fileLoc$,&totalTrials%)
    'This function expects a trials file with only 3 columns: S1, S1Spkr, S1dB
    
    var status%;
    var lineCount%;
    var keepGoing% := 1;
    var numRead%;
    var readLine$[4];
    var fh0%;
    
    status% := 0;  'begin with "failure", change to success if success
    
    printlog("Loading Trial File: %s\n",fileLoc$);
    
    'First, make sure the file won't barf on us
    numRead% := RecVerifyInputFile%(fileLoc$);
    if numRead% <> 3 then
        if numRead% = -1 then
            message("Starting over!|Failure to read trials file!");
        else
            message("Starting over!|Incorrect number of fields in trials file (expected 3 fields, got "+Str$(numRead%)+")!");
        endif
        return status%;  'returns failure
    endif;
        
    'Then read the file
    fh0%:=FileOpen(fileLoc$,8,0);
    
    'readsetup(""," ","","","	");
    readsetup(""," "+Chr$(9),"","","	");  'Making tab -- Chr$(9) -- a soft separator, so extra tabs for lining up rows will be skipped
    
    'Skip past the header line
    numRead% := read(readLine$[0:4]);
    
    while keepGoing% do
        'Read the next line in the file, return line and number of fields read
        numRead% := read(readLine$[0:4]);  'reading as many as four columns as a check - if four successfully read, something is wrong with the file
        lineCount% += 1;
        
        'Place values into global variables
        docase
        case numRead% = 3 then
            recTrialS1%[lineCount%-1] := val(readLine$[0]);
            recTrialS1Spkr%[lineCount%-1] := val(readLine$[1]);
            recTrialS1DeltadB[lineCount%-1] := val(readLine$[2]);
        case numRead%<0 then
            keepGoing% := 0;
            totalTrials% := lineCount%-1;  'set to return the number of lines read, this will be useful
            status% := 1;  'not sure that will work with the other logic
        else
            message("Starting over!|Failure to successfully read file with three fields despite initial check!");
            keepGoing% := 0;
        endcase;    
    wend;    
    
    fileclose();  'close fh0%, the currently open file
    
    return status%;
    
end
'===== End RecLoadTrialsFile3Col =====
'
'


'
'
'===== RecLoadTrialsFile6ColOr3Col =====
func RecLoadTrialsFile6ColOr3Col%(fileLoc$,&totalTrials%)
'the idea here is that for some characterization experiments, we have the "old" 6-column trials files (even though
'we weren't using the other column) and in the future (particularly for doing calibration) a 3-column file will be
'more convenient, but we don't want to have to make a whole separate GUI category for the two, this will let us do
'either
    
    var status%;
    var lineCount%;
    var keepGoing% := 1;
    var numRead%;
    var readLine$[7];
    var fh0%;
    
    status% := 0;  'begin with "failure", change to success if success
    
    printlog("Loading Trial File: %s\n",fileLoc$);
    
    'First, make sure the file won't barf on us
    numRead% := RecVerifyInputFile%(fileLoc$);
    if numRead% <> 6 and numRead% <> 3 then
        if numRead% = -1 then
            message("Starting over!|Failure to read trials file!");
        else
            message("Starting over!|Incorrect number of fields in trials file (expected 3 or 6 fields, got "+Str$(numRead%)+")!");
        endif
        return status%;  'returns failure
    endif;
        
    'Then read the file
    fh0%:=FileOpen(fileLoc$,8,0);
    
    'readsetup(""," ","","","	");
    readsetup(""," "+Chr$(9),"","","	");  'Making tab -- Chr$(9) -- a soft separator, so extra tabs for lining up rows will be skipped
    
    'Skip past the header line
    numRead% := read(readLine$[0:7]);
    
    while keepGoing% do
        'Read the next line in the file, return line and number of fields read
        numRead% := read(readLine$[0:7]);  'reading as many as seven lines as a check - if seven successfully read, something is wrong with the file
        lineCount% += 1;
        
        'Place values into global variables
        docase
        case numRead% = 6 then
            recTrialS1%[lineCount%-1] := val(readLine$[0]);
            recTrialS2%[lineCount%-1] := val(readLine$[1]);
            recTrialS1Spkr%[lineCount%-1] := val(readLine$[2]);
            recTrialS2Spkr%[lineCount%-1] := val(readLine$[3]);
            recTrialS1DeltadB[lineCount%-1] := val(readLine$[4]);
            recTrialS2DeltadB[lineCount%-1] := val(readLine$[5]);
        case numRead% = 3 then
            recTrialS1%[lineCount%-1] := val(readLine$[0]);
            recTrialS2%[lineCount%-1] := 0;
            recTrialS1Spkr%[lineCount%-1] := val(readLine$[1]);
            recTrialS2Spkr%[lineCount%-1] := 0;
            recTrialS1DeltadB[lineCount%-1] := val(readLine$[2]);
            recTrialS2DeltadB[lineCount%-1] := 0;
        case numRead%<0 then
            keepGoing% := 0;
            totalTrials% := lineCount%-1;  'set to return the number of lines read, this will be useful
            status% := 1;  'not sure that will work with the other logic
        else
            message("Starting over!|Failure to successfully read file with three or six fields despite initial check!");
            keepGoing% := 0;
        endcase;    
    wend;    
    
    fileclose();  'close fh0%, the currently open file
    
    'Just some debugging code, correct read is verified
'    printlog("Column 1 was %d\n",recTrialS1%[]);
'    printlog("Column 2 was %d\n",recTrialS2%[]);
'    printlog("Column 3 was %d\n",recTrialS1Spkr%[]);
'    printlog("Column 4 was %d\n",recTrialS2Spkr%[]);
'    printlog("Column 5 was %f\n",recTrialS1DeltadB[]);
'    printlog("Column 6 was %f\n",recTrialS2DeltadB[]);
    
    return status%;
    
end
'===== End RecLoadTrialsFile6ColOr3Col =====
'
'






'
'
'===== RecLoadTrialsFile9 =====
func RecLoadTrialsFile9%(fileLoc$,&totalTrials%)
    'a 9-column version of RecLoadTrialsFile, includes distractor stimulus
    
    
    var status%;
    var lineCount%;
    var keepGoing% := 1;
    var numRead%;
    var readLine$[10];
    var fh0%;
    
    status% := 0;  'begin with "failure", change to success if success
    
    printlog("Loading Trial File: %s\n",fileLoc$);
    
    'First, make sure the file won't barf on us
    numRead% := RecVerifyInputFile%(fileLoc$);
    if numRead% <> 9 then
        if numRead% = -1 then
            message("Starting over!|Failure to read trials file!");
        else
            message("Starting over!|Incorrect number of fields in trials file (expected 9 fields, got "+Str$(numRead%)+")!");
        endif
        return status%;  'returns failure
    endif;
        
    'Then read the file
    fh0%:=FileOpen(fileLoc$,8,0);
    
    'readsetup(""," ","","","	");
    readsetup(""," "+Chr$(9),"","","	");  'Making tab -- Chr$(9) -- a soft separator, so extra tabs for lining up rows will be skipped
    
    'Skip past the header line
    numRead% := read(readLine$[0:9]);
    
    while keepGoing% do
        'Read the next line in the file, return line and number of fields read
        numRead% := read(readLine$[0:10]);  'reading as many as ten lines as a check - if ten successfully read, something is wrong with the file
        lineCount% += 1;
        
        'Place values into global variables
        docase
        case numRead% = 9 then
            recTrialS1%[lineCount%-1] := val(readLine$[0]);
            recTrialS2%[lineCount%-1] := val(readLine$[1]);
            recTrialDistractor%[lineCount%-1][1] := val(readLine$[2]);  'loading into index 1, index 0 will remain zeros as there is no distractor for S1
            recTrialS1Spkr%[lineCount%-1] := val(readLine$[3]);
            recTrialS2Spkr%[lineCount%-1] := val(readLine$[4]);
            recTrialDistractorSpkr%[lineCount%-1][0] := val(readLine$[5]);  'here, loading a "dummy" value into index 0, should not be used but putting it in just in case as 0 is not a legal speaker value
            recTrialDistractorSpkr%[lineCount%-1][1] := val(readLine$[5]);
            recTrialS1DeltadB[lineCount%-1] := val(readLine$[6]);
            recTrialS2DeltadB[lineCount%-1] := val(readLine$[7]);
            recTrialDistractorDeltadB[lineCount%-1][1] := val(readLine$[8]);  'loading into index 1, index 0 will remain zeros as there is no distractor for S1
        case numRead%<0 then
            keepGoing% := 0;
            totalTrials% := lineCount%-1;  'set to return the number of lines read, this will be useful
            status% := 1;  'not sure that will work with the other logic
        else
            message("Starting over!|Failure to successfully read file with nine fields despite initial check!");
            keepGoing% := 0;
        endcase;    
    wend;    
    
    fileclose();  'close fh0%, the currently open file
    
    return status%;
    
end
'===== End RecLoadTrialsFile9 =====
'
'


'
'
'===== RecLoadTrialsFile22 =====
func RecLoadTrialsFile22%(fileLoc$,&totalTrials%)
    'a 22-column version of RecLoadTrialsFile, includes distractor stimulus
    
    
    var status%;
    var lineCount%;
    var keepGoing% := 1;
    var numRead%;
    var readLine$[23];
    var fh0%;
    var tempDist%;
    var tempDistSpkr%;
    var tempDistddB;
    
    status% := 0;  'begin with "failure", change to success if success
    
    printlog("Loading Trial File: %s\n",fileLoc$);
    
    'First, make sure the file won't barf on us
    numRead% := RecVerifyInputFile%(fileLoc$);
    if numRead% <> 22 then
        if numRead% = -1 then
            message("Starting over!|Failure to read trials file!");
        else
            message("Starting over!|Incorrect number of fields in trials file (expected 22 fields, got "+Str$(numRead%)+")!");
        endif
        return status%;  'returns failure
    endif;
        
    'Then read the file
    fh0%:=FileOpen(fileLoc$,8,0);
    
    'readsetup(""," ","","","	");
    readsetup(""," "+Chr$(9),"","","	");  'Making tab -- Chr$(9) -- a soft separator, so extra tabs for lining up rows will be skipped
    
    'Skip past the header line
    numRead% := read(readLine$[0:7]);
    
    while keepGoing% do
        'Read the next line in the file, return line and number of fields read
        numRead% := read(readLine$[0:23]);  'reading as many as 23 lines as a check - if 23 successfully read, something is wrong with the file
        lineCount% += 1;
        
        'Place values into global variables
        docase
        case numRead% = 22 then
            'read in the first ten values, have to hold the final distractor values in temp, will place at end later
            recTrialS1%[lineCount%-1] := val(readLine$[0]);
            recTrialS2%[lineCount%-1] := val(readLine$[1]);
            'recTrialDistractor%[lineCount%-1] := val(readLine$[2]);
            tempDist% := val(readLine$[2]);  'Hold this in temp, because we don't know how many S1.ns we have yet
            recTrialS1Spkr%[lineCount%-1] := val(readLine$[3]);
            recTrialS2Spkr%[lineCount%-1] := val(readLine$[4]);
            'recTrialDistractorSpkr%[lineCount%-1] := val(readLine$[5]);
            tempDistSpkr% := val(readLine$[5]);  'Hold this in temp, because we don't know how many S1.ns we have yet
            recTrialS1DeltadB[lineCount%-1] := val(readLine$[6]);
            recTrialS2DeltadB[lineCount%-1] := val(readLine$[7]);
            'recTrialDistractorDeltadB[lineCount%-1] := val(readLine$[8]);
            tempDistddB := val(readLine$[8]);  'Hold this in temp, because we don't know how many S1.ns we have yet
            recTrialNumS1ns%[lineCount%-1] := val(readLine$[9]);  'The S1 "counts" as an S1.n, so this will be between 1-5
            
            'read in the variable distractors
            recTrialDistractor%[lineCount%-1][1] := val(readLine$[10]);  'Do not fill recTrialDistractor%[xxx][0], no distractor for first S1
            recTrialDistractor%[lineCount%-1][2] := val(readLine$[11]);
            recTrialDistractor%[lineCount%-1][3] := val(readLine$[12]);
            recTrialDistractor%[lineCount%-1][4] := val(readLine$[13]);
            
            recTrialDistractorSpkr%[lineCount%-1][1] := val(readLine$[14]);
            recTrialDistractorSpkr%[lineCount%-1][2] := val(readLine$[15]);
            recTrialDistractorSpkr%[lineCount%-1][3] := val(readLine$[16]);
            recTrialDistractorSpkr%[lineCount%-1][4] := val(readLine$[17]);
            
            recTrialDistractorDeltadB[lineCount%-1][1] := val(readLine$[18]);
            recTrialDistractorDeltadB[lineCount%-1][2] := val(readLine$[19]);
            recTrialDistractorDeltadB[lineCount%-1][3] := val(readLine$[20]);
            recTrialDistractorDeltadB[lineCount%-1][4] := val(readLine$[21]);
            
            'copy final distractor into correct location, may overwrite "-1"s
            recTrialDistractor%[lineCount%-1][recTrialNumS1ns%[lineCount%-1]] := tempDist%;
            recTrialDistractorSpkr%[lineCount%-1][recTrialNumS1ns%[lineCount%-1]] := tempDistSpkr%;
            recTrialDistractorSpkr%[lineCount%-1][0] := recTrialDistractorSpkr%[lineCount%-1][1]; 'Put a legal value (next distractor speaker) into index 0, should not be used, but just in case
            recTrialDistractorDeltadB[lineCount%-1][recTrialNumS1ns%[lineCount%-1]] := tempDistddB;
            
        case numRead%<0 then
            keepGoing% := 0;
            totalTrials% := lineCount%-1;  'set to return the number of lines read, this will be useful
            status% := 1;  'not sure that will work with the other logic
        else
            printlog("Number of fields read is %d\n",numRead%);
            message("Starting over!|Failure to successfully read file with 22 fields despite initial check!");
            keepGoing% := 0;
        endcase;    
    wend;    
    
    fileclose();  'close fh0%, the currently open file
    
    return status%;
    
end
'===== End RecLoadTrialsFile22 =====
'
'





'
'
'===== RecLoadStimCalFile =====
func RecLoadStimCalFile%(fileLoc$,nSpk%,&recTotalStim%)
    

    var status%;
    var lineCount%;
    var keepGoing% := 1;
    var numRead%;
    var readLine$[34];
    var fh0%;
    var i%;
    
    status% := 0;  'begin with "failure", change to success if success
    
    printlog("Loading Stim/Cal File: %s\n",fileLoc$);
    
        
    'First, make sure the file won't barf on us
    numRead% := RecVerifyInputFile%(fileLoc$);
    if numRead% <> nSpk%+2 then
        if numRead% = -1 then
            message("Starting over!|Failure to read Stim/Cal file!");
        else
            message("Starting over!|Incorrect number of fields in Stim/Cal file (expected "+Str$(nSpk%+2)+" fields, got "+Str$(numRead%)+")!");
        endif
        return status%;  'returns failure
    endif;
        
    'Then read the file
    fh0%:=FileOpen(fileLoc$,8,0);
    
    'readsetup(""," ","","","	");
    readsetup(""," "+Chr$(9),"","","	");  'Making tab -- Chr$(9) -- a soft separator, so extra tabs for lining up rows will be skipped
    
    'Skip past the header line
    numRead% := read(readLine$[0:34]);
    
    while keepGoing% do
        'Read the next line in the file, return line and number of fields read
        numRead% := read(readLine$[0:34]);  'reading as many as 34 lines as a check - if 34 successfully read, something is wrong with the file
        lineCount% += 1;
        
        'Place values into global variables
        docase
        case numRead% = nSpk%+2 then
            recTrialLoadLoc$[lineCount%-1] := readLine$[0];  'Disk location of files to load, stim/cal file
            recTrialStimDur[lineCount%-1] := val(readLine$[1]);  'Stimulus duration
            for i% := 0 to nSpk%-1 do
                recTrialStimCal[lineCount%-1][i%] := val(readLine$[i%+2]);  'Calibration values per speaker
            next; 
        case numRead%<0 then 'quit at end of file
            keepGoing% := 0;
            lineCount% -= 1;  'Decrement to get correct count on EOF
            status% := 1;
        else
            message("Starting over!|Failure to successfully read file with "+Str$(nSpk%+2)+" fields despite initial check!");
            printlog("Failure to successfully read file with %d fields despite initial check!\n",nSpk%+2);
            keepGoing% := 0;
        endcase;    
    wend;    
    
    fileclose();  'close fh0%, the currently open file
    
    recTotalStim% := lineCount%;
    
    'Just some debugging code, correct read is verified
'    printlog("Column 1 was %s\n",recTrialLoadLoc$[]);
'    printlog("Column 2 was %f\n",recTrialStimDur[]);
'    printlog("Column 3 was %f\n",recTrialStimCal[][0]);
'    printlog("Column 4 was %f\n",recTrialStimCal[][1]);
'    printlog("Column 5 was %f\n",recTrialStimCal[][2]);
'    printlog("Column 6 was %f\n",recTrialStimCal[][3]);
'    printlog("Column 7 was %f\n",recTrialStimCal[][4]);
'    printlog("Column 8 was %f\n",recTrialStimCal[][5]);
'    printlog("Column 9 was %f\n",recTrialStimCal[][6]);
'    printlog("Column 10 was %f\n",recTrialStimCal[][7]);
'    printlog("Column 11 was %f\n",recTrialStimCal[][8]);
'    printlog("Column 12 was %f\n",recTrialStimCal[][9]);
'    printlog("Column 13 was %f\n",recTrialStimCal[][10]);
'    printlog("Column 14 was %f\n",recTrialStimCal[][11]);
'    printlog("Column 15 was %f\n",recTrialStimCal[][12]);
'    printlog("Column 16 was %f\n",recTrialStimCal[][13]);
'    printlog("Column 17 was %f\n",recTrialStimCal[][14]);
'    printlog("Column 18 was %f\n",recTrialStimCal[][15]);
'    printlog("Column 19 was %f\n",recTrialStimCal[][16]);
    
    return status%;
    
end
'===== End RecLoadStimCalFile =====
'
'



'
'
'===== RecLoadStimCalMFCarrierFile =====
func RecLoadStimCalMFCarrierFile%(fileLoc$,nSpk%,&recTotalStim%)
'These files by definition have two additional columns, Modulation Frequency and Carrier Type$, following Duration column   

    var status%;
    var lineCount%;
    var keepGoing% := 1;
    var numRead%;
    var readLine$[34];
    var fh0%;
    var i%;
    
    status% := 0;  'begin with "failure", change to success if success
    
    printlog("Loading Stim/Cal w/MF&Carrier File: %s\n",fileLoc$);
        
    'First, make sure the file won't barf on us
    numRead% := RecVerifyInputFile%(fileLoc$);
    if numRead% <> nSpk%+4 then
        if numRead% = -1 then
            message("Starting over!|Failure to read Stim/Cal file!");
        else
            message("Starting over!|Incorrect number of fields in Stim/Cal file (expected "+Str$(nSpk%+2)+" fields, got "+Str$(numRead%)+")!");
        endif
        return status%;  'returns failure
    endif;
        
    'Then read the file
    fh0%:=FileOpen(fileLoc$,8,0);
    
    'readsetup(""," ","","","	");
    readsetup(""," "+Chr$(9),"","","	");  'Making tab -- Chr$(9) -- a soft separator, so extra tabs for lining up rows will be skipped
    
    'Skip past the header line
    numRead% := read(readLine$[0:34]);
    
    while keepGoing% do
        'Read the next line in the file, return line and number of fields read
        numRead% := read(readLine$[0:34]);  'reading as many as 34 lines as a check - if 34 successfully read, something is wrong with the file
        lineCount% += 1;
        
        'Place values into global variables
        docase
        case numRead% = nSpk%+4 then
            recTrialLoadLoc$[lineCount%-1] := readLine$[0];  'Disk location of files to load, stim/cal file
            recTrialStimDur[lineCount%-1] := val(readLine$[1]);  'Stimulus duration
            recTrialMF[lineCount%-1] := val(readLine$[2]);   'Modulation frequency
            recTrialCarrier$[lineCount%-1] := readLine$[3];  'Carrier type
            for i% := 0 to nSpk%-1 do
                recTrialStimCal[lineCount%-1][i%] := val(readLine$[i%+4]);  'Calibration values per speaker
            next; 
        case numRead%<0 then 'quit at end of file
            keepGoing% := 0;
            lineCount% -= 1;  'Decrement to get correct count on EOF
            status% := 1;
        else
            message("Starting over!|Failure to successfully read file with "+Str$(nSpk%+2)+" fields despite initial check!");
            printlog("Failure to successfully read file with %d fields despite initial check!\n",nSpk%+2);
            keepGoing% := 0;
        endcase;    
    wend;    
    
    fileclose();  'close fh0%, the currently open file
    
    recTotalStim% := lineCount%;
    
    return status%;
    
end
'===== End RecLoadStimCalMFCarrierFile =====
'
'



'
'
'===== RecLoadStimCalDistractorFile =====
func RecLoadStimCalDistractorFile%(fileLoc$,nSpk%,&recTotalStim%)
'These files by definition have two additional columns, Modulation Frequency and Carrier Type$, following Duration column

    var status%;
    var lineCount%;
    var keepGoing% := 1;
    var numRead%;
    var readLine$[34];
    var fh0%;
    var i%;
    
    status% := 0;  'begin with "failure", change to success if success
    
    printlog("Loading Distractor Stim/Cal w/MF&Carrier File: %s\n",fileLoc$);
        
    'First, make sure the file won't barf on us
    numRead% := RecVerifyInputFile%(fileLoc$);
    if numRead% <> nSpk%+4 then  'here there are four extra columns, file location$, duration, MF, carrier type$
        if numRead% = -1 then
            message("Starting over!|Failure to read Stim/Cal file!");
        else
            message("Starting over!|Incorrect number of fields in Stim/Cal file (expected "+Str$(nSpk%+2)+" fields, got "+Str$(numRead%)+")!");
        endif
        return status%;  'returns failure
    endif;
        
    'Then read the file
    fh0%:=FileOpen(fileLoc$,8,0);
    
    'readsetup(""," ","","","	");
    readsetup(""," "+Chr$(9),"","","	");  'Making tab -- Chr$(9) -- a soft separator, so extra tabs for lining up rows will be skipped
    
    'Skip past the header line
    numRead% := read(readLine$[0:34]);
    
    while keepGoing% do
        'Read the next line in the file, return line and number of fields read
        numRead% := read(readLine$[0:34]);  'reading as many as 34 lines as a check - if 34 successfully read, something is wrong with the file
        lineCount% += 1;
        
        'Place values into global variables
        docase
        case numRead% = nSpk%+4 then
            recTrialLoadLocDistractor$[lineCount%-1] := readLine$[0];  'Disk location of files to load, stim/cal file
            recTrialDurDistractor[lineCount%-1] := val(readLine$[1]);  'Trial duration
            recTrialMFDistractor[lineCount%-1] := val(readLine$[2]);   'Modulation frequency
            recTrialCarrierDistractor$[lineCount%-1] := readLine$[3];  'Carrier type
            for i% := 0 to nSpk%-1 do
                recTrialStimCalDistractor[lineCount%-1][i%] := val(readLine$[i%+4]);  'Calibration values per speaker
            next; 
        case numRead%<0 then 'quit at end of file
            keepGoing% := 0;
            lineCount% -= 1;  'Decrement to get correct count on EOF
            status% := 1;
        else
            message("Starting over!|Failure to successfully read file with "+Str$(nSpk%+2)+" fields despite initial check!");
            printlog("Failure to successfully read file with %d fields despite initial check!\n",nSpk%+2);
            keepGoing% := 0;
        endcase;    
    wend;    
    
    fileclose();  'close fh0%, the currently open file
    
    recTotalStim% := lineCount%;
    
    return status%;
    
end
'===== End RecLoadStimCalDistractorFile =====
'
'





'
'
'===== RecLoadStimFile =====
func RecLoadStimFile%(fileLoc$,&recTotalStim%)
    'Added optional Stimulus Index column as first column 8/30/23 jj
    'The idea here is that it can be convenient for the construction
    'of the trials file to have "index gaps" (e.g. in some cases this
    'allows "similar" stimuli to have identical 2-digit indices but
    'to vary in a particular stimulus property in the "hundreds" 
    'digit).  Since the stimulus property variables currently are
    '5000 elements in length, there should be plenty of room for 
    '"blanks" in the variables.  If the Stimulus Index column is not
    'present, stimulus index will be taken as the sequential row
    'number, starting from 0 (the prior default behavior).

    var status%;
    var lineCount%;
    var keepGoing% := 1;
    var numRead%;
    var readLine$[13];
    var fh0%;
    var stimIndex%;
    
    status% := 0;  'begin with "failure", change to success if success
    
    printlog("Loading Stim File: %s\n",fileLoc$);

    'First, make sure the file won't barf on us
    numRead% := RecVerifyInputFile%(fileLoc$);
    PrintLog("numRead is: %d \n", numRead%);
    if numRead% < 11 or numRead% > 12 then   'expect 11 (no stim index column) or 12 (with stim index column)
        if numRead% = -1 then
            message("Starting over!|Failure to read Tone/Noise/AM generation file!");
        else
            message("Starting over!|Incorrect number of fields in Tone/Noise/AM generation file (expected 11 or 12 fields, got "+Str$(numRead%)+")!");
        endif
        return status%;  'returns failure
    endif;
        
    'Then read the file
    fh0%:=FileOpen(fileLoc$,8,0);
    
    'readsetup(""," ","","","	");
    readsetup(""," "+Chr$(9),"","","	");  'Making tab -- Chr$(9) -- a soft separator, so extra tabs for lining up rows will be skipped
    
    'Skip past the header line
    numRead% := read(readLine$[0:13]);
    
    while keepGoing% do
        'Read the next line in the file, return line and number of fields read
        numRead% := read(readLine$[0:13]);  'reading as many as 13 lines as a check - if 13 successfully read, something is wrong with the file
        lineCount% += 1;
        
        'Place values into global variables
        docase
        case numRead% = 11 then
            recStimPresent%[lineCount%-1] := lineCount%-1;                 'Keep this to check trials
            recTrialStimDur[lineCount%-1] := val(readLine$[0]);            'Stimulus duration
            recTrialGenLowpassHz[lineCount%-1] := val(readLine$[1]);       'A list of lowpass values - if -1, no lowpass, same as highpass means tone
            recTrialGenHighpassHz[lineCount%-1] := val(readLine$[2]);      'Same as above, highpass
            recTrialGenIsSweep[linecount%-1] := val(readLine$[3]);         'Determines if FM sweep is present
            recTrialGenAMFreqHz[lineCount%-1] := val(readLine$[4]);        'A list of AM frequency values, if 0 no AM
            recTrialGenAMDepthPct[lineCount%-1] := val(readLine$[5]);      'A list of AM depth values in percent, if 0 no depth
            recTrialGenAMPhaseDeg[lineCount%-1] := val(readLine$[6]);      'A list of AM phases, 0 = AM starts low, 90 = AM starts middle and rising, 180 = AM starts high, 270 = AM starts middle, falling
            recTrialGenTonePhaseDeg[lineCount%-1] := val(readLine$[7]);    'A list of tone phases, 0 = tone starts middle, rising (sine phase), 90 = tone starts high (cosine phase), note different than AM phase, only used for tone, not noise
            recTrialGenGauss%[lineCount%-1] := val(readLine$[8]);          'If 1 create Gaussian noise, if 0 create uniform noise
            recTrialGenRampMS[lineCount%-1] := val(readLine$[9]);          'Duration in ms of front/back ramp, ramp is 1-Cos^2
            recTrialGenSeed%[lineCount%-1] := val(readLine$[10]);          'Seed for random number generator, 0 = unspecified, will make own random number
            
            'this is a bit weird, we're just putting the same value into a different variable (could have assigned val(readLine$[4]) again...)
            recTrialMF[lineCount%-1] := recTrialGenAMFreqHz[lineCount%-1]; 'For whatever reason, this value is used in GenTrialsStereoDis%(), and other than adding this I don't have to change it to make it work for generating stims
            if recTrialGenIsSweep[linecount%-1] = 4 then
                recTrialMF2[lineCount%-1] := recTrialGenAMPhaseDeg[lineCount%-1];  'And assign second modulation frequency if this is an AM/FM stimulus
                if recTrialGenTonePhaseDeg[lineCount%-1] < 0 then  'negative values indicate a sweep gap
                    recTrialSweepGap[lineCount%-1] := -recTrialGenTonePhaseDeg[lineCount%-1];  
                else  'positive values indicate an intensity
                    recTrialSweepIntensity[lineCount%-1] := recTrialGenTonePhaseDeg[lineCount%-1];
                endif
            endif
        case numRead% = 12 then
            stimIndex% := val(readLine$[0]);                             'Stimulus index
            recStimPresent%[lineCount%-1] := stimIndex%;                 'Keep this to check trials
            recTrialStimDur[stimIndex%] := val(readLine$[1]);            'Stimulus duration
            recTrialGenLowpassHz[stimIndex%] := val(readLine$[2]);       'A list of lowpass values - if -1, no lowpass, same as highpass means tone
            recTrialGenHighpassHz[stimIndex%] := val(readLine$[3]);      'Same as above, highpass
            recTrialGenIsSweep[stimIndex%] := val(readLine$[4]);         'Determines if FM sweep is present
            recTrialGenAMFreqHz[stimIndex%] := val(readLine$[5]);        'A list of AM frequency values, if 0 no AM
            recTrialGenAMDepthPct[stimIndex%] := val(readLine$[6]);      'A list of AM depth values in percent, if 0 no depth
            recTrialGenAMPhaseDeg[stimIndex%] := val(readLine$[7]);      'A list of AM phases, 0 = AM starts low, 90 = AM starts middle and rising, 180 = AM starts high, 270 = AM starts middle, falling
            recTrialGenTonePhaseDeg[stimIndex%] := val(readLine$[8]);    'A list of tone phases, 0 = tone starts middle, rising (sine phase), 90 = tone starts high (cosine phase), note different than AM phase, only used for tone, not noise
            recTrialGenGauss%[stimIndex%] := val(readLine$[9]);          'If 1 create Gaussian noise, if 0 create uniform noise
            recTrialGenRampMS[stimIndex%] := val(readLine$[10]);         'Duration in ms of front/back ramp, ramp is 1-Cos^2
            recTrialGenSeed%[stimIndex%] := val(readLine$[11]);          'Seed for random number generator, 0 = unspecified, will make own random number
            
            'this is a bit weird, we're just putting the same value into a different variable (could have assigned val(readLine$[4]) again...)
            recTrialMF[stimIndex%] := recTrialGenAMFreqHz[stimIndex%]; 'For whatever reason, this value is used in GenTrialsStereoDis%(), and other than adding this I don't have to change it to make it work for generating stims
            if recTrialGenIsSweep[stimIndex%] = 4 then
                recTrialMF2[stimIndex%] := recTrialGenAMPhaseDeg[stimIndex%];  'And assign second modulation frequency if this is an AM/FM stimulus
                if recTrialGenTonePhaseDeg[stimIndex%] < 0 then  'negative values indicate a sweep gap
                    recTrialSweepGap[stimIndex%] := -recTrialGenTonePhaseDeg[stimIndex%];  
                else  'positive values indicate an intensity
                    recTrialSweepIntensity[stimIndex%] := recTrialGenTonePhaseDeg[stimIndex%];
                endif
            endif
        case numRead%<0 then  'quit on end of file
            keepGoing% := 0;
            lineCount% -= 1;  'Decrement to get correct count on EOF
            status% := 1;
        else
            message("Starting over!|Failure to successfully read file with 11 or 12 fields despite initial check!");
            keepGoing% := 0;
        endcase;    
    wend;    
    
    fileclose();  'close fh0%, the currently open file
    
    recTotalStim% := lineCount%;
    
    'Just some debugging code, correct read is verified
'    printlog("Column 1 was %f\n",recTrialStimDur[]);
'    printlog("Column 2 was %f\n",recTrialGenLowpassHz[]);
'    printlog("Column 3 was %f\n",recTrialGenHighpassHz[]);
'    printlog("Column 4 was %f\n",recTrialGenIsSweep[]);
'    printlog("Column 5 was %f\n",recTrialGenAMFreqHz[]);
'    printlog("Column 6 was %f\n",recTrialGenAMDepthPct[]);
'    printlog("Column 7 was %f\n",recTrialGenAMPhaseDeg[]);
'    printlog("Column 8 was %f\n",recTrialGenTonePhaseDeg[]);
'    printlog("Column 9 was %d\n",recTrialGenGauss%[]);
'    printlog("Column 10 was %f\n",recTrialGenRampMS[]);
'    printlog("Column 11 was %d\n",recTrialGenSeed%[]);
    
    return status%;
    
end
'===== End RecLoadStimFile =====
'
'




'
'
'===== NameThatStimulus =====
func NameThatStimulus$(n%,seedind%)
    'a function that looks at the parameters of a generated stimulus and writes a name for it
    'useful for putting something logical into a SampleText 
    'seed index is included
    'the ramp duration is NOT reported as it's probably never relevant; obviously it would be an easy add
    'The one thing to keep in mind here is that when it says 450HzLo with no Hi, that's 450-Inf highpass noise
    'and when it says 450HzHi with no Lo, that's 0-450 Hz lowpass noise
    var name$;
    var dur$;   'easy, do this for everything
    var carrier$;  'this is the complicated one, can be tone, noise, BP, tone includes tone phase if not 0
    var am$;    'includes AM phase if not 0
    var seed$;  'seed for noise
    var amphse$;'for am phase, if necessary
    var isComb% := 0;  'Makes an IF statement cleaner
    
    'Duration is easy
    dur$ := str$(recTrialStimDur[n%]) + "ms";
    
    'Freq is a pain, also construct seed info here, but write seed at the end of the string 
    docase
    case recSearchStimType% = 3 then 'if it's a click, just say that and move on
        dur$ := "click";  'Technically, dur will be listed as 200 ms, but that's not really correct
    case recTrialGenLowpassHz[n%] = -100 then  'silence
        carrier$ := "_Silence";
    case recTrialGenLowpassHz[n%] < 0 and recTrialGenHighpassHz[n%] < 0 then 'noise
        docase
        case recTrialGenGauss%[n%] = 1 then 'Gaussian noise
            carrier$ := "_GaussNoise";
        case recTrialGenGauss%[n%] = -1 then 'Pink noise
            carrier$ := "_PinkNoise";
        else 'uniform noise
            carrier$ := "_UniformNoise";
        endcase;
        'PrintLog("recStimCount% = %d \n", recStimCount%); '*jao debugging
        'Not sure what jao was debugging, but there was an issue here in identifying the correct random seed.  
        'recStimCount% indexes the ordinal of stimuli in each trial, but the stimuli are not necessarily played
        'in numeric order.  In some cases (e.g. Search) there is only one stimulus in the PWAs but multiple
        'repeats of that stimulus.  In those cases only the random seed on the first stimulus was being accurately 
        'reported, after that it was being reported as "0".  Still have to debug this, but I *think* it should
        'give the right value.  I'm not sure how to test this for multiple PWAs.  In fact, I don't think ANY scenario
        'uses multiple PWAs AND generated random noise.  OK, until now.
        'It wasn't working.  I'm going to punt and just have the function call explicitly tell me which PWA to use,  at
        'least as a temporary fix until needed.  Old line that doesn't work commented here, replaced all other instances below
        'seed$ := "_Seed" + str$(recCurrRandomSeed%[recPWAList%[recStimCount%][recTrialOrder%[recCurrentTrial%-1]]],1,10);
        seed$ := "_Seed" + str$(recCurrRandomSeed%[seedind%],1,10);        'use 10 significant digits (should be 9 max from Clockseed on Matlab, 11 overflows CED anyway)
    case recTrialGenLowpassHz[n%] = recTrialGenHighpassHz[n%] then 'tone
        if recTrialGenTonePhaseDeg[n%] = 0 then 'standard, don't note phase
            carrier$ := "_" + str$(recTrialGenLowpassHz[n%]) + "Hz";
        else 'note non-standard phase
            carrier$ := "_" + str$(recTrialGenLowpassHz[n%]) + "Hz_" + str$(recTrialGenTonePhaseDeg[n%]) + "DegTonePhase";
        endif;
    case recTrialGenLowpassHz[n%] < 0 then 'lowpass
        docase
        case recTrialGenGauss%[n%] = 1 then 'Gaussian noise
            carrier$ := "_GaussNoise_" + str$(recTrialGenHighpassHz[n%]) + "HzHi";
        case recTrialGenGauss%[n%] = -1 then 'Pink noise
            carrier$ := "_PinkNoise_" + str$(recTrialGenHighpassHz[n%]) + "HzHi";
        else 'uniform noise
            carrier$ := "_UniformNoise_" + str$(recTrialGenHighpassHz[n%]) + "HzHi";
        endcase;
        seed$ := "_Seed" + str$(recCurrRandomSeed%[seedind%],1,10);  'use 10 significant digits (should be 9 max from Clockseed on Matlab, 11 overflows CED anyway)
    case recTrialGenHighpassHz[n%] < 0 then 'highpass
        docase
        case recTrialGenGauss%[n%] = 1 then 'Gaussian noise
            carrier$ := "_GaussNoise_" + str$(recTrialGenLowpassHz[n%]) + "HzLo";
        case recTrialGenGauss%[n%] = -1 then 'Pink noise
            carrier$ := "_PinkNoise_" + str$(recTrialGenLowpassHz[n%]) + "HzLo";
        else 'uniform noise
            carrier$ := "_UniformNoise_" + str$(recTrialGenLowpassHz[n%]) + "HzLo";
        endcase;
        seed$ := "_Seed" + str$(recCurrRandomSeed%[seedind%],1,10);  'use 10 significant digits (should be 9 max from Clockseed on Matlab, 11 overflows CED anyway)
    case recTrialGenIsSweep[n%] = 0 then 'bandpass
        docase
        case recTrialGenGauss%[n%] = 1 then 'Gaussian noise
            carrier$ := "_GaussNoise_" + str$(recTrialGenLowpassHz[n%]) + "HzLo_" + str$(recTrialGenHighpassHz[n%]) + "HzHi";
        case recTrialGenGauss%[n%] = -1 then 'Pink noise
            carrier$ := "_PinkNoise_" + str$(recTrialGenLowpassHz[n%]) + "HzLo_" + str$(recTrialGenHighpassHz[n%]) + "HzHi";
        else 'uniform noise
            carrier$ := "_UniformNoise_" + str$(recTrialGenLowpassHz[n%]) + "HzLo_" + str$(recTrialGenHighpassHz[n%]) + "HzHi";
        endcase;
        seed$ := "_Seed" + str$(recCurrRandomSeed%[seedind%],1,10);  'use 10 significant digits (should be 9 max from Clockseed on Matlab, 11 overflows CED anyway)
    case recTrialGenIsSweep[n%] = -2 then 'lower comb
        isComb% := 1;
        docase
        case recTrialGenGauss%[n%] = 1 then 'Gaussian noise
            carrier$ := "_LowComb_GaussNoise_" + str$(recTrialGenLowpassHz[n%]) + "HzLo_" + str$(recTrialGenHighpassHz[n%]) + "HzHi_" + str$(recTrialGenAMPhaseDeg[n%]) + "ToothBW_" + str$(recTrialGenTonePhaseDeg[n%]) + "ToothSpacing";
        case recTrialGenGauss%[n%] = -1 then 'Pink noise
            carrier$ := "_LowComb_PinkNoise_" + str$(recTrialGenLowpassHz[n%]) + "HzLo_" + str$(recTrialGenHighpassHz[n%]) + "HzHi_" + str$(recTrialGenAMPhaseDeg[n%]) + "ToothBW_" + str$(recTrialGenTonePhaseDeg[n%]) + "ToothSpacing";
        else 'uniform noise
            carrier$ := "_LowComb_UniformNoise_" + str$(recTrialGenLowpassHz[n%]) + "HzLo_" + str$(recTrialGenHighpassHz[n%]) + "HzHi_" + str$(recTrialGenAMPhaseDeg[n%]) + "ToothBW_" + str$(recTrialGenTonePhaseDeg[n%]) + "ToothSpacing";
        endcase;
        seed$ := "_Seed" + str$(recCurrRandomSeed%[seedind%],1,10);  'use 10 significant digits (should be 9 max from Clockseed on Matlab, 11 overflows CED anyway)    
    case recTrialGenIsSweep[n%] = 2 then 'higher comb
        isComb% := 1;
        docase
        case recTrialGenGauss%[n%] = 1 then 'Gaussian noise
            carrier$ := "_HighComb_GaussNoise_" + str$(recTrialGenLowpassHz[n%]) + "HzLo_" + str$(recTrialGenHighpassHz[n%]) + "HzHi_" + str$(recTrialGenAMPhaseDeg[n%]) + "ToothBW_" + str$(recTrialGenTonePhaseDeg[n%]) + "ToothSpacing";
        case recTrialGenGauss%[n%] = -1 then 'Pink noise
            carrier$ := "_HighComb_PinkNoise_" + str$(recTrialGenLowpassHz[n%]) + "HzLo_" + str$(recTrialGenHighpassHz[n%]) + "HzHi_" + str$(recTrialGenAMPhaseDeg[n%]) + "ToothBW_" + str$(recTrialGenTonePhaseDeg[n%]) + "ToothSpacing";
        else 'uniform noise
            carrier$ := "_HighComb_UniformNoise_" + str$(recTrialGenLowpassHz[n%]) + "HzLo_" + str$(recTrialGenHighpassHz[n%]) + "HzHi_" + str$(recTrialGenAMPhaseDeg[n%]) + "ToothBW_" + str$(recTrialGenTonePhaseDeg[n%]) + "ToothSpacing";
        endcase;
        seed$ := "_Seed" + str$(recCurrRandomSeed%[seedind%],1,10);  'use 10 significant digits (should be 9 max from Clockseed on Matlab, 11 overflows CED anyway)    
    else 'FM sweep
        if recTrialGenTonePhaseDeg[n%] = 0 then 'standard, don't note phase
            carrier$ := "_FMSweep_start" + str$(recTrialGenLowpassHz[n%]) + "Hz_end" +  str$(recTrialGenHighpassHz[n%]) + "Hz_" + str$(recSearchFMNumReverses%) + "Reverses";
        else 'note non-standard phase
            carrier$ := "_FMSweep_start" + str$(recTrialGenLowpassHz[n%]) + "Hz_end" +  str$(recTrialGenHighpassHz[n%]) + "Hz_" + str$(recSearchFMNumReverses%) + "Reverses_" + str$(recTrialGenTonePhaseDeg[n%]) + "DegTonePhase";
        endif;
    endcase;
            
    'AM is pretty easy, if it's not AM/FM
    if recTrialGenIsSweep[n%] <> 4 then  'NOT AM/FM
        'first get the phase, if any
        if recTrialGenAMPhaseDeg[n%] > 0 and isComb% = 0 then
            amphse$ := "_" + str$(recTrialGenAMPhaseDeg[n%]) + "DegAmPhase";
        endif;
        
        if recTrialGenAMFreqHz[n%] > 0 then
            am$ := "_" + str$(recTrialGenAMFreqHz[n%]) + "AMHz_" + str$(recTrialGenAMDepthPct[n%]) + "AMDepth";
        endif;
    else 'AM/FM
        'get both AM frequencies
        am$ := "_" + str$(recTrialMF[n%]) + "AMHz_" + str$(recTrialMF2[n%]) + "AM2Hz_" + str$(recTrialGenAMDepthPct[n%]) + "AMDepth";
        'here "amphse$" is hijacked to give info about the gap/intensity of the sweep
        docase
        case recTrialSweepIntensity[n%] = 1 and recTrialSweepGap[n%] = 0 then
            amphse$ := ""; 'will start empty, but being explicit that we will not note anything if no gap, full intensity
        case recTrialSweepIntensity[n%] < 1 then
            amphse$ := "_" + str$(recTrialSweepIntensity[n%]) + "GapIntensity";
        else 'recTrialSweepGap[n%] > 0
            amphse$ := "_" + str$(recTrialSweepGap[n%]) + "GapMS";
        endcase
    endif;
    
    
    name$ := dur$ + carrier$ + am$ + amphse$ + seed$;
    
    if recExpToRun% = recExpCharButton% and recCharLoadStim% = 1 then
        name$ := "(stim is loaded, can't autoname)";
    endif;    
    
    return name$;
    
end
'===== End NameThatStimulus =====
'
'


'
'
'===== NameThatStimulusStereoDis =====
func NameThatStimulusStereoDis$(n%,stim%,PWAind%)
    'a function that looks at the parameters of a generated stimulus and writes a name for it
    'useful for putting something logical into a SampleText 
    'StereoDis (and presumably any generated stereo experiment) needs a 2-D seed list, just adding a
    'new function rather than having to give dummy inputs to all the other calls
    'the ramp duration is NOT reported as it's probably never relevant; obviously it would be an easy add
    'The one thing to keep in mind here is that when it says 450HzLo with no Hi, that's 450-Inf highpass noise
    'and when it says 450HzHi with no Lo, that's 0-450 Hz lowpass noise
    var name$;
    var dur$;   'easy, do this for everything
    var carrier$;  'this is the complicated one, can be tone, noise, BP, tone includes tone phase if not 0
    var am$;    'includes AM phase if not 0
    var seed$;  'seed for noise
    var amphse$;'for am phase, if necessary
    var isComb% := 0;  'Makes an IF statement cleaner
    
    'Duration is easy
    dur$ := str$(recTrialStimDur[n%]) + "ms";
    
    'Freq is a pain, also construct seed info here, but write seed at the end of the string 
    docase
    case recSearchStimType% = 3 then 'if it's a click, just say that and move on
        dur$ := "click";  'Technically, dur will be listed as 200 ms, but that's not really correct
    case recTrialGenLowpassHz[n%] < 0 and recTrialGenHighpassHz[n%] < 0 then 'noise
        docase
        case recTrialGenGauss%[n%] = 1 then 'Gaussian noise
            carrier$ := "_GaussNoise";
        case recTrialGenGauss%[n%] = -1 then 'Pink noise
            carrier$ := "_PinkNoise";
        else 'uniform noise
            carrier$ := "_UniformNoise";
        endcase;
        'PrintLog("recStimCount% = %d \n", recStimCount%); '*jao debugging
        'Not sure what jao was debugging, but there was an issue here in identifying the correct random seed.  
        'recStimCount% indexes the ordinal of stimuli in each trial, but the stimuli are not necessarily played
        'in numeric order.  In some cases (e.g. Search) there is only one stimulus in the PWAs but multiple
        'repeats of that stimulus.  In those cases only the random seed on the first stimulus was being accurately 
        'reported, after that it was being reported as "0".  Still have to debug this, but I *think* it should
        'give the right value.  I'm not sure how to test this for multiple PWAs.  In fact, I don't think ANY scenario
        'uses multiple PWAs AND generated random noise.  OK, until now.
        seed$ := "_Seed" + str$(recStereoDisSeedList%[stim%][PWAInd%],1,10);  'use 10 significant digits (should be 9 max from Clockseed on Matlab, 11 overflows CED anyway)
    case recTrialGenLowpassHz[n%] = recTrialGenHighpassHz[n%] then 'tone
        if recTrialGenTonePhaseDeg[n%] = 0 then 'standard, don't note phase
            carrier$ := "_" + str$(recTrialGenLowpassHz[n%]) + "Hz";
        else 'note non-standard phase
            carrier$ := "_" + str$(recTrialGenLowpassHz[n%]) + "Hz_" + str$(recTrialGenTonePhaseDeg[n%]) + "DegTonePhase";
        endif;
    case recTrialGenLowpassHz[n%] < 0 then 'lowpass
        docase
        case recTrialGenGauss%[n%] = 1 then 'Gaussian noise
            carrier$ := "_GaussNoise_" + str$(recTrialGenHighpassHz[n%]) + "HzHi";
        case recTrialGenGauss%[n%] = -1 then 'Pink noise
            carrier$ := "_PinkNoise_" + str$(recTrialGenHighpassHz[n%]) + "HzHi";
        else 'uniform noise
            carrier$ := "_UniformNoise_" + str$(recTrialGenHighpassHz[n%]) + "HzHi";
        endcase;
        seed$ := "_Seed" + str$(recStereoDisSeedList%[stim%][PWAInd%],1,10);  'use 10 significant digits (should be 9 max from Clockseed on Matlab, 11 overflows CED anyway)
    case recTrialGenHighpassHz[n%] < 0 then 'highpass
        docase
        case recTrialGenGauss%[n%] = 1 then 'Gaussian noise
            carrier$ := "_GaussNoise_" + str$(recTrialGenLowpassHz[n%]) + "HzLo";
        case recTrialGenGauss%[n%] = -1 then 'Pink noise
            carrier$ := "_PinkNoise_" + str$(recTrialGenLowpassHz[n%]) + "HzLo";
        else 'uniform noise
            carrier$ := "_UniformNoise_" + str$(recTrialGenLowpassHz[n%]) + "HzLo";
        endcase;
        seed$ := "_Seed" + str$(recStereoDisSeedList%[stim%][PWAInd%],1,10);  'use 10 significant digits (should be 9 max from Clockseed on Matlab, 11 overflows CED anyway)
    case recTrialGenIsSweep[n%] = 0 then 'bandpass
        docase
        case recTrialGenGauss%[n%] = 1 then 'Gaussian noise
            carrier$ := "_GaussNoise_" + str$(recTrialGenLowpassHz[n%]) + "HzLo_" + str$(recTrialGenHighpassHz[n%]) + "HzHi";
        case recTrialGenGauss%[n%] = -1 then 'Pink noise
            carrier$ := "_PinkNoise_" + str$(recTrialGenLowpassHz[n%]) + "HzLo_" + str$(recTrialGenHighpassHz[n%]) + "HzHi";
        else 'uniform noise
            carrier$ := "_UniformNoise_" + str$(recTrialGenLowpassHz[n%]) + "HzLo_" + str$(recTrialGenHighpassHz[n%]) + "HzHi";
        endcase;
        seed$ := "_Seed" + str$(recStereoDisSeedList%[stim%][PWAInd%],1,10);  'use 10 significant digits (should be 9 max from Clockseed on Matlab, 11 overflows CED anyway)
    case recTrialGenIsSweep[n%] = -2 then 'lower comb
        isComb% := 1;
        docase
        case recTrialGenGauss%[n%] = 1 then 'Gaussian noise
            carrier$ := "_LowComb_GaussNoise_" + str$(recTrialGenLowpassHz[n%]) + "HzLo_" + str$(recTrialGenHighpassHz[n%]) + "HzHi_" + str$(recTrialGenAMPhaseDeg[n%]) + "ToothBW_" + str$(recTrialGenTonePhaseDeg[n%]) + "ToothSpacing";
        case recTrialGenGauss%[n%] = -1 then 'Pink noise
            carrier$ := "_LowComb_PinkNoise_" + str$(recTrialGenLowpassHz[n%]) + "HzLo_" + str$(recTrialGenHighpassHz[n%]) + "HzHi_" + str$(recTrialGenAMPhaseDeg[n%]) + "ToothBW_" + str$(recTrialGenTonePhaseDeg[n%]) + "ToothSpacing";
        else 'uniform noise
            carrier$ := "_LowComb_UniformNoise_" + str$(recTrialGenLowpassHz[n%]) + "HzLo_" + str$(recTrialGenHighpassHz[n%]) + "HzHi_" + str$(recTrialGenAMPhaseDeg[n%]) + "ToothBW_" + str$(recTrialGenTonePhaseDeg[n%]) + "ToothSpacing";
        endcase;
        seed$ := "_Seed" + str$(recCurrRandomSeed%[recPWAList%[recStimCount%][recTrialOrder%[recCurrentTrial%-1]]],1,10);  'use 10 significant digits (should be 9 max from Clockseed on Matlab, 11 overflows CED anyway)    
    case recTrialGenIsSweep[n%] = 2 then 'higher comb
        isComb% := 1;
        docase
        case recTrialGenGauss%[n%] = 1 then 'Gaussian noise
            carrier$ := "_HighComb_GaussNoise_" + str$(recTrialGenLowpassHz[n%]) + "HzLo_" + str$(recTrialGenHighpassHz[n%]) + "HzHi_" + str$(recTrialGenAMPhaseDeg[n%]) + "ToothBW_" + str$(recTrialGenTonePhaseDeg[n%]) + "ToothSpacing";
        case recTrialGenGauss%[n%] = -1 then 'Pink noise
            carrier$ := "_HighComb_PinkNoise_" + str$(recTrialGenLowpassHz[n%]) + "HzLo_" + str$(recTrialGenHighpassHz[n%]) + "HzHi_" + str$(recTrialGenAMPhaseDeg[n%]) + "ToothBW_" + str$(recTrialGenTonePhaseDeg[n%]) + "ToothSpacing";
        else 'uniform noise
            carrier$ := "_HighComb_UniformNoise_" + str$(recTrialGenLowpassHz[n%]) + "HzLo_" + str$(recTrialGenHighpassHz[n%]) + "HzHi_" + str$(recTrialGenAMPhaseDeg[n%]) + "ToothBW_" + str$(recTrialGenTonePhaseDeg[n%]) + "ToothSpacing";
        endcase;
        seed$ := "_Seed" + str$(recCurrRandomSeed%[recPWAList%[recStimCount%][recTrialOrder%[recCurrentTrial%-1]]],1,10);  'use 10 significant digits (should be 9 max from Clockseed on Matlab, 11 overflows CED anyway)    
    else 'FM sweep
        if recTrialGenTonePhaseDeg[n%] = 0 then 'standard, don't note phase
            carrier$ := "_FMSweep_start" + str$(recTrialGenLowpassHz[n%]) + "Hz_end" +  str$(recTrialGenHighpassHz[n%]) + "Hz_" + str$(recSearchFMNumReverses%) + "Reverses";
        else 'note non-standard phase
            carrier$ := "_FMSweep_start" + str$(recTrialGenLowpassHz[n%]) + "Hz_end" +  str$(recTrialGenHighpassHz[n%]) + "Hz_" + str$(recSearchFMNumReverses%) + "Reverses_" + str$(recTrialGenTonePhaseDeg[n%]) + "DegTonePhase";
        endif;
    endcase;
            
    'AM is pretty easy, if it's not AM/FM - note that AM/FM shouldn't happen in StereoDis, but just covering bases
    if recTrialGenIsSweep[n%] <> 4 then  'NOT AM/FM
        'first get the phase, if any
        if recTrialGenAMPhaseDeg[n%] > 0 and isComb% = 0 then
            amphse$ := "_" + str$(recTrialGenAMPhaseDeg[n%]) + "DegAmPhase";
        endif;
        
        if recTrialGenAMFreqHz[n%] > 0 then
            am$ := "_" + str$(recTrialGenAMFreqHz[n%]) + "AMHz_" + str$(recTrialGenAMDepthPct[n%]) + "AMDepth";
        endif;
    else 'AM/FM
        'get both AM frequencies
        am$ := "_" + str$(recTrialMF[n%]) + "AMHz_" + str$(recTrialMF2[n%]) + "AM2Hz_" + str$(recTrialGenAMDepthPct[n%]) + "AMDepth";
        'here "amphse$" is hijacked to give info about the gap/intensity of the sweep
        docase
        case recTrialSweepIntensity[n%] = 1 and recTrialSweepGap[n%] = 0 then
            amphse$ := ""; 'will start empty, but being explicit that we will not note anything if no gap, full intensity
        case recTrialSweepIntensity[n%] < 1 then
            amphse$ := "_" + str$(recTrialSweepIntensity[n%]) + "GapIntensity";
        else 'recTrialSweepGap[n%] > 0
            amphse$ := "_" + str$(recTrialSweepGap[n%]) + "GapMS";
        endcase
    endif;
    
    name$ := dur$ + carrier$ + am$ + amphse$ + seed$;
    
    if recExpToRun% = recExpCharButton% and recCharLoadStim% = 1 then
        name$ := "(stim is loaded, can't autoname)";
    endif;    
    
    return name$;
    
end
'===== End NameThatStimulusStereoDis =====
'
'




'
'
'===== GenTrialsSearch =====
func GenTrialsSearch%()
    'At this point, the GenTrialsXXX functions are not in triallistgen.s2s.  Most of this is due to concerns about
    'the global variables needed.
    var i%;
    var j%;
    var status% := 1;
    var nS%;  'number of S1 stimuli 
    var nRS%; 'number of repeats for speaker sweep
    var nR%;  'number of repeats, for tone sweep 
    var nT%;  'number of tones, for tone sweep
    var nCyc%;  'number of cycles per "trial" if there are more than 20 individual tones in a tone sweep 
    var currTone%;  'current tone (PWA), if there are more than 20 individual tones in a tone sweep
    var nSpkr%; '# speakers in current array (needed or is this already a global?)
    var nCycS%;  'number of cycles per "trial" for speaker sweep 
    var currSpkr%;  'current speaker (PWA), for speaker sweep
    
    nR% := recSearchToneSweepRepeats%;  'shorthand
    nT% := recSearchToneSweepNSteps%;  'shorthand again
    nRS% := recSearchSpeakerSweepRepeats%;
    
    nSpkr% := recNSpeakers%; 'shorthand again. speaker sweep! '10 for debugging purposes
    if recDebug% > 0 then
        nSpkr% := 10; '10 for debugging purposes to equal recMaxTrial
    endif;
    currSpkr% := 1; 'start with speaker 1
    
    'Tone sweeps have to be different!  No S2 for those.
    for i% := 0 to recNTrials%-1 do
        nS% := recMinS1% + Floor(Rand(recVarS1%+1,0));  'using Floor with an offset of 1 because the range of Rand is 0 -> .999... 
        recTrialOrder%[i%] := i%;  'set initial trial order
        docase
        case recSearchStimType% = 4 and (nT%*nR% <= recMaxStimPerTrial%) then 'for tone sweeps, simple version where all trials are identical
            for j% := 0 to nT%-1 do  'for each tone in the tone sweep
                recStimList%[j%][i%] := j%;  'fill Stim list with indices of the sweep tones, from low to high (freqs already set by dialog box)
                arrconst(recPWAList%[j%*nR%:nR%][i%],j%);  'fill PWA list with nR% copies of tone
                'PrintLog("recPWAList is now: d% \n", recPWAList%); 'temprary! for dbugging
                
            next;
            arrconst(recSpeakerList%[0:nT%][i%],recS1Speaker%);  'only one speaker
            recNUniqueStims%[i%] := nT%;
            arrconst(recDeltadBList[0:nT%*nR%][i%],recDeltadBLevel);  'do not set any delta dB, may change if Gregg wants roving
            recTrialTerminalIndex%[i%] := (nT%*nR%)-1;  'it's an index, subtract 1
            recTrialTerminalIsS2%[i%] := 0;  'last stimulus is not an S2
            
        case recSearchStimType% = 4 and (nT%*nR% > recMaxStimPerTrial%) then 'complicated version of tone sweeps, if there are more than 20 tones in a sweep
            for j% := 0 to nT%-1 do  'for each tone in the tone sweep
                recStimList%[j%][i%] := j%;  'fill Stim list with indices of the sweep tones, from low to high (freqs already set by dialog box)
            next; 
            arrconst(recSpeakerList%[0:nT%][i%],recS1Speaker%);  'only one speaker            
            recNUniqueStims%[i%] := nT%;
            
            nCyc% := floor(recMaxStimPerTrial%/nR%);  'divide max stims by number of repeats to see how many repeats can fit
            for j% := 0 to nCyc%-1 do
                arrconst(recPWAList%[j%*nR%:nR%][i%],currTone%);  'fill PWA list with nR% copies of tone
                currTone% += 1;
                if currTone% = nT% then  'wrap currTone% when necessary
                    currTone% := 0;
                endif;
            next;
            arrconst(recDeltadBList[0:nCyc%*nR%][i%],recDeltadBLevel);  'do not set any delta dB, may change if Gregg wants roving
            recTrialTerminalIndex%[i%] := (nCyc%*nR%)-1;  'it's an index, subtract 1
            recTrialTerminalIsS2%[i%] := 0;  'last stimulus is not an S2
            
        case recSearchStimType% = 5 then 'speaker sweep with broadband noise
            recStimList%[0][i%] := 0;  'Set first value in recStimList% to zero, there is only one stimulus        
            recNUniqueStims%[i%] := 1; 'only 1 b/c all noise        
            ArrConst(recSpeakerList%[0:nRS%][i%], currSpkr%);
            currSpkr% +=1; 'increment speaker number for next trial   
            if currSpkr% > nSpkr% then  'reset to 1 if last speaker in array
                currSpkr% := 1;
            endif;
            
            arrconst(recPWAList%[0:nRS%][i%],0);  'Fill recPWAList% with zeros = the PWAs we will play
            arrconst(recDeltadBList[0:nRS%][i%],recDeltadBLevel);  'do not set any delta dB, may change if Gregg wants roving
            recTrialTerminalIndex%[i%] := nRS%-1;  'it's an index, subtract 1
            recTrialTerminalIsS2%[i%] := 0;  'last stimulus is not an S2
            
        case recActive% = 0 or recPropCatch >= Rand() then 'other search types, if passive or catch, do not put in an S2
            recStimList%[0][i%] := 0;  'Set first value in recStimList% to zero, there is only one stimulus
            recSpeakerList%[0][i%] := recS1Speaker%;  'Set speaker for the only stimulus
            recNUniqueStims%[i%] := 1;  'only one unique stimulus
            arrconst(recPWAList%[0:nS%][i%],0);  'Fill recPWAList% with zeros = the PWAs we will play
            arrconst(recDeltadBList[0:nS%][i%],recDeltadBLevel);  'do not set any delta dB, may change if Gregg wants roving
            recTrialTerminalIndex%[i%] := nS%-1;  'it's an index, subtract 1
            recTrialTerminalIsS2%[i%] := 0;  'last stimulus is not an S2
            'printlog("Nontarget/Catch trial, recTrialTerminalIndex% is %d\n",recTrialTerminalIndex%[i%]);
            
            
        else 'put in an S2
            recStimList%[0][i%] := 0;  'Set first value in recStimList% to zero, there is only one stimulus
            recStimList%[1][i%] := 0;  'Set second value in recStimList% to zero, there is only one stimulus
            recSpeakerList%[0][i%] := recS1Speaker%;  'Set speaker for the S1
            recSpeakerList%[1][i%] := recS2Speaker%;  'Set speaker for the S2
            recNUniqueStims%[i%] := 2;  'two unique stimuli (due to calib on different speaker), fill two PWAs
            arrconst(recPWAList%[0:nS%][i%],0);  'Fill recPWAList% with zeros = the PWAs we will play
            recPWAList%[nS%][i%] := 1;  'And fill the final slot in the PWA list with 1, the S2 stimulus
            arrconst(recDeltadBList[0:nS%+1][i%],recDeltadBLevel);  'do not set any delta dB, may change if Gregg wants roving
            recTrialTerminalIndex%[i%] := nS%;  'it's an index, subtract 1 ( = nS%+1-1)
            'printlog("Target trial, recTrialTerminalIndex% is %d\n",recTrialTerminalIndex%[i%]);
            recTrialTerminalIsS2%[i%] := 1;  'last stimulus is an S2
            
        endcase;        
    next; 
    if recSearchStimType% < 4 then 'We refuse to shuffle tone sweeps and speaker sweeps (as of 1/8/20, this is the ONLY situation where we ignore the shuffle variable)
        if recShuffle% = 1 then
            ShuffleList%(recTrialOrder%[0:recNTrials%]);  'create a randpermed version of recTrialOrder (only valid indices), but not for tone sweep or speaker sweep
        endif;
    else
        recShuffle% := 0;  'if we are refusing to shuffle, at least let's keep that knowledge for later in the code
    endif;
    return status%;  'right now, it "can't" fail
end
'===== End GenTrialsSearch =====
'
'




'
'
'===== GenTrialsAudiogram =====
func GenTrialsAudiogram%()
    'this should be relatively simple, we're just making one trial for each tone, the staircase will be handled by the idle loop    
    var i%;
    var status% := 1;
    
    recNTrials% := recAudiogramNFreqs%;  'one trial for each tone
    recInitRewardmL := 0;  'hard code training reward to OFF
    recHoldRewardmL := 0;  'hard code training reward to OFF
    recTrialInitReward% := 0;  'hard code init reward to OFF -  this actually won't matter unless somebody goes through the AMDisc/SpaceDis dialogs first
    
    'recAudiogramNFreqs%,recAudiogramToneFreqLow,recAudiogramToneFreqHigh,recAudiogramFreqList[]  'values are already calculated  
    
    'loop through each trial
    for i% := 0 to recNTrials%-1 do
        
        'set initial trial order, for now this will not be changed
        recTrialOrder%[i%] := i%;     
        
        'set stim list, speaker list, etc.
        recStimList%[0][i%] := i%;  'fill stim list with indices from 0 to n-1, we will do trials in order
        recSpeakerList%[0][i%] := recS1Speaker%;  'Set speaker for the S1
        recNUniqueStims%[i%] := 1;  'one unique stimulus, fill one PWA
        recPWAList%[0][i%] := 0;  'we will use PWA 0
        recDeltadBList[0][i%] := 0;  'do not set any delta dB, may change if Gregg wants roving
        recTrialTerminalIndex%[i%] := 0;
        recTrialTerminalIsS2%[i%] := 1;  'last stimulus is an S2 
        
        'write parameters for the generated stimulus
        recTrialStimDur[i%] := 200;  'Jackie says always 200 ms for audiogram
        recTrialGenRampMS[i%] := 2;  'short ramp
        recTrialGenAMFreqHz[i%] := 0;
        recTrialGenAMDepthPct[i%] := 0;
        recTrialGenAMPhaseDeg[i%] := 0;
        recTrialGenTonePhaseDeg[i%] := 0;
        recTrialGenGauss%[i%] := 0;  
        recTrialGenSeed%[i%] := 0; 
        recTrialGenLowpassHz[i%] := recAudiogramFreqList[i%];
        recTrialGenHighpassHz[i%] := recAudiogramFreqList[i%];
        recTrialGenIsSweep[i%] := 0;       
              
    next; 
    
    return status%;  'right now, it "can't" fail
end
'===== End GenTrialsAudiogram =====
'
'









'
'
'===== GenTrialsFRAFromDialog =====
func GenTrialsFRAFromDialog%()
    var status% := 1;
    var nTonePips%;
    const nFMSweeps%:=10;  'this really can't change
    var i%;
    var j%;
    var k%;
    var numS1perTrial%[recMaxTrial%];
    var nS1%;
    var nS2%;
    var temp;            'Stuff for mod function...sure wish CED had one
    var t;               '(and the floating point crapola...ugh)
    var i;               'Also for mod
    var ind%;            'this too
    var whichS1StimInd%[recMaxStimPerTrial%*recMaxTrial%];  'S1 stimuli only vary in stimulus ID
    var whichS1DeltadB[recMaxStimPerTrial%*recMaxTrial%];        'and dB level
    var S1Shuffle%[recMaxStimPerTrial%*recMaxTrial%];       'for shuffling S1s
    var whichS2Speaker%[recMaxTrial%];  'only one S2 per trial, so this is big enough
    var count%;
    
    '===== Create Stimuli =====
    
    'For creating stimuli, there will be only one noise stimulus and a ton of tone pips/FM, so we'll
    'put the noise stimulus in position 0 of the stimuli variables
    nTonePips% := recFRAFreqNSteps%;
    
    'Set trial generation variables for the noise burst, both S2 and rate-level will use this stimulus, but at different speakers
    recTrialStimDur[0] := 200;
    recTrialGenRampMS[0] := 2;  'short ramp
    recTrialGenAMFreqHz[0] := 0;
    recTrialGenAMDepthPct[0] := 0;
    recTrialGenAMPhaseDeg[0] := 0;
    recTrialGenTonePhaseDeg[0] := 0;
    recTrialGenGauss%[0] := 1;  'use gaussian noise
    recTrialGenSeed%[0] := 0;  'This makes it unfrozen, need to make sure we're recording the seed
    recTrialGenLowpassHz[0] := -1;
    recTrialGenHighpassHz[0] := -1;
    recTrialGenIsSweep[0] := 0;
'        printlog("stim index = 0\t"); ' check stim! 
'        printlog("Rate-level (noise)\n");
'    'Fill whichS1StimInd%[] and whichS1DeltadB[] for the rate-level noises
    count% := 0;  'reset, though it's the first time used
    for i% := 0 to recRateLeveldBNSteps%-1 do
        for j% := 0 to recRateLevelNRepeats%-1 do
            whichS1StimInd%[count%] := 0;  'always is stimulus 0
            whichS1DeltadB[count%] := 65-recRateLeveldBList[i%];  'delta dB is additional atten, default stims will play at 65
'                printlog("count = %d\t", count%); ' check stimlist! 
'                printlog("Rate-level %d\n", whichS1DeltadB[count%]);
            count% += 1;        
        next;
    next;
    
    
    'Set trial generation variables for the tone pips
    'Also fill whichS1StimInd%[] and whichS1DeltadB[] for the tone pips
    'A lot of this COULD be "ArrConst"ed, but since we have to loop anyway, why clutter the code?
    for i% := 1 to nTonePips% do
        recTrialStimDur[i%] := 50;
        recTrialGenRampMS[i%] := 2;  'short ramp
        recTrialGenAMFreqHz[i%] := 0;
        recTrialGenAMDepthPct[i%] := 0;
        recTrialGenAMPhaseDeg[i%] := 0;
        recTrialGenTonePhaseDeg[i%] := 0;
        recTrialGenGauss%[i%] := 0;  
        recTrialGenSeed%[i%] := 0; 
        recTrialGenLowpassHz[i%] := recFRAFreqList[i%-1];
        recTrialGenHighpassHz[i%] := recFRAFreqList[i%-1];
        recTrialGenIsSweep[i%] := 0;
        for j% := 0 to recFRAdBNSteps%-1 do
            for k% := 0 to recFRANRepeats%-1 do  'recFRANRepeats% will probably be 1, that's OK as for i% := 0 to 0 executes once as expected
                whichS1StimInd%[count%] := i%;  'i% holds the stim index of the current tone
                whichS1DeltadB[count%] := 65-recFRAdBList[j%];  'recFRAdBList[j%] holds the dB of the current tone, delta dB is additional atten, default stims will play at 65
'                printlog("count = %d\t", count%); ' check stimlist! 
'                printlog("Tone pip: %d\n", whichS1DeltadB[count%]);
                count% += 1;
            next;
        next;
'        printlog("stim index = %d\t", i%); ' check stim! 
'        printlog("Tone pip: %d\n", recFRAFreqList[i%-1]);
    next;

    
    'Set trial generation variables for the FM sweeps...
    'Also fill whichS1StimInd%[] and whichS1DeltadB[] for the FM sweeps
    'Fill FMSweepDur%[]
    recFMSweepDur%[0] := recFMSweepDur1%;
    recFMSweepDur%[1] := recFMSweepDur2%;
    recFMSweepDur%[2] := recFMSweepDur3%;
    recFMSweepDur%[3] := recFMSweepDur4%;
    recFMSweepDur%[4] := recFMSweepDur5%;
    recFMSweep%[0] := recFMSweepStart%;  'low end of sweep, will reverse as well
    recFMSweep%[1] := recFMSweepEnd%; 'high end of sweep, will reverse as well
    for i% := 1 to nFMSweeps% do
        'Set values that are constant
        recTrialGenRampMS[i%+nTonePips%] := 2;  'short ramp
        recTrialGenAMFreqHz[i%+nTonePips%] := 0;
        recTrialGenAMDepthPct[i%+nTonePips%] := 0;
        recTrialGenAMPhaseDeg[i%+nTonePips%] := 0;
        recTrialGenTonePhaseDeg[i%+nTonePips%] := 0;
        recTrialGenGauss%[i%+nTonePips%] := 0;  
        recTrialGenSeed%[i%+nTonePips%] := 0;
        'Set duration, different for different sweeps
        i := i%-1;
        t := frac(i/(nFMSweeps%/2));
        temp := (nFMSweeps%/2)*t;
        ind% := round(temp);  'gets mod of i%,5...stupid, stupid floating point stuff kills it without these steps
        recTrialStimDur[i%+nTonePips%] := recFMSweepDur%[ind%];  'gets duration based on mod result
        'Set direction of sweep
        ind% := floor(i/(nFMSweeps%/2));
        recTrialGenLowpassHz[i%+nTonePips%] := recFMSweep%[ind%];  'if mod is 0, goes 500-20000...
        recTrialGenHighpassHz[i%+nTonePips%] := recFMSweep%[1-ind%];  '...if mod is 1, goes 20000-500
        recTrialGenIsSweep[i%+nTonePips%] := 1;
        for j% := 0 to recFMSweepRepeats%-1 do
            whichS1StimInd%[count%] := i%+nTonePips%;  'i%+nTonePips% holds the stim index of the current FM sweep
            whichS1DeltadB[count%] := 65-recSpaceS2dBLevel;  'recSpaceS2dBLevel holds the dB of the tone sweeps as well as the S2s, delta dB is additional atten, default stims will play at 65
'                printlog("count = %d\t", count%); ' check stimlist! 
'                printlog("FMsweeps: %d\n", recTrialStimDur[i%+nTonePips%]);
            count% += 1;
        next;
'        printlog("stim index = %d\t", i%+nTonePips%); ' check stim! 
'        printlog("FM sweep: %d\n", recFMSweep%[ind%]);
   next;

'Set trial variables for AMnoise...
for i% := 0 to nMTFrates%-1 do
    'AM Noise generation variables - same as AMdisc
    j% := i%+nTonePips%+nFMSweeps%+1; 'use j% now as trial index instead of i%
    recTrialStimDur[j%] := 500;
    recTrialGenRampMS[j%] := 5;  
    recTrialGenAMFreqHz[j%] := MTFrates[i%];
    recTrialGenAMDepthPct[j%] := 100; '100% depth
    recTrialGenAMPhaseDeg[j%] := 0;
    recTrialGenTonePhaseDeg[j%] := 0;
    recTrialGenGauss%[j%] := 1;  'use gaussian noise
    recTrialGenSeed%[j%] := 0;  'This makes it unfrozen, need to make sure we're recording the seed
    recTrialGenLowpassHz[j%] := -1;
    recTrialGenHighpassHz[j%] := -1;
    recTrialGenIsSweep[j%] := 0;
    for k% := 1 to recS1AMnoiseReps% do
        'fill repeats & increment count...
        whichS1StimInd%[count%] := j%;  'j% holds the stim index of the current AM
        whichS1DeltadB[count%] := 0;  'default stims will play at 65
'                printlog("count = %d\t", count%); ' check stimlist! 
'                printlog("AM noise: %d\n", MTFrates[i%]);
        count% += 1;
    next;
'    printlog("stim index = %d\t", j%); ' check stim! this is going to be a long list
'    printlog("AM noise: this rate = %d\t", MTFrates[i%]);
'    printlog("AM noise: duration = %d\n", recTrialStimDur[j%]);
next;

'Adding bandpass noise!
for i% := 0 to nBPnoises%-1 do
    'BP noise generations variables
    j% := i%+nTonePips%+nFMSweeps%+nMTFrates%+1;
    recTrialStimDur[j%] := 200;
    recTrialGenRampMS[j%] := 2;  'short ramp
    recTrialGenAMFreqHz[j%] := 0;
    recTrialGenAMDepthPct[j%] := 0;
    recTrialGenAMPhaseDeg[j%] := 0;
    recTrialGenTonePhaseDeg[j%] := 0;
    recTrialGenGauss%[j%] := 1;  'use gaussian noise
    recTrialGenSeed%[j%] := 0;  'This makes it unfrozen, need to make sure we're recording the seed
    recTrialGenLowpassHz[j%] := recBPnoisesLOs%[i%];
    recTrialGenHighpassHz[j%] := recBPnoisesHIs%[i%];
    recTrialGenIsSweep[0] := 0;
    for k% := 1 to recBPnoiseReps% do
        'fill repeats & increment count...
        whichS1StimInd%[count%] := j%;  'j% holds the stim index of the current BP
        whichS1DeltadB[count%] := 0;  'default stims will play at 65
        count% += 1;
    next;
next;    
    
    'Fill an S1Shuffle variable with the indices of S1 trials
    for i% := 0 to count%-2 do  'count-2 because it is incremented one last time above and not decremented
        S1Shuffle%[i%] := i%;
    next;
    'And shuffle it
    if recShuffle% = 1 then
        ShuffleList%(S1Shuffle%[0:count%]);  'create a randpermed version (only valid indices)
    endif;
    
    
    
    ' ===== Create Trials =====
    '#S1s = number of tone pips in FRA plus number of noise bursts in rate-level function + number of AM noises in MTFs
    nS1% := (nTonePips%*recFRAdBNSteps%*recFRANRepeats%)+(recRateLevelNRepeats%*recRateLeveldBNSteps%)+(nFMSweeps%*recFMSweepRepeats%)+(nMTFrates%*recS1AMnoiseReps%)+(nBPnoises%*recBPnoiseReps%);  
    printlog("nS1% = %d\n", nS1%);
    nS2% := (recNSpeakers%-1)*recSpaceNRepeats%;  'that's number of noises at speakers not in the S1 position
    printlog("nS2% = %d\n", nS2%);
    recNTrials% := nS2%;  'Set global Ntrials
    'Average is (now) 3.833 S1 per S2
    DealNumberOfS1s%(nS1%,nS2%,recMinS1%,recMinS1%+recCharVarS1%-1,numS1perTrial%[]);  'this is OK
    
    
    'Fill whichS2Speaker%[] with the speaker indices we will be using
    'At this point I realize there's no indication whether speaker number is expected to start at 0 or 1.  Guessing 1.
    count% := 0;  'reset
    for i% := 1 to recNSpeakers% do  'this is right, we go through all speakers
        if i% <> recS1Speaker% then  'don't use the S1 speaker of course
            for j% := 1 to recSpaceNRepeats% do 'recRateLevelNRepeats% do - separated from S2-Space count!
                whichS2Speaker%[count%] := i%;
                count% += 1;
            next;
        endif;
    next;
    'And shuffle it (actually, I believe this is be unnecessary because the S1s ARE shuffled and the trial order is later shuffled)
    if recShuffle% = 1 then
        ShuffleList%(whichS2Speaker%[0:count%]);  'create a randpermed version (only valid indices)
    endif;
    
    
    'Fill recStimList[][] etc. for each trial, end at an S2 every time
    count% := 0;
    for i% := 0 to nS2%-1 do  'for each trial
        recTrialOrder%[i%] := i%;  'Just randomize this after the loop
        recTrialTerminalIndex%[i%]  := numS1perTrial%[i%];  'not "+1" due to 0-based indexing
        recTrialTerminalIsS2%[i%] := 1;  'all trials have a terminal S2 
        'fill the S1 information
        for j% := 0 to numS1perTrial%[i%]-1 do
            recStimList%[j%][i%] := whichS1StimInd%[S1Shuffle%[count%]]; 'this is stimulus index, all stims considered "unique" 
            recDeltadBList[j%][i%] := whichS1DeltadB[S1Shuffle%[count%]];  'And dB
            recPWAList%[j%][i%] := j%;  'this is PWA to play, just PWA in order
            recSpeakerList%[j%][i%] := recS1Speaker%;  'This is the "main" speaker
            count% += 1;
        next;
        'and now we're ready for the S2
        'Note that j% gets incremented one last time to trigger the "exit" of the loop, and thus is now
        'the correct index to use.  However, since this bothers the crap out of me, I'm explicitly setting it.
        j% := numS1perTrial%[i%];  'because of zero-based indexing, the number of S1s is the index of the S2
        recStimList%[j%][i%] := 0;  'this is stimulus index, S2 stimulus is noise, which is 0 
        recDeltadBList[j%][i%] := 65-recSpaceS2dBLevel;  'Delta dB (additional atten) for S2 stimuli, default stims will play at 65
        recPWAList%[j%][i%] := j%;  'this is PWA to play, just play in order
        recSpeakerList%[j%][i%] := whichS2Speaker%[i%];
        'And finally the number of unique stims - all stims are treated as unique (i.e. loaded into their own PWA) even if they're technically "not"
        recNUniqueStims%[i%] := j%+1;  'j% is index of final stimulus, so number of stims (all unique) is +1
    next;
    'Randomize the list order
    if recShuffle% = 1 then
        ShuffleList%(recTrialOrder%[0:nS2%]);
    endif;
    
    return status%;
end
'===== End GenTrialsFRAFromDialog =====
'
'






'
'
'===== GenTrialsCharParallel =====
func GenTrialsCharParallel%()
    var status% := 1;
    var i%;
    var j%;
    var count% := 0;
    var rewardInt% := 5;
    var miniTrialOrder%[recTotalTrials%];
    var RepeatsPerStim% := 1;
    var rewardArray%[80];
    var rewardIndex%;
    
    ' ===== Create Trials =====
    recNTrials% := (recTotalTrials%*RepeatsPerStim%);  'Set global Ntrials
    if recNTrials% > recMaxTrial% then
        message("Too many trials requested!  Quitting!");
        halt
    endif  
    
    'recTrialTerminalndex%[] is just 0 as there is only one sound per trial

    for i% := 0 to recTotalTrials%-1 do ' 1. populate miniTrialOrder%
        miniTrialOrder%[i%] := i%;
    next;    

    for i% := 0 to recTotalTrials% do    '2. save values into rec2StimList, rec2SpeakerList, rec2DeltadBList
        rec2StimList%[i%][0] := RecTrialS1%[i%];  
        rec2StimList%[i%][1] := RecTrialS2%[i%];         
    
        rec2SpeakerList%[i%][0] := RecTrialS1Spkr%[i%];
        rec2SpeakerList%[i%][1] := RecTrialS2Spkr%[i%];
    
        rec2DeltadBList[i%][0] := recTrialS1DeltadB[i%];
        rec2DeltadBList[i%][1] := recTrialS2DeltadB[i%];
        
        'recNUniqueStims%[i%] does not need to be set for a parallel PWA scenario
    next;

    for i% := 0 to recCharRepeatsPerStim%-1 do '3. Fill recTrialOrder. go through each RepeatPerStim and...
        
        if recShuffle% = 1 then
            ShuffleList%(miniTrialOrder%);      'shuffle the miniTrialOrder
        endif;
    
        for j% := 0 to recTotalTrials%-1 do   'load this "chunk" of the order into the RecTrialOrder
            recTrialOrder%[count%] := miniTrialOrder%[j%];
            count% += 1;                    'increment count to the next spot in RecTrialOrder to fill
        next;
    next;
    
    'REWARDS - first clear the recFRAReward array
    for i% := 0 to recMaxTrial%-1 do
         recCharReward%[i%] := 0;
    next;
    
    
    'Rewards for FRA are based on random intervals of 10 to 15 trials between rewards
    'Old silly commented code has been deleted 1/18/22, if you need it, go back earlier than that. 
    'Note - DO NOT INDEX THIS WITH RecTrialOrder%[] - it's a payment schedule and if the 
    'stimuli are randomized the payment schedule goes all wrong
    count% := 0;  'reset count
    while count% < recNTrials%-15 do
        j% := rand(6,10);  'random integer between 10 and 15
        count% := count% + j%;  'use j% as interval, this is next rewarded trial
        recCharReward%[count%-1] := 1;  'assign rewarded trial
    wend
    recCharReward%[recNTrials%-1] := 1;  'reward final trial, to be nice
    
    
    return status%;
end
'===== End GenTrialsCharParallel =====
'
'



'
'
'===== GenTrialsCharSingle =====
func GenTrialsCharSingle%()
    'Different than GenTrialsCharParallel%() in that input trials will only have an S1, no S2
    var status% := 1;
    var i%;
    var j%;
    var count% := 0;
    var rewardInt% := 5;
    var miniTrialOrder%[recTotalTrials%];
    var RepeatsPerStim% := 1;
    var rewardArray%[80];
    var rewardIndex%;
    
    ' ===== Create Trials =====
    recNTrials% := (recTotalTrials%*RepeatsPerStim%);  'Set global Ntrials
    if recNTrials% > recMaxTrial% then
        message("Too many trials requested!  Quitting!");
        halt
    endif  
    
    'recTrialTerminalndex%[] is just 0 as there is only one sound per trial

    for i% := 0 to recTotalTrials%-1 do ' 1. populate miniTrialOrder%
        miniTrialOrder%[i%] := i%;
    next;    

    for i% := 0 to recTotalTrials%-1 do    '2. save values into recStimList, recSpeakerList, recDeltadBList
        recStimList%[0][i%] := recTrialS1%[i%];                                            
        recSpeakerList%[0][i%] := recTrialS1Spkr%[i%];
        recDeltadBList[0][i%] := recTrialS1DeltadB[i%];
        
        recNUniqueStims%[i%] := 1;
    next;

    for i% := 0 to recCharRepeatsPerStim%-1 do '3. Fill recTrialOrder. go through each RepeatPerStim and...
        
        if recShuffle% = 1 then
            ShuffleList%(miniTrialOrder%);      'shuffle the miniTrialOrder
        endif;
    
        for j% := 0 to recTotalTrials%-1 do   'load this "chunk" of the order into the RecTrialOrder
            recTrialOrder%[count%] := miniTrialOrder%[j%];
            count% += 1;                    'increment count to the next spot in RecTrialOrder to fill
        next;
    next;
    
    'REWARDS - first clear the recFRAReward array
    for i% := 0 to recMaxTrial%-1 do
         recCharReward%[i%] := 0;
    next;
    
    
    'Rewards for FRA are based on random intervals of 10 to 15 trials between rewards 
    'Note - DO NOT INDEX THIS WITH RecTrialOrder%[] - it's a payment schedule and if the 
    'stimuli are randomized the payment schedule goes all wrong
    count% := 0;  'reset count
    while count% < recNTrials%-15 do
        j% := rand(6,10);  'random integer between 10 and 15
        count% := count% + j%;  'use j% as interval, this is next rewarded trial
        recCharReward%[count%-1] := 1;  'assign rewarded trial
    wend
    recCharReward%[recNTrials%-1] := 1;  'reward final trial, to be nice
    
    
    return status%;
end
'===== End GenTrialsCharSingle =====
'
'





'===== GenTrialsDis =====
'modeled off of GenTrialsFRA... 
'a generic trial gen function for discrimination experiments (AMDis and SpaceDis), takes recExpToRun% as input to figure out what to do
func GenTrialsDis%(recExpToRun%)
    var status% := 1;
    var i%;
    var j%;
    var k%;
    var trialrep%;
    var numS1perTrial%;
    var nS1%;
    var nS2%;
    var RepeatsPerStim%;
    var responseTrial%; '1 if hit/miss, 0 if catch
    const dBrove% := 0; 'Rand(dBrove%,0) = 0,1,2,3,4 dB ; set to 0 to turn roving off
    
    'global vars set up in RecLoadTrialsFile: 
    '            recTrialS1%
    '            recTrialS2%
    '            recTrialS1Spkr%
    '            recTrialS2Spkr%
    '            recTrialS1DeltadB
    '            recTrialS2DeltadB
    
    'get Expt specific vars
    docase
    case recExpToRun% = recExpAMDiscButton% then
        RepeatsPerStim% := recAMDiscRepeatsPerStim%;  
    case recExpToRun% = recExpSpaceDisButton% then    
        RepeatsPerStim% := recSpaceDisRepeatsPerStim%;  
    endcase
    
    ' ===== Create Trials =====
    recNTrials% := (recTotalTrials%*RepeatsPerStim%);  'Set global Ntrials
    nS1% := recNTrials%;
    nS2% := recNTrials%;
    
    'Fill recStimList[][] etc. for each trial, 
    k% := 0; 'trial index counter, should increment to total recNTrials%-1
    for trialrep% := 0 to RepeatsPerStim%-1 do 'for number of trial repetitions  
        for i% := 0 to recTotalTrials%-1 do  'for each trial type in input table, so,i%=line# in stim table
            
            recTrialOrder%[k%] := k%;  'Just randomize this after the loop
            'determine how many S1 repeats to do this time:
            numS1perTrial% := recMinS1%+Floor(Rand(recVarS1%+1,0)); 'how it's done in GenTrialsSearch%().. not sure why it's not: Rand({recVarS1%,1})
            recTrialTerminalIndex%[k%]  := numS1perTrial%;  'not "+1" due to 0-based indexing       
            
            'Case through each possible type of trial
            docase  
            case recIsGoNoGo% = 1 and recExpToRun% = recExpAMDiscButton% then 'gonogo
                if recTrialS1%[i%]<>recTrialS2%[i%] then 'case this bitch to separate up/down trials
                    responseTrial% := 1;  'trial is hit/miss (has terminal S2) --> up OR down
                    'printlog("this is a CHANGE trial, S1 = %d and S2 = %d\n",recTrialS1%[i%],recTrialS2%[i%]);
                else 'they're the same
                    responseTrial% := 0;  'trial is catch (no terminal S2?? ...DONT THINK THIS IS CORRECT) 
                    'printlog("this is a CATCH trial, S1 = %d and S2 = %d\n",recTrialS1%[i%],recTrialS2%[i%]);
                endif
                recTrialTerminalIsS2%[k%] := responseTrial%; 'wait, how does this work for up/down? 'I HAVE NO IDEA HOW THIS SHOULD WORK! HELP!     
            case recIsGoNoGo% = 0 and recExpToRun% = recExpAMDiscButton% then 'up/down forced choice
                docase
                case recTrialS2%[i%] < recTrialS1%[i%]  then 
                    'LO trial
                    'printlog("this is a DOWN trial, S1 = %d and S2 = %d\n",recTrialS1%[i%],recTrialS2%[i%]);
                    recTrialTerminalIsS2%[k%] := 2; 'S2-LO --> StimComplete in RecGoNoGoEng *jao
                case recTrialS2%[i%] > recTrialS1%[i%] then
                    'HI trial
                    'printlog("this is a UP trial, S1 = %d and S2 = %d\n",recTrialS1%[i%],recTrialS2%[i%]);
                    recTrialTerminalIsS2%[k%] := 1; 'S2-HI --> StimComplete in RecGoNoGoEng *jao
                case recTrialS2%[i%] = recTrialS1%[i%] then
                    'catch trial --> to be rewarded 50% of the time; trials used to determine HI/LO;UP/DOWN bias
                    ' printlog("this is a SAME trial, S1 = %d and S2 = %d\n",recTrialS1%[i%],recTrialS2%[i%]);
                endcase;
                'NOW DO SPACE TRIALS!
            case recIsGoNoGo% = 1 and recExpToRun% = recExpSpaceDisButton% then 'gonogo
                if recTrialS1Spkr%[i%]<>recTrialS2Spkr%[i%] then 'case this bitch to separate up/down trials
                    responseTrial% := 1;  'trial is hit/miss (has terminal S2) --> up OR down
                    'printlog("this is a CHANGE trial, S1 = %d and S2 = %d\n",recTrialS1%[i%],recTrialS2%[i%]);
                else 'they're the same
                    responseTrial% := 0;  'trial is catch 
                    'printlog("this is a CATCH trial, S1 = %d and S2 = %d\n",recTrialS1%[i%],recTrialS2%[i%]);
                endif
                recTrialTerminalIsS2%[k%] := responseTrial%; 'wait, how does this work for up/down? 'I HAVE NO IDEA HOW THIS SHOULD WORK! HELP!     
            case recIsGoNoGo% = 0 and recExpToRun% = recExpSpaceDisButton% then 'up/down forced choice
                docase
                case recTrialS2Spkr%[i%] < recTrialS1Spkr%[i%]  then 
                    'LO trial (Left or CounterClockwise)
                    'printlog("this is a DOWN trial, S1 = %d and S2 = %d\n",recTrialS1%[i%],recTrialS2%[i%]);
                    recTrialTerminalIsS2%[k%] := 2; 'S2-LO --> StimComplete in RecGoNoGoEng *jao
                case recTrialS2Spkr%[i%] > recTrialS1Spkr%[i%] then
                    'HI trial (Right or Clockwise)
                    'printlog("this is a UP trial, S1 = %d and S2 = %d\n",recTrialS1%[i%],recTrialS2%[i%]);
                    recTrialTerminalIsS2%[k%] := 1; 'S2-HI --> StimComplete in RecGoNoGoEng *jao
                case recTrialS2Spkr%[i%] = recTrialS1Spkr%[i%] then
                    'catch trial --> to be rewarded 50% of the time; trials used to determine HI/LO;UP/DOWN bias
                    'recTrialTerminalIsS2%[k%] := 0; 'is this right? works without it tho...???
                    ' printlog("this is a SAME trial, S1 = %d and S2 = %d\n",recTrialS1%[i%],recTrialS2%[i%]);
                endcase;
            else
                printlog("something is fucked. recIsGoNoGo% has not been set= %d or case recExpToRun% was not passed in \n",recIsGoNoGo%);
            endcase; 
            
            'fill the S1 information (for how ever many S1 repeats there are)
            for j% := 0 to numS1perTrial%-1 do
                recStimList%[j%][k%] := recTrialS1%[i%]; 'this is stimulus index, all stims considered "unique" (?)
                recSpeakerList%[j%][k%] := recTrialS1Spkr%[i%];  'And speaker
                'recDeltadBList[j%][k%] := recTrialS1DeltadB[i%];  'And dB 'this is the value from the input tables
                recDeltadBList[j%][k%] := recTrialS1DeltadB[i%]+recDeltadBLevel+Rand(dBrove%,0); 'this is the value from the GUI - use this instead! (different for each monkey)
                recPWAList%[j%][k%] := j%;  'this is PWA to play, just PWA in order
            next;
            
            'and now we're ready for the S2
            'Note that j% gets incremented one last time to trigger the "exit" of the loop, and thus is now
            'the correct index to use.  However, since this bothers the crap out of me, I'm explicitly setting it.
            j% := numS1perTrial%;  'because of zero-based indexing, the number of S1s is the index of the S2
            recStimList%[j%][k%] := recTrialS2%[i%];  'S2 stimulus for this trial
            recSpeakerList%[j%][k%] := recTrialS2Spkr%[i%]; 'S2 speaker
            'recDeltadBList[j%][k%] := recTrialS2DeltadB[i%];  'Delta dB (additional atten) for S2 stimuli, default stims will play at 65
            recDeltadBList[j%][k%] := recTrialS2DeltadB[i%]+recDeltadBLevel+Rand(dBrove%,0); 'value from GUI, use this intead (different for each monkey)
            recPWAList%[j%][k%] := j%;  'this is PWA to play, just play in order
            
            'And finally the number of unique stims - all stims are treated as unique (i.e. loaded into their own PWA) even if they're technically "not"
            recNUniqueStims%[k%] := j%+1;  'j% is index of final stimulus, so number of stims (all unique) is +1
            
            k% +=1; 'increment trial counter
        next; 'end loop (i) through trial types in stim file  
    next; 'end trialrep for 
    
    'Randomize the list order
    'printlog("recTrialOrder% before shuffling %d\n",recTrialOrder%);'[0][k%]);
    if recShuffle% = 1 then
        ShuffleList%(recTrialOrder%[0:nS2%]);
    endif;
    
    docase 'for printlogging..
    case recExpToRun% = recExpAMDiscButton% then
        printlog("AMDis trials generated and shuffled successfully! recTrialOrder = %d\n",recTrialOrder%);'[0][k%]);  
    case recExpToRun% = recExpSpaceDisButton% then    
        printlog("SpaceDis trials generated and shuffled successfully! recTrialOrder = %d\n",recTrialOrder%);'[0][k%]);  
    endcase
    
    return status%;
end
'===== End GenTrialsDis =====
'
'




'
'
'===== GenTrialsStereoDis =====

func GenTrialsStereoDis%()
    var status% := 1;
    var i%;
    var j%;
    var count% := 0;
    var miniTrialOrder%[recTotalTrials%];
    
    ' ===== Create Trials =====
    recNTrials% := (recTotalTrials%*recStereoDisRepeatsPerStim%);  'Set global Ntrials

    for i% := 0 to recTotalTrials%-1 do    
        miniTrialOrder%[i%] := i%;  ' 1. populate miniTrialOrder%, etc.
        recTrialTerminalIndex%[i%] := 1;  'For this experiment, every trial has exactly one S1 and one S2, so zero-based terminal index is 1
        recPWAList%[0][i%] := 0;  'this is PWA to play, just use PWAs in order
        recPWAList%[1][i%] := 1;  '(recPWAList%[][] is a more meaningful variable for things like search where PWAs get pre-loaded and we bounce through them, we use it here for convenience)
        
        recStimList%[0][i%] := RecTrialS1%[i%];  '2. save values into recStimList, recSpeakerList, recDeltadBList
        recStimList%[1][i%] := RecTrialS2%[i%];  'and distractor versions as well
        recDistractorStimList%[1][i%] := recTrialDistractor%[i%][1];  'changed this to 2-D to accommodate GNG
        
        recSpeakerList%[0][i%] := RecTrialS1Spkr%[i%];
        recSpeakerList%[1][i%] := RecTrialS2Spkr%[i%];
        recDistractorSpeakerList%[0][i%] := recTrialDistractorSpkr%[i%][1];  'Should not be read, but just in case needs to be a legal speaker
        recDistractorSpeakerList%[1][i%] := recTrialDistractorSpkr%[i%][1];  'changed this to 2-D to accommodate GNG
    
        recDeltadBList[0][i%] := recTrialS1DeltadB[i%]+recDeltadBLevel;
        recDeltadBList[1][i%] := recTrialS2DeltadB[i%]+recDeltadBLevel;
        recDistractorDeltadBList[1][i%] := recTrialDistractorDeltadB[i%][1];  'changed this to 2-D to accommodate GNG
        
        'recNUniqueStims% does not need to be set when we use parallel PWAs
        
        docase
        case recTrialMF[RecTrialS1%[i%]] > recTrialMF[RecTrialS2%[i%]]  then 
            'LO trial
            recTrialTerminalIsS2%[i%] := 2; 'S2-LO --> use in StimComplete in RecGoNoGoEng 
        case recTrialMF[RecTrialS1%[i%]] < recTrialMF[RecTrialS2%[i%]] then
            'HI trial
            recTrialTerminalIsS2%[i%] := 1; 'S2-HI --> use in StimComplete in RecGoNoGoEng 
        case recTrialS2%[i%] = recTrialS1%[i%] or recTrialMF[RecTrialS1%[i%]] = recTrialMF[RecTrialS2%[i%]] then
            'catch trial
            recTrialTerminalIsS2%[i%] := 0;  'S2 = S1
        endcase;
        
    next;

    for i% := 0 to recStereoDisRepeatsPerStim%-1 do '3. Fill recTrialOrder. go through each RepeatPerStim and...
        
        if recShuffle% = 1 then
            ShuffleList%(miniTrialOrder%);      'shuffle the miniTrialOrder
        endif;
    
        for j% := 0 to recTotalTrials%-1 do   'load this "chunk" of the order into the RecTrialOrder
            recTrialOrder%[count%] := miniTrialOrder%[j%];
            count% += 1;                    'increment count to the next spot in RecTrialOrder to fill
        next;
    next;
        
    return status%;
end
'===== End GenTrialsStereoDis =====
'
'


'
'
'===== GenTrialsStereoDisGNG =====
'My initial look suggests this will not run - and may not have for quite some time
'It appears we need at least two parallel PWAs, and the initialization of multiple
'parallel PWAs was disabled quite some time ago (years?)  This needs a serious
'overhaul, but I don't think it's going to be used anytime soon, so I'm going to 
'rainy-day it.  -jj 1/20/22
'Hmm, this caveat is ALSO present in front of the FC version of this function, which definitely
'works.  I'll need to assess whether the GNG version might actually work after all, despite
'being repeatedly labeled as non-functional.  Perhaps the labels just were accidentally not
'removed?  But, again rainy day, too busy to look hard right now.  -jj 8/22/23
func GenTrialsStereoDisGNG%()
    var status% := 1;
    var i%;
    var j%;
    var count% := 0;
    var rewardInt% := 5;
    var miniTrialOrder%[recTotalTrials%];
    var randNum := 0;
    var randInt%;
    var randInt2%;
    var rewardArray%[80];
    var rewardIndex%;
    
    ' ===== Create Trials =====
    recNTrials% := (recTotalTrials%*recStereoDisRepeatsPerStim%);  'Set global Ntrials

    for i% := 0 to recTotalTrials%-1 do    
        miniTrialOrder%[i%] := i%;  ' 1. populate miniTrialOrder%, etc.
        recTrialTerminalIndex%[i%] := recTrialNumS1ns%[i%];  'For this experiment, there are a variable number of S1.ns, if number of S1.ns is 2, then third stimulus is terminal (index = 2)
        
        for j% := 0 to recTrialTerminalIndex%[i%] do
        
            recPWAList%[j%][i%] := j%;  'this is PWA to play, just use PWAs in order
            '(recPWAList%[][] is a more meaningful variable for things like search where PWAs get pre-loaded and we bounce through them, we use it here for convenience)
            
            '2. save values into rec2StimList, rec2SpeakerList, rec2DeltadBList
            if j% < recTrialTerminalIndex%[i%] then
                recStimList%[j%][i%] := RecTrialS1%[i%];  'Stim will be S1 except on terminal index
                recSpeakerList%[j%][i%] := RecTrialS1Spkr%[i%];  'Same thing for speaker
                recDeltadBList[j%][i%] := recTrialS1DeltadB[i%]+recDeltadBLevel;  'Same thing for delta dB
            else
                recStimList%[j%][i%] := RecTrialS2%[i%];  'Stim will be S2 on terminal index
                recSpeakerList%[j%][i%] := RecTrialS2Spkr%[i%];  'Same thing for speaker
                recDeltadBList[j%][i%] := recTrialS2DeltadB[i%]+recDeltadBLevel;  'Same thing for delta dB
            endif;
            
            recDistractorStimList%[j%][i%] := recTrialDistractor%[i%][j%];  'changed this to 2-D to accommodate GNG
            recDistractorSpeakerList%[j%][i%] := recTrialDistractorSpkr%[i%][j%];  'changed this to 2-D to accommodate GNG
            recDistractorDeltadBList[j%][i%] := recTrialDistractorDeltadB[i%][j%];  'changed this to 2-D to accommodate GNG
            
            'recNUniqueStims% does not need to be set when we use parallel PWAs
        next;
        
        docase
        case recTrialMF[RecTrialS1%[i%]] > recTrialMF[RecTrialS2%[i%]]  then 
            'LO trial
            recTrialTerminalIsS2%[i%] := 2; 'S2-LO --> use in StimComplete in RecGoNoGoEng 
        case recTrialMF[RecTrialS1%[i%]] < recTrialMF[RecTrialS2%[i%]] then
            'HI trial
            recTrialTerminalIsS2%[i%] := 1; 'S2-HI --> use in StimComplete in RecGoNoGoEng 
        case recTrialS2%[i%] = recTrialS1%[i%] then  'if it is the same stimulus it is the same MF
            'catch trial
            recTrialTerminalIsS2%[i%] := 0;  'S2 = S1
        endcase;
            
    next;

    for i% := 0 to recStereoDisRepeatsPerStim%-1 do '3. Fill recTrialOrder. go through each RepeatPerStim and...
        
        if recShuffle% = 1 then
            ShuffleList%(miniTrialOrder%);      'shuffle the miniTrialOrder
        endif;
    
        for j% := 0 to recTotalTrials%-1 do   'load this "chunk" of the order into the RecTrialOrder
            recTrialOrder%[count%] := miniTrialOrder%[j%];
            count% += 1;                    'increment count to the next spot in RecTrialOrder to fill
        next;
    next;
        
    return status%;
end
'===== End GenTrialsStereoDisGNG =====
'
'




'
'
'===== GenTrialsOneStimDiscrim =====

func GenTrialsOneStimDiscrim%()
    var status% := 1;
    var i%;
    var j%;
    var count% := 0;
    var miniTrialOrder%[recTotalTrials%];
    var firstValue;
    var firstValue$;
    var secondValue;
    var secondValue$;
    
    ' ===== Create Trials =====
    recNTrials% := (recTotalTrials%*recOneStimDiscrimRepeatsPerStim%);  'Set global Ntrials
    
    'Strip out path and extension from filenames, put into recTrialLoadName$[], if necessary
    if recOneStimDiscrimTarget1Ind% = 4 then
        StripStimStringArray%(recTrialLoadLoc$[],recTrialLoadName$[],1,1);
    endif
    
    for i% := 0 to recTotalTrials%-1 do    
        miniTrialOrder%[i%] := i%;  ' 1. populate miniTrialOrder%, etc.
        recTrialTerminalIndex%[i%] := 0;  'For this experiment, every trial has exactly one S1, so zero-based terminal index is 0
        recPWAList%[0][i%] := 0;  'this is PWA to play, there is only one
        
        recStimList%[0][i%] := recTrialS1%[i%];  '2. save values into recStimList, recSpeakerList, recDeltadBList, recNUniqueStims
        
        recSpeakerList%[0][i%] := recTrialS1Spkr%[i%];
    
        recDeltadBList[0][i%] := recTrialS1DeltadB[i%]+recDeltadBLevel;  'this is trial-based attenuation
        
        recNUniqueStims%[i%] := 1;
        
        'Here is where the trick is.  Here is where we have to assign values that allow us to make the 
        'experiment move correctly through the GNGEngine
        'Note that basically any stimulus we will be calling the "target" response should have a
        'value of 1 and any stimulus we will be calling the "nontarget" response should have a 
        'value of 0
        'The "target" and "nontarget" values map more more precisely onto "Response 1" and "Response 2"
        'respectively.  We count "hits" and "CRs", etc. but really that's just for convenience to map
        'this stuff onto the GNG paradigm that already existed.
        'The easiest way to do this is to independently get the "first" and "second" values
        'and then compare them
        'Index is not i%, it is recTrialS1%[i%], because that is the index of the stimulus on this trial
        'Get first value for each trial
        docase
        case recOneStimDiscrimTarget1Ind% = 0 then  'this is using AMFreq as first value
            firstValue := recTrialMF[recTrialS1%[i%]];
        case recOneStimDiscrimTarget1Ind% = 1 then  'this is using ToneFreq as first value
            firstValue := recTrialGenLowpassHz[recTrialS1%[i%]];
        case recOneStimDiscrimTarget1Ind% = 2 then  'this is using Duration as first value
            firstValue := recTrialStimDur[recTrialS1%[i%]];
        case recOneStimDiscrimTarget1Ind% = 3 then  'this is using AMDepth as first value
            firstValue := recTrialGenAMDepthPct[recTrialS1%[i%]];
        case recOneStimDiscrimTarget1Ind% = 4 then  'this is using StimName as first value...hmm
            firstValue$ := recTrialLoadName$[recTrialS1%[i%]];
        endcase
        'Get second value for each trial
        docase
        case recOneStimDiscrimTarget2Ind% = 0 then  'this is using AMFreq2 as second value
            secondValue := recTrialMF2[recTrialS1%[i%]];
        case recOneStimDiscrimTarget2Ind% = 1 then  'this is using VALUE as second value
            secondValue := recOneStimDiscrimValue;   'setting both of these is redundant, as we will only use one,
            secondValue$ := recOneStimDiscrimValue$; 'but it's easier
        endcase
        'Compare first and second value based on request from dialog
        docase
        case recOneStimDiscrimVersusInd% = 0 then  'this is "target is greater than"
            docase
            case firstValue > secondValue then
                recTrialTerminalIsS2%[i%] := 1;  'Target
            case secondValue > firstValue then  
                recTrialTerminalIsS2%[i%] := 2;  'Non-Target
            else 'values are the same
                recTrialTerminalIsS2%[i%] := 0;  'Catch
            endcase                
        case recOneStimDiscrimVersusInd% = 1 then  'this is "target is less than"
            docase
            case firstValue > secondValue then
                recTrialTerminalIsS2%[i%] := 2;  'Non-Target
            case secondValue > firstValue then  
                recTrialTerminalIsS2%[i%] := 1;  'Target
            else 'values are the same
                recTrialTerminalIsS2%[i%] := 0;  'Catch
            endcase 
        case recOneStimDiscrimVersusInd% = 2 and recOneStimDiscrimTarget1Ind% < 4 then  'this is "target is equal to", numeric version
            docase
            case firstValue = secondValue then
                recTrialTerminalIsS2%[i%] := 1;  'Target
            else 'values are different
                recTrialTerminalIsS2%[i%] := 2;  'Non-Target, there is no catch!
            endcase  
        case recOneStimDiscrimVersusInd% = 2 and recOneStimDiscrimTarget1Ind% = 4 then  'this is "target is equal to", string version
            docase
            case firstValue$ = secondValue$ then
                recTrialTerminalIsS2%[i%] := 1;  'Target
            else 'values are different
                recTrialTerminalIsS2%[i%] := 2;  'Non-Target, there is no catch!
            endcase
        case recOneStimDiscrimVersusInd% = 3 then  'this is "target contains" 
            docase
            case InStr(firstValue$,secondValue$) > 0 then
                recTrialTerminalIsS2%[i%] := 1;  'Target
            else 'second value is not contained in first value
                recTrialTerminalIsS2%[i%] := 2;  'Non-Target, there is no catch!
            endcase
        endcase          
    next;

    for i% := 0 to recOneStimDiscrimRepeatsPerStim%-1 do '3. Fill recTrialOrder. go through each RepeatPerStim and...
        
        if recShuffle% = 1 then
            ShuffleList%(miniTrialOrder%);      'shuffle the miniTrialOrder
        endif;
    
        for j% := 0 to recTotalTrials%-1 do   'load this "chunk" of the order into the RecTrialOrder
            recTrialOrder%[count%] := miniTrialOrder%[j%];
            count% += 1;                    'increment count to the next spot in RecTrialOrder to fill
        next;
    next;
        
    return status%;
end
'===== End GenTrialsOneStimDiscrim =====
'
'










'
'
'===== GenTrialsLongTone =====
func GenTrialsLongTone%()
    var status% := 1;
    var i%;
    var j%;
    var count%;
    
    
    
    'Note that the noise is hardcoded in PrepareLongNoise to be Gaussian as that is what is used elsewhere
    
    recNTrials% := recLongToneNRepeats%*nLongTones%;
    
    if recNTrials% > recMaxTrial% then
        message("The maximum number of trials is " + Str$(recMaxTrial%) + " but " + Str$(recNTrials%) + " trials were requested!");
        return 0;
    endif;
    
    'for i% := 0 to nLongTones%-1 do
    '    for j% := 0 to recLongToneNRepeats%-1 do
    '        'recLongToneDurationList[count%] := LongDurs[i%];  
    '        recLongToneDurationIndex%[count%] := i%;
    '        count% += 1;
    '    next
    'next
    '
    'if recShuffle% = 1 then
    '    'ShuffleList(recLongToneDurationList[0:recNTrials%]);  'create a randpermed version of recLongToneDurationList (only valid indices)
    '    ShuffleList%(recLongToneDurationIndex%[0:recNTrials%]);  'create a randpermed version of recLongToneDurationIndex% (only valid indices)   
    'endif;
    
    'Use Usrey randomization to get blocked random - note that the values going into recLongToneDurationList[] are not correct and will be overwritten - just need a variable the right size here
    GetRepeatedParameterProgression%(nLongTones%, recLongToneNRepeats%, recLongToneDurationList[], recLongToneDurationIndex%[], 1, nLongTones%, 0, recShuffle%);
    
    
    for i% := 0 to recNTrials%-1 do
        recLongToneDurationList[i%] := LongDurs[recLongToneDurationIndex%[i%]];
    next
    
    'Sanity check passed!
    'printlog("Long tone durations are: %f\n",recLongToneDurationList[]);
    'halt;
    
    return status%;
end
'===== End GenTrialsLongTone =====
'
'





'
'
'===== ConvertmLToSeconds =====
func ConvertmLToSeconds(mL)
    var sec;
    var a;
    var b;
    var c;
    
    
    ''''Old calculation based on pump juicer
    'if mL <= 0.417 then
    '    sec := (mL + 0.072)/13; 'The relationships in this function have been painstakingly calculated for the
    'else                        'Recanzone juicer on the left-hand booth.  The relationship between TDT reward time
    '    sec := (mL - 0.24)/4.7; 'and output is best described by two linear functions which intersect at a delivery
    'endif                       'of 0.417 mL (which corresponds to 0.0376 seconds of requested reward.
    'return sec;                 'If this script is used on another booth or the juicer is changed, the function will 
                                 'need to be recalculated.
    
    '''For the new(er, man, they're not that new) solenoid juicers, there is a fresh calculation
    '''The juicers on both booths actually deliver a very similar amount, close enough that we can
    '''totally use one averaged calculation for both booths (technically, I just plotted the data
    '''from both booths together and did a single linear fit using it.
    '''Here, we will not use an inflection point.
    '''The equation we will use is: mL = 2.643*sec - 0.1191
    '''or: sec = (mL + 0.1191)/2.643
    '''
    '''This equation is...not great.  We get quite a bit less than we asked for.  There may be several
    '''issues.  First, we most likely did our calculations with water, not juice.  Water deliveries will 
    '''be maybe 15% more than juice due to viscosity.  Second, I suspect the juicer lick tube was set on
    '''the ground for the measurement, which may affect the water column.  Together these might account
    '''for the fact that deliveryis about 4x less than request.  I mean, maybe that plus bad calculations
    '''when measuring?  We're doing it again, and we're being thorough.
'    if mL <= 0 then  'if we ask for 0 mL, don't give anything
'        sec := 0;
'    else
'        sec := (mL + 0.1191)/2.643
'    endif
    
    
    
    'And it's time for YET ANOTHER REVISIT on this.
    'Things will be super complicated, because we're going to have an estimate of delivery size for
    'water and juice separately, and small booth and big booth separately.  Furthermore, we want to 
    'characterize the delivery across the entire volume of the bottle (it looks like it does change
    'somewhat, on the order of maybe (by eyeball and from memory) 20% from the top to the bottom. 
    'We also want to try to characterize by open duration.  Hopefully we choose some decent endpoints.
    'It appears that 275 ms is a fairly long open duration, it gives as much as 0.3 mL per hit.
    'Ballpark range is like 150-350 mL (depends on size of monkey, if good worker).  Still 0.3 mL per
    'hit at 500 trials worth would be 150 mL so maybe that's not so, so long after all.  Perhaps
    'Recanzone monkeys work drier than Usrey monkeys.  Or maybe they're getting a lot more than 500
    'trials in, which is certainly possible.
    'For whatever reason, our initial estimate above was that we were getting about 2.6 mL per second
    'of open time.  This does not appear to be very accurate, and it would seem that more accurately
    'we are getting roughly 0.8-1.2 mL per second of open time - point being, if that number is not
    'around 1 mL per second, take a more careful look.
    
    'OK.  I did some janky modeling of the juicer response.  It appears that we can adequately describe
    'the FLOW (that is mL/sec) with an equation that looks like this:
    '
    'Flow = baseline + (volume in bottle * fill factor) + (open duration * open factor)
    'Flow: y (mL/sec) [ranges from about 0.6 - 1.3 in realistic scenarios]
    'Baseline: c (mL/sec) [ranges from about 0.34 - 0.45]
    'Volume in bottle: x (mL) [ranges from 0 - 600]
    'Fill factor: m (mL/sec*mL) [ranges from 0.00025 - 0.0004]
    'Open duration: t (sec) [ranges from about 0.1 - 0.4]
    'Open factor: n (mL/sec^2) [ranges from about 1.5 to 2]  Note that this is calculated for msec in juicerCalib2021.m,  have to multiply by 1000
    '
    'y = mx + nt + c
    '
    'Now mL delivered = y*t, or 
    'mL = t(mx + nt +c)
    '0 = nt^2 + (mx+c)t - mL
    'This is a quadratic equation, easy enough, a --> n, b --> mx+c, c --> -mL
    
    'Calculate using quadratic equation, we want the positive root (of course)
    c := -mL;  'c is just requested mL, but negative
    docase
    case recJuiceWaterBooth% = 0 then 'Water, small booth
        a := 2;  'this is swn*1000 from juicerCalib2021.m
        b := 0.444 + (recCurrentJuiceVolumemL*0.000365);  'these are swc and swm from juicerCalib2021.m
    case recJuiceWaterBooth% = 1 then 'Juice, small booth
        a := 1.6;  'this is sjn*1000 from juicerCalib2021.m
        b := 0.415 + (recCurrentJuiceVolumemL*0.000397);  'these are sjc and sjm from juicerCalib2021.m
    case recJuiceWaterBooth% = 2 then 'Water, big booth
        a := 1.7;  'this is bwn*1000 from juicerCalib2021.m
        b := 0.340 + (recCurrentJuiceVolumemL*0.000383);  'these are bwc and bwm from juicerCalib2021.m
    case recJuiceWaterBooth% = 3 then 'Juice, big booth
        a := 1.4;  'this is bjn*1000 from juicerCalib2021.m
        b := 0.395 + (recCurrentJuiceVolumemL*0.000277);  'these are bjc and bjm from juicerCalib2021.m
    endcase            
    
    'Solve using quadratic formula, positive root only
    sec := (-b + sqrt((b*b)-(4*a*c)))/(2*a);  
    
    return sec;
    
    
    
end                             


'===== RecLEDReminderDialog =====

'A dialog for the Cueing experiment

func RecLEDReminderDialog%()
    
    var i%;
    var status% := 0;
    var exptext$;
    var expcolor$;
    var shite%;

docase
    case recExpToRun% = recExpAMDiscButton% then
        exptext$ := "AMDis";
        expcolor$ := "RED";
    case recExpToRun% = recExpSpaceDisButton% then    
        exptext$ := "Space Dis";
        expcolor$ := "YELLOW";
    case recExpToRun% = recExpSearchButton% then
        exptext$ := "Search";
        expcolor$ := "GREEN";
    case recExpToRun% = recExpCharButton% then
        exptext$ := "FRA";
        expcolor$ := "GREEN";
    case recExpToRun% = recExpJoyTrnButton% then 
        exptext$ := "JoyTrain";
        expcolor$ := "RED";
    case recExpToRun% = recExpCueingButton% then
        exptext$ := "Cueing";
        expcolor$ := "RED or YELLOW";
    case recExpToRun% = recExpAudiogramButton% then 
        exptext$ := "Audiogram";
        expcolor$ := "GREEN";
    case recExpToRun% = recExpStereoDisButton% then
        exptext$ := "Stereo Dis";
        expcolor$ := "RED";
    case recExpToRun% = recExpLongToneButton% then
        exptext$ := "Long Tone";
        expcolor$ := "GREEN";
    case recExpToRun% = recExpOneStimDiscrimButton% then
        exptext$ := "One Stim Discrim";
        expcolor$ := "RED";
    else
        exptext$ := "Unknown Experiment Type - tell Jeff";
        expcolor$ := "I hope you know";
endcase

    ' Generate the dialog
    DlgCreate("LED Switch Reminder!");', 25, 10);
    DlgText("You are running " + exptext$ + "!", 3,1);
    DlgText("LED color is " + expcolor$, 5,2);
    DlgText("***check the speaker cable too! ***",1,4);

    ' Show the dialog. 
    i%:=DlgShow(shite%);
    
    ' If user hit OK then return 1. 
	if i% = 1 then
        status% := 1;
    else
        status% := 1; 'force this to OK anyway
    endif
    
	return status%;
   
end;

'===== End RecLEDReminderDialog =====
'
'


'===== SplitString =====

'A function to split up a STRING$ at the character found in CHAR$, and to separate with the string in SEPARATOR$
'Will attempt to make strings of length N% or less
'If CHAR$ is "slash", then SplitString will split along either forward or backslashes

'This function will probably most frequently be used to do the following:
'str$ := "ThisString/IsWayTooLong/ForTheEntireThingToBeDisplayed/InAMessageDialog/SoWeAreCuttingIt/DownABit.txt";
'sstr$ := SplitString$(str$,"slash","\n",60);
'message(sstr$);
func SplitString$(string$,char$,separator$,n%);
    var newString$;
    var uhoh% := 0;
    var inds%[len(string$)];  'allow as many indices as there are characters in the input
    var numFound% := 0;
    var tempInd% := -1;  'to get into while loop, this can't be 0
    var tempInd2% := -1;  'to get into while loop, this can't be 0
    var prevInd% := 1;
    var thisChar$;  'if CHAR$ is "slash" things get a bit more complicated and we can't use CHAR$ directly
    var thisChar2$;
    var i%;
    var sepInd%;
    var offset%;
    
    newString$ := string$;
    
    if len(newString$) = 0 then  'if the input string is empty, the subsequent code will break, so let's just bail!
        return newString$;
    endif
    
    if char$ = "slash" then  'find indices of BOTH types of slashes
        thischar$ := "/";
        thisChar2$ := "\\";
        while (tempInd% <> 0 or tempInd2% <> 0) and uhoh% <= len(string$) do  'don't let WHILE get stuck
            uhoh% += 1;  'don't let WHILE get stuck
            tempInd% := InStr(newString$,thisChar$,prevInd%);
            tempInd2% := InStr(newString$,thisChar2$,prevInd%);
            docase
            case tempInd% = 0 and tempInd2% = 0 then  'if we found no slashes
                'There are no more slashes, do nothing, will break out of WHILE
            case tempInd2% = 0 and tempInd% > 0 then  'if we found an instance of the forward slash, but no backslash, save forward slash location in inds%[]
                inds%[numFound%] := tempInd%;
                numFound% += 1;
                prevInd% := tempInd% + 1;
            case tempInd% = 0 and tempInd2% > 0 then  'if we found an instance of the backslash, but no forward slash, save backslash location in inds%[]
                inds%[numFound%] := tempInd2%;
                numFound% += 1;
                prevInd% := tempInd2% + 1;
            case tempInd% < tempInd2% then  'if we found an instance of both slashes, and forward slash is first, save forward slash location in inds%[]
                inds%[numFound%] := tempInd%;
                numFound% += 1;
                prevInd% := tempInd% + 1;
            case tempInd2% < tempInd% then  'if we found an instance of both slashes, and backslash is first, save backslash location in inds%[]
                inds%[numFound%] := tempInd2%;
                numFound% += 1;
                prevInd% := tempInd2% + 1;
            'There should logically be no other cases, right?
            endcase
        wend
    else 'find all indices matching input CHAR$ 
        while tempInd% <> 0 and uhoh% <= len(string$) do  'don't let WHILE get stuck
            uhoh% += 1;  'don't let WHILE get stuck
            tempInd% := InStr(newString$,char$,prevInd%);
            if tempInd% > 0 then  'if we found an instance of the character, save that in inds%[]
                inds%[numFound%] := tempInd%;
                numFound% += 1;
                prevInd% := tempInd% + 1;
            endif
        wend
    endif
    
    'once all instances are found, add on the total length of the string as an index
    inds%[numFound%] := len(string$);
    
    'testing, let's confirm these indices are OK
    'printlog("The indices found are %d\n\n",inds%[]);
    
    'update string to insert separator following characters, based on n%
    uhoh% := 0;
    offset% := 0;
    while inds%[numFound%] > n% and uhoh% <= len(string$) do 
        uhoh% += 1;  'don't let WHILE get stuck
        
        'if the final index is too big, insert a separator (as late as possible)
        sepInd% := 0;
        'printlog("Current indices are %d\n",inds%[]);
        for i% := 0 to numFound% do  'check the final character of the string even if it does not match CHAR$
            docase
            case inds%[i%] > n% and i% = 0 then
                sepInd% := 0 + offset%;  'don't crash if the first index is greater than the requested size
                break
            case inds%[i%] > n% then
                sepInd% := inds%[i%-1] + offset%;  'once we are past the length limit, break at the *previous* separator
                break
            endcase
        next
        'if we have no separators within the length limit, we have to punt and put in a separator at n%
        if sepInd% < 1+offset% then
            sepInd% := n% + offset%;
        endif;
        'printlog("Location of separator is %d\n",sepInd%);
        'insert separator
        newString$ := Left$(newString$,sepInd%) + separator$ + Right$(newString$,len(newString$)-sepInd%);
        'update indices by subtracting location of new "start point"
        'arrsub(inds%[],sepInd%+len(separator$))
        arrsub(inds%[],sepInd%-offset%);
        offset% := sepInd% + len(separator$);  'update offset to account for new indices
        
    wend

    return newString$
end;

'===== End SplitString =====
'
'



'===== StripStimStringArray%() =====
'
'This function takes an array of strings and strips off the path
'and/or the file extension in each string.  It will deal with both
'forward and backslashes; the extension is assumed to be all the
'characters following the final period, if present.  Stripped
'strings are returned in the OUT$[] array, which must be long
'enough to hold the final non-empty value in the IN$[] array.
func StripStimStringArray%(in$[],out$[],stripPath%,stripExt%)
    var numConverted%;
    var i%;
    var temp$;
    
    'Loop through all elements of the input string array
    for i% := 0 to Len(in$[])-1 do
        temp$ := in$[i%];
        'If the input is not empty, move forward
        if temp$ <> "" then
            'if there is no spot in OUT for the value, quit and complain
            if Len(out$[])-1 < i% then
                message("The input array (" + Str$(Len(in$[])) + ") is too long for the output array (" + Str$(Len(out$[])) + ")!");
                return numConverted%;
            endif
            'Strip this string and count it
            out$[i%] := StripStimString$(temp$,stripPath%,stripExt%);
            numConverted% += 1;
        else  'If the input is empty, just clear OUT, don't count it
            if Len(out$[]) > i% then
                out$[i%] := "";
            endif
        endif
    next    
    
    return numConverted%;   
    'I would just note that the majority of weird stuff in this code is all designed to allow out$[] to be 
    'smaller than in$[] so long as in$[] is empty beyond the length of out$[].  This feature will never be
    'useful.  Oh well.
end

'===== End StripStimStringArray%() =====
'
'

'===== StripStimString$() =====
'
'This function takes a string and strips off the path and/or the 
'file extension.  It will deal with both forward and backslashes; 
'the extension is assumed to be all the characters following the 
'final period, if present.  Returns the stripped string.  May be
'run as a standalone function, but is designed to do the dirty
'work for StripStimStringArray%().
func StripStimString$(in$,stripPath%,stripExt%)
    var out$;
    var forward$ := "/";
    var back$ := "\\";
    var period$ := ".";
    var ind%;
    var bind%;
    var pind%;
    var i%;
    
    out$ := in$;
    if stripPath% > 0 then
        'We want the last forward slash, we will flip, find the first forward slash, and adjust for the flip
        ind% := InStr(Reverse$(out$),forward$);
        'We want the last backslash, we will flip, find the first backslash, and adjust for the flip
        bind% := InStr(Reverse$(out$),back$);
        if ind% + bind% > 0 then 'if any slash is found
            if ind% > bind% then
                out$ := Right$(out$,ind%-1);  'Using Right$(), adjustment for the flip is easy
            else
                out$ := Right$(out$,bind%-1);
            endif
        endif
    endif
    if stripExt% > 0 then
        'We want the last period, we will flip, find the first period, and adjust for the flip
        pind% := InStr(Reverse$(out$),period$);
        out$ := Left$(out$,Len(Out$)-pind%);
    endif
    return out$;
end

'===== End StripStimString$() =====
'
'


'===== GetDrivePath$ =====
' moved to filesystemvars.s2s 12-11-2018 djs
