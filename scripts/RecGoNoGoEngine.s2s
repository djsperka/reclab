
'This script does not execute any code when the script which includes it is run - it is merely the set of functions
'which define the workings of the presentation engine.  Use RunGoNoGoEngine%() to get things going.


'==========================   Global variables  ============================================


' channel numbers and window handles
'const recDAC0Channel% := 1;          ' DAC0 output should be tee'd and input to ADC port 6
'const recTrigChannel% := 2;          ' Channel for trigger recording (teed from trig input!)
'const recLeverChannel% := 3;         ' Channel for behavioral lever recording
'const configJoyXChannel% := 4;       ' Channel for JoystickX
'const configJoyYChannel% := 5;       ' Channel for JoystickY
''const recTrode1Channel% := 11;       ' First electrode. Don't use channel numbers above this
'const recTrode2Channel% := 12;       ' I'm breaking the above rule (don't use channel numbers above this)
'const recTrode3Channel% := 13;       '   because it makes no sense to me.  If it turns out to matter
'const recTrode4Channel% := 14;       '   then I suppose we'll figure that out!
'const recTrode5Channel% := 15;
'const recTrode6Channel% := 16;
'const recTrode7Channel% := 17;
'const recTrode8Channel% := 18;
'const recTrode9Channel% := 19;
'const recTrode10Channel% := 20;

' channel numbers ***and window handles***??
' there are 1-32 max # electrodes on our probe, so reserve these channel numbers for electrodes and don't use them elsewhere
' as far as I can tell, channel numbers are arbitrary (as opposed to Ports#s), so use channel #s 40 and up for non-electrodes
const recLeverChannel% := 33;         ' Channel for behavioral lever recording ; 3-->40
const configJoyXChannel% := 34;       ' Channel for JoystickX 4-->40
const configJoyYChannel% := 35;       ' Channel for JoystickY 5-->41
const recDAC0Channel% := 36;          ' DAC0 output should be tee'd and input to ADC port 6 ; 1-->46
const recTrigChannel% := 37;          ' Channel for trigger recording (teed from trig input!) 2-->42
const configStimCopyChannel1% := 50;
const configStimCopyChannel2% := 51;

'electrode channel, port & number variables (because you cant make a const array)
const maxTrodes% := 32; '29;'30; 'max # of electrodes we can record is 30, limited by available Ports; 29 for now b/c of stupid textmark constraint
var recTrodePosition%[maxTrodes%];'
var recTrodeChannel%[maxTrodes%];
var recTrodePort%[maxTrodes%];
var maxTrodesThisExpt% := 4;  'if we are stimulating, we need two ports to monitor the stimulation, this reduces the number of ports available for electrodes

' ports
const recTriggerPort% := 0; 'qwhy????
const recLeverPort% := 1; 'does not need to be distinct from joystick because they will never be used at the same time
const configJoyXPort% := 0;  'A2D port (changed from 2 to 0)
const configJoyYPort% := 1;  'A2D port (changed from 3 to 1)
const configStimCopyPort1% := 6;  'per Conor, Reclab will NOT be using multi-contact probes and stimulation together, we can plug into front, if we use stim reward, max channels will be 4, won't interfere
const configStimCopyPort2% := 7;

' memory channels
var recMemChanLeverDebounce%;

' For Joystick
var joystickXOffset; 'use registry  
var joystickYOffset;
var joyview%;
var joydatachan%;
var LastPos%;
var JoystickReadOnce%;
var LeverCodes%[4]; 
var XPos%;
var YPos%;
var XTime;
var YTime;
var inOrigin%;
var RespDevice%;
var inTrialInit%;
var inResponse1%;
var inResponse2%;
var TrialResponse%;
var ResponseTime;
var OffAxis%;
var XJoy;
var YJoy;
var doIncUp%;
var doIncDown%;
var doIncLeft%;
var doIncRight%;
var doIncTrialInit%[4];  'indicates which channels to increment on succesful trial init
var doDecTrialInit%[4];  'indicates which channels to decrement on failed trial init
var doIncHit%[4];  'indicates which channels to increment on succesful hit
var doIncCR%[4];  'indicates which channels to increment on succesful CR
var doDecPassiveMiss%[4];  'indicates which channels to decrement on passive miss (no decrement on active miss)
var doDecPassiveFA%[4];  'indicates which channels to decrement on passive FA (no decrement on active FA)

' for anything other than electrodes!
var recXYWindowView%;              ' View variable for XY window
var recDataWindowView%;            ' View variable for data window


'This is all for ExtractSpaceInitialize
var recHBeh%;       ' ecode file
var recHBak%;       ' spikes
var recTLastProcessed := -1;
var recChanWM%;
var recChanTM%;



'Variables for PlaySound 
'const recTTMaxSpeakers% := 100;
const recDAC0Key$        := "A";
'var recTTSpeakers%[recTTMaxSpeakers%];    ' speaker numbers - each is considered a trial type. Can have duplicates. 
'var recTTAtten[recTTMaxSpeakers%];        ' atten to use for each speaker number in g_spcTTSpeakers%[]
var recTone%                := 0;
var recFreq%                := 20000;
var StimOn;                                ' time of stimulus onset
var PrevStimOn;                            ' time of previous stimulus onset, avoids error if Spike2 code executes faster than sequencer
var UsPerTime;                             ' number of microseconds per sequencer sample period
var TimePerADC;                            ' 
var SecPerSample;                          ' 
var RewOn;                                 ' time of reward onset
var PrevRewOn;                             ' time of previous reward onset, avoids error if Spike2 code executes faster than sequencer


'These variables are unused - not sure if I will need them
'var recTTSpikeCounts%[recTTMaxSpeakers%][recMaxTrials%]; ' spike counts for completed trials on each trial type
'var recTTSpikeRate[recTTMaxSpeakers%][recMaxTrials%];    ' spike rates for completed trials on each trial type
'var recTTSpikeRateMean[recTTMaxSpeakers%];' mean spike rate for each trial type
'var recTTSpikeRateStd[recTTMaxSpeakers%]; ' std dev for above. 
'var recTTIndexBackground%;                 ' index into TT arrays which is the background speaker/atten pair. 


' toolbar button numbers
const recStartButton%         := 1;
const recPauseButton%         := 2;
const recResumeButton%        := 3;
const recSelectNewExptButton% := 4;
'const recRewardButton%        := 5; 'REMOVED! use Timing/Reward button instead!
const recStopButton%          := 5;
const recTimingRewardButton%  := 6;
const recJoystickButton%      := 7;
const recCalibrationButton%   := 8;


' States and state control vars 
var isInterrupt%;
var isEarlyHit%;
var isEarlyMiss%;
var isEarlyFA%;
var isEarlyCR%;
var recIsPaused%;
const stateStart%                             := 0;
const stateInitializeTrials%                  := 1;
const stateWaitForInitiationMovement%         := 2;
const stateLazyMonkeyTimeout%                 := 3;
const statePreTrialDelay%                     := 4;
const stateStartSoundA%                       := 5;
const stateSoundAPlaying%                     := 6;
const stateISIDelay%                          := 7;
const stateStartSoundB%                       := 8;
const stateSoundBPlaying%                     := 9;
const stateTrainingReward%                    := 10;
const stateInResponseWindow%                  := 11;
const stateHitReward%                         := 12;
const stateFalsePositive%                     := 13;
const stateMissTimeout%                       := 14;
const stateDone%                              := 20;
const stateTDTError%                          := 21;
const stateCodingError%                       := 22;
const stateFAInterrupt%                       := 23;
const stateStartSoundC%                       := 24;
const stateSoundCPlaying%                     := 25;
const stateCRReward%                          := 26;
const stateStartCEDBlink%                     := 27;
const stateCEDBlinking%                       := 28;
'const stateTDTBlink%                          := 29;
const stateStartSoundD%                       := 30;
const stateSoundDPlaying%                     := 31;
const stateFalseAlarmAudiogram%               := 32;

var recDelayIntervalTime         := 0;
var tNow:=0;		' latest time for which there are values recorded. Used in IdleLoop%
var tStartBlink;    ' used in idle loop
var tLast:=-1;		' last time we checked for a trigger. 
var tLastJoyUpdate; 'last time we updated the joystick
var iState%:=stateStart%;		' present state
var tStateStart:=-1;	' time that present state started. Used to measure wait time, fixation time, etc. 
var tNextTrial;
var isTerminalS1%:=0;    'if trial has terminal S1, logic of state loop must change, so we need to keep track
var RTESDIsPressed%;  'has ReturnToExperimentSelectionDialog button been pressed?
var recLeverState%;
var recLeverTime;   'this is the time of the most recent lever EVENT - one that we are going to record as a hit, etc.
var recLastLever;   'this is the time of the most recent lever change - whether we plan to record it or not
var recPreciseTrialTime;
var recLeverCodes%[4];
var startingNewExpt%;  'only used with joystick, marks beginning of experiment so that joystick events in the past are "forgotten"
var nextStateImmed% := 1;  'when we are changing to a new state, by default we carry to that state immediately instead of waiting for the next idle loop call
var coinFlipResult%;    'to reward SAME trials for AMDis Hi/Lo *jao
var responseMode%;                  'branched from isS2% (IdleLoop) for Hi/Lo responses, has to be global to work

'output variables --> for ToolbarText (first step of user feedback)
var numHits% := 0;
var numMisses% := 0;
var numFPs% := 0;
var numFAs% := 0; 'need a CR counter too... (NOT USED NOW)
var numHiResps% := 0; 'reset after each block?
var numLoResps% := 0; 'reset after each block? (kind of redundant, but that's OK)
var percentUPthisBlock;
var percentHITthisBlock;
var amountRewarded := 0;

'var channels%[4];


'#include "reccreate.s2s"  'functions for creation of stimuli, superceded by reclab_panstim.m


'This is the overarching function which is called by the main (template) file
'This function simply creates the sample configuration, initializes the play wave areas,
'initializes the windows, and initializes the toolbar.  Once the toolbar is started, the 
'remainder of the work is done by the idle function once the toolbar is started.  Breaking
'out of the toolbar will then return control to the (template) file.
func RunGoNoGoEngine%()

    'This variable appears to be completely unused at this time
'    channels%[0] := recTrode1Channel%;
'    channels%[1] := recTrigChannel%;
'    channels%[2] := recLeverChannel%;
'    channels%[3] := 30;
    view(recLog%).print("Begin func RunGoNoGoEngine%.\n");    
    'We do want to start from the start state!
    iState% := stateStart%;
    
    'Set up sampling configuration
    if recCEDIsPresent% = 1 and recCurrentlySampling% = 0 then
        CreateSampleConfiguration();   'CreateSampleConfiguration() is below     TODO: make sure it is OK, fix up .pls file
        view(recLog%).print("Sample configuration created - func RunGoNoGoEngine%.\n");
    endif;
    
    
    ' Initialize PlayWave areas. The call to InitializePlayWaveAreas MUST
    ' come before the call to InitializeWindows -- that's where FileNew() is called. See Spike2
    ' docs for PlayWaveAdd(): PlayWaveAdd must be called before FileNew() for sampling window.
    if recCEDIsPresent% = 1 and recCurrentlySampling% = 0 then 'don't try to initialize a PlayWaveArea if there's no 1401
        InitializePlayWaveAreas();  'InitializePlayWaveAreas() is below 
        view(recLog%).print("PWAs initialized - func RunGoNoGoEngine%.\n");
    endif;
    
    
    'Open XY and data windows
    'Positioned after InitializePlayWaveAreas() because PlayWaveAdd() must be called before FileNew()
    if recCEDIsPresent% = 1 and recCurrentlySampling% = 0 then
        InitializeWindows();           'InitializeWindows() is below, opens one XYwindow and one data sampling window
        view(recLog%).print("Windows initialized - func RunGoNoGoEngine%.\n");
       
        'For now, cutting out ExtractSpaceInitialize as ExtractSpace is being shelved at least temporarily.
        'Since ExtractSpaceInitialize's main function is to set up an online view of the data plotted in 
        'recXYWindowView%, this will almost certainly be re-established, perhaps shortly.
            'ExtractSpaceInitialize(recXYWindowView%,recNSpeakers%);  'TODO: ExtractSpaceInitialize() is in extract_space_functions, may need to be adapted
        'This function basically does prep to plot a polar plot of activity v. speaker location.  Assumes full circular
        'array, evenly spaced, speaker 0 at top and subsequent speakers clockwise.  Could be adapted for more variable arrays.
    endif;
    

    ' Initialize toolbar. Once Toolbar is called the experiment is controlled by the toolbar
    ' buttons. Toolbar() does not return until one of the toolbar functions returns 0 - Stop%()
    ' does that if pressed, IdleLoop%() returns an iStatus% of 0 when it reaches the end of all trials. 
    ' What is confusing is that although the Toolbar returns, it's not quite dead.  It's still there in
    ' the background (even visible, but grayed out).  I suppose that's the way it is, an exited,
    ' not-running Toolbar can still be seen because at an early step we made it visible.  OK.
    ' However, a crucial step is that when returning to the experiment selection dialog, the Toolbar's 
    ' idle function must be "turned off", or more technically, directed to no function: ( ToolbarSet(0, ""); )
    ' rather than our state-logic idle loop.  That's because the Toolbar remembers things, and when we
    ' start it up again, if it still thinks the idle function is our state-logic loop, it jumps right into 
    ' it.  If we clear that idle function, then only the Start%() function sets the Toolbar idle function 
    ' to our state-logic loop and gets things going.

    InitializeToolbar();
    ToolbarSet(0, "");  'explicitly set the idle function to nothing - for some reason on second/third/etc. expts. the idle function is kicking in early even though I don't think it should be active yet   
    printlog("Toolbar initialized\n");
    view(recLog%).print("Toolbar initialized - func RunGoNoGoEngine%.\n");

    JoystickReadOnce% := 0; 'initialize joystick position ~jao 12Aug2014

    Toolbar("Hit \"Start\" to begin sampling.", 0x3ff);  'Run the toolbar; the experiment will be here most of the time
    'once we leave the toolbar, return to calling function
    return recReadyToQuit%;

end






'==========================  Local functions below ===========================================


''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' SetTrodeChannels (called by CreateSampleConfiguration) sets the electrode channel numbers and 
' port numbers that correspond to electrode position on the linear array probe. In other words, 
' this contains the electrode/port/channel mapping that is crucial to keep track of when running 
' experiments! So, don't fuck with it unless you are sure you know what you're doing!
' ~jao 2014 Aug 21
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func SetTrodeChannels()
'make a func so that if you want to make this a dialog function its easier
var i%;
var index%;
var portNum%;
var trodeNum%;

'TrodePorts will not change! same as TrodeChans, unless TrodeChannels changes/becomes configurable 
'recTrodePort% := [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31]; 
'for i% := 1 to 28 do 'maxTrodes = 30, limited by available Ports
for i% := 1 to maxTrodesThisExpt% do 'maxTrodes = 30, limited by available Ports  updated by jj 9/5/2016 to allow for two stimulation inputs at the end
    index% := i%-1; 'index starts at 0
    portNum% := i%+1; 'first electrode is on Port 2
    recTrodePort%[index%] := portNum%;
    recTrodePosition%[index%] := portNum%; 'this way all the numbers are the same! easyPeasy!
    recTrodeChannel%[index%] := portNum%;
next;

'***THIS IS IMPORTANT *** ELECTRODE NAMES ARE SET HERE
'30 electrode positions on probe that are being used, for cases where channel number cannot be the same as the electrode position:
'recTrodePosition% := (2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31);
'for i% := 1 to maxTrodes% do 'maxTrodes = 30, limited by available Ports
'    index% := i%-1; 'index starts at 0
'    trodeNum% := i%+1; 'first electrode is on Port 2
'    recTrodePosition%[index%] := trodeNum%;
'next;
'
'
''channel numbers mostly correspond to electrode position on probe:
'' note that channel 30 is reserved for TextMark data, and 31 seems to be keyboard
''i tried using 50, and 51 instead of 30 & 31, but that just looks weird
''recTrodeChannel% := [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,50,51];
'if recNElectrodes% > 0 then
'    for i% := 1 to maxTrodes% do'29 do '
'        recTrodeChannel%[i%-1] := i%;
'    next;
'    
''    recTrodeChannel%[0] := 2; 
''    recTrodeChannel%[1] := 3; 
''    recTrodeChannel%[2] := 4; 
''    recTrodeChannel%[3] := 5;
''    recTrodeChannel%[4] := 6;
''    recTrodeChannel%[5] := 7;
''    recTrodeChannel%[6] := 8;
''    recTrodeChannel%[7] := 9;
''    recTrodeChannel%[8] := 10;
''    recTrodeChannel%[9] := 11;
''    recTrodeChannel%[10] := 12;
''    recTrodeChannel%[11] := 13;
''    recTrodeChannel%[12] := 14;
''    recTrodeChannel%[13] := 15;
''    recTrodeChannel%[14] := 16;
''    recTrodeChannel%[15] := 17;
''    recTrodeChannel%[16] := 18;
''    recTrodeChannel%[17] := 19;
''    recTrodeChannel%[18] := 20;
''    recTrodeChannel%[19] := 21;
''    recTrodeChannel%[20] := 22;
''    recTrodeChannel%[21] := 23;
''    recTrodeChannel%[22] := 24;
''    recTrodeChannel%[23] := 25;
''    recTrodeChannel%[24] := 26;
''    recTrodeChannel%[25] := 27;
''    recTrodeChannel%[26] := 28;
''    recTrodeChannel%[27] := 29;
''    recTrodeChannel%[28] := 50; '30 reserved for TextMark
''    recTrodeChannel%[29] := 51; '31 seems to be reserved for Keyboard input
'            'i don't like this because 50 and 51 are orphaned, i'd rather move everything back and keep it contiguous
'endif
'
end
'======  end SetTrodeChannels() ======================


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' CreateSampleConfiguration()
' jackie's version, 2014 Aug 21
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc CreateSampleConfiguration()
    
	var index;
    var r;
    var i%;
    var thisTrodeString$;
    var sampleRate%;
    sampleRate% := 50000; 'was 28000
    'call SetTrodeChannels to fill Trode Channels, Ports, and Numbers arrays
    SetTrodeChannels();

PrintLog("Port numbers on CED are......: %d \n", recTrodePort%);
PrintLog(" >> for Trode Channel numbers: %d \n", recTrodeChannel%);
PrintLog(" >> for Trode Probe Positions: %d \n", recTrodePosition%);

    ' Initialize sampling settings 'probably shouldn't fuck with these
    SampleClear();  'remove any previous sampling settings - shouldn't really do anything, but I seem to be getting a wavemark when I shouldn't be asking for one
    SampleChannels(200); 'Set the max number of channels to be 100! this should solve all my problems
    SampleAutoComment(0);  'no automatic prompt for file comments when sampling ends
	SampleAutoCommit(30);  'automatically commit sampling every 30 seconds
    SampleAutoFile(0);     'set auto-filing state to "off"
    'SampleAutoName$("reclab000");  'set file name template
    
    ' Event channel 0 is for sound triggers
    SampleEvent(recTrigChannel%, recTriggerPort%, 2, 10);  'create a level channel to capture triggers, 10 Hz max sustained
    SampleComment$(recTrigChannel%, "Trigger");
    SampleTitle$(recTrigChannel%, "Trigger");

    if recUseJoystick% = 0 then
        ' Event channel 1 is for the lever
        SampleEvent(recLeverChannel%, recLeverPort%, 2, 10);  'create a level channel for the lever, 10 Hz max sustained
        SampleTitle$(recLeverChannel%, "Lever");
        SampleComment$(recLeverChannel%, "Lever");
    else
        'create joystick channels
        'X
        SampleWaveform(configJoyXChannel%,configJoyXPort%,5000); 
        SampleComment$(configJoyXChannel%,"JoystikX");
        SampleTitle$(configJoyXChannel%,"JoystikX");
        'Y
        SampleWaveform(configJoyYChannel%,configJoyYPort%,5000); 
        SampleComment$(configJoyYChannel%,"JoystikY");
        SampleTitle$(configJoyYChannel%,"JoystikY");
        'Read joystick offsets
        GetJoystickOffsets(0);  'there is only one joystick type for Recanzone and it is 0
        'Set additional info for joystick channels, notably offset
        SampleCalibrate(configJoyXChannel%,"volt",1,joystickXOffset);
        SampleCalibrate(configJoyYChannel%,"volt",1,joystickYOffset);
        
        'Create XY view for joystick display
        joyview% := FileNew(12);  'open an XY window
        'Create a new channel in the XY view to display the fixation point
        joydatachan% := XYSetChan(0);
        XRange(-2.75,2.75);  'set XRange
        YRange(-2,-2.75,2.75);  'set YRange, all visible channels
        XYDrawMode(0,5,0);  'turns off automatic axis range mode
        WindowVisible(1);  'make window visible
        'Window(75, 55, 100, 100); 'set to lower 16th of screen
        Window(0, 60, 40, 100); 'trying different position
        XYColour(joydatachan%,16);  'set a colo(u)r for joydatachan%
        XYSize(joydatachan%,-1); 'for channel joydatachan%, plot only one point at a time (-1)
    endif

    ' Text marks
    SampleTextMark(200);  'set channel 30 as TextMark channel, 200 characters, which is max allowed by CED
    recChanTM% := 30;  'That's the TextMark channel --> this isn't used anywhere, it's just to remind us that channel 30 IS textmark (by default)
    '31 is keyboard input also
    
    ' Record DAC0 (sound output) only on debug, it will inflate the file sizes...
    if recDebug% = 1 then
        SampleWaveform(recDAC0Channel%, 6, 50000);   'create a 50 kHz channel to record sound output (on testing only)
        SampleTitle$(recDAC0Channel%, "DAC0");
        SampleComment$(recDAC0Channel%, "DAC0");
    endif

' Record as many electrodes as specified in Experiment Selection Dialog
if recNElectrodes% = 2 then'IF 2 CHANNELS: assume you're Teeing off a single input channel to do wavemark & waveform!
    i%:=0; 'do channel 1
        SampleWaveMark(recTrodeChannel%[i%],recTrodePort%[i%], 100, 34, 15, sampleRate%); 'channel#, port#,sustained spike rate, points, pre-trigger, sampling rate
        thisTrodeString$ := "Trode " + Str$(recTrodePosition%[i%]);
        SampleTitle$(recTrodeChannel%[i%], "OnliWaveM"); 'name Channel with actual trode position #
        SampleComment$(recTrodeChannel%[i%], "Single trode: online wavemark"); 'and comment Channel with Trode Position #
    i%:=1; 'do channel 2
        SampleWaveform(recTrodeChannel%[i%],recTrodePort%[i%], sampleRate%); 'channel#, port#, and "ideal" samplig rate
        thisTrodeString$ := "Trode " + Str$(recTrodePosition%[i%]);
        SampleTitle$(recTrodeChannel%[i%], "Single trode"); 'name Channel with actual trode position #
        SampleComment$(recTrodeChannel%[i%], "Single trode: continuous record"); 'and comment Channel with Trode Position #
    
else if recNElectrodes% = 3 then'IF 3 CHANNELS: assume you're Teeing off a single input channel to do wavemark & waveform & an event channel
    '**** YOU'RE GOING TO NEED A MORE SOPHISTICATED WAY TO HANDLE THESE OPTIONS!!****
    i%:=0; 'do channel 1
        SampleWaveMark(recTrodeChannel%[i%],recTrodePort%[i%], 100, 34, 15, sampleRate%); 'channel#, port#,sustained spike rate, points, pre-trigger, sampling rate
        thisTrodeString$ := "Trode " + Str$(recTrodePosition%[i%]);
        SampleTitle$(recTrodeChannel%[i%], "OnliWaveM"); 'name Channel with actual trode position #
        SampleComment$(recTrodeChannel%[i%], "Single trode: online wavemark"); 'and comment Channel with Trode Position #
    i%:=1; 'do channel 2
        SampleWaveform(recTrodeChannel%[i%],recTrodePort%[i%], sampleRate%); 'channel#, port#, and "ideal" samplig rate
        thisTrodeString$ := "Trode " + Str$(recTrodePosition%[i%]);
        SampleTitle$(recTrodeChannel%[i%], "Single trode"); 'name Channel with actual trode position #
        SampleComment$(recTrodeChannel%[i%], "Single trode: continuous record"); 'and comment Channel with Trode Position #
    i%:=2; 'do channel 3 - event chan (TTL)
        SampleEvent(recTrodeChannel%[i%],1,1,1000); 'channel#, EVENT port#, 1=event on rising edge,max sustained event rate (Hz)
        thisTrodeString$ := "Trode " + Str$(recTrodePosition%[i%]);
        SampleTitle$(recTrodeChannel%[i%], "TTL in"); 'name Channel with actual trode position #
        SampleComment$(recTrodeChannel%[i%], "Single trode: TTL input"); 'and comment Channel with Trode Position #        
        
else 'all wavemark
    for i% := 0 to recNElectrodes%-1 do  'if recNElectrodes% is 0, this gloriously does nothing with no error!
        'ditch the case statements and loop it
        'SampleWaveform instead of WaveMark --> will have to filter but then we get LFP data too, which may be pretty cool!
        SampleWaveform(recTrodeChannel%[i%],recTrodePort%[i%], sampleRate%); 'channel#, port#, and "ideal" sampling rate
        thisTrodeString$ := "Trode " + Str$(recTrodePosition%[i%]);
        SampleTitle$(recTrodeChannel%[i%], thisTrodeString$); 'name Channel with actual trode position #
        SampleComment$(recTrodeChannel%[i%], thisTrodeString$); 'and comment Channel with Trode Position #
    '    printlog("thisTrodeString$ = " + thisTrodeString$ + "\n");   
    next;
    endif
endif


' NOTE: wavemark channels must be b/w 1-100    
'Note that the sample rate is strange (28 kHz).  These are exactly the Usrey lab conventions, so whatevs.
'Actual sampling rate may vary! (constrained by hardware)

    'set up stimulation copy ports
    if recRewardType% > 0 then
        SampleWaveform(configStimCopyChannel1%,configStimCopyPort1%,5000);
        SampleWaveform(configStimCopyChannel2%,configStimCopyPort2%,5000);
    endif;
    
    
    
    
' Set optimise mode (do this last). Settings specific to Power1401 625 (that's the "5"). 
    ' The second arg groups channels with same ideal rates together so they all get same 
    ' actual rate. That means multiple electrodes (if used) will all get same actual rate, 
    ' assuming you use same ideal rate (in SampleWavemark()). 
    
    printlog("PLS file load success is %d\n",SampleSequencer(script$ + "recgen.pls")+1); 'Load sample sequencer
    
	SampleOptimise(2, 1, 5, 2, 50, -1, 1);  'Optimization settings, don't change unless there's an issue; turn burst mode on!!
    SampleMode(1);  'Continuous recording
end

' ========== end CreateSampleConfiguration ===============
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' CreateSampleConfiguration()
' original version (10waveMarks)
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''

'proc CreateSampleConfiguration()
'    
'	var index;
'    var r;
'    var i%;
'    
'    ' Initialize sampling settings
'    SampleClear();  'remove any previous sampling settings - shouldn't really do anything, but I seem to be getting a wavemark when I shouldn't be asking for one
'	SampleAutoComment(0);  'no automatic prompt for file comments when sampling ends
'	SampleAutoCommit(30);  'automatically commit sampling every 30 seconds
'    SampleAutoFile(0);     'set auto-filing state to "off"
'    'SampleAutoName$("reclab000");  'set file name template
'    
'    ' Event channel 0 is for sound triggers
'    SampleEvent(recTrigChannel%, recTriggerPort%, 2, 10);  'create a level channel to capture triggers, 10 Hz max sustained
'    SampleComment$(recTrigChannel%, "Trigger");
'    SampleTitle$(recTrigChannel%, "Trigger");
'    
'    if recUseJoystick% = 0 then
'        ' Event channel 1 is for the lever
'        SampleEvent(recLeverChannel%, recLeverPort%, 2, 10);  'create a level channel for the lever, 10 Hz max sustained
'        SampleTitle$(recLeverChannel%, "Lever");
'        SampleComment$(recLeverChannel%, "Lever");
'    else
'        'create joystick channels
'        'X
'        SampleWaveform(configJoyXChannel%,configJoyXPort%,5000); 
'        SampleComment$(configJoyXChannel%,"JoystikX");
'        SampleTitle$(configJoyXChannel%,"JoystikX");
'        'Y
'        SampleWaveform(configJoyYChannel%,configJoyYPort%,5000); 
'        SampleComment$(configJoyYChannel%,"JoystikY");
'        SampleTitle$(configJoyYChannel%,"JoystikY");
'        'Read joystick offsets
'        GetJoystickOffsets(0);  'there is only one joystick type for Recanzone and it is 0
'        'Set additional info for joystick channels, notably offset
'        SampleCalibrate(configJoyXChannel%,"volt",1,joystickXOffset);
'        SampleCalibrate(configJoyYChannel%,"volt",1,joystickYOffset);
'        
'        'Create XY view for joystick display
'        joyview% := FileNew(12);  'open an XY window
'        'Create a new channel in the XY view to display the fixation point
'        joydatachan% := XYSetChan(0);
'        XRange(-2.75,2.75);  'set XRange
'        YRange(-2,-2.75,2.75);  'set YRange, all visible channels
'        XYDrawMode(0,5,0);  'turns off automatic axis range mode
'        WindowVisible(1);  'make window visible
'        'Window(75, 55, 100, 100); 'set to lower 16th of screen
'        Window(0, 60, 40, 100); 'trying different position
'        XYColour(joydatachan%,16);  'set a colo(u)r for joydatachan%
'        XYSize(joydatachan%,-1); 'for channel joydatachan%, plot only one point at a time (-1)
'    endif
'    
'    
'    
'    ' Text marks
'    SampleTextMark(200);  'set channel 30 as TextMark channel, 200 characters, which is max allowed by CED
'    recChanTM% := 30;  'That's the TextMark channel
'    
'    ' Record DAC0 (sound output) only on debug, it will inflate the file sizes...
'    if recDebug% = 1 then
'        SampleWaveform(recDAC0Channel%, 6, 50000);   'create a 50 kHz channel to record sound output (on testing only)
'        SampleTitle$(recDAC0Channel%, "DAC0");
'        SampleComment$(recDAC0Channel%, "DAC0");
'    endif
'    
'    
'	' Record as many electrodes as specified in Experiment Selection Dialog
'    for i% := 1 to recNElectrodes% do  'if recNElectrodes% is 0, this gloriously does nothing with no error!
'        docase
'        case i% = 1 then
'            SampleWaveMark(recTrode1Channel%, 0, 100, 34, 15, 28000); ' chan, ADC port, sustained spike rate, points, pre-trigger, rate
'            SampleTitle$(recTrode1Channel%, "Trode 1"); 
'            SampleComment$(recTrode1Channel%, "Trode 1");
'        case i% = 2 then
'            SampleWaveMark(recTrode2Channel%, 1, 100, 34, 15, 28000); ' chan, ADC port, sustained spike rate, points, pre-trigger, rate
'            SampleTitle$(recTrode2Channel%, "Trode 2");
'            SampleComment$(recTrode2Channel%, "Trode 2");
'        case i% = 3 then
'            SampleWaveMark(recTrode3Channel%, 2, 100, 34, 15, 28000); ' chan, ADC port, sustained spike rate, points, pre-trigger, rate
'            SampleTitle$(recTrode3Channel%, "Trode 3");  
'            SampleComment$(recTrode3Channel%, "Trode 3");            
'        case i% = 4 then
'            SampleWaveMark(recTrode4Channel%, 3, 100, 34, 15, 28000); ' chan, ADC port, sustained spike rate, points, pre-trigger, rate
'            SampleTitle$(recTrode4Channel%, "Trode 4"); 
'            SampleComment$(recTrode4Channel%, "Trode 4");            
'        case i% = 5 then
'            SampleWaveMark(recTrode5Channel%, 4, 100, 34, 15, 28000); ' chan, ADC port, sustained spike rate, points, pre-trigger, rate
'            SampleTitle$(recTrode5Channel%, "Trode 5"); 
'            SampleComment$(recTrode5Channel%, "Trode 5");
'        case i% = 6 then
'            SampleWaveMark(recTrode6Channel%, 5, 100, 34, 15, 28000); ' chan, ADC port, sustained spike rate, points, pre-trigger, rate
'            SampleTitle$(recTrode6Channel%, "Trode 6");
'            SampleComment$(recTrode6Channel%, "Trode 6");
'        case i% = 7 then
'            SampleWaveMark(recTrode7Channel%, 6, 100, 34, 15, 28000); ' chan, ADC port, sustained spike rate, points, pre-trigger, rate
'            SampleTitle$(recTrode7Channel%, "Trode 7");   
'            SampleComment$(recTrode7Channel%, "Trode 7");
'        case i% = 8 then
'            SampleWaveMark(recTrode8Channel%, 7, 100, 34, 15, 28000); ' chan, ADC port, sustained spike rate, points, pre-trigger, rate
'            SampleTitle$(recTrode8Channel%, "Trode 8");
'            SampleComment$(recTrode8Channel%, "Trode 8");
'        case i% = 9 then
'            SampleWaveMark(recTrode9Channel%, 8, 100, 34, 15, 28000); ' chan, ADC port, sustained spike rate, points, pre-trigger, rate
'            SampleTitle$(recTrode9Channel%, "Trode 9"); 
'            SampleComment$(recTrode9Channel%, "Trode 9");            
'        case i% = 10 then
'            SampleWaveMark(recTrode10Channel%, 9, 100, 34, 15, 28000); ' chan, ADC port, sustained spike rate, points, pre-trigger, rate
'            SampleTitle$(recTrode10Channel%, "Trode 10");
'            SampleComment$(recTrode10Channel%, "Trode 10");            
'        endcase;        
'    next;
'    'Note that the sample rate is strange (28 kHz) and 34 samples covers about 1.25 ms.  These are exactly the Usrey lab conventions, so whatevs.
'    
'    
'    ' Set optimise mode (do this last). Settings specific to Power1401 625 (that's the "5"). 
'    ' The second arg groups channels with same ideal rates together so they all get same 
'    ' actual rate. That means multiple electrodes (if used) will all get same actual rate, 
'    ' assuming you use same ideal rate (in SampleWavemark()). 
'    
'    printlog("PLS file load success is %d\n",SampleSequencer(script$ + "recgen.pls")+1); 'Load sample sequencer
'    
'	SampleOptimise(2, 1, 5, 2, 50);  'Optimization settings, don't change unless there's an issue
'    SampleMode(1);  'Continuous recording
'end
'
'
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' InitializeWindows()
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc InitializeWindows()
    
    ' Since we are opening files here, set the path. 
    FilePathSet(data$, 1, 1);  'Sets path for new data files
    
    ' Open xy window for use in online display
    'Currently disabled because ExtractSpaceInitialize etc. are disabled, so it does nothing.  May
    'need to be brought back online earlier than ExtractSpace!
    'recXYWindowView% := FileNew(12);
	'Window(0, 50, 50, 100); 
	'View(recXYWindowView%).WindowVisible(1);
    
	'Open the data sampling window -- only if CED is present!
    if recCEDIsPresent% = 1 then
        recDataWindowView% := FileNew(0,4);
        Window(0, 0, 100, 50); 
        View(recDataWindowView%).WindowVisible(1);
        
        if recUseJoystick% = 0 then
            ' Create a memory channel for the debounced lever information
            recMemChanLeverDebounce% := MemChan(8,25); 'Create textmark channel for debounced lever with attached lever value, 25 characters
            ChanTitle$(recMemChanLeverDebounce%,"DBLever");  'Give it a title
            chanshow(recMemChanLeverDebounce%);  'Show it
        else
            CreateJoystickChannels%();
        endif;
        
    endif
    
end;




'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' InitializeToolbar - prepare toolbar buttons. Note that the idle processing function 
' (ToolbarSet(0, blah, blah)) is not set here. That's done when the user hits the start 
' button.
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc InitializeToolbar()
    
	View(App(8)).WindowVisible(0);	'Hide the standard sample bar
	ToolbarVisible(1);
	ToolbarSet(recStartButton%, "Start", Start%);
	ToolbarSet(recPauseButton%, "Pause", Pause%);
	ToolbarSet(recResumeButton%, "Resume", Resume%);
    ToolbarSet(recSelectNewExptButton%, "New Expt.", PrepToReturnToExptSelectDialog%);
	'ToolbarSet(recRewardButton%, "Reward", Reward%); 'use Timing/Reward button instead!
    ToolbarSet(recStopButton%, "Stop Sampling", Stop%);
    Toolbarset(recTimingRewardButton%, "Timing/Reward", CallTimingReward%);
    Toolbarset(recJoystickButton%, "Joystick", CallJoystick%);
    ToolbarSet(recCalibrationButton%, "Joystick Calibration", CalibrateJoystick%);  'automatic joystick calibration - make sure power is on to joystick
    
    ' Explicitly set enabled state of things...
    ToolbarEnable(recStartButton%, 1);
    ToolbarEnable(recPauseButton%, 0);
    ToolbarEnable(recResumeButton%, 0);
    ToolbarEnable(recSelectNewExptButton%, 1); 'set to 0 because doesn't work until after "Start" anyway  :( *jao - has to be 1 here to call window
    'ToolbarEnable(recRewardButton%, 1);
    ToolbarEnable(recStopButton%, 0);
    ToolbarEnable(recTimingRewardButton%, 0);
    ToolbarEnable(recJoystickButton%, 0);
    ToolbarEnable(recCalibrationButton%, 1);
    
end;

    


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' GetPlayWaveKey$(index%)
' 
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func GetPlayWaveKey$(index%)
    
    return Chr$(Asc(recDAC0Key$)+index%);
    
end




'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' InitializePlayWaveAreas - add play wave areas for sounds. 
' Areas will be allocated in order: "A", "B", .... up to the
' max number of stimuli per trial.  We will reload each
' PlayWaveArea on a trial-by-trial basis, if necessary.
' Currently, the max number of stimuli per trial is hardcoded at 10
' 
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Proc InitializePlayWaveAreas()
    var st;
    var i%;

        
    for i% := 0 to recMaxPWA%-1 do

        st := PlayWaveAdd(GetPlayWaveKey$(i%), GetPlayWaveKey$(i%), recDAC0%, recPlayRateHz, recMaxPoints%);
        if st < 0 then
            Message("Error in PlayWaveAdd for area " + GetPlayWaveKey$(i%));
            halt;
        else
            PlayWaveTrigger(GetPlayWaveKey$(i%), 1);  'set playwave area to triggered mode
        endif        
        
    next
          
end





'----------------- PlaySound ---------------------------------------------------------------
'
' PlaySound plays the sound for the trial number in recTrialOrder%[recCurrentTrial%].
' It sets the correct speaker and PA4 attenuation and logs a SampleText detailing the stimulus.
'
'-------------------------------------------------------------------------------------------

Func PlaySound%(isS2%)
    var atten;
    var calatten;
    var trlatten;
    var s$;
    var playChar$;
    var spkr%;
    var playInd%;
    var status%;
    var isS2$;
    var thisStim%;  'this is the index of the physical stimulus (re: stim file list or stim properties list)
    var thisPWAIndex%;  'this is the PWA it will be found in on this trial
    var maxdB;
        
    'Get index of current trial
    playInd% := recTrialOrder%[recCurrentTrial%-1];  'recCurrentTrial is in human units, convert to index units
    
    'Note that recStimCount% (which steps us through the n S1s and S2, if present, is incremented 
    'in StimComplete% and reset to zero in PrepareNewTrial%.
    
    'Get this PWA index
    thisPWAIndex% := recPWAList%[recStimCount%][playInd%];
    
    'Get this stimulus index
    thisStim% := recStimList%[thisPWAIndex%][playInd%];
    
    'Get play wave area with current stimulus
    'playChar$ := GetPlayWaveKey$(recStimCount%);  
    playChar$ := GetPlayWaveKey$(thisPWAIndex%);
    
    'Get speaker for current stimulus
    spkr% := recSpeakerList%[thisPWAIndex%][playInd%];

    
    'Get calibrating attenuation for current stimulus - this is the value to set a stimulus to 65 dB, by definition
    if recMatGenStim% = 0 then
        calatten := recTrialStimCal[thisStim%][spkr%-1];  'I think we have to label speakers 1:N, not 0:N-1, so adjusting that here
        'calatten := recAttenList%[recStimCount%][playInd%];  'value originally read from file
        'calatten := recAttenList%[thisStim%][playInd%];  'value originally read from file
    else
        'calatten := recGeneratedAtten[recStimCount%];  'value created at time of stimulus generation
        calatten := recGeneratedAtten[thisPWAIndex%];  'value created at time of stimulus generation
    endif;
    
    'Get trial-based attenuation for current stimulus
    trlatten := recDeltadBList[recStimCount%][playInd%];  'corresponds to recPWAList%[][], index the same way
    
    'Get total attenuation
    printlog("cal atten is %f and current db is %f\n",calatten,recAudiogramCurrentdB);
    if recExpToRun% = recExpAudiogramButton% then
        atten := 65 + calatten - recAudiogramCurrentdB;
    else
        atten := calatten + trlatten;  'for all other cases, attenuation is calibrating attenuation + trial attenuation
    endif;
    
    'It is possible that due to the maximum intensity of the stimulus that the requested attenuation
    '(particularly in the audiogram) could be negative.  If so, we are screwed.  Set atten to 0 and point
    'this out to the user
    if atten < 0 then
        atten := 0;
        maxdB := 65 + calatten;
        if recExpToRun% = recExpAudiogramButton% then
            recAudiogramCurrentdB := maxdB;  'reset requested dB on audiogram to max allowed
            'Removing message box because it is causing issues with experimentation
            'message("dB requested is above maximum possible for this stim, has been set to %f",maxdB);
            printlog("dB requested is above maximum possible for this stim (%s), has been set to %f",NameThatStimulus$(thisStim%),maxdB);
        else
            'Removing message box because it is causing issues with experimentation
            'message("Requested attenuation was negative, has been reset to 0!");
            printlog("Requested attenuation (%f dB) was negative for this stimulus (%s), has been reset to 0!",calatten + trlatten,NameThatStimulus$(thisStim%));
        endif;
    endif;
    
        
    
    'Set some attenuation (30 db) during testing, just for the sake of our ears.
    'Once reclab_panstim starts returning a value here, we're in business
    'For now, don't set any attenuation if there is trial-based (e.g. intensity tuning) because
    'it would be useful to hear that.  If those are too loud, drop the atten=0 part and just dump
    '30 dB during the debug phase.  Might want to comment this all out once we're up and running
    'if atten = 0 and recDebug% = 1 then
    if recCalibIsPresent% = 0 then
        if recSearchStimType% = 3 then
            atten := 0;  'for clicks, don't attenuate
        else
            'atten := rand(4,30);  'To check that the PA4 is working properly, let's just set a new value every time
            atten := 30;  'temporary, during calibrations
        endif;
    endif;
    
    
    ' Set speaker and atten
    if recCEDIsPresent% = 1 then
        status% := recSpeaker%(spkr%);
        if status% <> 0 then
            return status%;
        endif;
          
        status% := recAtten%(atten);
        if status% <> 0 then
            return status%;
        endif;  
    endif;
    
    'This may not be terribly useful, stimulus ID might be helpful as well - but it's just a log and the sampletext is later
    'use trlatten for attenuation because calibrating attenuation isn't informative
    RecLogStatus("PlaySound", "SPK " + str$(spkr%) + " ATT " + str$(trlatten) + "\n");
    

    if recCEDIsPresent% = 1 then
        
        ' Send sample key for the play wave area. Sequencer Variable 3 holds the number of clock ticks at presentation
        SafeSampleKey(playChar$);
        
        StimOn := SampleSeqVar(3)*UsPerTime/1000000;  'Now, StimOn holds actual presentation time, usually
        while StimOn = PrevStimOn do  'This will happen if the above line occurs before the stim starts
            yield(.001,1023);  'yield a millisecond until the stimulus starts playing
            StimOn := SampleSeqVar(3)*UsPerTime/1000000;  'Keep checking until StimOn is updated
        wend;          
        PrevStimOn := StimOn;  'keep track of most recent StimOn
        
        'determine S1/S2 status
        docase
        case isS2% = 0 then
            isS2$ := "S1";   'indicates non-terminal S1, trial continues on CR, trial terminates on FA
        case isS2% = 1 then
            isS2$ := "S2";   'Indicates S2, trial terminates on H/M, will be rewarded for H
        case iss2% = 2 then
            isS2$ := "S1T";  'indicates terminal S1, trial terminates on CR/FA, will be rewarded for CR
        endcase
        
        'write stimulus to sampletext, we need to separate this out based on experiment type
        ' The sample text string contains the following (comma-separated) fields:
        ' 1. playChar: A for first stimulus in a trial, B for second, etc., up to J.
        ' 2. time: time of onset of stimulus
        ' 2. trial number: overall trial counter
        ' 3. speaker number
        ' 4. trial-based attenuation
        ' 5. freq for tone, filename for loaded stims.  (what's most appropriate for generated stims?) 
        '    this is actually a big question.  I think I'll want to have a function that simply determines 
        '    what the best "english" translation of the stimulus is...
        
        docase
        case recMatGenStim% = 0 then 'stimuli are read from a file
            's$ := Print$("\"%s\",%s,%d,%d,%.1f,\"%s\"", playChar$, isS2$, recCurrentTrial%, spkr%, trlatten, recTrialLoadLoc$[recPWAList%[recStimCount%][playInd%]]);
            s$ := Print$("\"%s\",%f,%s,%d,%d,%.1f,\"%s\"", playChar$, StimOn, isS2$, recCurrentTrial%, spkr%, trlatten, recTrialLoadLoc$[thisStim%]);
            SampleText(s$, StimOn);
        case recMatGenStim% = 1 then 'stimuli are generated
            's$ := Print$("\"%s\",%s,%d,%d,%.1f,\"%s\"", playChar$, isS2$, recCurrentTrial%, spkr%, trlatten, NameThatStimulus$(recPWAList%[recStimCount%][playInd%]));
            s$ := Print$("\"%s\",%f,%s,%d,%d,%.1f,\"%s\"", playChar$, StimOn, isS2$, recCurrentTrial%, spkr%, trlatten, NameThatStimulus$(thisStim%));
            SampleText(s$, StimOn);
        endcase
        
    endif
    
    'Calculate the duration in points of the stimulus
    'recPlayPoints% := recPlayRateHz*recTrialDur[recPWAList%[recStimCount%][playInd%]]/1000;  'recTrialDur is in ms   
    recPlayPoints% := recPlayRateHz*recTrialDur[thisStim%]/1000;  'recTrialDur is in ms     
    
    return status%;
end





'----------- StimComplete%(isS2%, success%) -------------------------------------
'
' Stim has ended. isS2% tells StimComplete% whether the just-finished stimulus 
' is an S1 (0), S2 (1), or terminal S1 (2). .. or S3 (3) *jao 
' success% tells the function whether the response was successful: 1=good, 0=bad.
' (Success on an S1 is no response, success on an S2 is response)
' Records text marker, does an analysis update using ExtractSpace. 
'
' A return value of -1 means an error has occurred, abort. 
' When isS2%=0, return value of 0 means continue with S1 stims, return value of 1
' means move on to terminal S2 stim, return value of 2 means move on to terminal S1 stim.
' When isS2%=1 the return value (unless it is negative) is ignored, but is set to 0, because
' the next stimulus will be an S1.
'
'--------------------------------------------------------------------------------

'Note that on 0,0 input, the current trial counter will be decremented and the interrupted trial will be shuffled in later.

func StimComplete%(isS2%, success%)
    var status% := 0;
    var strtmp$;
    var stimInd%;
    var termInd%;
    var now;
    var resultCode$;
    
    'Get index of current trial
    stimInd% := recTrialOrder%[recCurrentTrial%-1];  'recCurrentTrial is in human units, convert to index units
    docase
    case isS2% = 0 then  'stimulus is S1, not terminal
        if success% = 1 then
            ' Record completed stim here, and update online analysis. 
            ' This will print the same output, e.g. "E,234" for each non-terminal S1 in trial 234, so there may be multiple sampletexts with the same entry
            resultCode$ := "E";
            'strtmp$ := Print$("E,%d", recCurrentTrial%);  'E is for, I dunno, Early Correct Rejection?  (Keeping 'E' from original code)
            'SampleText(strtmp$, recPreciseTrialTime);
            
'            'Increment within-trial stimulus counter, if we've played all the S1s, return 1 if playing the S2 or 2 if playing a terminal S1
'            recStimCount% += 1;
'            termInd% := recTrialTerminalIndex%[stimInd%];  'terminal index
'            if termInd% = recStimCount% then 'if the next stimulus is the terminal stimulus
'                docase '*jao
'                    case recTrialTerminalIsS2%[stimInd%] = 1 then 'terminal stimulus is a target ; for AMDis is(HI) recTrialS2%[i%] > recTrialS1%[i%] 
'                        status% := 1;  'return indicates S2 is next (S2-HI if AMDis)
'                    case recTrialTerminalIsS2%[stimInd%] = 2 then 'terminal stim in a target (LO) recTrialS2%[i%] < recTrialS1%[i%] *jao 
'                        printlog("AMDis Lo: next stim will be a decrease in AMrate, responseMode:=3 \n"); 
'                        status% := 3;  'return indicates S2-LO is next
'                    else
'                        status% := 2;  'return indicates terminal S1 is next 'For AMDis(now Hi/Lo) this would-be-catch trial will be rewarded 50% *jao
'                endcase;
'                'otherwise, return is 0 indicating non-terminal S1
'            endif;
        else 'false alarm on S1
            'trial counter will be decremented in the idle loop
            resultCode$ := "F";
            'strtmp$ := Print$("F,%d", recCurrentTrial%);  'F is for False Alarm, there is fundamentally no difference between an early FA and a terminal FA - the monkey doesn't know
            'SampleText(strtmp$, recPreciseTrialTime);
            status% := 0;  'After FA, we will indicate the next stimulus is an S1, as it will be.
        endif
    case isS2% = 1 and (recExpToRun% = recExpAMDiscButton% or recExpToRun% = recExpSpaceDisButton%) then  'If it's an S2 (target), AMDis S2-HI *jao
        printlog("AMDis Hi!, current trial is %d\n", recCurrentTrial%); 
        if success% = 1 then
            resultCode$ := "HH";
            'strtmp$ := Print$("HH,%d", recCurrentTrial%);  'H is for Hit
            'SampleText(strtmp$, recPreciseTrialTime);
        else
            resultCode$ := "MH";
            'strtmp$ := Print$("MH,%d", recCurrentTrial%);  'M is for Miss
            'SampleText(strtmp$, recPreciseTrialTime);
        endif;
        status% := 0;  'After S2, we will indicate the next stimulus is an S1, as it will be.
    case isS2% = 1 then  'If it's an S2 (target) - (SAME/DIFF)
        if success% = 1 then
            resultCode$ := "H";
            'strtmp$ := Print$("H,%d", recCurrentTrial%);  'H is for Hit
            'SampleText(strtmp$, recPreciseTrialTime);
        else
            resultCode$ := "M";
            'strtmp$ := Print$("M,%d", recCurrentTrial%);  'M is for Miss
            'SampleText(strtmp$, recPreciseTrialTime);
        endif;
        status% := 0;  'After S2, we will indicate the next stimulus is an S1, as it will be.
    case isS2% = 3 then  'If it's an S2 (target) 'AMDis S2-LO *jao - case is unique to AMDis and SpaceDis
        printlog("AMDis Lo!, current trial is %d\n", recCurrentTrial%);
        if success% = 1 then
            resultCode$ := "HL";
            'strtmp$ := Print$("HL,%d", recCurrentTrial%);  'H is for Hit
            'SampleText(strtmp$, recPreciseTrialTime);
        else
            resultCode$ := "ML";
            'strtmp$ := Print$("ML,%d", recCurrentTrial%);  'M is for Miss
            'SampleText(strtmp$, recPreciseTrialTime);
        endif;
        status% := 0;  'After S2, we will indicate the next stimulus is an S1, as it will be.
    case isS2% = 2 and (recExpToRun% = recExpAMDiscButton% or recExpToRun% = recExpSpaceDisButton%) then 'If it's a terminal S1 (intended no-response in gonogo) 'AMDis Hi/Lo case *jao
        printlog("AMDis SAME!, current trial is %d\n", recCurrentTrial%); 
        'we want to know if they went up or down!! (and also if rewarded, but need to know behavior too!!
        if success% = 1 then 'for HI/LO, success=1 means this trial was rewarded (coinFlipResult%) *jao
            resultCode$ := "SR";
            'strtmp$ := Print$("SR,%d", recCurrentTrial%);  'REWARDED SAME trial *jao
            'SampleText(strtmp$, recPreciseTrialTime);
        else
            resultCode$ := "SN";
            'strtmp$ := Print$("SN,%d", recCurrentTrial%);  'NOT REWARDED SAME trial *jao
            'SampleText(strtmp$, recPreciseTrialTime);
        endif;
        status% := 0;  'After S2, we will indicate the next stimulus is an S1, as it will be.
    case isS2% = 2 then 'If it's a terminal S1 (intended no-response)  - (SAME/DIFF)
        if success% = 1 then
            resultCode$ := "C";
            'strtmp$ := Print$("C,%d", recCurrentTrial%);  'C is for Correct Rejection, trial is over (This code is new, all other codes are old)
            'SampleText(strtmp$, recPreciseTrialTime);
        else
            resultCode$ := "F";
            'strtmp$ := Print$("F,%d", recCurrentTrial%);  'F is for False Alarm, there is fundamentally no difference between an early FA and a terminal FA - the monkey doesn't know
            'SampleText(strtmp$, recPreciseTrialTime);
        endif;
        status% := 0;  'After S2, we will indicate the next stimulus is an S1, as it will be.
    else
        RecLogError("StimComplete", "Unknown ttype (" + str$(isS2%) + ")");
        status% := -1;
    endcase
    'do it here instead!
    if recExpToRun% = recExpAudiogramButton% then
        strtmp$ := Print$("%s,%d,%f",resultCode$, recCurrentTrial%, recAudiogramPreviousdB);  'use previous dB, current dB is already updated
    else
        strtmp$ := Print$("%s,%d", resultCode$, recCurrentTrial%);
    endif;
    
    SampleText(strtmp$, recPreciseTrialTime);

    'call BehOutput now! (hijacking this logic, haha!)
    if recLogThisResult% = 1 then  'this value will be 1 and not be changed if we are not doing an audiogram - so basically always log, unless audiogram, in which case maybe log
        BehOutput(resultCode$, isS2%);
    endif;
    
    
    'increment StimCounter AFTER call to BehOutput!!!
    if isS2% = 0 and success% = 1 then  'stimulus is S1, not terminal
        'Increment within-trial stimulus counter, if we've played all the S1s, return 1 if playing the S2 or 2 if playing a terminal S1
        recStimCount% += 1;
        termInd% := recTrialTerminalIndex%[stimInd%];  'terminal index
        if termInd% = recStimCount% then 'if the next stimulus is the terminal stimulus
            docase '*jao
            case recTrialTerminalIsS2%[stimInd%] = 1 then 'terminal stimulus is a target ; for AMDis is(HI) recTrialS2%[i%] > recTrialS1%[i%] 
                status% := 1;  'return indicates S2 is next (S2-HI if AMDis)
            case recTrialTerminalIsS2%[stimInd%] = 2 then 'terminal stim in a target (LO) recTrialS2%[i%] < recTrialS1%[i%] *jao 
                printlog("AMDis Lo: next stim will be a decrease in AMrate, responseMode:=3 \n"); 
                status% := 3;  'return indicates S2-LO is next
            else
                status% := 2;  'return indicates terminal S1 is next 'For AMDis(now Hi/Lo) this would-be-catch trial will be rewarded 50% *jao
            endcase;
            'otherwise, return is 0 indicating non-terminal S1
        endif;
    endif;
    return status%;
    
    'TODO Figure out this ExtractSpace bit.  Doesn't look like recHBeh%/recHBak% handles are made...
    'All right, as regards the ExtractSpace stuff: For now, we're going to shelve this in order to
    'move forward.  The essential idea is that we can (and perhaps don't have to) create output files
    'on the fly for ease of Recanzone analysis.  In the past (i.e. the original ExtractSpace) these
    'files were designed to comport with longstanding Recanzone analysis.  This is probably no longer
    'necessary.  If such output files are needed, we can make them, but for now we'll leave it out and
    'later determine what is necessary.
    'if recCEDIsPresent% = 1 then
    'now := MaxTime();
    'First 4 arguments kosher, checking remaining.  Now last 4 OK.  Args 5-7 are unassigned.
    'ExtractSpace(recTLastProcessed, now, recDataWindowView%, recXYWindowView%, recHBeh%, recHBak%, recChanWM%, recChanTM%, recTrigChannel%, recLeverChannel%, recNSpeakers%);
    'recTLastProcessed := now;
    'endif
    
    'I'm kind of assuming this went with ExtractSpace
    'UpdateOnlineAnalysis();  'It was commented out when I found it.    
    
    
end





'''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' Start%()
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Start%()
    
    ' Disable start button, enable stop and pause
    view(recLog%).print("In Start%(). About to enable Toolbar.\n");
    ToolbarEnable(recStartButton%, 0);
    ToolbarEnable(recStopButton%, 1);
    ToolbarEnable(recPauseButton%, 1);
    ToolbarEnable(recTimingRewardButton%, 1);
    ToolbarEnable(recJoystickButton%, 1);
    ToolbarEnable(recSelectNewExptButton%, 1); 'enable it here because I disabled it before - :( *jao - button doesn't work after Start!
    view(recLog%).print("Toolbar Enabled.\n");

    ' Start the sampling.
    docase    
    case recCEDIsPresent% = 1 and recCurrentlySampling% = 0 then
        view(recLog%).print("CED is present. About to start sampling.\n");
        SampleStart();
        ToolbarText("Sampling started.");  ' Tell the world about it. 
        printlog("Sampling started\n");  ' Tell her about it, tell her everything you feel
        view(recLog%).print("Sampling started.\n");
        recCurrentlySampling% := 1;  'don't start sampling again
        TimePerADC := SampleTimePerAdc();  'get AD conversion rate
        UsPerTime := SampleUsPerTime();  'get # of microseconds per sample
        SecPerSample := TimePerADC*UsPerTime/1000000; 'get seconds per sample
        SampleText(recExptText$+"_"+blockTag$);  'put in the experiment type
        startingNewExpt% := 1;  'should be OK to start here
    case recCEDIsPresent% = 1 and recCurrentlySampling% = 1 then
        'if already sampling still want some of this stuff to happen!
        SampleText(recExptText$+"_"+blockTag$);  'put in the experiment type
        startingNewExpt% := 1;  'this allows a reset of joystick event checking
    case recCEDIsPresent% = 0 and recCurrentlySampling% = 0 then
        'virtually start sampling
        recCurrentlySampling% := 1;
        printlog("'Sampling' started\n");  ' Tell her about it, tell her everything you feel
        SampleText(recExptText$+"_"+blockTag$);  'put in the experiment type
        startingNewExpt% := 1;  'this allows a reset of joystick event checking
    endcase
    
    ' Set idle function
    ToolbarSet(0, "", IdleLoop%);
    
    ' Set iState to start
    iState% := stateStart%;    
    
    return 1;
end





'''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' Stop%() - stops sampling
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Stop%()
    PrintLog("Stop called\n");
    PrintLog("#HITS = " + str$(numHits%) + ",   #MISSES = " + str$(numMisses%) + ",   #FPs = " + str$(numFPs%) + ",   LastHitReward(mL) = " + str$(LastHitReward) + ",   TOTAL Juice(mL) = " + str$(amountRewarded) + ".\n");            
    
    recCurrentlySampling% := 0;    
    
    ' Stop sampling....
    if SampleStatus() <> -1 then
        SafeSampleKey("S");  'Kill blink sequence, if one exists - when does this happens? think about making it not safe ~jao
        SafeSampleKey("K");  'Kill reward, just in case, only relevant if CED is being used
        SampleStop();
        'FileSaveAs(recFileSaveLoc$ + recMonkPrefix$ + ".smr", -1); 'Save data file automagically 
        FileSaveAs(recFileSaveLoc$ + recMonkPrefix$ + "_"+ Date$(2,2,3,3,"-")+ blockTag$ + ".smr", -1); 'NEW FORMAT! add date automagically! 

    endif

    ' Returning zero from here or any ToolbarSet() functions causes the 
    ' Toolbar() function to return.
    recReadyToQuit% := 1;  'prevent from trying to open another experiment
    return 0;
    
end



'''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' PrepToReturnToExptSelectDialog%() - sets idle loop to return
' to experiment selection dialog when the current trial is complete
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func PrepToReturnToExptSelectDialog%()
    RTESDIsPressed% := 1;
    return 1;  '<-------  This missing line cost me literally like 50 hours to track down.
end;


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' ReturnToExptSelectDialog%() - continues sampling, but opens expt. selection dialog
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func ReturnToExptSelectDialog%()
    PrintLog("Return to Expt. Selection Dialog called\n"); 
    
    'Reset appropriate variables
    recCurrentTrial% := 0;  'start with trial #1
    recSearchLoaded% := 0;  'Need to reset recSearchLoaded, or load will be skipped even for non-search scenarios
    RTESDIsPressed% := 0;
    recExptText$ := "";
    recIsPaused% := 0;      ' djs - if pause, then hit "new expt", this must be set back to zero or the idle loop
                            ' will still think you're paused!
    
    'Unset the idle function, so things don't start moving immediately when the Toolbar is next called
    'ToolbarSet(0, "");
    
    ' This causes the Toolbar() to return
    return 0;


end


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' Pause%()
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Pause%()
    PrintLog("Pause called\n");
    recIsPaused% := 1;
    ToolbarEnable(recResumeButton%, 1);
    ToolbarEnable(recPauseButton%, 0);
    return 1;
end






'''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' Resume%()
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Resume%()
    PrintLog("Resume called\n");
    recIsPaused% := 0;
    ToolbarEnable(recResumeButton%, 0);
    ToolbarEnable(recPauseButton%, 1);
    return 1;
end





'''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' CallTimingReward%()
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func CallTimingReward%()
    PrintLog("Pause called to bring up Timing/Reward Dialog\n");
    recIsPaused% := 1;
    recRunTimeCall% := 1;
    recWhichDialogCalled% := 1;  '1 is for timing/reward
    'Don't let nobody do nothing! (start and resume are already disabled)
    ToolbarEnable(recPauseButton%, 0);
    ToolbarEnable(recSelectNewExptButton%, 0);
'    ToolbarEnable(recRewardButton%, 0);
    ToolbarEnable(recStopButton%, 0);
    ToolbarEnable(recTimingRewardButton%, 0);
    ToolbarEnable(recJoystickButton%, 0);
    return 1;
end





'''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' CallJoystick%()
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func CallJoystick%()
    PrintLog("Pause called to bring up Joystick Properties Dialog\n");
    recIsPaused% := 1;
    recRunTimeCall% := 1;
    recWhichDialogCalled% := 2;  '2 is for joystick
    'Don't let nobody do nothing! (start and resume are already disabled)
    ToolbarEnable(recPauseButton%, 0);
    ToolbarEnable(recSelectNewExptButton%, 0);
 '   ToolbarEnable(recRewardButton%, 0);
    ToolbarEnable(recStopButton%, 0);
    ToolbarEnable(recTimingRewardButton%, 0);
    ToolbarEnable(recJoystickButton%, 0);
    return 1;
end



'''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' ReturnFromDialogCall%()
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func ReturnFromDialogCall%()
    recRunTimeCall% := 0;  'reset RunTimeCall
    recIsPaused% := 0;  'set it free
    recWhichDialogCalled% := 0;  'no dialog called anymore
    'reenable appropriate buttons
    ToolbarEnable(recPauseButton%, 1);
    ToolbarEnable(recSelectNewExptButton%, 1);
'    ToolbarEnable(recRewardButton%, 1);
    ToolbarEnable(recStopButton%, 1);
    ToolbarEnable(recTimingRewardButton%, 1);
    ToolbarEnable(recJoystickButton%, 1);
    return 1;
end




'''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' Reward%()
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Reward%()
    ' This function is now used for all reward!
    var stmp%;
    var tStart;
    var tNow;
    var data%[10];  'oversized for readTDTreply%
    var temp%;
    var s;
    
    stmp% := recReward%(recRewardMs%,recJuiceToStimDelay%,recCurrentRewardType%,0);
    
    return stmp%;  'return 0 on success
end





''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' 
' ChangeStateTo
' 
' Call this function on exit from a state. The var stateTo% should be the state to enter
' on the next call to the loop function. 
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc ChangeStateTo(stateTo%)
	iState% := stateTo%;
    nextStateImmed% := 1;  'nothing to wait for
    if recCEDIsPresent% = 1 then
        tStateStart := View(recDataWindowView%).MaxTime();
    else
        tStateStart := tNow;
    endif
end;





''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' 
' RecLogStatus
' 
' Utility to write msg to log window. Will not write if rgDebug is not set. 
' Like 
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc RecLogStatus(stateName$, msg$)
    'if recDebug% = 1 then
        PrintLog("S:    " + stateName$ + "  Tstart: " + str$(tStateStart) + " " + msg$ + "\n");
    'endif
end





''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' 
' RecLogError
' 
' Like RecLogStatus, a utility to write msg to log window. 
' Unlike RecLogStatus, RecLogError will write no matter what - regardless of rgDebug value.
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc RecLogError(stateName$, msg$)
    PrintLog("ERROR===============================================\n");
    if stateName$ = "" then
        PrintLog(msg$ + "\n");
    else
        PrintLog("S:    " + stateName$ + "  Tstart: " + str$(tStateStart) + " " + msg$ + "\n");
    endif
    PrintLog("====================================================\n");
end





''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' 
' RecLogInfo
' 
' Like RecLogStatus, a utility to write msg to log window. 
' Unlike RecLogStatus, RecLogInfo will write no matter what - regardless of rgDebug value.
' Although as of 5/24/2012 it's not ever used.  Oh well.
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc RecLogInfo(msg$)
    PrintLog("INFO " + msg$ + "\n");
end










'------- PrepareNextTrial% --------------------------------------------------------
' 
' Called prior to initiating a set of S1/S2 stimuli. 
' Return 1 if all is well, 0 if all trials are done, negative for error. 
'
' This is the place to get a list of stimuli to run and load Play Wave areas as needed. 
' All stuff (like loading stimuli) which will be too costly time-wise to do while a 
' trial is running should be done here. 


func PrepareNextTrial%(dontLoadPWAs%)
    var i%;
    var ind%;
    var thisSpkr%;
    var thisTrial%;
    var thisPWA%;
    var nread%:= 0;  'looks unused but won't hurt
    var file$;
    var fh%;
    var statement$;
    var pwChar$;
    var matPutOK% := 0;
    var ok% := 1;  'by default, return 1 (success)

    
    ' Check to see if we are done
    if recCurrentTrial% >= recNTrials% then
        return 0;  'end the sequence
    endif;

    'Printlog current trial
    printlog("Current trial is %d\n",recCurrentTrial%);

    ' Get index of current trial
    thisTrial% :=  recTrialOrder%[recCurrentTrial%];  'recCurrentTrial is an index, BUT it hasn't been incremented yet, so don't subtract 1
    
    
    
    ' Put current trial sequence into log file
    if recDebug% = 1 then
        printlog("recCurrentTrial is %d\n",recCurrentTrial%);
        printlog("thisTrial is %d\n",thisTrial%);
        PrintLog("Trial #%d, TrialList ",recCurrentTrial%+1);
        printlog("Terminal index is %d\n",recTrialTerminalIndex%[thisTrial%]);
        PrintLog("Stims: ");
        for i% := 0 to recTrialTerminalIndex%[thisTrial%] do
            ' Get current PWA
            thisPWA% := recPWAList%[i%][thisTrial%];
            ' Print stmulus number
            PrintLog(str$(recStimList%[thisPWA%][thisTrial%]) + " ");
            next
        PrintLog("\nPWAs: ");
        for i% := 0 to recTrialTerminalIndex%[thisTrial%] do
            ' Get current PWA
            thisPWA% := recPWAList%[i%][thisTrial%];
            ' Print PWA number
            PrintLog(str$(thisPWA%) + " ");
            next
        PrintLog("\n");
    endif
    
    
    if dontLoadPWAs% = 0 then
        ' Generate/Load stimuli and put them into PlayWaveAreas
        'for i% := 0 to recTrialTerminalIndex%[thisTrial%] do
        for i% := 0 to recNUniqueStims%[thisTrial%]-1 do
            'Get play wave area for current stimulus
            pwChar$ := GetPlayWaveKey$(i%); 
            
            'get index of trial
            ind% := recStimList%[i%][thisTrial%];
            
            'get speaker of trial
            thisSpkr% := recSpeakerList%[i%][thisTrial%];
                
            'Set recStimTransfer%[] to zeros
            arrconst(recStimTransfer%[],0);  
            
            docase
            case recMatGenStim% = 1 and recMatlabIsPresent% = 0 and recCEDIsPresent% = 0 then  'this is testing
                'don't do anything, just pretend all is OK
            case recMatGenStim% = 1 and recMatlabIsPresent% = 0 and recCEDIsPresent% = 1 then  'this is a boo-boo
                message("Holy crap, I can't generate the stimulus because you said there's no Matlab!");
                recReadyToQuit% := 1;  'This will allow the entire thing to quit
                SafeSampleKey("M");
                Stop%();
                return -1;
            case recMatGenStim% = 1 and recSearchStimType% <> 3 then  'Generate stimuli using Matlab - even something CED can do like tones.  Just easier to be consistent.
                'opening a figure is slow, but everything else looks fast.  I can't quite ID exactly how long these things take
                'because things look like they happen in about 15-ms increments as far as CED's "Seconds()" command is concerned.
                'Needless to say, you can operate several commands (put, get, eval) without any time elapsing, then 15 ms for a
                'similar command.  Whether that's OS time or just clock precision I don't know.  What I do know is that under optimal
                'conditions you can put and get a 100000-element float in essentially 0 time, and maximally 15 ms.  So in principle as
                'long as the Matlab commands to eval are quick, we shouldn't worry about the time to do up to 10 "gets".  If we can
                'cleverly have all of them come simultaneously (i.e. a 2-d array of stimuli), that's cool too.  May not be necessary.
                
                matPutOK% := matPutOK% + PutMatlabValueFloat%("fs",recPlayRateHz);  'on any fail, matPutOK% will increment (negative ones)
                matPutOK% := matPutOK% + PutMatlabValueFloat%("dur",recTrialDur[ind%]);  'size of trial is variable, that's OK
                matPutOK% := matPutOK% + PutMatlabValueFloat%("lohz",recTrialGenLowpassHz[ind%]);  'Value of lowpass Hz or tone freq will be correctly interpreted by Matlab
                matPutOK% := matPutOK% + PutMatlabValueFloat%("hihz",recTrialGenHighpassHz[ind%]);  'Ditto
                matPutOK% := matPutOK% + PutMatlabValueFloat%("issweep",recTrialGenIsSweep%[ind%]);
                matPutOK% := matPutOK% + PutMatlabValueFloat%("amfreq",recTrialGenAMFreqHz[ind%]);
                matPutOK% := matPutOK% + PutMatlabValueFloat%("amdepth",recTrialGenAMDepthPct[ind%]);
                matPutOK% := matPutOK% + PutMatlabValueFloat%("amphase",recTrialGenAMPhaseDeg[ind%]);
                matPutOK% := matPutOK% + PutMatlabValueFloat%("tonephase",recTrialGenTonePhaseDeg[ind%]);
                matPutOK% := matPutOK% + PutMatlabValueFloat%("gauss",recTrialGenGauss%[ind%]);  
                matPutOK% := matPutOK% + PutMatlabValueFloat%("ramp",recTrialGenRampMS[ind%]);
                matPutOK% := matPutOK% + PutMatlabValueInt%("seed",recTrialGenSeed%[ind%]);  
                matPutOK% := matPutOK% + PutMatlabValueInt%("pad",recMaxPoints%);
                matPutOK% := matPutOK% + PutMatlabValueInt%("spk",thisSpkr%);
                
                if matPutOK% < 0 then 'error in at least one matlab put operation - not sure what to do (try again, quit?)
                    message("There has been an error in sending data to Matlab!  Quitting!");
                    recReadyToQuit% := 1;  'This will allow the entire thing to quit
                    SafeSampleKey("M");
                    Stop%();
                    return -1;
                endif;
                
                'Ask Matlab to create the stimulus - reclab_panstim can make just about anything
                'NOTE THAT WITHOUT THE CALIB VARIABLE, THE FULL STATEMENT DOES NOT WORK PROPERLY
                'USE THE TRUNCATED STATEMENT WITH NO CALIB UNTIL CALIBRATION IS IMPLEMENTED
                if recCalibIsPresent% = 1 then
                    statement$ := "[stimulus atten65 seed] = reclab_panstim(dur,fs,lohz,hihz,issweep,amfreq,amdepth,amphase,tonephase,gauss,ramp,seed,pad,AFFT(1,spk));";  'this is for the FFT filtering method
                    'statement$ := "[stimulus atten65 seed] = reclab_panstim(dur,fs,lohz,hihz,issweep,amfreq,amdepth,amphase,tonephase,gauss,ramp,seed,pad,AFilt(1,spk));";  'this is for the standard filtering method
                else
                    statement$ := "[stimulus atten65 seed] = reclab_panstim(dur,fs,lohz,hihz,issweep,amfreq,amdepth,amphase,tonephase,gauss,ramp,seed,pad);";
                endif;
                EvalMatlabStatement%(statement$);
                'printlog("%s\n",statement$);
                'printlog("Values are %d %d %d %d ",recTrialDur[ind%],recPlayRateHz,recTrialGenLowpassHz[ind%],recTrialGenHighpassHz[ind%]);
                'printlog("%d %d %d %d %d ",recTrialGenIsSweep%[ind%],recTrialGenAMFreqHz[ind%],recTrialGenAMDepthPct[ind%],recTrialGenAMPhaseDeg[ind%],recTrialGenTonePhaseDeg[ind%]);
                'printlog("%d %d %d %d %d \n",recTrialGenGauss%[ind%],recTrialGenRampMS[ind%],recTrialGenSeed%[ind%],recMaxPoints%,thisSpkr%);
            
            
                'Get the stimulus and the seed back from Matlab
                GetMatlabValueIntArray%("stimulus",recStimTransfer%[]);
                GetMatlabValueFloat%("atten65",recGeneratedAtten[i%]);
                GetMatlabValueInt%("seed",recCurrRandomSeed%[i%]);  'put current random seed into variable for NameThatStimulus
            
                'printlog("gen values are %d\n",recStimTransfer%[4000:50]);   
            
                'Note that loading the filter coefficients for each speaker on each call would be a time-waster.
                'Instead, we will load up CALIB into the Matlab workspace as the experiment begins, and the call
                'to RECLAB_PANSTIM above will use that CALIB variable (indexed by the speaker).
                
            case recMatGenStim% = 1 and recSearchStimType% = 3 then  'Clicks - matlab is not set up to generate these
                
            recStimTransfer%[1] := 32767;  'make the second element (2^15)-1, then everything else 0 - that's a click
            'arrconst(recStimTransfer%[3:500],30000);
            'printlog("click values are %d\n",recStimTransfer%[0:20]); 
            
            else  'Load stimuli from file
                
                'get filename
                file$ := recTrialLoadLoc$[ind%];
                
                'open current stimulus
                fh%:=fileopen(file$,9,0);
                if fh%<0 then
                    message("Warning Message | failed to load the stimulus waveform!");
                    printlog("Quitting because the Stim waveform %s failed to load!\n",file$);
                    Stop%();
                    return -1;
                endif;
                
                'reads fh% two bytes at a time, puts in recStimTransfer%[]
                nread%:=breadsize(2,recStimTransfer%[]); 
                
                'close current stimulus
                fileclose();  'close fh%
                
            endcase;
            
            'Finally, place the stimulus into the appropriate Play Wave Area
            if recCEDIsPresent% = 1 then
                PlayWaveCopy(pwChar$, recStimTransfer%[]);  'recStimTransfer% is an integer array and as such should be signed 16 bit integers
            endif;
            
        next;
    endif;


    recStimCount% := 0;  'Reset stim count
    return ok%;
    
end





'''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' IdleLoop%()
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func IdleLoop%()
	var iStatus% := 1;	' this is return value. value of 1 (0) continues (stops) processing
    var stmp%;
    var isS2%;
    var strtmp$;
    var isPlaying%;
    var PWA$;
    var s$;
    var temprnd;  'a temporary variable to hold a Rand, used for changing reward type


    nextStateImmed% := 1;  'obviously we run the damn thing the FIRST time through each idle loop
    
    while nextStateImmed% = 1 do  'Allows repeat of internal loop; otherwise we have to wait until the idle function is called again, OS may grab time
        
        'Get the current time
        if recCEDIsPresent% = 1 then
            tNow :=  View(recDataWindowView%).MaxTime();
        else
            tNow += .05;  'simulate 50 ms between loops
        endif
        
        'Don't repeat this (internal) loop unless there is a state change or specifically asked to below for timing purposes
        nextStateImmed% := 0; 
               
        
        
    'Update the joystick plot every 5 ms
    'printlog("recUseJoystick% is %d and tNow is %f and tLastJoyUpdate is %f\n",recUseJoystick%,tNow,tLastJoyUpdate);
        if recUseJoystick% <> 0 and tNow-tLastJoyUpdate > .005 and recCEDIsPresent% = 1 then
            XJoy := View(recDataWindowView%).ChanMeasure(configJoyXChannel%,2,tNow-.001,tNow-.006);
            YJoy := View(recDataWindowView%).ChanMeasure(configJoyYChannel%,2,tNow-.001,tNow-.006);
            View(joyview%).XYAddData(joydatachan%,XJoy,YJoy);  'do not need to flip axis values
            tLastJoyUpdate := tNow;
        'printlog("Updated joystick voltage with x voltage %f and y voltage %f\n",XJoy,YJoy);
        endif;
        
        
        
        ' ============= State Logic - determine which state we are in 
        docase
        case iState% = stateStart% then
            'This state is only entered once per "experiment" - once per each time the template file passes control
            RecLogStatus("Start", "Starting state logic loop.");
            ChangeStateTo(stateInitializeTrials%);
            
            
        case iState% = stateInitializeTrials% then
        
            ToolbarText("#HITS = " + str$(numHits%) + ",   #MISSES = " + str$(numMisses%) + ",   #FPs = " + str$(numFPs%) + ";   LastHit(mL) = " + str$(LastHitReward) + 
                        ",   TOTAL(mL) = " + str$(amountRewarded) + ";   On Trial # " + str$(recCurrentTrial%) + " of " + str$(recNTrials%) + ".");                       

            ' prepare stimuli for the next trial.
            ' this is the point where the expt can be paused. Operator can hit the pause
            ' button anytime, but the actual pause will happen here. --> added a few pause checks, will check in each state up until statePreTrialDelay
            
            if RTESDIsPressed% = 1 then  'if the ReturnToExperimentSelectionDialog button has been pressed, this is where we return
                ReturnToExptSelectDialog%();  'this doesn't actually get us out...but it changes some variables
                iStatus% := 0;  'this is how we get out
                nextStateImmed% := 0;  'this keeps the rest of everything from executing
            endif;
            
 
            CheckLever%("inOrigin%",1);  'flush joystick/lever data, default to inOrigin
            'only original check for pause location....
            if recIsPaused% = 0 and iStatus% = 1 then  'if not paused and we actually keep going, do trial initialization
                
                docase
                case recExpToRun% = recExpAudiogramButton% and recAudiogramStartNewTrial% = 1 then
                    stmp% := PrepareNextTrial%(0); 'load PWAs, should gracefully pass through in debug mode as well
                case recExpToRun% = recExpAudiogramButton% and recAudiogramStartNewTrial% = 0 then    
                    recCurrentTrial% -= 1;  'if current trial (in human units) is same as last trial, PrepareNextTrial will exit.  Decrement, will reincrement upon return. -jj 8/21/17
                    stmp% := PrepareNextTrial%(1);  'don't load PWAs for repeated audiogram stimuli
                case recExpToRun% = recExpSearchButton% and recSearchLoaded% = 1 then
                    stmp% := PrepareNextTrial%(1);  'don't load PWAs for search trials after #1
                else
                    stmp% := PrepareNextTrial%(0); 'load PWAs, should gracefully pass through in debug mode as well
                    recSearchLoaded% := 1;  'only allow loading PWAs once for search                  
                endcase;
                
                docase
                case stmp% = 0 then
                    RecLogStatus("PrepareNextTrial", "All trials are done!");
                    ChangeStateTo(stateDone%);
                    'Note that we can't actually get here from Search, the user simply hits the NewExpt. button to end search and move on
                case stmp% < 0 then
                    RecLogStatus("PrepareNextTrial", "Error return value from PrepareNextTrial%");
                    ChangeStateTo(stateCodingError%);
                else
                    recCurrentTrial% += 1;  'recCurrentTrial% only incremented here, upon successful load of new trial.
                    docase
                    case recExpToRun% = recExpAudiogramButton% and recAudiogramStartNewTrial% = 1 then 
                        recAudiogramStartNewTrial% := 0;  'the increment above has been accepted, don't let it increment again until new frequency is needed
                    case recExpToRun% = recExpAudiogramButton% and recAudiogramStartNewTrial% = 0 then
                        'recCurrentTrial% -= 1;  'if we are not starting a new trial on audiogram, undo increment of trial counter (now more correctly done earlier -jj 8/21/17)
                    endcase;
                    RecLogStatus("PrepareNextTrial", "Trial #" + str$(recCurrentTrial%) + " ready.");
                    ChangeStateTo(stateWaitForInitiationMovement%);
                endcase
            else  'but if paused, check to see if we have a call out to a dialog box to change values
                if recRunTimeCall% = 1 then
                    docase
                    case recWhichDialogCalled% = 1 then
                        RecExpTimingRewardDialog%();
                        ReturnFromDialogCall%();
                    case recWhichDialogCalled% = 2 then
                        RecExpLeverJoystickDialog%();  
                        ReturnFromDialogCall%();
                    endcase
                endif
            endif
            
            
        case iState% = stateWaitForInitiationMovement% then   'this state just decides which state to go to, it's easier than replacing all the instances 
        'CHECK FOR PAUSE HERE TOO:
            if recIsPaused% = 0 and iStatus% = 1 then  'if not paused and we actually keep going, do trial initialization
                
                'If necessary, change the reward type on this trial (recRewardType 0/1 does not change)
                'Note that this step is done here rather than stateInitializeTrials because all relevant results
                'go through this state (miss, various FA, lazy monkey), but lazy monkey does NOT go through stateInitializeTrials
                docase  
                case recRewardType% = 3 and recChangeRewardType% = 1 then 'cycle through reward types
                    recChangeRewardType% := 0;  'Reset, don't change again until necessary
                    recCurrentRewardType% += 1;  'increment current reward type
                    if recCurrentRewardType% = 3 then 'legal values are [0 1 2], if 3, cycle to 0
                        recCurrentRewardType% := 0;
                    endif;
                case recRewardType% = 4 then 'and recChangeRewardType% = 1 then 'select random reward type based on values set in dialog
                    'recChangeRewardType% := 0;  'Reset, don't change again until necessary
                    temprnd := Rand(100,0);  'get rand, values in dialog are in terms of percentage
                    docase
                    case temprnd < recPctJuice% then
                        recCurrentRewardType% := 0;  'set juice
                    case temprnd > recPctJuice% and temprnd < (recPctJuice%+recPctStimulation%) then
                        recCurrentRewardType% := 1;  'set stimulation
                    else
                        recCurrentRewardType% := 2;  'set juice + stimulation
                    endcase   
                case recRewardType% = 5 then
                    temprnd := Rand(100,0);  'get rand, values in dialog are in terms of percentage
                    docase
                    case temprnd < recPctStimulation% then
                        recCurrentRewardType% := 2;  'set juice + stimulation
                    else
                        recCurrentRewardType% := 0;  'set juice only
                    endcase
                endcase
                
                
                docase
                case recCurrentRewardType% = 0 then
                    SampleText("Trial #" + str$(recCurrentTrial%) + ", Juice reward", tNow);
                case recCurrentRewardType% = 1 then
                    SampleText("Trial #" + str$(recCurrentTrial%) + ", Stim reward", tNow);
                case recCurrentRewardType% = 2 then
                    SampleText("Trial #" + str$(recCurrentTrial%) + ", Juice+Stim reward", tNow);
                endcase
                
                
                
                'do state stuff here...
                ChangeStateTo(stateStartCEDBlink%);
                
            else  'but if paused, check to see if we have a call out to a dialog box to change values
                if recRunTimeCall% = 1 then
                    docase
                    case recWhichDialogCalled% = 1 then
                        RecExpTimingRewardDialog%();
                        ReturnFromDialogCall%();
                    case recWhichDialogCalled% = 2 then
                        RecExpLeverJoystickDialog%();  
                        ReturnFromDialogCall%();
                    endcase
                endif
            endif
        
            
            
        case iState% = stateStartCEDBlink% then
            'CHECK FOR PAUSE HERE TOO:
            if recIsPaused% = 0 and iStatus% = 1 then  'if not paused and we actually keep going, do trial initialization
                'do state stuff here
                CheckLever%("inOrigin%",1);
                if inOrigin% = 1 then  'lever must be in origin to start blink
                    if tNow > tNextTrial then
                        RecLogStatus("WaitTrlInit", "Blink/Wait.");
                        if recCEDIsPresent% = 1 and recActive% = 1 then
                            SampleSeqVar(4,1);  'set the flash sequence to on
                            Sampleseqvar(6,500/SampleSeqClock(1));  'Flashing at 500 ms, divide by sequencer period in ms to get number of sequencer clock ticks
                            sampleseqvar(5,ceil((recTrialInitWindow*1000)/(500*2)));  'Set sequencer variable 5 to number of flashes, 500 ms flash duration, put recTrialInitWindow in ms
                            sampleseqvar(8,1);  'Set Flash-Allow variable to 1, this allows flashing
                            SafeSampleKey("L");  'Start the flash
                            tStartBlink :=  View(recDataWindowView%).MaxTime();    
                        else
                            tStartBlink := tNow;
                        endif;
                        ChangeStateTo(stateCEDBlinking%);
                    endif;
                else
                    if tNow > recTrialInitWindow + tNextTrial then  'Use trial init window both for getting into origin and starting trial
                        RecLogStatus("PreBlinkPeriod", "Timeout waiting for lever/joystick into origin.");
                        ChangeStateTo(stateLazyMonkeyTimeout%);
                    endif;
                endif;
            else  'but if paused, check to see if we have a call out to a dialog box to change values
                if recRunTimeCall% = 1 then
                    docase
                    case recWhichDialogCalled% = 1 then
                        RecExpTimingRewardDialog%();
                        ReturnFromDialogCall%();
                    case recWhichDialogCalled% = 2 then
                        RecExpLeverJoystickDialog%();  
                        ReturnFromDialogCall%();
                    endcase
                endif
            endif
            
        case iState% = stateCEDBlinking% then
            'CHECK FOR PAUSE HERE TOO:
            if recIsPaused% = 0 and iStatus% = 1 then  'if not paused and we actually keep going, do trial initialization
                'do state stuff here
                 if tNow < tStartBlink + recTrialInitWindow then
    '                if recCEDIsPresent% = 1  and recActive% = 1 then
    '                    CheckLever%();
    '                else
    '                    inTrialInit% := 1; 'simulate success
    '                endif;
                    CheckLever%("inTrialInit%",1);
                    'printlog("InTrialInit value is %d and time is %f\n",inTrialInit%,tNow);
                    if inTrialInit% = 1 then
                        SampleKey("S"); 'stop blink sequence *immediately* - therefore, do not use SafeSampleKey
                        if recFixLED% = 1 then
                            SafeSampleKey("L"); 'turn on LED for fixpt
                        endif;
                        RecLogStatus("WaitTrlInit", "Delay interval=" + str$(recDelayIntervalTime) + " s.");
                        'Increment, if appropriate
                        ChangeThresh2(doIncTrialInit%[]);
                        'Calculate new delay interval time
                        recDelayIntervalTime := recMinOnsetDelay + Rand(recVarOnsetDelay, 0);
                        ChangeStateTo(statePreTrialDelay%);
                    endif;
                 else  'this is timeout
                    SafeSampleKey("S"); 'stop blink sequence immediately, though it should already be stopped - this might need to be unSafe'd as well
                    RecLogStatus("WaitTrlInit", "Timeout waiting for trial initiation.");
                    'Decrement, if appropriate
                    'ChangeThresh(-doIncUp%,-doIncDown%,-doIncLeft%,-doIncRight%); 'old version
                    ChangeThresh2(doDecTrialInit%[]);
                    ChangeStateTo(stateLazyMonkeyTimeout%);
                 endif;

            else  'but if paused, check to see if we have a call out to a dialog box to change values
                if recRunTimeCall% = 1 then
                    docase
                    case recWhichDialogCalled% = 1 then
                        RecExpTimingRewardDialog%();
                        ReturnFromDialogCall%();
                    case recWhichDialogCalled% = 2 then
                        RecExpLeverJoystickDialog%();  
                        ReturnFromDialogCall%();
                    endcase
                endif
            endif
            
'        case iState% = stateTDTBlink% then
'
'           'CHECK FOR PAUSE HERE TOO:
'            if recIsPaused% = 0 and iStatus% = 1 then  'if not paused and we actually keep going, do trial initialization
'                'do state stuff here
'                CheckLever%("inOrigin%",1);
'                if inOrigin% = 1 then  'lever must be up to start blink
'                    if tNow > tNextTrial then
'                        
'                        RecLogStatus("WaitTrlInit", "Blink/Wait.");
'                        
'                        'leave this the same...recBlinkUntilLeverDown%() is special, and I DON'T want to recode it
'                        if recCEDIsPresent% = 1 and recActive% = 1 then
'                            stmp% := recBlinkUntilLeverDown%(.5, recTrialInitWindow);  
'                            'Will leave LED on once lever is down
'                            if recFixLED% = 0 then
'                                SafeSampleKey("M"); 'turn LED off if we are not using it for fixation
'                            endif;
'                        else
'                            stmp% := 1;  'simulate success in lever press
'                        endif
'                        
'                        docase
'                        case stmp% = 1 then
'                            recDelayIntervalTime := recMinOnsetDelay + Rand(recVarOnsetDelay, 0);
'                            'SafeSampleKey("P");  'TODO: What is this?  Still don't know.  Not in Recgen.pls!
'                            RecLogStatus("WaitTrlInit", "Delay interval=" + str$(recDelayIntervalTime) + " s.");
'                            'Increment, if appropriate
'                            ChangeThresh2(doIncTrialInit%[]);
'                            ChangeStateTo(statePreTrialDelay%);
'                        case stmp% = 0 then
'                            RecLogStatus("WaitTrlInit", "Timeout waiting for lever down.");
'                            'Decrement, if appropriate
'                            'ChangeThresh(-doIncUp%,-doIncDown%,-doIncLeft%,-doIncRight%);
'                            ChangeThresh2(doDecTrialInit%[]);
'                            ChangeStateTo(stateLazyMonkeyTimeout%);
'                        else
'                            PrintLog("ERROR in recBlinkUntilLeverDown%()!!!\n");
'                            Message("Error in recBlinkUntilLeverDown!");
'                            ChangeStateTo(stateTDTError%);
'                        endcase
'                    endif;
'                else
'                    RecLogStatus("PreBlinkPeriod", "Timeout waiting for lever up.");
'                    ChangeStateTo(stateLazyMonkeyTimeout%);
'                endif;
'            
'            else  'but if paused, check to see if we have a call out to a dialog box to change values
'                if recRunTimeCall% = 1 then
'                    docase
'                    case recWhichDialogCalled% = 1 then
'                        RecExpTimingRewardDialog%();
'                        ReturnFromDialogCall%();
'                    case recWhichDialogCalled% = 2 then
'                        RecExpLeverJoystickDialog%();  
'                        ReturnFromDialogCall%();
'                    endcase
'                endif
'            endif
'            
        case iState% = stateLazyMonkeyTimeout% then
            CheckLever%("inOrigin%",1);  'Flush lever/joystick during timeout, default assign to in origin
            if tNow - tStateStart > recLazyMonkeyTO then
                RecLogStatus("LazyMonkeyTimeout", "Timeout period done. Trial #" + str$(recCurrentTrial%) + " ready.");
                recChangeRewardType% := 1;  'will change reward type after lazy timeout, if other conditions are met 
                ChangeStateTo(stateWaitForInitiationMovement%);  'restart as if we had just finished loading
                tNextTrial := tNow;
            endif
            
            
            
        case iState% = statePreTrialDelay% then
            'printlog("tnow is %f and tstatestart is %f and diff is %f\n",tNow,tStateStart, tNow-tStateStart);
            CheckLever%("inTrialInit%",1);
            docase  
            case inTrialInit% <> 1 and recCEDIsPresent% = 1  and recActive% = 1 and recExpToRun% = recExpAudiogramButton% then 
                'for the Audiogram experiment, we need to treat this NOT as a slip
                RecLogStatus("DelayInterval", "False Alarm during delay.");
                ChangeStateTo(stateFalseAlarmAudiogram%); 
                SafeSampleKey("M");  'turn off LED
            case inTrialInit% <> 1 and recCEDIsPresent% = 1  and recActive% = 1 then
                'for all other experiments we are generous and treat this as a slip
                RecLogStatus("DelayInterval", "Interrupt during delay.");
                ChangeStateTo(stateWaitForInitiationMovement%);  'no interrupt penalty, it's probably a slip, just start over
                tNextTrial := tNow;
            case tNow - tStateStart >= recDelayIntervalTime then
                RecLogStatus("DelayInterval", "Delay done.");
                docase
                case recDoJoyTrain% = 1 then '*jao
                    ChangeStateTo(stateHitReward%); 
                case recTrialInitReward% <> 0 then 'if not zero (might be -1 from last trial)
                    recTrialInitReward% :=1; 'set it back to 1
                    ChangeStateTo(stateTrainingReward%);
                case recExpToRun% = recExpAudiogramButton% then
                    isS2% := 1;  'all audiogram stimuli deserve a response
                    ChangeStateTo(stateStartSoundB%);  'for audiogram, there is only one sound, we want a response, so let's just call it sound B
                else
                    ChangeStateTo(stateStartSoundA%);
                endcase '*jao
            endcase
            
            
            
        case iState% = stateStartSoundA% then
            
            RecLogStatus("TrialSoundA", "Call expt function");
            if recCEDIsPresent% = 1 then
                stmp% := PlaySound%(isS2%);  
            else
                stmp% := 0;  'simulate playing sound if no CED
                printlog("No CED, stim would be %s\n",NameThatStimulus$(recStimList%[recPWAList%[recStimCount%][recTrialOrder%[recCurrentTrial%-1]]][recTrialOrder%[recCurrentTrial%-1]]));
            endif;
            
            docase
            case stmp% = 0 then
                isPlaying% := 1;
                ChangeStateTo(stateSoundAPlaying%);
            case stmp% < 0 then
                RecLogStatus("TrialSoundA", "PlaySound returned negative value.");
                ChangeStateTo(stateTDTError%);
            else
                RecLogStatus("TrialSoundA", "PlaySound returned unknown value (>0).");
                ChangeStateTo(stateTDTError%);
            endcase
            
            
            
        case iState% = stateSoundAPlaying% then
            
            if recCEDIsPresent% = 1 then  'only check play wave status if the CED is there
                PWA$ := PlayWaveStatus$(recPointsPlayed%);
            endif;
            
            docase
            case recCEDIsPresent% = 0 then
                isPlaying% := 0;  'simulate end of stimulus
            case recPointsPlayed% >= recPlayPoints%  then
                isPlaying% := 0;  'Stimulus is not currently playing if it's in blank space following stimulus
                PlayWaveStop();  'stop playing stimulus while we're at it
            case PWA$ = "" then
                isPlaying% := 0;  'Stimulus is not currently playing if PWA has stopped
            endcase;
            
            CheckLever%("inTrialInit%",1);
            docase
            case isPlaying% = 0 then  'use isPlaying rather than PlayWaveStatus because the PWA may be longer than the stimulus
                if isInterrupt% = 1 then
                    isInterrupt% := 0;  'reset variable
                    StimComplete%(0, 0);  'recPreciseTrialTime was determined when interrupt occurred
                    SafeSampleKey("M");
                    ChangeStateTo(stateFAInterrupt%);  'on FA interrupt, reshuffle entire stim sequence in later
                else
                    ChangeStateTo(stateISIDelay%);
                endif
            case recActive% = 0 then
                'Do nothing here if sound is playing but there is no task; simply wait for sound to stop                
            case inTrialInit% <> 1 then  'if the sound is still playing, check for interrupt
                'institute interrupt procedure, will be completed on the next iteration or when stimulus stops
                if isInterrupt% = 0 then  'only do this for "first" interrupt, if stimulus continues  
                    recPreciseTrialTime := recLeverTime;  'time interrupt occurred
                    RecLogStatus("TrialSoundA", "False Positive Interrupt! Lever is up");
                    numFPs% += 1;  'increment FP counter
                    isInterrupt% := 1;  'don't institute interrupt procedure twice if stimulus continues to end
                    if recContinueSoundOnS1Interrupt% = 0 then
                        if recCEDIsPresent% = 1 then
                            PlayWaveStop();  'stop playing stimulus
                        endif;
                        isPlaying% := 0;
                    endif;
                endif;                
            endcase
            
            
            
        case iState% = stateISIDelay% then
            ' Check that lever is still down.
'            if recCEDIsPresent% = 1 and recActive% = 1 then
'                CheckLever%()
'                'printlog("Lever status is %d, dammit!\n",stmp%);
'            else
'                inTrialInit% := 1; 'simulate lever down in testing, and in non-response scenarios
'            endif
            CheckLever%("inTrialInit%",1);
            docase
            'case stmp% < 0 then
            '    RecLogError("WaitLvrUp", "ERROR (" + str$(stmp%) + ")in recLeverDown()");
            '    Message("Error in recLeverDown()!!!");
            '    ChangeStateTo(stateTDTError%);
            case inTrialInit% <> 1 then
                RecLogStatus("WaitISI", "False Positive! Lever is up");
                numFPs% += 1;  'increment FP counter
                recPreciseTrialTime := recLeverTime;  'time false positive occurred
                StimComplete%(0, 0);
                SafeSampleKey("M");
                ChangeStateTo(stateFAInterrupt%);  'this is a false alarm, but S2 has not played, so shuffle stimulus sequence back in
            else
                if tNow - tStateStart > recISI then
                    RecLogStatus("WaitISI", "ISI done.");
                    recPreciseTrialTime := tNow;  'time ISI is complete
                    responseMode% := -1; 'reset for debugging
                    isS2% := StimComplete%(0, 1);
                    responseMode% := isS2%; 'branched from isS2% for Hi/Lo responses
                    docase 
                    case isS2% = 0 then
                        ChangeStateTo(stateStartSoundA%);
                    case isS2% = 1 then
                        isTerminalS1% := 0;
                        ChangeStateTo(stateStartSoundB%);  'for AMdis: Hi (S2>S1)
                    case isS2% = 2 then
                        isTerminalS1% := 1;
                        ChangeStateTo(stateStartSoundC%);  'SoundC is a terminal S1 - a stimulus which will be rewarded for no-go; for Hi/Lo case, will be rewarded 50%
                        if recExpToRun% = recExpAMDiscButton% or recExpToRun% = recExpSpaceDisButton% then
                            coinFlipResult% := round(rand()); 'simple 50/50 way. might want to create a variable "sameRewardRate" or something.
                            printlog("coinFlipResult% = /d%", coinFlipResult%); '*jao
                        endif;
                    case isS2% = 3 then
                        isTerminalS1% := 0;
                        ChangeStateTo(stateStartSoundD%);  'for AMDis: Lo (S2<S1) *jao
                    else
                        RecLogStatus("WaitISI", "Unknown return value from StimComplete");
                        Message("Error in StimComplete%()!!!");
                        ChangeStateTo(stateCodingError%);
                    endcase
                endif
            endcase
            
            
            
        case iState% = stateStartSoundB% then
            RecLogStatus("TrialSoundB", "Call expt function");
            if recCEDIsPresent% = 1 then
                stmp% := PlaySound%(isS2%);
            else
                stmp% := 0;  'simulate sound playing if CED is not present
                printlog("No CED, stim would be %s\n",NameThatStimulus$(recStimList%[recPWAList%[recStimCount%][recTrialOrder%[recCurrentTrial%-1]]][recTrialOrder%[recCurrentTrial%-1]]));
            endif;
            docase
            case stmp% = 0 then
                isPlaying% := 1;
                ChangeStateTo(stateSoundBPlaying%);
            case stmp% < 0 then
                RecLogStatus("TrialSoundB", "PlaySound returned negative value.");
                ChangeStateTo(stateTDTError%);
            else
                RecLogStatus("TrialSoundB", "PlaySound returned unknown value (>0).");
                ChangeStateTo(stateTDTError%);
            endcase
            
            
            
        case iState% = stateSoundBPlaying% then
            if recCEDIsPresent% = 1 then
                PWA$ := PlayWaveStatus$(recPointsPlayed%);
            endif;
            docase
            case recCEDIsPresent% = 0 then
                isPlaying% := 0;  'simulate end of stimulus
            case recPointsPlayed% >= recPlayPoints%  then
                isPlaying% := 0;  'Stimulus is not currently playing if it's in blank space following stimulus
                PlayWaveStop();  'stop playing stimulus while we're at it
            case PWA$ = "" then
                isPlaying% := 0;  'Stimulus is not currently playing if PWA has stopped
            endcase;
            
            CheckLever%("inResponse1%",0);  'default is no early hit
            docase
            case isPlaying% = 0 then  'trying to use isPlaying rather than PlayWaveStatus because the PWA may be longer than the stimulus
                RecLogStatus("WaitTrialSoundB", "Sound done playing.");
                ChangeStateTo(stateTrainingReward%);  'check for training reward no matter what - ask Jackie if we want them to NOT get training reward if S2 is interrupted
            case recActive% = 0 then
                'Do nothing here if sound is playing but there is no task; simply wait for sound to stop
            case recIsGoNoGo% = 1 and inResponse1% = 1 then  'if the sound is still playing, check for early hit (go/no-go)
                'accept response whether sound should be stopped or not
                if isEarlyHit% = 0 then
                    isEarlyHit% := 1;  'this is a hit before the sound has stopped playing
                    recPreciseTrialTime := recLeverTime;  'time early hit occurred
                    RecLogStatus("WaitTrialSoundB", "Lever is in response 1 - HIT interrupting S2");
                    if recContinueSoundOnS2Interrupt% = 0 then
                        if recCEDIsPresent% = 1 then
                            PlayWaveStop();  'stop playing stimulus
                        endif;
                        isPlaying% := 0;
                    endif;
                endif;
            case recIsGoNoGo% = 0 and inResponse2% = 1 then 'if the sound is still playing, check for early "miss" (FC)
                'accept response whether sound should be stopped or not
                if isEarlyMiss% = 0 then
                    isEarlyMiss% := 1;  'this is a miss before the sound has stopped playing
                    recPreciseTrialTime := recLeverTime;  'time early hit occurred
                    RecLogStatus("WaitTrialSoundB", "Lever is in response 2 - MISS interrupting S2");
                    if recContinueSoundOnS2Interrupt% = 0 then
                        if recCEDIsPresent% = 1 then
                            PlayWaveStop();  'stop playing stimulus
                        endif;
                        isPlaying% := 0;
                    endif;
                endif;
            case recIsGoNoGo% = 0 and inResponse1% = 1 then  'if the sound is still playing, check for early hit (FC)
                'accept response whether sound should be stopped or not
                if isEarlyHit% = 0 then
                    isEarlyHit% := 1;  'this is a hit before the sound has stopped playing
                    recPreciseTrialTime := recLeverTime;  'time early hit occurred
                    RecLogStatus("WaitTrialSoundB", "Lever is in response 1 - HIT interrupting S2");
                    if recContinueSoundOnS2Interrupt% = 0 then
                        if recCEDIsPresent% = 1 then
                            PlayWaveStop();  'stop playing stimulus
                        endif;
                        isPlaying% := 0;
                    endif;
                endif;
            endcase;
            
            
            
        case iState% = stateStartSoundC% then  'sound C is a terminal S1
            'Logic here is actually the same as for sound B
            RecLogStatus("TrialSoundC", "Call expt function");
            if recCEDIsPresent% = 1 then
                stmp% := PlaySound%(isS2%);
            else
                stmp% := 0;  'simulate sound playing if CED is not present
                printlog("No CED, stim would be %s\n",NameThatStimulus$(recStimList%[recPWAList%[recStimCount%][recTrialOrder%[recCurrentTrial%-1]]][recTrialOrder%[recCurrentTrial%-1]]));
            endif;  
            docase
            case stmp% = 0 then
                isPlaying% := 1;
                ChangeStateTo(stateSoundCPlaying%);
            case stmp% < 0 then
                RecLogStatus("TrialSoundC", "PlaySound returned negative value.");
                ChangeStateTo(stateTDTError%);
            else
                RecLogStatus("TrialSoundC", "PlaySound returned unknown value (>0).");
                ChangeStateTo(stateTDTError%);
            endcase            
            
            
            
        case iState% = stateSoundCPlaying% then
            'here there really is no difference between terminal S1 ("nontarget") and target trials, we deal with the difference
            'in stateInResponseWindow% (at least if there's no interrupt of the stimulus
            
            if recCEDIsPresent% = 1 then
                PWA$ := PlayWaveStatus$(recPointsPlayed%);
            endif;
            docase
            case recCEDIsPresent% = 0 then
                isPlaying% := 0;  'simulate end of stimulus
            case recPointsPlayed% >= recPlayPoints%  then
                isPlaying% := 0;  'Stimulus is not currently playing if it's in blank space following stimulus
                PlayWaveStop();  'stop playing stimulus while we're at it
            case PWA$ = "" then
                isPlaying% := 0;  'Stimulus is not currently playing if PWA has stopped
            endcase;
            
            CheckLever%("inResponse1%",1);  'default no false alarm
            docase
            case isPlaying% = 0 then  'trying to use isPlaying rather than PlayWaveStatus because the PWA may be longer than the stimulus
                RecLogStatus("WaitTrialSoundC", "Sound done playing.");
                if isEarlyFA% = 1 then
                    ChangeStateTo(stateInResponseWindow%);  'this will just shunt to the FA penalty, but it keeps the logic consistent
                else
                    ChangeStateTo(stateTrainingReward%);
                endif;
            case recActive% = 0 then
                'Do nothing here if sound is playing but there is no task; simply wait for sound to stop
            case recIsGoNoGo% = 1 and inResponse1% = 1 then 'if the sound is still playing, check for early FA (go/no-go)
                'accept response whether sound should be stopped or not
                if isEarlyFA% = 0 then
                    isEarlyFA% := 1;  'this is a hit before the sound has stopped playing
                    recPreciseTrialTime := recLeverTime;  'time early FA occurred
                    RecLogStatus("WaitTrialSoundC", "Lever is up - FA interrupting terminal S1");
                    if recContinueSoundOnS1Interrupt% = 0 then
                        if recCEDIsPresent% = 1 then
                            PlayWaveStop();  'stop playing stimulus
                        endif;
                        isPlaying% := 0;
                    endif
                endif
            case recIsGoNoGo% = 0 and inResponse2% = 1 then 'if the sound is still playing, check for early CR (FC)
                'accept response whether sound should be stopped or not
                if isEarlyCR% = 0 then
                    isEarlyCR% := 1;  'this is a hit before the sound has stopped playing
                    recPreciseTrialTime := recLeverTime;  'time early FA occurred
                    RecLogStatus("WaitTrialSoundC", "Lever is up - FA interrupting terminal S1");
                    if recContinueSoundOnS1Interrupt% = 0 then
                        if recCEDIsPresent% = 1 then
                            PlayWaveStop();  'stop playing stimulus
                        endif;
                        isPlaying% := 0;
                    endif
                endif
            case recIsGoNoGo% = 0 and inResponse1% = 1 then 'if the sound is still playing, check for early FA (FC)
                'accept response whether sound should be stopped or not
                if isEarlyFA% = 0 then
                    isEarlyFA% := 1;  'this is a hit before the sound has stopped playing
                    recPreciseTrialTime := recLeverTime;  'time early FA occurred
                    RecLogStatus("WaitTrialSoundC", "Lever is up - FA interrupting terminal S1");
                    if recContinueSoundOnS1Interrupt% = 0 then
                        if recCEDIsPresent% = 1 then
                            PlayWaveStop();  'stop playing stimulus
                        endif;
                        isPlaying% := 0;
                    endif
                endif                
            endcase            
            
        'Keep this space open for Sound D - a terminal S3 stimulus! --> here it is! *jao
        case iState% = stateStartSoundD% then
            RecLogStatus("TrialSoundD", "Call expt function");
            if recCEDIsPresent% = 1 then
                stmp% := PlaySound%(isS2%);
            else
                stmp% := 0;  'simulate sound playing if CED is not present
                printlog("No CED, stim would be %s\n",NameThatStimulus$(recStimList%[recPWAList%[recStimCount%][recTrialOrder%[recCurrentTrial%-1]]][recTrialOrder%[recCurrentTrial%-1]]));
            endif;
            docase
            case stmp% = 0 then
                isPlaying% := 1;
                ChangeStateTo(stateSoundDPlaying%);
            case stmp% < 0 then
                RecLogStatus("TrialSoundD", "PlaySound returned negative value.");
                ChangeStateTo(stateTDTError%);
            else
                RecLogStatus("TrialSoundD", "PlaySound returned unknown value (>0).");
                ChangeStateTo(stateTDTError%);
            endcase     'exactly the same as stateStartSoundB *jao
                       
            
        case iState% = stateSoundDPlaying% then
            if recCEDIsPresent% = 1 then
                PWA$ := PlayWaveStatus$(recPointsPlayed%);
            endif;
            docase
            case recCEDIsPresent% = 0 then
                isPlaying% := 0;  'simulate end of stimulus
            case recPointsPlayed% >= recPlayPoints%  then
                isPlaying% := 0;  'Stimulus is not currently playing if it's in blank space following stimulus
                PlayWaveStop();  'stop playing stimulus while we're at it
            case PWA$ = "" then
                isPlaying% := 0;  'Stimulus is not currently playing if PWA has stopped
            endcase;
            
            CheckLever%("inResponse2%",0);  'default is no early hit 'switched to Response2 for S3 *jao
            docase
            case isPlaying% = 0 then  'trying to use isPlaying rather than PlayWaveStatus because the PWA may be longer than the stimulus
                RecLogStatus("WaitTrialSoundD", "Sound done playing.");
                ChangeStateTo(stateTrainingReward%);  'check for training reward no matter what - ask Jackie if we want them to NOT get training reward if S2 is interrupted
            case recActive% = 0 then
                'Do nothing here if sound is playing but there is no task; simply wait for sound to stop
            case recIsGoNoGo% = 1 and inResponse2% = 1 then  'if the sound is still playing, check for early hit (go/no-go) 'Response2=Hit, though this case should never really happen *jao
                'accept response whether sound should be stopped or not
                if isEarlyHit% = 0 then
                    isEarlyHit% := 1;  'this is a hit before the sound has stopped playing
                    recPreciseTrialTime := recLeverTime;  'time early hit occurred
                    RecLogStatus("WaitTrialSoundD", "Lever is in response 1 - HIT interrupting S2 ... WAIT! HOW DID WE GET HERE?!");
                    if recContinueSoundOnS2Interrupt% = 0 then
                        if recCEDIsPresent% = 1 then
                            PlayWaveStop();  'stop playing stimulus
                        endif;
                        isPlaying% := 0;
                    endif;
                endif;
            case recIsGoNoGo% = 0 and inResponse1% = 1 then 'if the sound is still playing, check for early "miss" (FC) 'Response1=Miss, *jao
                'accept response whether sound should be stopped or not
                if isEarlyMiss% = 0 then
                    isEarlyMiss% := 1;  'this is a miss before the sound has stopped playing
                    recPreciseTrialTime := recLeverTime;  'time early hit occurred
                    RecLogStatus("WaitTrialSoundD", "Lever is in response 2 - MISS interrupting S2");
                    if recContinueSoundOnS2Interrupt% = 0 then
                        if recCEDIsPresent% = 1 then
                            PlayWaveStop();  'stop playing stimulus
                        endif;
                        isPlaying% := 0;
                    endif;
                endif;
            case recIsGoNoGo% = 0 and inResponse2% = 1 then  'if the sound is still playing, check for early hit (FC) 'Response2=Hit, *jao
                'accept response whether sound should be stopped or not
                if isEarlyHit% = 0 then
                    isEarlyHit% := 1;  'this is a hit before the sound has stopped playing
                    recPreciseTrialTime := recLeverTime;  'time early hit occurred
                    RecLogStatus("WaitTrialSoundD", "Lever is in response 1 - HIT interrupting S2");
                    if recContinueSoundOnS2Interrupt% = 0 then
                        if recCEDIsPresent% = 1 then
                            PlayWaveStop();  'stop playing stimulus
                        endif;
                        isPlaying% := 0;
                    endif;
                endif;
            endcase;
    
            
        case iState% = stateTrainingReward% then
            
            ' Are we giving free (training) rewards? If we are, then do so, otherwise we just pass on through. 
            if recTrainingRewardmL > 0 then
                RecLogStatus("TrainingReward", "Giving training reward, size " + str$(recTrainingRewardmL) + " mLs");
                amountRewarded += recTrainingRewardmL;  'add reward to juice counter
                if recCEDIsPresent% = 1 then
                    recRewardMs% := ConvertmLToSeconds(recTrainingRewardmL)*1000;
                    if recCEDIsPresent% then
                        stmp% := Reward%();
                    else
                        stmp% := 0;  'simulate success in reward if debugging
                    endif;
                    
                    if stmp% <> 0 then
                        PrintLog("ERROR in recREWARD%()!!! Value of stmp is %d\n",stmp%);
                        Message("Error in recREWARD%()!!!  stmp is" + str$(stmp%));
                        ChangeStateTo(stateTDTError%);  'TDT error is actually apropriate because if CED is called, no error checking is used right now
                    endif;
                endif
            else
                RecLogStatus("TrainingReward", "No training reward.");
            endif
            if recTrialInitReward% = 1 then
                recTrialInitReward% := -1; 'so that after soundA we can pass by this and move forward!! *jao (i feel smart!)
                printlog("INIT REWARD? recTrainingRewardmL= %f and recTrialInitReward= %d\n", recTrainingRewardmL,recTrialInitReward%);
                ChangeStateTo(stateStartSoundA%);
            else
                ChangeStateTo(stateInResponseWindow%);
            endif;
            
            
            
        case iState% = stateInResponseWindow% then
            
            if recActive% = 1 then
                if isTerminalS1% = 1 then
                    CheckLever%("inResponse2%",1);  'check lever status, simulate CR for debugging
                else
                    CheckLever%("inResponse1%",1);  'check lever status, simulate hit for debugging
                endif;
            else 
                if isTerminalS1% = 1 then
                    inResponse2% := 1; 'simulate CR for passive
                else
                    inResponse1% := 1;  'simulate hit for passive
                endif;
            endif
               
            docase
                'Early hit, interrupted final stimulus, this is OK   
            case isEarlyHit% = 1 then  'we don't care about the state of the lever; it was already released early
                isEarlyHit% := 0;  'reset variable
                'time of early hit is recorded above
                SafeSampleKey("M");
                if recExpToRun% = recExpAudiogramButton% then
                    UpdateAudiogram(1);  'hit, make audiogram stimulus quieter, etc.
                endif;
                StimComplete%(1, 1);  'must come after UpdateAudiogram()
                numHits% += 1; 'increment HIT counter
                ChangeStateTo(stateHitReward%);
            
            'AMDis Hi/Lo --> SAME trials early response
            case isEarlyFA% = 1 or isEarlyCR% = 1 and (recExpToRun% = recExpAMDiscButton% or recExpToRun% = recExpSpaceDisButton%) then  'AMDis Hi/Lo --> SAME trial, inResponse1% OR 2                 
                docase
                case isEarlyCR% = 1 then 'inResponse2%
                    isEarlyCR% := 0;  'reset variable
                    RecLogStatus("InResponseWindow", "In response position 2 , SAME trial - went Lo (early)");
                    'want to keep track of which response happened in output...
                case isEarlyFA% = 1 then 'inResponse1%
                    isEarlyFA% := 0;  'reset variable
                    RecLogStatus("InResponseWindow", "In response position 1 , SAME trial - went Hi (early)");
                    'want to keep track of which response happened in output...
                else
                    printlog("how the hell did we get here?");
                endcase;
            
                'time of early "FA" or "CR" (response) is recorded above ; for either response do:
                StimComplete%(2, coinFlipResult%);   'terminal S1
                SafeSampleKey("M");
                'NOTE: do not increment hit or miss counter for SAME trials in HI/LO experiment
                if coinFlipResult% = 1 then
                    ChangeStateTo(stateHitReward%);
                else
                    ChangeStateTo(stateMissTimeout%);
                endif;

            'Early FA, interrupted final stimulus before actual response window
            case isEarlyFA% = 1 then  'we don't care about the state of the lever; it was already released early
                isEarlyFA% := 0;  'reset variable
                'time of early FA is recorded above
                StimComplete%(2, 0);  'terminal S1
                SafeSampleKey("M");
                numFAs% += 1;  'increment FA counter
                ChangeStateTo(stateFalsePositive%);
            'Early CR, interrupted final stimulus, this is OK   
            case isEarlyCR% = 1 then  'we don't care about the state of the lever; it was already released early
                isEarlyCR% := 0;  'reset variable
                'time of early hit is recorded above
                StimComplete%(2, 1);   'terminal S1
                SafeSampleKey("M");
                'CR counter?
                ChangeStateTo(stateHitReward%);
            'Early Miss, interrupted final stimulus before actual response window
            case isEarlyMiss% = 1 then  'we don't care about the state of the lever; it was already released early
                isEarlyMiss% := 0;  'reset variable
                'time of early FA is recorded above
                StimComplete%(1, 0);
                SafeSampleKey("M");
                numMisses% += 1;  'increment MISS counter
                ChangeStateTo(stateFalsePositive%);
            'Error in RecLeverDown%()...not much point checking for this as most will be joystick and it never triggered anyway
            'case stmp% < 0 then
            '    RecLogError("WaitLvrUp", "ERROR (" + str$(stmp%) + ")in recLeverDown()");
            '    Message("Error in recLeverDown()!!!");
            '    ChangeStateTo(stateTDTError%);
            'Hit in response window    
            
        'AMDis HI/LO    *jao
            case inResponse1% = 1 and responseMode% = 1 and (recExpToRun% = recExpAMDiscButton% or recExpToRun% = recExpSpaceDisButton%) then 'HI, HIT
            'isTerminalS1% = 0 then 
                'SafeSampleKey("R");  'not in Recgen.pls!
                RecLogStatus("InResponseWindow", "In response position 1 - HIT HI");
                recPreciseTrialTime := recLeverTime;  'time hit occurred
                StimComplete%(1, 1);
                SafeSampleKey("M"); 'what is this about?
                numHits% += 1; 'increment HIT counter
                ChangeStateTo(stateHitReward%);
            'Lo-Hit in response window    
            case inResponse2% = 1 and responseMode% = 3 then 'LO, HIT -implied: and (recExpToRun% = recExpAMDiscButton% or recExpToRun% = recExpSpaceDisButton%)
            'isTerminalS1% = 0 then 
                'SafeSampleKey("R");  'not in Recgen.pls!
                RecLogStatus("InResponseWindow", "In response position 2 - HIT Lo");
                recPreciseTrialTime := recLeverTime;  'time hit occurred
                StimComplete%(3, 1);
                SafeSampleKey("M"); 'what is this about?
                numHits% += 1; 'increment HIT counter
                ChangeStateTo(stateHitReward%);
            'Hi-Miss in response window    
            case inResponse2% = 1 and responseMode% = 1 and (recExpToRun% = recExpAMDiscButton% or recExpToRun% = recExpSpaceDisButton%) then 'HI, MISS
            'isTerminalS1% = 0 then  
                RecLogStatus("InResponseWindow", "In response position 2 - MISS, HI");
                recPreciseTrialTime := recLeverTime;  'time FA occurred
                StimComplete%(1, 0);  
                SafeSampleKey("M");
                if recMissRepeats% = 1 and recMissRepeatsCounter% <= recMissRepeatsMax% then 'might need a -1 here
                    'Decrement current trial index (which was incremented above in stateInitializeTrials)
                    recCurrentTrial% := recCurrentTrial% - 1; 'this should do it!?
                    '**increment recMissRepeatsCounter HERE and reset to 0 in StateHitReward**
                    printlog("MissRepeatsCounter = %d this trial; keeps track of consecutive Misses \n", recMissRepeatsCounter%);
                    recMissRepeatsCounter% += 1; 'increment MissRepeatsCounter, keep track of consecutive Misses
                    printlog("MissRepeatsCounter incremented! is now = %d \n", recMissRepeatsCounter%);
                else
                    printlog("not repeating missed trials \n");
                endif
                numMisses% += 1;  'increment MISS counter
                ChangeStateTo(stateMissTimeout%);
            'Lo-MISS in response window    
            case inResponse1% = 1 and responseMode% = 3 and (recExpToRun% = recExpAMDiscButton% or recExpToRun% = recExpSpaceDisButton%) then 'LO, MISS
            'isTerminalS1% = 0 then  
                'SafeSampleKey("R");  'not in Recgen.pls!
                RecLogStatus("InResponseWindow", "In response position 1 - MISS, Lo");
                recPreciseTrialTime := recLeverTime;  'time hit occurred
                StimComplete%(3, 0);   'gotcha bitch!
                SafeSampleKey("M");
                if recMissRepeats% = 1 and recMissRepeatsCounter% <= recMissRepeatsMax% then 'might need a -1 here
                    'Decrement current trial index (which was incremented above in stateInitializeTrials)
                    recCurrentTrial% := recCurrentTrial% - 1; 'this should do it!?
                    '**increment recMissRepeatsCounter HERE and reset to 0 in StateHitReward**
                    printlog("MissRepeatsCounter = %d this trial; keeps track of consecutive Misses \n", recMissRepeatsCounter%);
                    recMissRepeatsCounter% += 1; 'increment MissRepeatsCounter, keep track of consecutive Misses
                    printlog("MissRepeatsCounter incremented! is now = %d \n", recMissRepeatsCounter%);

                else
                    printlog("not repeating missed trials \n");
                endif
                numMisses% += 1;  'increment MISS counter
                ChangeStateTo(stateMissTimeout%);
            
            'SAME and in either response window    
            case responseMode% = 2 and (recExpToRun% = recExpAMDiscButton% or recExpToRun% = recExpSpaceDisButton%) and (inResponse1% = 1 or inResponse2% = 1) then 'SAME, either response
            'isTerminalS1% = 1 then  
                'SafeSampleKey("R");  'not in Recgen.pls!
                if inResponse1% = 1 then
                    RecLogStatus("InResponseWindow", "In response position 1 , SAME trial - went Hi");
                    'want to keep track of which response happened in output...
                else 'inResponse2% = 1 
                    RecLogStatus("InResponseWindow", "In response position 2 , SAME trial - went Lo");
                    'want to keep track of which response happened in output...
                endif;
                recPreciseTrialTime := recLeverTime;  'time response occurred
                StimComplete%(2, coinFlipResult%);  '**this variable needs to be declared and established somewhere** *jao 
                SafeSampleKey("M");
                'NOTE: do not increment hit or miss counter for SAME trials in HI/LO experiment
                if coinFlipResult% = 1 then
                    ChangeStateTo(stateHitReward%);
                else
                    ChangeStateTo(stateMissTimeout%);
                endif;

        'the original code for SAME/DIFF:
            case inResponse1% = 1 and isTerminalS1% = 0 then  'forced choice OR go/no-go
                'SafeSampleKey("R");  'not in Recgen.pls!
                RecLogStatus("InResponseWindow", "In response position 1 - HIT");
                recPreciseTrialTime := recLeverTime;  'time hit occurred
                SafeSampleKey("M");
                if recExpToRun% = recExpAudiogramButton% then
                    UpdateAudiogram(1);  'hit, make audiogram stimulus quieter, etc.
                endif;
                StimComplete%(1, 1);  'must come after UpdateAudiogram()
                numHits% += 1; 'increment HIT counter
                ChangeStateTo(stateHitReward%);
            'False alarm in response window    
            case inResponse1% = 1 and isTerminalS1% = 1 then  'forced choice OR go/no-go
                RecLogStatus("InResponseWindow", "In response position 1 - False Alarm on terminal S1");
                recPreciseTrialTime := recLeverTime;  'time FA occurred
                StimComplete%(2, 0);  'terminal S1
                SafeSampleKey("M");
                numFAs% += 1;  'increment FA counter
                ChangeStateTo(stateFalsePositive%);
            'CR in response window    
            case inResponse2% = 1 and isTerminalS1% = 1 then  'forced choice only
                'SafeSampleKey("R");  'not in Recgen.pls!
                RecLogStatus("InResponseWindow", "In response position 2 - Correct Rejection");
                recPreciseTrialTime := recLeverTime;  'time hit occurred
                StimComplete%(2, 1);    'terminal S1
                SafeSampleKey("M");
                'CR counter?
                ChangeStateTo(stateHitReward%);
            'Miss in response window    
            case inResponse2% = 1 and isTerminalS1% = 0 then  'forced choice only
                RecLogStatus("InResponseWindow", "In response position 2 - Miss on terminal S2");
                recPreciseTrialTime := recLeverTime;  'time FA occurred
                StimComplete%(1, 0);
                SafeSampleKey("M");
                numMisses% += 1;  'increment MISS counter
                ChangeStateTo(stateFalsePositive%); 'should this be MissTimeout?? - reshuffle trial?
            
            'Response window is closed, failure to respond on forced choice
            case tNow - tStateStart > recResponseWindow and recIsGoNoGo% = 0 then
                RecLogStatus("InResponseWindow", "Lever not up - timed out - NO RESPONSE ON FORCED CHOICE");
                recPreciseTrialTime := tNow;  'time response window closed - note we could be more precise (e.g. tStateStart + recResponseWindow) but why?  There's no "event" 
                StimComplete%(isTerminalS1%+1, 0);  'this covers whether it is terminal S1 or not
                SafeSampleKey("M");
                'Decrement joystick thresholds if appropriate
                docase  'doing a case statement here because I think there might be "isTerminalS1% == 2" down the road
                case isTerminalS1% = 1 then
                    ChangeThresh2(doDecPassiveMiss%[]);
                case isTerminalS1% = 0 then
                    ChangeThresh2(doDecPassiveFA%[]);
                endcase;
                'Decrement current trial index (which was incremented above in stateInitializeTrials)
                recCurrentTrial% := recCurrentTrial% - 1;
                'Send current trial to "middle" of remaining trials
                SendTrialToMiddle%(recNTrials%,recCurrentTrial%,1,recTrialOrder%[]);  'at least one intervening trial 'reshuffle trial if no response!
                RecLogStatus("InResponseWindow", "NO RESPONSE ON FORCED CHOICE - trial reshuffled");
                'numFPs% += 1;  'increment FP counter   'NOTE: NOT SURE WHETHER TO INCREMENT FA COUNTER HERE OR NOT
                ChangeStateTo(stateMissTimeout%);  'go to miss timeout for no response --> OR, delete reshuffling above and do FA timeout
            'Response window is closed, miss on go/no-go   
            case tNow - tStateStart > recResponseWindow and recIsGoNoGo% = 1 and isTerminalS1% = 0 then  'go/no-go miss
                RecLogStatus("InResponseWindow", "Lever not up - timed out - MISS");
                recPreciseTrialTime := tNow;  'time response window closed - note we could be more precise (e.g. tStateStart + recResponseWindow) but why?  There's no "event" 
                numMisses% += 1;  'increment MISS counter
                if recExpToRun% = recExpAudiogramButton% then
                    UpdateAudiogram(-1);  'miss, make audiogram stimulus louder, etc.
                    'Calculate new delay interval time
                    recDelayIntervalTime := recMinOnsetDelay + Rand(recVarOnsetDelay, 0);
                    ChangeStateTo(statePreTrialDelay%);  'for the audiogram, misses are expected, just change state to pre-trial delay and do not turn off LED
                else
                    SafeSampleKey("M");
                    ChangeStateTo(stateMissTimeout%);
                endif;
                StimComplete%(1, 0);  'must come after UpdateAudiogram()
            'Response window is closed, correct rejection on go/no-go  
            case tNow - tStateStart > recResponseWindow and recIsGoNoGo% = 1 and isTerminalS1% = 1 then  'go/no-go CR
                RecLogStatus("InResponseWindow", "Lever not up - Correct Rejection on terminal S1");
                recPreciseTrialTime := tNow;  'time response window closed - note we could be more precise (e.g. tStateStart + recResponseWindow) but why?  There's no "event"
                StimComplete%(2, 1);  'terminal S1
                SafeSampleKey("M");
                'CR counter?
                ChangeStateTo(stateCRReward%);  
                'Otherwise, the response window is still open and the lever is still down    
            else
                'Nothing, just a comment                
            endcase
            'We can aggressively wait for the response if the RT is important, just uncomment below (is RT even recorded?)
            nextStateImmed% := 0;   'or don't, testing
            
            
            
        case iState% = stateMissTimeout% then
            CheckLever%("inOrigin%",1);  'Flush lever/joystick during timeout, just simulate inorigin for debug
            'if Miss or FA, reset to thisHitReward so that it will go to base reward next time:
            thisHitReward := 0; 'reset thisreward
            if tNow - tStateStart > recMissTO then
                RecLogStatus("MissTimeout", "Timeout period done.");
                recChangeRewardType% := 1;  'will change reward type after miss, if other conditions are met 
                ChangeStateTo(stateInitializeTrials%);  'move to next trial
                tNextTrial := tNow;  'ready to go
            endif
            
            
            
        case iState% = stateFalsePositive% then 
            'this state is used to give a FA timeout for an incorrect response to a terminal S1 (nontarget) stim 
            'no real need to repeat entire stim sequence as the whole sequence was presented
            CheckLever%("inOrigin%",1);  'Flush lever/joystick during timeout, just simulate inorigin for debug
            'if Miss or FA, reset to thisHitReward so that it will go to base reward next time:
            thisHitReward := 0; 'reset thisreward
            if tNow - tStateStart > recFalseAlarmTO then
                RecLogStatus("FalsePositiveTimeout", "Timeout period done.");
                recChangeRewardType% := 1;  'will change reward type after FA, if other conditions are met 
                'ChangeStateTo(stateWaitForInitiationMovement%);  'was stateInitializeTrials% but we want to repeat the stimulus
                'ChangeStateTo(stateInitializeTrials%);  'No, actually, I don't think we do want to repeat the stimulus
                'ACTUALLY - we want to shuffle this back in, since there's no diff between a false positive on the final
                'stimulus and one on a prior stimulus.  Note that in the future there may be human experiments where this
                'distinction is valid, so I'm keeping it in.  In that event (only vaguely planned) I think the best way will
                'be to branch inside this logic state.
                
                'Decrement current trial index (which was incremented above in stateInitializeTrials)
                recCurrentTrial% := recCurrentTrial% - 1;
                
                'Send current trial to "middle" of remaining trials
                SendTrialToMiddle%(recNTrials%,recCurrentTrial%,1,recTrialOrder%[]);  'at least one intervening trial
                
                ChangeStateTo(stateInitializeTrials%); 
                tNextTrial := tNow;  'ready to go
            endif
            
            
        case iState% = stateFalseAlarmAudiogram% then 
            'this state is used to give a FA timeout for a response not corresponding to a stimulus
            'we do not want to reset any of the audiogram values here, just restart on the same stimulus at
            'the same intensity and same staircase state as before
            CheckLever%("inOrigin%",1);  'Flush lever/joystick during timeout, just simulate inorigin for debug
            if tNow - tStateStart > recFalseAlarmTO then
                RecLogStatus("FalsePositiveTimeout", "Timeout period done.");
                recChangeRewardType% := 1;  'will change reward type after FA, if other conditions are met 
                
                'Do not decrement current trial index.  
                'recCurrentTrial% := recCurrentTrial% - 1;
                
                ChangeStateTo(stateInitializeTrials%); 
                tNextTrial := tNow;  'ready to go
            endif            
            
            
        case iState% = stateFAInterrupt% then
            'this state is used to repeat a FA interrupted stimulus, so that the S2 gets played
            CheckLever%("inOrigin%",1);  'Flush lever/joystick during timeout, just simulate inorigin for debug
            if tNow - tStateStart > recFalseAlarmTO then
                RecLogStatus("FAInterruptTimeout", "Timeout period done. Trial #" + str$(recCurrentTrial%) + " being reshuffled.");
                recChangeRewardType% := 1;  'will change reward type after FA, if other conditions are met 
                
                'Decrement current trial index (which was incremented above in stateInitializeTrials)
                recCurrentTrial% := recCurrentTrial% - 1;
                
                'Send current trial to "middle" of remaining trials
                SendTrialToMiddle%(recNTrials%,recCurrentTrial%,1,recTrialOrder%[]);  'at least one intervening trial
                
                ChangeStateTo(stateInitializeTrials%); 
                tNextTrial := tNow;  'ready to go
            endif            
            
            
            
        case iState% = stateHitReward% then
            
            'Increment, if appropriate
            ChangeThresh2(doIncHit%[]);
            'ChangeThresh(doIncUp%,doIncDown%,doIncLeft%,doIncRight%);
            recMissRepeatsCounter% := 0; 'reset MissRepeatsCounter to 0, keep track of consecutive Misses
            
            if recHitRewardmL > 0 then
                'do reward increment stuff (note: if no increment then adding 0 every time will do nothing)
                if thisHitReward = 0 then 'it was reset! (or this is the first trial)
                    thisHitReward := recHitRewardmL; 'this reward will be the base reward level
                    'lastHitReward not needed in this case, will be initialized below after first Hit is given
                else
                    thisHitReward := lastHitReward + recHitRewardIncmL;
                    if thisHitReward > recMaxHitRewardmL then 'check if this exceeds Max
                        thisHitReward := recMaxHitRewardmL;
                    endif    
                endif
                RecLogStatus("HitReward", "Giving Hit Reward, size=" + str$(thisHitReward) + " mLs"); 'replaced recHitRewardmL with thisHitReward
                amountRewarded += thisHitReward;  'add this reward to juice counter
                lastHitReward := thisHitReward; 'save this hit reward value for next time (does this need to be lower down?)
                if recCEDIsPresent% = 1 then
                    recRewardMs% := ConvertmLToSeconds(thisHitReward)*1000; 'replaced recHitRewardmL with thisHitReward
                    recRewardMs := recRewardMs%;  'we need a float version for later math
                    s$ := Print$("Reward,%f,%d", tNow, recRewardMs%);
                    SampleText(s$, tNow);
                    if recCEDIsPresent% then
                        stmp% := Reward%();
                    else
                        stmp% := 0;  'simulate success in reward if debugging
                    endif;
                    
                    if stmp% <> 0 then
                        PrintLog("ERROR in recREWARD%()!!! STMP is %d\n",stmp%);
                        Message("Error in recREWARD%()!!!");
                        ChangeStateTo(stateTDTError%);  'TDT error is actually apropriate because if CED is called, no error checking is used right now
                    else
                        ChangeStateTo(stateInitializeTrials%);  'move to next trial after reward is done
                        tNextTrial := tNow + (recRewardMs/1000);
                    endif;
                else
                    ChangeStateTo(stateInitializeTrials%);  'move to next trial after reward is done
                    tNextTrial := tNow; 'the TDT delay is built in, ready to go
                endif
            else
                ChangeStateTo(stateInitializeTrials%);  'move to next trial after reward is done
                tNextTrial := tNow; 'the TDT delay is built in, ready to go
            endif;
            
            
        case iState% = stateCRReward% then
            
            'Increment, if appropriate
            ChangeThresh2(doIncCR%[]);
            'ChangeThresh(doIncUp%,doIncDown%,doIncLeft%,doIncRight%);
            
            if recCRRewardmL > 0 then
                RecLogStatus("CRReward", "Giving CR Reward, size=" + str$(recCRRewardmL) + " mLs");
                amountRewarded += recCRRewardmL;  'add reward to juice counter
                if recCEDIsPresent% = 1 then
                    recRewardMs% := ConvertmLToSeconds(recCRRewardmL)*1000;
                    s$ := Print$("Reward,%f,%d", tNow, recRewardMs%);
                    SampleText(s$, tNow);
                    if recCEDIsPresent% then
                        stmp% := Reward%();
                    else
                        stmp% := 0;  'simulate success in reward if debugging
                    endif;
                    
                    if stmp% <> 0 then
                        PrintLog("ERROR in recREWARD%()!!!\n");
                        Message("Error in recREWARD%()!!!");
                        ChangeStateTo(stateTDTError%);  'TDT error is actually apropriate because if CED is called, no error checking is used right now
                    endif;
                endif
            endif
            ChangeStateTo(stateInitializeTrials%);  'move to next trial when reward is done
            tNextTrial := tNow + (recRewardMs/1000);
            
        case iState% = stateDone% then
            PrintLog("#HITS = " + str$(numHits%) + ",   #MISSES = " + str$(numMisses%) + ",   #FPs = " + str$(numFPs%) + ",   LastHitReward(mL) = " + str$(LastHitReward) + ",   TOTAL Juice(mL) = " + str$(amountRewarded) + ".\n");            
            SafeSampleKey("M");
            RecLogStatus("Done", "");
            iStatus% := 0;
            recReadyToQuit% := 0;
            ReturnToExptSelectDialog%();  'If the current expt. is "done" allow another to be run without stopping sampling
            'Stop%();
            
            
            
        case iState% = stateTDTError% then
            
            'find a way to break all the way out
            
            'This is temporary so it does something logical but should be updated eventually
            RecLogStatus("A TDT Error has occurred!", "");
            recReadyToQuit% := 1;  'This will allow the entire thing to quit
            SafeSampleKey("M");
            iStatus% := 0;
            Stop%();
            
            
            
        case iState% = stateCodingError% then
            
            'find a way to break all the way out
            
            'This is temporary so it does something logical but should be updated eventually
            RecLogStatus("A coding Error has occurred!", "");
            iStatus% := 0;
            recReadyToQuit% := 1;  'This will allow the entire thing to quit
            SafeSampleKey("M");
            Stop%();
            
            
            
        else
            
            RecLogStatus("UNKNOWN STATE", "iState%=" + str$(iState%));
            Message("Unknown state (%d)!", iState%);
            iStatus% := 0;
            recReadyToQuit% := 1;  'This will allow the entire thing to quit
            SafeSampleKey("M");
            Stop%();          
        endcase

    wend  'close the nextStateImmed% while

    return iStatus%;  'if iStatus% is 0, the Toolbar() will return
end




'=================================Debounce the Lever Channel=================================
'This function serves as a software debounce for incoming TTL pulses.  It can only parse 1000
'events at one time, but is called every time the idle loop is called (if we are sampling) and at 
'so the 1000 event limit should not really be in danger.
'If there are > 1000 events, I BELIEVE it will simply parse the first 1000, allowing it to 
'continue parsing 1000 events each time it is called until it is caught up.  ...that hasn't been tested.
func DebounceLever%(Now)
    
    var TimesArray[1000];            'array of times of most recent events
    var TimesArrayTemp[999];         'array of times used only the first time through
    var LeverStatusAfter[1000];      'array of lever statuses corresponding to TimesArray[]
    var TimeToPrev[1000];            'array of differences between times in TimesArray[] and previous event
    var TimeToNext[1000];            'array of differences between times in TimesArray[] and next event
    var temp1[999];
    var temp2;
    var RealEventTime[1000];         'Holds times of real (not bouncing) events 
    var RealEventValue[1000];        'Holds lever values resulting from real events
    var EventCount%;                 'Counter for real events
    var ValueCount%;                 'Counter for real lever values
    var DebounceTime := .040;        'Debounce over 40 ms, can be changed manually
    var NumEvents%;                  'Number of potential lever events in the current execution
    var LeverString$;						'A string which details the lever event (for textmark channel)
    var ii%, jj%, BreakVar;
    
    
    view(recDataWindowView%);
    
    if recLeverTime = 0 then 'if it's the first pass or there have not been any events (LeverInitTime and LeverResponseTime are identical for lever scenarios)
        NumEvents% := chandata(recLeverChannel%,TimesArrayTemp[],0,Now);  'put recent times of lever presses in a temporary array
        arrconst(TimesArray[1:999],TimesArrayTemp[]);  'move temporary numbers to regular array, leaving first time blank (indicates "known" event at time = 0)
        NumEvents% := NumEvents% + 1;  'Increment NumEvents% by one to account for asserted event at time = 0
    else
        NumEvents% := chandata(recLeverChannel%,TimesArray[],recLeverTime,Now);  'put times of recent lever presses in regular array, starting with most recent known event
    endif;
    'printlog("Events are at %f and recLeverTime is %f and now is %f\n",TimesArray[],recLeverTime,Now);
    
	'There should always be a "first event" at LeverInitTime.  If there are no more, we haven't actually
	'had anything happen, so don't do anything
    if NumEvents% > 1 then
		'Calculate time to previous, next events
        
		'Fill temp1 with a shifted version of TimesArray, shifted one to the left
		'Note that the fill for a single element must be done differently
        if NumEvents% = 2 then
            temp1[0] := TimesArray[1];
        else
            arrconst(temp1[0:NumEvents%-1],TimesArray[1:NumEvents%-1]);
        endif;
        
		'Subtract, so temp1[x] holds the time difference between TimesArray[x] and TimesArray[x+1]
        arrsub(temp1,TimesArray[]);
        
		'Fill TimeToNext and TimeToPrev, note that temp1[NumEvents%-1] will be negative, and is useless
        if NumEvents% = 2 then
            TimeToPrev[1] := temp1[0];
            TimeToNext[0] := temp1[0];
        else
            arrconst(TimeToPrev[1:NumEvents%-1],temp1[0:NumEvents%-1]);
            arrconst(TimeToNext[0:NumEvents%-1],temp1[0:NumEvents%-1]);
        endif;
        
		'Fill final spot in TimeToNext with time to Now.
        TimeToNext[NumEvents%-1] := Now - TimesArray[NumEvents%-1];
        
		'Get lever status resulting from each lever event
        for ii% := 1 to NumEvents%-1 do 'only consider events starting at second position in array
            nexttime(recLeverChannel%,TimesArray[ii%],temp2);  'temp2 will be 0 if low-to-high and 1 if high-to-low
            LeverStatusAfter[ii%] := 1 - temp2; 'LeverStatusAfter will be 1 if low-to-high and 0 if high-to-low
        next;
        
        
		'Check each event in TimesArray (except [0])
        for ii% := 1 to NumEvents%-1 do 
			'If there was more than DebounceTime between the previous event and this one, the
			'previous state was stable, this should be considered a real event
            if TimeToPrev[ii%] > DebounceTime then
                RealEventTime[EventCount%] := TimesArray[ii%];
                EventCount% := EventCount% + 1;
				'Get the lever status for this event by looking for next stable period
                BreakVar := 0;
                jj% := ii%;
                while jj% <= NumEvents%-1 and BreakVar = 0 do
                    if TimeToNext[jj%] > DebounceTime then 'it has been stable long enough
                        RealEventValue[ValueCount%] := LeverStatusAfter[jj%];
                        ValueCount% := ValueCount% + 1;
                        BreakVar := 1;
                    else
                        jj% := jj% + 1;
                    endif;
                wend;
            endif;
        next;
        
		'Check to see that the number of lever presses and events correspond appropriately
        if ValueCount% <> EventCount% then
            if ValueCount% > EventCount% then
                printlog("Quitting because we have found more real lever presses than real events.  This is a serious bug!\n");
                'view(HiddenLogHandle%).print("Quitting because we have found more real lever presses than real events.  This is a serious bug!\r");
                Stop%();
            endif;
            if ValueCount% < EventCount%-1 then
                printlog("Quitting because we have found more than one event which does not correspond to a stable lever press!\n");
                'view(HiddenLogHandle%).print("Quitting because we have found more than one event which does not correspond to a stable lever press!\r");
                Stop%();
            else
                EventCount% := EventCount%-1;  'decrement, do not consider last event real as we do not have a
                'corresponding lever press
            endif;
        endif;
        
        'Put events in memory channel if they exist and change LeverInitTime/LeverResponseTime/LeverInit%/LeverResponse%
        if EventCount% > 0 then	
            'verbose, just taken out
            'printlog("Debounce: The lever events we considered to be real occurred at times: %f\n",RealEventTime[0:EventCount%]);

            for ii% := 0 to EventCount%-1 do
                recLeverCodes%[0] := RealEventValue[ii%];
                if RealEventValue[ii%] = 1 then
                    LeverString$ := "Lever Pressed";
                else
                    LeverString$ := "Lever Released";
                endif;
                view(recDataWindowView%).MemSetItem(recMemChanLeverDebounce%,0,RealEventTime[ii%],recLeverCodes%[],LeverString$);
            next;
            'return most recent event and value
            recLeverTime := RealEventTime[ii%-1]; 'subtract one because ii% is incremented a final time by the for loop
            recLeverState% := RealEventValue[ii%-1]; 'ditto
            
            'more Sutter stuff, probably not necessary here
			'indicate whether lever is in the origin (meaning not pressed), only if we are responding w/ lever
			'also indicate if lever is in trial initiation position
			'also indicate if lever is in trial response position
            'if RespDevice% = 0 then
            '    InOrigin% := 1 - LeverPos%;
            '    TrialInit% := LeverPos%;
            '    TrialResponse% := InOrigin%;  'for lever, trial response position is same as origin
            '    if TrialResponse% = 1 then
            '        ResponseTime := LeverTime;
            '    endif;
            'endif;
            
        endif;  'end "if there were any events"
        
    endif;  
    
    return 1;
    
end;



'A simple function which points to either recLeverDown%() or DebounceLever%() or ReadJoystick%() as appropriate
func CheckLever%(varName$,varState%)
    'printlog("CHECKLEVER: varName$ is %s, varState% is %d\n",varName$,varState%);
    'This function no longer returns a value, it merely changes inOrigin%, inTrialInit%, inResponse1%, inResponse2%
    'Major update to CheckLever% - the problem is that there was really no way to move the "experiment" forward
    'in testing mode.  Now CheckLever% REQUIRES two inputs in the form of a variable name (inOrigin%, etc.) and a
    'state to set that variable to which will allow the state logic to step forward.  This will only happen if BOTH
    'the CED and TDT are not present, otherwise, the program assumes you're actually trying to run it.
    if recActive% = 1 and recCEDIsPresent% = 1 then
        docase  'note that in all cases recLeverTime is set within the called function
        case recUseJoystick% = 0 then
            DebounceLever%(tNow);  'DebounceLever%() is run at the beginning of each idle loop, do it again if necessary before calling 
            inOrigin% := 1-recLeverState%;
            inTrialInit% := recLeverState%;
            inResponse1% := inOrigin%;  'for a lever, response 1 position is the origin (not pressed)
            inResponse2% := 0;  'there is no response 2 with a lever
            'If recLeverState% is -1 (TDT error), the other values will be recognizably illegal
        case recUseJoystick% = 1 then
            ReadJoystick%();  'ReadJoystick calls another function (AssignJoystickVariables) to get
            'joystick position variables, not done here.
        else
            printlog("Unknown value " + Str$(recUseJoystick%) + " for recUseJoystick%, this is probably your problem!\n");        
        endcase
    else
        docase
        case varName$ = "inOrigin%" then
            inOrigin% := varState%;
        case varName$ = "inTrialInit%" then
            inTrialInit% := varState%;
        case varName$ = "inResponse1%" then
            inResponse1% := varState%;
        case varName$ = "inResponse2%" then
            inResponse2% := varState%;
        else
            printlog("Unknown value " + varName$ + " in debug level of CheckLever% call!\n");
        endcase        
    endif
       
'   printlog("inOrigin is %d, inTrialInit is %d, inResponse1 is %d, inResponse2 is %d, and reclevertime is %f\n",inOrigin%,inTrialInit%,inResponse1%,inResponse2%,recLeverTime);
'   these values were all 0 for recGoNoGo =1!

return 0
    
end;

'-----------  BehOutput(result$, isS2%) -------------------------------------
' creates and writes to text file output with relevant behavioral variables
' for each experiment (Space and AMDis so far)
' probably could be a proc, not a function, but i'll leave it in case I want to add a return value??
func BehOutput(resultCode$, isS2%)
    'called from StimComplete%
    'resultCode$ is determined in StimComplete% from success% and isS2% is passed forward from IdleLoop%
    'see NameThatStimulus$ (RecRoom) for how to extract stimulus variables!
    
    var fh%; 'file handle
    var exptext$;
    'var playInd% := recTrialOrder%[recCurrentTrial%-1];  'recCurrentTrial is in human units, convert to index units
    var thisStim%;
    var spkr%;
    var joyResponse%;
    var missReps%;
    'NameThatStimulus$(recStimList%[recPWAList%[recStimCount%][recTrialOrder%[recCurrentTrial%-1]]][recTrialOrder%[recCurrentTrial%-1]]));
    'other vars to include?
    'Get trial-based attenuation for current stimulus
    '   trlatten := recDeltadBList[recStimCount%][playInd%];  'corresponds to recPWAList%[][], index the same way
    'carrier% := recTrialGenGauss%[n%]; '1 if Gaussian, 0 if uniform noise
    thisStim% := recStimList%[recPWAList%[recStimCount%][recTrialOrder%[recCurrentTrial%-1]]][recTrialOrder%[recCurrentTrial%-1]];
    spkr% := recSpeakerList%[recPWAList%[recStimCount%][recTrialOrder%[recCurrentTrial%-1]]][recTrialOrder%[recCurrentTrial%-1]];
    
    PrintLog("***thisStim = %d and thisSpeaker = %d\n",thisStim%,spkr%);
    printlog("**Stim should be %s\n",NameThatStimulus$(recStimList%[recPWAList%[recStimCount%][recTrialOrder%[recCurrentTrial%-1]]][recTrialOrder%[recCurrentTrial%-1]]));
    'determing expt specific strings... etc..
    'this docase also ensures a new file will be created for each experiment or for which vars to add for which expt
    docase
    case recExpToRun% = recExpAMDiscButton% then
        exptext$ := "AMDis";
    case recExpToRun% = recExpSpaceDisButton% then    
        exptext$ := "SpaceDis";
    case recExpToRun% = recExpSearchButton% then
        exptext$ := "Search";
    case recExpToRun% = recExpFRAButton% then
        exptext$ := "FRA";
    case recExpToRun% = recExpJoyTrnButton% then 
        exptext$ := "JoyTrain";
    case recExpToRun% = recExpCueingButton% then
        exptext$ := "Cueing";
    case recExpToRun% = recExpAudiogramButton% then
        exptext$ := "Audiogram";    
    endcase
    
    joyResponse% :=0;
    docase
    case inResponse1% = 1 then
        joyResponse% :=1;
    case inResponse2% = 1 then
        joyResponse% :=2;
    else
        joyResponse% :=0;
        '    PrintLog("fucked up joyResponse ...?\n");
    endcase
    
    if recMissRepeats% = 1 then
        missReps% := recMissRepeatsMax%;
    else 
        missReps% := 0;
    endif
    
    'just use first 3 chars of monk name/prefix and then append date so format is consistent
    'blockTag$ ensures a new file complete with header file is created for each block - these will be concatenated later during analysis (easiest way to keep track of blocks)
    fh%:=FileOpen(recFileSaveLoc$ + recMonkPrefix$ +"_"+ Date$(2,2,3,3,"-")+ blockTag$ +"_"+ exptext$ + ".txt",8,2); 'or 3 to create if DNE
    'PrintLog("BehOutput: Filename is " + recFileSaveLoc$ + recMonkPrefix$ +"_"+ Date$(2,2,3,3,"-")+ blockTag$ +"_"+ exptext$ + ".txt\n");
    'PrintLog("BehOutput: File handle = %d\n", fh%);
    
    if fh%<0 then 'if file does not exist... create it! and stuff
        'OR check for a firstTime or newBlock variable to figure out what to do...
        fh%:=FileOpen(recFileSaveLoc$ + recMonkPrefix$ +"_"+ Date$(2,2,3,3,"-")+ blockTag$ +"_"+ exptext$ + ".txt",8,3); '3 to create file
        'file header chunk: expt, monk, date, time info:
        PrintLog("\nBehOutput: File handle = %d\n", fh%);
        PrintLog("%s\n", "Stimulus file is" + recSelectedStimFile$);
        PrintLog("Trials file is %s\n\n",recSelectedTrialsFile$);
        
        view(fh%).print(recMonkPrefix$+"\t"+Date$(20,1,3,3," ")+" "+Time$(1,3)+"\t"+exptext$+"Block "+blockTag$+"\n");
        'FORMAT 1  'file header chunk cont..: trials file & stim file if AMDis or Space (or Cueing) and Speaker Array used
        view(fh%).print("Stimulus file: %s\n",recSelectedStimFile$);
        view(fh%).print("Trials file: %s\n",recSelectedTrialsFile$);
        view(fh%).print("Joy Init = %d\nResponse1 = %d\nResponse2 = %d\n", recTrialInitPosition%,recTrialResponsePosition1%,recTrialResponsePosition2%);
        'header cont... miss repeats and training reward (i.e., is this a training file or real behavior)
        view(fh%).print("Miss repeats max = %d\ntraining reward = %.2f\n", missReps%, recTrainingRewardmL);
        'header for trial by trial info
        view(fh%).print("Speaker array = %d\n",recNSpeakers%); 
        'for AMDis and SpaceDis... (case this bitch to add experiment formats)
        
        'FORMAT 2?  'file header chunk cont..: trials file & stim file if AMDis or Space (or Cueing) and Speaker Array used
        '    view(fh%).print("Stimulus file \tTrials file \t Joy Init \tResponse1 \tResponse2 \tMiss repeats max \ttraining reward \tSpeaker array \n");
        '    view(fh%).print("%s\t%s\t%d\t%d\t%d\t%d\t%f\t%d\n",recSelectedStimFile$,recSelectedTrialsFile$, recTrialInitPosition%,recTrialResponsePosition1%,recTrialResponsePosition2%,recMissRepeatsMax%,recTrainingRewardmL,recNSpeakers%);
        '
        
        'For now, there is only one format of log file, but we will need at least one more for Audiogram -jj
        docase
        case recExpToRun% = recExpAudiogramButton% then
            view(fh%).print("\n%s\t%s\t%s\t%s\n","Spkr","Freq","dB","Result"); 'header for trial vars
        else 'in all other cases, this is what Jackie has right now - case statement can be easily updated in the future
            view(fh%).print("\n%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n","Trial","Stype","AMrate","Spkr","Atten","Result","Resp","RespTime"); 'header for trial vars
            'or split S1 and S2 into two lines - call after each StimComplete --> yes. this will be called after each stimulus from StimComplete
        endcase
    endif
    '**TODO: fix the monkprefix problem and then create a new file for each block..
    'solution: add a block number/tag variable?? (the letter that goes at the end of the file name)
    
    'now fill in the data for this trial
    'for AMDis and SpaceDis... (case this bitch to add experiment formats)(casing this bitch -jj)
    docase
    case recExpToRun% = recExpAudiogramButton% then
        view(fh%).print("%d\t%d\t%f\t%s\n",spkr%,recTrialGenLowpassHz[thisStim%],recAudiogramPreviousdB,resultCode$);
    else
        view(fh%).print("%d\t%d\t%d\t%d\t%d\t%s\t%d\t%f\n",recCurrentTrial%,isS2%+1,recTrialGenAMFreqHz[thisStim%],spkr%,recDeltadBList[recStimCount%][recTrialOrder%[recCurrentTrial%-1]],resultCode$,joyResponse%,recPreciseTrialTime); 'data!
    endcase
    'NOTE: output key for "Stype"
    'isS2%+1 = 1 for S1, 2 for S2 (change), 3 for terminal S1 (same - NoGo trial), and 4 for terminal S1 for forced choice
    'for Stype = 4, see resultCode for reward status
    
    'don't forget to close the file!
    fileclose(fh%);

end
'-----------  end of BehOutput(result$, isS2%) -------------------------------------



'A function to update the logic variables for the audiogram
proc UpdateAudiogram(AGresult%)
    'AGresult% will be 1 following a hit and -1 following a miss
    
    recAudiogramPreviousdB := recAudiogramCurrentdB; 'hold value of most recent dB, will be used for logging
    
    docase
    case AGresult% = 1 and recAudiogramCurrentDirection% = 1 then
        'This is a hit while getting louder
        'This is a reversal (countable, loggable)
        recAudiogramCurrentDirection% := 0;  'reverse the direction
        recAudiogramCurrentdB := recAudiogramCurrentdB - recAudiogramQuieterdBStep;  'update atten, make stim quieter (note: due to reversal cannot be on initial direction)
        recAudiogramCurrentReversals% += 1;  'increment number of reversals
        recLogThisResult% := 1;  'always log this result
        recAudiogramIsInitialDirection% := 0;  'there has been a reversal, we are not in the initial direction
    case AGresult% = 1 and recAudiogramCurrentDirection% = 0 then
        'This is a hit while getting quieter
        'This is not a reversal
        if recAudiogramIsInitialDirection% = 1 then
            recAudiogramCurrentdB := recAudiogramCurrentdB - recAudiogramInitialdBStep;  'update atten, make stim quieter using large value
        else
            recAudiogramCurrentdB := recAudiogramCurrentdB - recAudiogramQuieterdBStep;  'update atten, make stim quieter using normal value
        endif;
        if recAudiogramOnlyLogReversals% = 0 then
            recLogThisResult% := 1;  'log this result
        else
            recLogThisResult% := 0;  'do not log this result
        endif;
    case AGresult% = -1 and recAudiogramCurrentDirection% = 1 then
        'This is a miss while getting louder
        'This is not a reversal
        if recAudiogramIsInitialDirection% = 1 then
            recAudiogramCurrentdB := recAudiogramCurrentdB + recAudiogramInitialdBStep;  'update atten, make stim louder using large value
        else
            recAudiogramCurrentdB := recAudiogramCurrentdB + recAudiogramLouderdBStep;  'update atten, make stim louder using normal value
        endif;
        if recAudiogramOnlyLogReversals% = 0 then
            recLogThisResult% := 1;  'log this result
        else
            recLogThisResult% := 0;  'do not log this result
        endif;
    case AGresult% = -1 and recAudiogramCurrentDirection% = 0 then
        'This is a miss while getting quieter
        'This is a reversal (loggable, but not countable - does not count towards total number of reversals)  
        recAudiogramCurrentDirection% := 1;  'reverse the direction 
        recAudiogramCurrentdB := recAudiogramCurrentdB + recAudiogramLouderdBStep;  'update atten, make stim louder (note: due to reversal cannot be on initial direction)
        recLogThisResult% := 1;  'always log this result
        recAudiogramIsInitialDirection% := 0;  'there has been a reversal, we are not in the initial direction
    endcase
    
    'If we have reached the correct number of reversals, reset for next frequency of audiogram
    if recAudiogramCurrentReversals% = recAudiogramNReversals% then
        recAudiogramCurrentDirection% := recAudiogramInitialDirection%;  'reset to original direction
        recAudiogramIsInitialDirection% := 1;  'reset this as well
        recAudiogramCurrentReversals% := 0; 
        recAudiogramStartNewTrial% := 1;
        recAudiogramCurrentdB := recAudiogramStartdB; 'reset initial dB value
    else
        'recAudiogramStartNewTrial% := 0;  'this would be redundant, this is properly zeroed right after the increment in stateinitializetrials
    endif

    
    
end
