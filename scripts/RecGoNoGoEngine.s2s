
'This script does not execute any code when the script which includes it is run - it is merely the set of functions
'which define the workings of the presentation engine.  Use RunGoNoGoEngine%() to get things going.


'==========================   Global variables  ============================================


' channel numbers and window handles
const recDAC0Channel% := 1;          ' DAC0 output should be tee'd and input to ADC port 6
const recTrigChannel% := 2;          ' Channel for trigger recording (teed from trig input!)
const recLeverChannel% := 3;         ' Channel for behavioral lever recording
const configJoyXChannel% := 4;       ' Channel for JoystickX
const configJoyYChannel% := 5;       ' Channel for JoystickY
const recTrode1Channel% := 11;       ' First electrode. Don't use channel numbers above this
const recTrode2Channel% := 12;       ' I'm breaking the above rule (don't use channel numbers above this)
const recTrode3Channel% := 13;       '   because it makes no sense to me.  If it turns out to matter
const recTrode4Channel% := 14;       '   then I suppose we'll figure that out!
const recTrode5Channel% := 15;
const recTrode6Channel% := 16;
const recTrode7Channel% := 17;
const recTrode8Channel% := 18;
const recTrode9Channel% := 19;
const recTrode10Channel% := 20;



' ports
const recTriggerPort% := 0;
const recLeverPort% := 1;
const configJoyXPort% := 2;  'A2D port
const configJoyYPort% := 3;  'A2D port

' memory channels
var recMemChanLeverDebounce%;

' For Joystick
var joystickXOffset; 'use registry  
var joystickYOffset;
var joyview%;
var joydatachan%;
var LastPos%;
var JoystickReadOnce%;
var LeverCodes%[4]; 
var XPos%;
var YPos%;
var XTime;
var YTime;
var InOrigin%;
var RespDevice%;
var TrialInit%;
var TrialResponse%;
var ResponseTime;
var OffAxis%;
var XJoy;
var YJoy;
var doIncUp%;
var doIncDown%;
var doIncLeft%;
var doIncRight%;

' for anything other than electrodes!
var recXYWindowView%;              ' View variable for XY window
var recDataWindowView%;            ' View variable for data window


'This is all for ExtractSpaceInitialize
var recHBeh%;       ' ecode file
var recHBak%;       ' spikes
var recTLastProcessed := -1;
var recChanWM%;
var recChanTM%;



'Variables for PlaySound 
'const recTTMaxSpeakers% := 100;
const recDAC0Key$        := "A";
'var recTTSpeakers%[recTTMaxSpeakers%];    ' speaker numbers - each is considered a trial type. Can have duplicates. 
'var recTTAtten[recTTMaxSpeakers%];        ' atten to use for each speaker number in g_spcTTSpeakers%[]
var recTone%                := 0;
var recFreq%                := 20000;
var StimOn;                                ' time of stimulus onset
var PrevStimOn;                            ' time of previous stimulus onset, avoids error if Spike2 code executes faster than sequencer
var UsPerTime;                             ' number of microseconds per sequencer sample period
var TimePerADC;                            ' 
var SecPerSample;                          ' 
var RewOn;                                 ' time of reward onset
var PrevRewOn;                             ' time of previous reward onset, avoids error if Spike2 code executes faster than sequencer


'These variables are unused - not sure if I will need them
'var recTTSpikeCounts%[recTTMaxSpeakers%][recMaxTrials%]; ' spike counts for completed trials on each trial type
'var recTTSpikeRate[recTTMaxSpeakers%][recMaxTrials%];    ' spike rates for completed trials on each trial type
'var recTTSpikeRateMean[recTTMaxSpeakers%];' mean spike rate for each trial type
'var recTTSpikeRateStd[recTTMaxSpeakers%]; ' std dev for above. 
'var recTTIndexBackground%;                 ' index into TT arrays which is the background speaker/atten pair. 


' toolbar button numbers
const recStartButton%         := 1;
const recPauseButton%         := 2;
const recResumeButton%        := 3;
const recSelectNewExptButton% := 4;
const recRewardButton%        := 5;
const recStopButton%          := 6;
const recTimingRewardButton%  := 7;
const recJoystickButton%      := 8;
const recCalibrationButton%   := 9;


' States and state control vars 
var isInterrupt%;
var isEarlyHit%;
var isEarlyFA%;
var recIsPaused%;
const stateStart%                             := 0;
const stateInitializeTrials%                  := 1;
const stateWaitForInitiationMovement%         := 2;
const stateLazyMonkeyTimeout%                 := 3;
const statePreTrialDelay%                     := 4;
const stateStartSoundA%                       := 5;
const stateSoundAPlaying%                     := 6;
const stateISIDelay%                          := 7;
const stateStartSoundB%                       := 8;
const stateSoundBPlaying%                     := 9;
const stateTrainingReward%                    := 10;
const stateInResponseWindow%                  := 11;
const stateHitReward%                         := 12;
const stateFalsePositive%                     := 13;
const stateMissTimeout%                       := 14;
const stateDone%                              := 20;
const stateTDTError%                          := 21;
const stateCodingError%                       := 22;
const stateFAInterrupt%                       := 23;
const stateStartSoundC%                       := 24;
const stateSoundCPlaying%                     := 25;
const stateCRReward%                          := 26;
const stateStartCEDBlink%                     := 27;
const stateCEDBlinking%                       := 28;
const stateTDTBlink%                          := 29;

var recDelayIntervalTime         := 0;
var tNow:=0;		' latest time for which there are values recorded. Used in IdleLoop%
var tStartBlink;    ' used in idle loop
var tLast:=-1;		' last time we checked for a trigger. 
var tLastJoyUpdate; 'last time we updated the joystick
var iState%:=stateStart%;		' present state
var tStateStart:=-1;	' time that present state started. Used to measure wait time, fixation time, etc. 
var tNextTrial;
var isTerminalS1%:=0;    'if trial has terminal S1, logic of state loop must change, so we need to keep track
var RTESDIsPressed%;  'has ReturnToExperimentSelectionDialog button been pressed?
var recLeverState%;
var recLeverTime;   'this is the time of the most recent lever EVENT - one that we are going to record as a hit, etc.
var recLastLever;   'this is the time of the most recent lever change - whether we plan to record it or not
var recPreciseTrialTime;
var recLeverCodes%[4];
var startingNewExpt%;  'only used with joystick, marks beginning of experiment so that joystick events in the past are "forgotten"
var nextStateImmed% := 1;  'when we are changing to a new state, by default we carry to that state immediately instead of waiting for the next idle loop call

'var channels%[4];


'#include "reccreate.s2s"  'functions for creation of stimuli, superceded by reclab_panstim.m


'This is the overarching function which is called by the main (template) file
'This function simply creates the sample configuration, initializes the play wave areas,
'initializes the windows, and initializes the toolbar.  Once the toolbar is started, the 
'remainder of the work is done by the idle function once the toolbar is started.  Breaking
'out of the toolbar will then return control to the (template) file.
func RunGoNoGoEngine%()

    'This variable appears to be completely unused at this time
'    channels%[0] := recTrode1Channel%;
'    channels%[1] := recTrigChannel%;
'    channels%[2] := recLeverChannel%;
'    channels%[3] := 30;
    
    'We do want to start from the start state!
    iState% := stateStart%;
    
    'Set up sampling configuration
    if recCEDIsPresent% = 1 and recCurrentlySampling% = 0 then
        CreateSampleConfiguration();   'CreateSampleConfiguration() is below     TODO: make sure it is OK, fix up .pls file
    endif;
    
    
    ' Initialize PlayWave areas. The call to InitializePlayWaveAreas MUST
    ' come before the call to InitializeWindows -- that's where FileNew() is called. See Spike2
    ' docs for PlayWaveAdd(): PlayWaveAdd must be called before FileNew() for sampling window.
    if recCEDIsPresent% = 1 and recCurrentlySampling% = 0 then 'don't try to initialize a PlayWaveArea if there's no 1401
        InitializePlayWaveAreas();  'InitializePlayWaveAreas() is below 
    endif;
    
    
    'Open XY and data windows
    'Positioned after InitializePlayWaveAreas() because PlayWaveAdd() must be called before FileNew()
    if recCEDIsPresent% = 1 and recCurrentlySampling% = 0 then
        InitializeWindows();           'InitializeWindows() is below, opens one XYwindow and one data sampling window
        
        'For now, cutting out ExtractSpaceInitialize as ExtractSpace is being shelved at least temporarily.
        'Since ExtractSpaceInitialize's main function is to set up an online view of the data plotted in 
        'recXYWindowView%, this will almost certainly be re-established, perhaps shortly.
            'ExtractSpaceInitialize(recXYWindowView%,recNSpeakers%);  'TODO: ExtractSpaceInitialize() is in extract_space_functions, may need to be adapted
        'This function basically does prep to plot a polar plot of activity v. speaker location.  Assumes full circular
        'array, evenly spaced, speaker 0 at top and subsequent speakers clockwise.  Could be adapted for more variable arrays.
    endif;
    

    ' Initialize toolbar. Once Toolbar is called the experiment is controlled by the toolbar
    ' buttons. Toolbar() does not return until one of the toolbar functions returns 0 - Stop%()
    ' does that if pressed, IdleLoop%() returns an iStatus% of 0 when it reaches the end of all trials. 
    ' What is confusing is that although the Toolbar returns, it's not quite dead.  It's still there in
    ' the background (even visible, but grayed out).  I suppose that's the way it is, an exited,
    ' not-running Toolbar can still be seen because at an early step we made it visible.  OK.
    ' However, a crucial step is that when returning to the experiment selection dialog, the Toolbar's 
    ' idle function must be "turned off", or more technically, directed to no function: ( ToolbarSet(0, ""); )
    ' rather than our state-logic idle loop.  That's because the Toolbar remembers things, and when we
    ' start it up again, if it still thinks the idle function is our state-logic loop, it jumps right into 
    ' it.  If we clear that idle function, then only the Start%() function sets the Toolbar idle function 
    ' to our state-logic loop and gets things going.

    InitializeToolbar();
    printlog("Toolbar initialized\n");
    Toolbar("Hit \"Start\" to begin sampling.", 0x3ff);  'Run the toolbar; the experiment will be here most of the time

    
    'once we leave the toolbar, return to calling function
    return recReadyToQuit%;

end






'==========================  Local functions below ===========================================



'''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' CreateSampleConfiguration()
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc CreateSampleConfiguration()
    
	var index;
    var r;
    var i%;
    
    ' Initialize sampling settings
    SampleClear();  'remove any previous sampling settings - shouldn't really do anything, but I seem to be getting a wavemark when I shouldn't be asking for one
	SampleAutoComment(0);  'no automatic prompt for file comments when sampling ends
	SampleAutoCommit(30);  'automatically commit sampling every 30 seconds
    SampleAutoFile(0);     'set auto-filing state to "off"
    'SampleAutoName$("reclab000");  'set file name template
    
    ' Event channel 0 is for sound triggers
    SampleEvent(recTrigChannel%, recTriggerPort%, 2, 10);  'create a level channel to capture triggers, 10 Hz max sustained
    SampleComment$(recTrigChannel%, "Trigger");
    SampleTitle$(recTrigChannel%, "Trigger");
    
    if recUseJoystick% = 0 then
        ' Event channel 1 is for the lever
        SampleEvent(recLeverChannel%, recLeverPort%, 2, 10);  'create a level channel for the lever, 10 Hz max sustained
        SampleTitle$(recLeverChannel%, "Lever");
        SampleComment$(recLeverChannel%, "Lever");
    else
        'create joystick channels
        'X
        SampleWaveform(configJoyXChannel%,configJoyXPort%,5000); 
        SampleComment$(configJoyXChannel%,"JoystikX");
        SampleTitle$(configJoyXChannel%,"JoystikX");
        'Y
        SampleWaveform(configJoyYChannel%,configJoyYPort%,5000); 
        SampleComment$(configJoyYChannel%,"JoystikY");
        SampleTitle$(configJoyYChannel%,"JoystikY");
        'Read joystick offsets
        GetJoystickOffsets(1);  'there is only one joystick type for Recanzone
        'Set additional info for joystick channels, notably offset
        SampleCalibrate(configJoyXChannel%,"volt",1,joystickXOffset);
        SampleCalibrate(configJoyYChannel%,"volt",1,joystickYOffset);
        
        'Create XY view for joystick display
        joyview% := FileNew(12);  'open an XY window
        'Create a new channel in the XY view to display the fixation point
        joydatachan% := XYSetChan(0);
        XRange(-2.5,2.5);  'set XRange
        YRange(-2,-2.5,2.5);  'set YRange, all visible channels
        XYDrawMode(0,5,0);  'turns off automatic axis range mode
        WindowVisible(1);  'make window visible
        'Window(75, 55, 100, 100); 'set to lower 16th of screen
        Window(0, 60, 40, 100); 'trying different position
        XYColour(joydatachan%,16);  'set a colo(u)r for joydatachan%
        XYSize(joydatachan%,-1); 'for channel joydatachan%, plot only one point at a time (-1)
    endif
    
    
    
    ' Text marks
    SampleTextMark(200);  'set channel 30 as TextMark channel, 200 characters, which is max allowed by CED
    recChanTM% := 30;  'That's the TextMark channel
    
    ' Record DAC0 (sound output) only on debug, it will inflate the file sizes...
    if recDebug% = 1 then
        SampleWaveform(recDAC0Channel%, 6, 50000);   'create a 50 kHz channel to record sound output (on testing only)
        SampleTitle$(recDAC0Channel%, "DAC0");
        SampleComment$(recDAC0Channel%, "DAC0");
    endif
    
    
	' Record as many electrodes as specified in Experiment Selection Dialog
    for i% := 1 to recNElectrodes% do  'if recNElectrodes% is 0, this gloriously does nothing with no error!
        docase
        case i% = 1 then
            SampleWaveMark(recTrode1Channel%, 0, 100, 34, 15, 28000); ' chan, ADC port, sustained spike rate, points, pre-trigger, rate
            SampleTitle$(recTrode1Channel%, "Trode 1"); 
            SampleComment$(recTrode1Channel%, "Trode 1");
        case i% = 2 then
            SampleWaveMark(recTrode2Channel%, 1, 100, 34, 15, 28000); ' chan, ADC port, sustained spike rate, points, pre-trigger, rate
            SampleTitle$(recTrode2Channel%, "Trode 2");
            SampleComment$(recTrode2Channel%, "Trode 2");
        case i% = 3 then
            SampleWaveMark(recTrode3Channel%, 2, 100, 34, 15, 28000); ' chan, ADC port, sustained spike rate, points, pre-trigger, rate
            SampleTitle$(recTrode3Channel%, "Trode 3");  
            SampleComment$(recTrode3Channel%, "Trode 3");            
        case i% = 4 then
            SampleWaveMark(recTrode4Channel%, 3, 100, 34, 15, 28000); ' chan, ADC port, sustained spike rate, points, pre-trigger, rate
            SampleTitle$(recTrode4Channel%, "Trode 4"); 
            SampleComment$(recTrode4Channel%, "Trode 4");            
        case i% = 5 then
            SampleWaveMark(recTrode5Channel%, 4, 100, 34, 15, 28000); ' chan, ADC port, sustained spike rate, points, pre-trigger, rate
            SampleTitle$(recTrode5Channel%, "Trode 5"); 
            SampleComment$(recTrode5Channel%, "Trode 5");
        case i% = 6 then
            SampleWaveMark(recTrode6Channel%, 5, 100, 34, 15, 28000); ' chan, ADC port, sustained spike rate, points, pre-trigger, rate
            SampleTitle$(recTrode6Channel%, "Trode 6");
            SampleComment$(recTrode6Channel%, "Trode 6");
        case i% = 7 then
            SampleWaveMark(recTrode7Channel%, 6, 100, 34, 15, 28000); ' chan, ADC port, sustained spike rate, points, pre-trigger, rate
            SampleTitle$(recTrode7Channel%, "Trode 7");   
            SampleComment$(recTrode7Channel%, "Trode 7");
        case i% = 8 then
            SampleWaveMark(recTrode8Channel%, 7, 100, 34, 15, 28000); ' chan, ADC port, sustained spike rate, points, pre-trigger, rate
            SampleTitle$(recTrode8Channel%, "Trode 8");
            SampleComment$(recTrode8Channel%, "Trode 8");
        case i% = 9 then
            SampleWaveMark(recTrode9Channel%, 8, 100, 34, 15, 28000); ' chan, ADC port, sustained spike rate, points, pre-trigger, rate
            SampleTitle$(recTrode9Channel%, "Trode 9"); 
            SampleComment$(recTrode9Channel%, "Trode 9");            
        case i% = 10 then
            SampleWaveMark(recTrode10Channel%, 9, 100, 34, 15, 28000); ' chan, ADC port, sustained spike rate, points, pre-trigger, rate
            SampleTitle$(recTrode10Channel%, "Trode 10");
            SampleComment$(recTrode10Channel%, "Trode 10");            
        endcase;        
    next;
    'Note that the sample rate is strange (28 kHz) and 34 samples covers about 1.25 ms.  These are exactly the Usrey lab conventions, so whatevs.
    
    
    ' Set optimise mode (do this last). Settings specific to Power1401 625 (that's the "5"). 
    ' The second arg groups channels with same ideal rates together so they all get same 
    ' actual rate. That means multiple electrodes (if used) will all get same actual rate, 
    ' assuming you use same ideal rate (in SampleWavemark()). 
    
    printlog("PLS file load success is %d\n",SampleSequencer(script$ + "recgen.pls")+1); 'Load sample sequencer
    
	SampleOptimise(2, 1, 5, 2, 50);  'Optimization settings, don't change unless there's an issue
    SampleMode(1);  'Continuous recording
end




'''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' InitializeWindows()
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc InitializeWindows()
    
    ' Since we are opening files here, set the path. 
    FilePathSet(data$, 1, 1);  'Sets path for new data files
    
    ' Open xy window for use in online display
    'Currently disabled because ExtractSpaceInitialize etc. are disabled, so it does nothing.  May
    'need to be brought back online earlier than ExtractSpace!
    'recXYWindowView% := FileNew(12);
	'Window(0, 50, 50, 100); 
	'View(recXYWindowView%).WindowVisible(1);
    
	'Open the data sampling window -- only if CED is present!
    if recCEDIsPresent% = 1 then
        recDataWindowView% := FileNew(0,4);
        Window(0, 0, 100, 50); 
        View(recDataWindowView%).WindowVisible(1);
        
        if recUseJoystick% = 0 then
            ' Create a memory channel for the debounced lever information
            recMemChanLeverDebounce% := MemChan(8,25); 'Create textmark channel for debounced lever with attached lever value, 25 characters
            ChanTitle$(recMemChanLeverDebounce%,"DBLever");  'Give it a title
            chanshow(recMemChanLeverDebounce%);  'Show it
        else
            CreateJoystickChannels%();
        endif;
        
    endif
    
end;




'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' InitializeToolbar - prepare toolbar buttons. Note that the idle processing function 
' (ToolbarSet(0, blah, blah)) is not set here. That's done when the user hits the start 
' button.
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc InitializeToolbar()
    
	View(App(8)).WindowVisible(0);	'Hide the standard sample bar
	ToolbarVisible(1);
	ToolbarSet(recStartButton%, "Start", Start%);
	ToolbarSet(recPauseButton%, "Pause", Pause%);
	ToolbarSet(recResumeButton%, "Resume", Resume%);
    ToolbarSet(recSelectNewExptButton%, "New Expt.", PrepToReturnToExptSelectDialog%);
	ToolbarSet(recRewardButton%, "Reward", Reward%);
    ToolbarSet(recStopButton%, "Stop Sampling", Stop%);
    Toolbarset(recTimingRewardButton%, "Timing/Reward", CallTimingReward%);
    Toolbarset(recJoystickButton%, "Joystick", CallJoystick%);
    ToolbarSet(recCalibrationButton%, "Joystick Calibration", CalibrateJoystick%);  'automatic joystick calibration - make sure power is on to joystick
    
    ' Explicitly set enabled state of things...
    ToolbarEnable(recStartButton%, 1);
    ToolbarEnable(recPauseButton%, 0);
    ToolbarEnable(recResumeButton%, 0);
    ToolbarEnable(recSelectNewExptButton%, 1);
    ToolbarEnable(recRewardButton%, 1);
    ToolbarEnable(recStopButton%, 0);
    ToolbarEnable(recTimingRewardButton%, 0);
    ToolbarEnable(recJoystickButton%, 0);
    ToolbarEnable(recCalibrationButton%, 1);
    
end;

    


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' GetPlayWaveKey$(index%)
' 
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func GetPlayWaveKey$(index%)
    
    return Chr$(Asc(recDAC0Key$)+index%);
    
end




'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' InitializePlayWaveAreas - add play wave areas for sounds. 
' Areas will be allocated in order: "A", "B", .... up to the
' max number of stimuli per trial.  We will reload each
' PlayWaveArea on a trial-by-trial basis, if necessary.
' Currently, the max number of stimuli per trial is hardcoded at 10
' 
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Proc InitializePlayWaveAreas()
    var st;
    var i%;

        
    for i% := 0 to recMaxPWA%-1 do

        st := PlayWaveAdd(GetPlayWaveKey$(i%), GetPlayWaveKey$(i%), recDAC0%, recPlayRateHz, recMaxPoints%);
        if st < 0 then
            Message("Error in PlayWaveAdd for area " + GetPlayWaveKey$(i%));
            halt;
        else
            PlayWaveTrigger(GetPlayWaveKey$(i%), 1);  'set playwave area to triggered mode
        endif        
        
    next
          
end





'----------------- PlaySound ---------------------------------------------------------------
'
' PlaySound plays the sound for the trial number in recTrialOrder%[recCurrentTrial%].
' It sets the correct speaker and PA4 attenuation and logs a SampleText detailing the stimulus.
'
'-------------------------------------------------------------------------------------------

Func PlaySound%(isS2%)
    var atten;
    var calatten;
    var trlatten;
    var s$;
    var playChar$;
    var spkr%;
    var playInd%;
    var status%;
    var isS2$;
    var thisStim%;  'this is the index of the physical stimulus (re: stim file list or stim properties list)
    var thisPWAIndex%;  'this is the PWA it will be found in on this trial
        
    'Get index of current trial
    playInd% := recTrialOrder%[recCurrentTrial%-1];  'recCurrentTrial is in human units, convert to index units
    
    'Note that recStimCount% (which steps us through the n S1s and S2, if present, is incremented 
    'in StimComplete% and reset to zero in PrepareNewTrial%.
    
    'Get this PWA index
    thisPWAIndex% := recPWAList%[recStimCount%][playInd%];
    
    'Get this stimulus index
    thisStim% := recStimList%[thisPWAIndex%][playInd%];
    
    'Get play wave area with current stimulus
    'playChar$ := GetPlayWaveKey$(recStimCount%);  
    playChar$ := GetPlayWaveKey$(thisPWAIndex%);
    
    'Get speaker for current stimulus
    spkr% := recSpeakerList%[thisPWAIndex%][playInd%];
    
    'Get calibrating attenuation for current stimulus - this is the value to set a stimulus to 65 dB, by definition
    if recMatGenStim% = 0 then
        calatten := recTrialStimCal[thisStim%][spkr%-1];  'I think we have to label speakers 1:N, not 0:N-1, so adjusting that here
        'calatten := recAttenList%[recStimCount%][playInd%];  'value originally read from file
        'calatten := recAttenList%[thisStim%][playInd%];  'value originally read from file
    else
        'calatten := recGeneratedAtten[recStimCount%];  'value created at time of stimulus generation
        calatten := recGeneratedAtten[thisPWAIndex%];  'value created at time of stimulus generation
    endif;
    
    'Get trial-based attenuation for current stimulus
    trlatten := recDeltadBList[recStimCount%][playInd%];  'corresponds to recPWAList%[][], index the same way
    
    'Get total attenuation
    atten := calatten + trlatten;
    
    'Set some attenuation (30 db) during testing, just for the sake of our ears.
    'Once reclab_panstim starts returning a value here, we're in business
    'For now, don't set any attenuation if there is trial-based (e.g. intensity tuning) because
    'it would be useful to hear that.  If those are too loud, drop the atten=0 part and just dump
    '30 dB during the debug phase.  Might want to comment this all out once we're up and running
    'if atten = 0 and recDebug% = 1 then
    if recCalibIsPresent% = 0 then
        if recSearchStimType% = 3 then
            atten := 0;  'for clicks, don't attenuate
        else
            'atten := rand(4,30);  'To check that the PA4 is working properly, let's just set a new value every time
            atten := 30;  'temporary, during calibrations
        endif;
    endif;
    
    
    ' Set speaker and atten
    if recCEDIsPresent% = 1 then
        status% := recSpeaker%(spkr%);
        if status% <> 0 then
            return status%;
        endif;
          
        status% := recAtten%(atten);
        if status% <> 0 then
            return status%;
        endif;  
    endif;
    
    'This may not be terribly useful, stimulus ID might be helpful as well - but it's just a log and the sampletext is later
    'use trlatten for attenuation because calibrating attenuation isn't informative
    RecLogStatus("PlaySound", "SPK " + str$(spkr%) + " ATT " + str$(trlatten) + "\n");
    

    if recCEDIsPresent% = 1 then
        
        ' Send sample key for the play wave area. Sequencer Variable 3 holds the number of clock ticks at presentation
        SafeSampleKey(playChar$);
        
        StimOn := SampleSeqVar(3)*UsPerTime/1000000;  'Now, StimOn holds actual presentation time, usually
        while StimOn = PrevStimOn do  'This will happen if the above line occurs before the stim starts
            yield(.001,1023);  'yield a millisecond until the stimulus starts playing
            StimOn := SampleSeqVar(3)*UsPerTime/1000000;  'Keep checking until StimOn is updated
        wend;          
        PrevStimOn := StimOn;  'keep track of most recent StimOn
        
        'determine S1/S2 status
        docase
        case isS2% = 0 then
            isS2$ := "S1";   'indicates non-terminal S1, trial continues on CR, trial terminates on FA
        case isS2% = 1 then
            isS2$ := "S2";   'Indicates S2, trial terminates on H/M, will be rewarded for H
        case iss2% = 2 then
            isS2$ := "S1T";  'indicates terminal S1, trial terminates on CR/FA, will be rewarded for CR
        endcase
        
        'write stimulus to sampletext, we need to separate this out based on experiment type
        ' The sample text string contains the following (comma-separated) fields:
        ' 1. playChar: A for first stimulus in a trial, B for second, etc., up to J.
        ' 2. time: time of onset of stimulus
        ' 2. trial number: overall trial counter
        ' 3. speaker number
        ' 4. trial-based attenuation
        ' 5. freq for tone, filename for loaded stims.  (what's most appropriate for generated stims?) 
        '    this is actually a big question.  I think I'll want to have a function that simply determines 
        '    what the best "english" translation of the stimulus is...
        
        docase
        case recMatGenStim% = 0 then 'stimuli are read from a file
            's$ := Print$("\"%s\",%s,%d,%d,%.1f,\"%s\"", playChar$, isS2$, recCurrentTrial%, spkr%, trlatten, recTrialLoadLoc$[recPWAList%[recStimCount%][playInd%]]);
            s$ := Print$("\"%s\",%f,%s,%d,%d,%.1f,\"%s\"", playChar$, StimOn, isS2$, recCurrentTrial%, spkr%, trlatten, recTrialLoadLoc$[thisStim%]);
            SampleText(s$);
        case recMatGenStim% = 1 then 'stimuli are generated
            's$ := Print$("\"%s\",%s,%d,%d,%.1f,\"%s\"", playChar$, isS2$, recCurrentTrial%, spkr%, trlatten, NameThatStimulus$(recPWAList%[recStimCount%][playInd%]));
            s$ := Print$("\"%s\",%f,%s,%d,%d,%.1f,\"%s\"", playChar$, StimOn, isS2$, recCurrentTrial%, spkr%, trlatten, NameThatStimulus$(thisStim%));
            SampleText(s$);
        endcase
        
    endif
    
    'Calculate the duration in points of the stimulus
    'recPlayPoints% := recPlayRateHz*recTrialDur[recPWAList%[recStimCount%][playInd%]]/1000;  'recTrialDur is in ms   
    recPlayPoints% := recPlayRateHz*recTrialDur[thisStim%]/1000;  'recTrialDur is in ms     
    
    return status%;
end





'----------- StimComplete%(isS2%, success%) -------------------------------------
'
' Stim has ended. isS2% tells StimComplete% whether the just-finished stimulus 
' is an S1 (0), S2 (1), or terminal S1 (2). 
' success% tells the function whether the response was successful: 1=good, 0=bad.
' (Success on an S1 is no response, success on an S2 is response)
' Records text marker, does an analysis update using ExtractSpace. 
'
' A return value of -1 means an error has occurred, abort. 
' When isS2%=0, return value of 0 means continue with S1 stims, return value of 1
' means move on to terminal S2 stim, return value of 2 means move on to terminal S1 stim.
' When isS2%=1 the return value (unless it is negative) is ignored, but is set to 0, because
' the next stimulus will be an S1.
'
'--------------------------------------------------------------------------------

'Note that on 0,0 input, the current trial counter will be decremented and the interrupted trial will be shuffled in later.

func StimComplete%(isS2%, success%)
    var status% := 0;
    var strtmp$;
    var stimInd%;
    var termInd%;
    var now;
    
    'Get index of current trial
    stimInd% := recTrialOrder%[recCurrentTrial%-1];  'recCurrentTrial is in human units, convert to index units
    docase
    case isS2% = 0 then  'stimulus is S1, not terminal
        if success% = 1 then
            ' Record completed stim here, and update online analysis. 
            ' This will print the same output, e.g. "E,234" for each non-terminal S1 in trial 234, so there may be multiple sampletexts with the same entry
            strtmp$ := Print$("E,%d", recCurrentTrial%);  'E is for, I dunno, Early Correct Rejection?  (Keeping 'E' from original code)
            SampleText(strtmp$, recPreciseTrialTime);
            
            'Increment within-trial stimulus counter, if we've played all the S1s, return 1 if playing the S2 or 2 if playing a terminal S1
            recStimCount% += 1;
            termInd% := recTrialTerminalIndex%[stimInd%];  'terminal index
            if termInd% = recStimCount% then 'if the next stimulus is the terminal stimulus
                if recTrialTerminalIsS2%[stimInd%] = 1 then 'terminal stimulus is a target
                    status% := 1;  'return indicates S2 is next
                else
                    status% := 2;  'return indicates terminal S1 is next
                endif;
                'otherwise, return is 0 indicating non-terminal S1
            endif;
        else 'false alarm on S1
            'trial counter will be decremented in the idle loop
            strtmp$ := Print$("F,%d", recCurrentTrial%);  'F is for False Alarm, there is fundamentally no difference between an early FA and a terminal FA - the monkey doesn't know
            SampleText(strtmp$, recPreciseTrialTime);
            status% := 0;  'After FA, we will indicate the next stimulus is an S1, as it will be.
        endif
    case isS2% = 1 then  'If it's an S2 (target)
            if success% = 1 then
                strtmp$ := Print$("H,%d", recCurrentTrial%);  'H is for Hit
                SampleText(strtmp$, recPreciseTrialTime);
            else
                strtmp$ := Print$("M,%d", recCurrentTrial%);  'M is for Miss
                SampleText(strtmp$, recPreciseTrialTime);
        endif;
        status% := 0;  'After S2, we will indicate the next stimulus is an S1, as it will be.
    case isS2% = 2 then 'If it's a terminal S1 (intended no-response)
            if success% = 1 then
                strtmp$ := Print$("C,%d", recCurrentTrial%);  'C is for Correct Rejection, trial is over (This code is new, all other codes are old)
                SampleText(strtmp$, recPreciseTrialTime);
            else
                strtmp$ := Print$("F,%d", recCurrentTrial%);  'F is for False Alarm, there is fundamentally no difference between an early FA and a terminal FA - the monkey doesn't know
                SampleText(strtmp$, recPreciseTrialTime);
            endif;
        status% := 0;  'After S2, we will indicate the next stimulus is an S1, as it will be.
    else
        RecLogError("StimComplete", "Unknown ttype (" + str$(isS2%) + ")");
        status% := -1;
    endcase
    return status%;
    
    'TODO Figure out this ExtractSpace bit.  Doesn't look like recHBeh%/recHBak% handles are made...
    'All right, as regards the ExtractSpace stuff: For now, we're going to shelve this in order to
    'move forward.  The essential idea is that we can (and perhaps don't have to) create output files
    'on the fly for ease of Recanzone analysis.  In the past (i.e. the original ExtractSpace) these
    'files were designed to comport with longstanding Recanzone analysis.  This is probably no longer
    'necessary.  If such output files are needed, we can make them, but for now we'll leave it out and
    'later determine what is necessary.
    'if recCEDIsPresent% = 1 then
        'now := MaxTime();
        'First 4 arguments kosher, checking remaining.  Now last 4 OK.  Args 5-7 are unassigned.
        'ExtractSpace(recTLastProcessed, now, recDataWindowView%, recXYWindowView%, recHBeh%, recHBak%, recChanWM%, recChanTM%, recTrigChannel%, recLeverChannel%, recNSpeakers%);
        'recTLastProcessed := now;
    'endif
            
    'I'm kind of assuming this went with ExtractSpace
    'UpdateOnlineAnalysis();  'It was commented out when I found it.    
    
    
end





'''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' Start%()
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Start%()
    
    ' Disable start button, enable stop and pause
    
    ToolbarEnable(recStartButton%, 0);
    ToolbarEnable(recStopButton%, 1);
    ToolbarEnable(recPauseButton%, 1);
    ToolbarEnable(recTimingRewardButton%, 1);
    ToolbarEnable(recJoystickButton%, 1);
    
    ' Start the sampling.
    docase    
    case recCEDIsPresent% = 1 and recCurrentlySampling% = 0 then
        SampleStart();
        ToolbarText("Sampling started.");  ' Tell the world about it. 
        printlog("Sampling started\n");  ' Tell her about it, tell her everything you feel
        recCurrentlySampling% := 1;  'don't start sampling again
        TimePerADC := SampleTimePerAdc();  'get AD conversion rate
        UsPerTime := SampleUsPerTime();  'get # of microseconds per sample
        SecPerSample := TimePerADC*UsPerTime/1000000; 'get seconds per sample
        SampleText(recExptText$);  'put in the experiment type
        startingNewExpt% := 1;  'this allows a reset of joystick event checking
    case recCEDIsPresent% = 0 and recCurrentlySampling% = 0 then
        'virtually start sampling
        recCurrentlySampling% := 1;
        printlog("Sampling started\n");  ' Tell her about it, tell her everything you feel
        SampleText(recExptText$);  'put in the experiment type
        startingNewExpt% := 1;  'this allows a reset of joystick event checking
    endcase
    
    ' Set idle function
    ToolbarSet(0, "", IdleLoop%);
    
    return 1;
end





'''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' Stop%() - stops sampling
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Stop%()
    PrintLog("Stop called\n");
    
    recCurrentlySampling% := 0;    
    
    ' Stop sampling....
    if SampleStatus() <> -1 then
        if useTDTforLever% = 0 then
            SampleKey("S");  'Kill blink sequence, if one exists
        endif;
        if useTDTforJuicer% = 0 then
            SafeSampleKey("K");  'Kill reward, just in case, only relevant if CED is being used
        endif;        
        SampleStop();
        FileSaveAs(recFileSaveLoc$ + recMonkPrefix$ + ".smr", -1); 'Save data file automagically 
    endif

    ' Returning zero from here any ToolbarSet() functions causes the 
    ' Toolbar() function to return.
    recReadyToQuit% := 1;  'prevent from trying to open another experiment
    return 0;
    
end



'''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' PrepToReturnToExptSelectDialog%() - sets idle loop to return
' to experiment selection dialog when the current trial is complete
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func PrepToReturnToExptSelectDialog%()
    RTESDIsPressed% := 1;
end;


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' ReturnToExptSelectDialog%() - continues sampling, but opens expt. selection dialog
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func ReturnToExptSelectDialog%()
    PrintLog("Return to Expt. Selection Dialog called\n"); 
    
    'Reset appropriate variables
    recCurrentTrial% := 0;  'start with trial #1
    recSearchLoaded% := 0;  'Need to reset recSearchLoaded, or load will be skipped even for non-search scenarios
    RTESDIsPressed% := 0;
    recExptText$ := "";
    
    'Unset the idle function, so things don't start moving immediately when the Toolbar is next called
    ToolbarSet(0, "");
    
    ' This causes the Toolbar() to return
    return 0;

end


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' Pause%()
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Pause%()
    PrintLog("Pause called\n");
    recIsPaused% := 1;
    ToolbarEnable(recResumeButton%, 1);
    ToolbarEnable(recPauseButton%, 0);
    return 1;
end






'''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' Resume%()
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Resume%()
    PrintLog("Resume called\n");
    recIsPaused% := 0;
    ToolbarEnable(recResumeButton%, 0);
    ToolbarEnable(recPauseButton%, 1);
    return 1;
end





'''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' CallTimingReward%()
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func CallTimingReward%()
    PrintLog("Pause called to bring up Timing/Reward Dialog\n");
    recIsPaused% := 1;
    recRunTimeCall% := 1;
    recWhichDialogCalled% := 1;  '1 is for timing/reward
    'Don't let nobody do nothing! (start and resume are already disabled)
    ToolbarEnable(recPauseButton%, 0);
    ToolbarEnable(recSelectNewExptButton%, 0);
    ToolbarEnable(recRewardButton%, 0);
    ToolbarEnable(recStopButton%, 0);
    ToolbarEnable(recTimingRewardButton%, 0);
    ToolbarEnable(recJoystickButton%, 0);
    return 1;
end





'''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' CallJoystick%()
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func CallJoystick%()
    PrintLog("Pause called to bring up Joystick Properties Dialog\n");
    recIsPaused% := 1;
    recRunTimeCall% := 1;
    recWhichDialogCalled% := 2;  '2 is for joystick
    'Don't let nobody do nothing! (start and resume are already disabled)
    ToolbarEnable(recPauseButton%, 0);
    ToolbarEnable(recSelectNewExptButton%, 0);
    ToolbarEnable(recRewardButton%, 0);
    ToolbarEnable(recStopButton%, 0);
    ToolbarEnable(recTimingRewardButton%, 0);
    ToolbarEnable(recJoystickButton%, 0);
    return 1;
end



'''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' ReturnFromDialogCall%()
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func ReturnFromDialogCall%()
    recRunTimeCall% := 0;  'reset RunTimeCall
    recIsPaused% := 0;  'set it free
    recWhichDialogCalled% := 0;  'no dialog called anymore
    'reenable appropriate buttons
    ToolbarEnable(recPauseButton%, 1);
    ToolbarEnable(recSelectNewExptButton%, 1);
    ToolbarEnable(recRewardButton%, 1);
    ToolbarEnable(recStopButton%, 1);
    ToolbarEnable(recTimingRewardButton%, 1);
    ToolbarEnable(recJoystickButton%, 1);
    return 1;
end




'''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' Reward%()
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Reward%()
    ' This function is now used for all reward!
    var stmp%;
    var tStart;
    var tNow;
    var data%[10];  'oversized for readTDTreply%
    var temp%;
    var s;
    
    stmp% := recReward%(recRewardMs%,useTDTforJuicer%);  'for TDT or CED
    
    'If we're using the TDT, we really ought to check for succesful completion before moving forward (CED has SafeSampleKey)
    if useTDTforJuicer% = 1 then
        'have to wait for juicer to stop, keep looking for TDT return on serial port until then.
        stmp% := -1;  'by default, assume failure
        s := recRewardMs%;  'get non-integer version of reward duration
        s := (s/1000) + 0.2;  'convert to seconds of expected reward, give 200 ms of slop
        if SampleStatus() = 2 then  'if we are currently sampling, use MaxTime()
            tStart := View(recDataWindowView%).MaxTime();  'this is the time that the reward command was sent, roughly
            while tNow < tStart + s do  'integer < float operation is OK
                temp% := readTDTReply%(data%[]);
                if temp% = -1 then 'if TDT has not yet put data onto the serial port
                    tNow := View(recDataWindowView%).MaxTime();  'fill tNow with current clock time
                    yield(.01);
                else
                    tNow := tStart + s + 1000;  'that'll break the loop
                    stmp% := 0;
                endif;
            wend;
        else 'This could happen because the reward button is enabled pre-sampling, but it's very rough (in seconds)
            'Please note that this function WILL FAIL if the reward delivery begins before midnight and ends after midnight.
            var tStart%;
            var tNow%;
            TimeDate(tStart%); 'get current clock time in seconds
            tStart := tStart%;  'get non-integer version
            while tNow% < tStart + s do  'integer < float operation is OK
                temp% := readTDTReply%(data%[]);
                if temp% = -1 then 'if TDT has not yet put data onto the serial port
                    TimeDate(tNow%);  'fill tNow% with current clock time
                    yield(.01);
                else
                    tNow% := tStart + s + 1000;  'that'll break the loop, tStart + s will be floored but no biggie
                    stmp% := 0;
                endif;
            wend;
        endif;    
    endif;
    return stmp%;  'return 0 on success
end





''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' 
' ChangeStateTo
' 
' Call this function on exit from a state. The var stateTo% should be the state to enter
' on the next call to the loop function. 
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc ChangeStateTo(stateTo%)
	iState% := stateTo%;
    nextStateImmed% := 1;  'nothing to wait for
    if recCEDIsPresent% = 1 then
        tStateStart := MaxTime();
    else
        tStateStart := tNow;
    endif
end;





''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' 
' RecLogStatus
' 
' Utility to write msg to log window. Will not write if rgDebug is not set. 
' Like 
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc RecLogStatus(stateName$, msg$)
    if recDebug% = 1 then
        PrintLog("S:    " + stateName$ + "  Tstart: " + str$(tStateStart) + " " + msg$ + "\n");
    endif
end





''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' 
' RecLogError
' 
' Like RecLogStatus, a utility to write msg to log window. 
' Unlike RecLogStatus, RecLogError will write no matter what - regardless of rgDebug value.
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc RecLogError(stateName$, msg$)
    PrintLog("ERROR===============================================\n");
    if stateName$ = "" then
        PrintLog(msg$ + "\n");
    else
        PrintLog("S:    " + stateName$ + "  Tstart: " + str$(tStateStart) + " " + msg$ + "\n");
    endif
    PrintLog("====================================================\n");
end





''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' 
' RecLogInfo
' 
' Like RecLogStatus, a utility to write msg to log window. 
' Unlike RecLogStatus, RecLogInfo will write no matter what - regardless of rgDebug value.
' Although as of 5/24/2012 it's not ever used.  Oh well.
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc RecLogInfo(msg$)
    PrintLog("INFO " + msg$ + "\n");
end










'------- PrepareNextTrial% --------------------------------------------------------
' 
' Called prior to initiating a set of S1/S2 stimuli. 
' Return 1 if all is well, 0 if all trials are done, negative for error. 
'
' This is the place to get a list of stimuli to run and load Play Wave areas as needed. 
' All stuff (like loading stimuli) which will be too costly time-wise to do while a 
' trial is running should be done here. 


func PrepareNextTrial%(dontLoadPWAs%)
    var i%;
    var ind%;
    var thisSpkr%;
    var thisTrial%;
    var thisPWA%;
    var nread%:= 0;  'looks unused but won't hurt
    var file$;
    var fh%;
    var statement$;
    var pwChar$;
    var matPutOK% := 0;
    var ok% := 1;  'by default, return 1 (success)

    
    ' Check to see if we are done
    if recCurrentTrial% >= recNTrials% then
        return 0;  'end the sequence
    endif;
    
    ' Get index of current trial
    thisTrial% :=  recTrialOrder%[recCurrentTrial%];  'recCurrentTrial is an index, BUT it hasn't been incremented yet, so don't subtract 1
    
    
    
    ' Put current trial sequence into log file
    if recDebug% = 1 then
        printlog("recCurrentTrial is %d\n",recCurrentTrial%);
        printlog("thisTrial is %d\n",thisTrial%);
        PrintLog("Trial #%d, TrialList ",recCurrentTrial%+1);
        printlog("Terminal index is %d\n",recTrialTerminalIndex%[thisTrial%]);
        PrintLog("Stims: ");
        for i% := 0 to recTrialTerminalIndex%[thisTrial%] do
            ' Get current PWA
            thisPWA% := recPWAList%[i%][thisTrial%];
            ' Print stmulus number
            PrintLog(str$(recStimList%[thisPWA%][thisTrial%]) + " ");
            next
        PrintLog("\nPWAs: ");
        for i% := 0 to recTrialTerminalIndex%[thisTrial%] do
            ' Get current PWA
            thisPWA% := recPWAList%[i%][thisTrial%];
            ' Print PWA number
            PrintLog(str$(thisPWA%) + " ");
            next
        PrintLog("\n");
    endif
    
    
    if dontLoadPWAs% = 0 then
        ' Generate/Load stimuli and put them into PlayWaveAreas
        'for i% := 0 to recTrialTerminalIndex%[thisTrial%] do
        for i% := 0 to recNUniqueStims%[thisTrial%]-1 do
            'Get play wave area for current stimulus
            pwChar$ := GetPlayWaveKey$(i%); 
            
            'get index of trial
            ind% := recStimList%[i%][thisTrial%];
            
            'get speaker of trial
            thisSpkr% := recSpeakerList%[i%][thisTrial%];
                
            'Set recStimTransfer%[] to zeros
            arrconst(recStimTransfer%[],0);  
            
            docase
            case recMatGenStim% = 1 and recMatlabIsPresent% = 0 and recCEDIsPresent% = 0 then  'this is testing
                'don't do anything, just pretend all is OK
            case recMatGenStim% = 1 and recMatlabIsPresent% = 0 and recCEDIsPresent% = 1 then  'this is a boo-boo
                message("Holy crap, I can't generate the stimulus because you said there's no Matlab!");
                recReadyToQuit% := 1;  'This will allow the entire thing to quit
                if useTDTforLever% = 1 then  'turn off LED
                    recTDTLEDOff%();
                else
                    SafeSampleKey("M");
                endif;
                Stop%();
                return -1;
            case recMatGenStim% = 1 and recSearchStimType% <> 3 then  'Generate stimuli using Matlab - even something CED can do like tones.  Just easier to be consistent.
                'opening a figure is slow, but everything else looks fast.  I can't quite ID exactly how long these things take
                'because things look like they happen in about 15-ms increments as far as CED's "Seconds()" command is concerned.
                'Needless to say, you can operate several commands (put, get, eval) without any time elapsing, then 15 ms for a
                'similar command.  Whether that's OS time or just clock precision I don't know.  What I do know is that under optimal
                'conditions you can put and get a 100000-element float in essentially 0 time, and maximally 15 ms.  So in principle as
                'long as the Matlab commands to eval are quick, we shouldn't worry about the time to do up to 10 "gets".  If we can
                'cleverly have all of them come simultaneously (i.e. a 2-d array of stimuli), that's cool too.  May not be necessary.
                
                matPutOK% := matPutOK% + PutMatlabValueFloat%("fs",recPlayRateHz);  'on any fail, matPutOK% will increment (negative ones)
                matPutOK% := matPutOK% + PutMatlabValueFloat%("dur",recTrialDur[ind%]);  'size of trial is variable, that's OK
                matPutOK% := matPutOK% + PutMatlabValueFloat%("lohz",recTrialGenLowpassHz[ind%]);  'Value of lowpass Hz or tone freq will be correctly interpreted by Matlab
                matPutOK% := matPutOK% + PutMatlabValueFloat%("hihz",recTrialGenHighpassHz[ind%]);  'Ditto
                matPutOK% := matPutOK% + PutMatlabValueFloat%("issweep",recTrialGenIsSweep%[ind%]);
                matPutOK% := matPutOK% + PutMatlabValueFloat%("amfreq",recTrialGenAMFreqHz[ind%]);
                matPutOK% := matPutOK% + PutMatlabValueFloat%("amdepth",recTrialGenAMDepthPct[ind%]);
                matPutOK% := matPutOK% + PutMatlabValueFloat%("amphase",recTrialGenAMPhaseDeg[ind%]);
                matPutOK% := matPutOK% + PutMatlabValueFloat%("tonephase",recTrialGenTonePhaseDeg[ind%]);
                matPutOK% := matPutOK% + PutMatlabValueFloat%("gauss",recTrialGenGauss%[ind%]);  
                matPutOK% := matPutOK% + PutMatlabValueFloat%("ramp",recTrialGenRampMS[ind%]);
                matPutOK% := matPutOK% + PutMatlabValueInt%("seed",recTrialGenSeed%[ind%]);  
                matPutOK% := matPutOK% + PutMatlabValueInt%("pad",recMaxPoints%);
                matPutOK% := matPutOK% + PutMatlabValueInt%("spk",thisSpkr%);
                
                if matPutOK% < 0 then 'error in at least one matlab put operation - not sure what to do (try again, quit?)
                    message("There has been an error in sending data to Matlab!  Quitting!");
                    recReadyToQuit% := 1;  'This will allow the entire thing to quit
                    if useTDTforLever% = 1 then  'turn off LED
                        recTDTLEDOff%();
                    else
                        SafeSampleKey("M");
                    endif;
                    Stop%();
                    return -1;
                endif;
                
                'Ask Matlab to create the stimulus - reclab_panstim can make just about anything
                'NOTE THAT WITHOUT THE CALIB VARIABLE, THE FULL STATEMENT DOES NOT WORK PROPERLY
                'USE THE TRUNCATED STATEMENT WITH NO CALIB UNTIL CALIBRATION IS IMPLEMENTED
                if recCalibIsPresent% = 1 then
                    statement$ := "[stimulus atten65 seed] = reclab_panstim(dur,fs,lohz,hihz,issweep,amfreq,amdepth,amphase,tonephase,gauss,ramp,seed,pad,AFFT(1,spk));";  'this is for the FFT filtering method
                    'statement$ := "[stimulus atten65 seed] = reclab_panstim(dur,fs,lohz,hihz,issweep,amfreq,amdepth,amphase,tonephase,gauss,ramp,seed,pad,AFilt(1,spk));";  'this is for the standard filtering method
                else
                    statement$ := "[stimulus atten65 seed] = reclab_panstim(dur,fs,lohz,hihz,issweep,amfreq,amdepth,amphase,tonephase,gauss,ramp,seed,pad);";
                endif;
                EvalMatlabStatement%(statement$);
                'printlog("%s\n",statement$);
                'printlog("Values are %d %d %d %d ",recTrialDur[ind%],recPlayRateHz,recTrialGenLowpassHz[ind%],recTrialGenHighpassHz[ind%]);
                'printlog("%d %d %d %d %d ",recTrialGenIsSweep%[ind%],recTrialGenAMFreqHz[ind%],recTrialGenAMDepthPct[ind%],recTrialGenAMPhaseDeg[ind%],recTrialGenTonePhaseDeg[ind%]);
                'printlog("%d %d %d %d %d \n",recTrialGenGauss%[ind%],recTrialGenRampMS[ind%],recTrialGenSeed%[ind%],recMaxPoints%,thisSpkr%);
            
            
                'Get the stimulus and the seed back from Matlab
                GetMatlabValueIntArray%("stimulus",recStimTransfer%[]);
                GetMatlabValueFloat%("atten65",recGeneratedAtten[i%]);
                GetMatlabValueInt%("seed",recCurrRandomSeed%[i%]);  'put current random seed into variable for NameThatStimulus
            
                'printlog("gen values are %d\n",recStimTransfer%[4000:50]);   
            
                'Note that loading the filter coefficients for each speaker on each call would be a time-waster.
                'Instead, we will load up CALIB into the Matlab workspace as the experiment begins, and the call
                'to RECLAB_PANSTIM above will use that CALIB variable (indexed by the speaker).
                
            case recMatGenStim% = 1 and recSearchStimType% = 3 then  'Clicks - matlab is not set up to generate these
                
            recStimTransfer%[1] := 32767;  'make the second element (2^15)-1, then everything else 0 - that's a click
            'arrconst(recStimTransfer%[3:500],30000);
            'printlog("click values are %d\n",recStimTransfer%[0:20]); 
            
            else  'Load stimuli from file
                
                'get filename
                file$ := recTrialLoadLoc$[ind%];
                
                'open current stimulus
                fh%:=fileopen(file$,9,0);
                if fh%<0 then
                    message("Warning Message | failed to load the stimulus waveform!");
                    printlog("Quitting because the Stim waveform %s failed to load!\n",file$);
                    Stop%();
                    return -1;
                endif;
                
                'reads fh% two bytes at a time, puts in recStimTransfer%[]
                nread%:=breadsize(2,recStimTransfer%[]); 
                
                'close current stimulus
                fileclose();  'close fh%
                
            endcase;
            
            'Finally, place the stimulus into the appropriate Play Wave Area
            if recCEDIsPresent% = 1 then
                PlayWaveCopy(pwChar$, recStimTransfer%[]);  'recStimTransfer% is an integer array and as such should be signed 16 bit integers
            endif;
            
        next;
    endif;


    recStimCount% := 0;  'Reset stim count
    return ok%;
    
end





'''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' IdleLoop%()
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func IdleLoop%()
	var iStatus% := 1;	' this is return value. value of 1 (0) continues (stops) processing
    var stmp%;
    var isS2%;
    var strtmp$;
    var isPlaying%;
    var PWA$;
    var s$;
    
    nextStateImmed% := 1;  'obviously we run the damn thing the FIRST time through each idle loop
    
    while nextStateImmed% = 1 do  'Allows repeat of internal loop; otherwise we have to wait until the idle function is called again, OS may grab time
        
        'Get the current time
        if recCEDIsPresent% = 1 then
            tNow := MaxTime();
        else
            tNow += .05;  'simulate 50 ms between loops
        endif
        
        'Don't repeat this (internal) loop unless there is a state change or specifically asked to below for timing purposes
        nextStateImmed% := 0;  
        
        
    'Update the joystick plot every 5 ms
    printlog("recUseJoystick% is %d and tNow is %f and tLastJoyUpdate is %f\n",recUseJoystick%,tNow,tLastJoyUpdate);
        if recUseJoystick% <> 0 and tNow-tLastJoyUpdate > .005 then
            XJoy := View(recDataWindowView%).ChanMeasure(configJoyXChannel%,2,tNow-.001,tNow-.006);
            YJoy := View(recDataWindowView%).ChanMeasure(configJoyYChannel%,2,tNow-.001,tNow-.006);
            View(joyview%).XYAddData(joydatachan%,-XJoy,-YJoy);  'both axes need to be "flipped" with negative values to display properly
            tLastJoyUpdate := tNow;
            printlog("Updated joystick voltage with x voltage %f and y voltage %f\n",XJoy,YJoy);
        endif;
        
        
        
        ' ============= State Logic - determine which state we are in 
        docase
        case iState% = stateStart% then
            'This state is only entered once per "experiment" - once per each time the template file passes control
            RecLogStatus("Start", "Starting state logic loop.");
            ChangeStateTo(stateInitializeTrials%);
            
            
            
        case iState% = stateInitializeTrials% then
            
            ' prepare stimuli for the next trial.
            ' this is the point where the expt can be paused. Operator can hit the pause
            ' button anytime, but the actual pause will happen here. 
            
            if RTESDIsPressed% = 1 then  'if the ReturnToExperimentSelectionDialog button has been pressed, this is where we return
                ReturnToExptSelectDialog%();
            endif;
            
            
            if recIsPaused% = 0 then  'if not paused, do trial initialization
                
                if recExpToRun% <> recExpSearchButton% or recSearchLoaded% = 0 then
                    stmp% := PrepareNextTrial%(0); 'load PWAs, should gracefully pass through in debug mode as well
                    recSearchLoaded% := 1;  'only load PWAs once for search
                else
                    stmp% := PrepareNextTrial%(1);  'don't load PWAs for search trials after #1
                endif;
                
                docase
                case stmp% = 0 then
                    RecLogStatus("PrepareNextTrial", "All trials are done!");
                    ChangeStateTo(stateDone%);
                    'Note that we can't actually get here from Search, the user simply hits the NewExpt. button to end search and move on
                case stmp% < 0 then
                    RecLogStatus("PrepareNextTrial", "Error return value from PrepareNextTrial%");
                    ChangeStateTo(stateCodingError%);
                else
                    recCurrentTrial% += 1;  'recCurrentTrial% only incremented here, upon successful load of new trial.
                    RecLogStatus("PrepareNextTrial", "Trial #" + str$(recCurrentTrial%) + " ready.");
                    ChangeStateTo(stateWaitForInitiationMovement%);
                endcase
            else  'but if paused, check to see if we have a call out to a dialog box to change values
                if recRunTimeCall% = 1 then
                    docase
                    case recWhichDialogCalled% = 1 then
                        RecExpTimingRewardDialog%();
                        ReturnFromDialogCall%();
                    case recWhichDialogCalled% = 2 then
                        RecExpLeverJoystickDialog%();  
                        ReturnFromDialogCall%();
                    endcase
                endif
                CheckLever%();  'during pause, flush joystick/lever data
            endif
            
            
        case iState% = stateWaitForInitiationMovement% then   'this state just decides which state to go to, it's easier than replacing all the instances 
            if useTDTforLever% = 1 then
                ChangeStateTo(stateTDTBlink%);
            else
                ChangeStateTo(stateStartCEDBlink%);
            endif;
            
            
        case iState% = stateStartCEDBlink% then
            if CheckLever%() = 0 then  'lever must be up to start blink
                if tNow > tNextTrial then
                    RecLogStatus("WaitLvrDown", "Blink/Wait.");
                    if recCEDIsPresent% = 1 and recActive% = 1 then
                        SampleSeqVar(4,1);  'set the flash sequence to on
                        Sampleseqvar(6,500/SampleSeqClock(1));  'Flashing at 500 ms, divide by sequencer period in ms to get number of sequencer clock ticks
                        sampleseqvar(5,(recTrialInitWindow*1000)/(500*2));  'Set sequencer variable 5 to number of flashes, 500 ms flash duration, put recTrialInitWindow in ms
                        sampleseqvar(8,1);  'Set Flash-Allow variable to 1, this allows flashing
                        SafeSampleKey("L");  'Start the flash
                        
                    endif;
                    if recCEDIsPresent% = 1 then
                        tStartBlink := MaxTime();
                    else
                        tStartBlink := tNow;
                    endif;
                    ChangeStateTo(stateCEDBlinking%);
                endif;
            else
                RecLogStatus("PreBlinkPeriod", "Timeout waiting for lever up.");
                ChangeStateTo(stateLazyMonkeyTimeout%);
            endif;
            
            
            
        case iState% = stateCEDBlinking% then
            if tNow < tStartBlink + recTrialInitWindow then
                if recCEDIsPresent% = 1  and recActive% = 1 then
                    stmp% := CheckLever%();
                else
                    stmp% := 1; 'simulate success
                endif;
                'printlog("Lever value is %d and time is %f\n",stmp%,tNow);
                if stmp% = 1 then
                    SampleKey("S"); 'stop blink sequence immediately
                    SafeSampleKey("L"); 'turn on LED for fixpt
                    RecLogStatus("WaitLvrDown", "Delay interval=" + str$(recDelayIntervalTime) + " s.");
                    ChangeStateTo(statePreTrialDelay%);
                endif;
            else  'this is timeout
                SampleKey("S"); 'stop blink sequence immediately, though it should already be stopped
                RecLogStatus("WaitLvrDown", "Timeout waiting for lever down.");
                'Decrement, if appropriate
                ChangeThresh(-doIncUp%,-doIncDown%,-doIncLeft%,-doIncRight%);
                ChangeStateTo(stateLazyMonkeyTimeout%);
            endif;
            
            
        case iState% = stateTDTBlink% then
            if CheckLever%() = 0 then  'lever must be up to start blink
                if tNow > tNextTrial then
                    
                    RecLogStatus("WaitLvrDown", "Blink/Wait.");
                    
                    if recCEDIsPresent% = 1 and recActive% = 1 then
                        stmp% := recBlinkUntilLeverDown%(.5, recTrialInitWindow);  
                        'Will leave LED on once lever is down
                    else
                        stmp% := 1;  'simulate success in lever press
                    endif
                    
                    docase
                    case stmp% = 1 then
                        recDelayIntervalTime := recMinOnsetDelay + Rand(recVarOnsetDelay, 0);
                        'SafeSampleKey("P");  'TODO: What is this?  Still don't know.  Not in Recgen.pls!
                        RecLogStatus("WaitLvrDown", "Delay interval=" + str$(recDelayIntervalTime) + " s.");
                        ChangeStateTo(statePreTrialDelay%);
                    case stmp% = 0 then
                        RecLogStatus("WaitLvrDown", "Timeout waiting for lever down.");
                        'Decrement, if appropriate
                        ChangeThresh(-doIncUp%,-doIncDown%,-doIncLeft%,-doIncRight%);
                        ChangeStateTo(stateLazyMonkeyTimeout%);
                    else
                        PrintLog("ERROR in recBlinkUntilLeverDown%()!!!\n");
                        Message("Error in recBlinkUntilLeverDown!");
                        ChangeStateTo(stateTDTError%);
                    endcase
                endif;
            else
                RecLogStatus("PreBlinkPeriod", "Timeout waiting for lever up.");
                ChangeStateTo(stateLazyMonkeyTimeout%);
            endif;
            
            
        case iState% = stateLazyMonkeyTimeout% then
            CheckLever%();  'Flush lever/joystick during timeout
            if tNow - tStateStart > recLazyMonkeyTO then
                RecLogStatus("LazyMonkeyTimeout", "Timeout period done. Trial #" + str$(recCurrentTrial%) + " ready.");
                ChangeStateTo(stateWaitForInitiationMovement%);  'restart as if we had just finished loading
            endif
            
            
            
        case iState% = statePreTrialDelay% then
            'printlog("tnow is %f and tstatestart is %f and diff is %f\n",tNow,tStateStart, tNow-tStateStart);
            docase
            case CheckLever%() <> 1 and recCEDIsPresent% = 1  and recActive% = 1 then
                RecLogStatus("DelayInterval", "Interrupt during delay.");
                ChangeStateTo(stateWaitForInitiationMovement%);  'no interrupt penalty, it's probably a slip, just start over
            case tNow - tStateStart >= recDelayIntervalTime then
                RecLogStatus("DelayInterval", "Delay done.");
                ChangeStateTo(stateStartSoundA%);
            endcase
            
            
            
        case iState% = stateStartSoundA% then
            
            RecLogStatus("TrialSoundA", "Call expt function");
            if recCEDIsPresent% = 1 then
                stmp% := PlaySound%(isS2%);  
            else
                stmp% := 0;  'simulate playing sound if no CED
                printlog("No CED, stim would be %s\n",NameThatStimulus$(recStimList%[recPWAList%[recStimCount%][recTrialOrder%[recCurrentTrial%-1]]][recTrialOrder%[recCurrentTrial%-1]]));
            endif;
            
            docase
            case stmp% = 0 then
                isPlaying% := 1;
                ChangeStateTo(stateSoundAPlaying%);
            case stmp% < 0 then
                RecLogStatus("TrialSoundA", "PlaySound returned negative value.");
                ChangeStateTo(stateTDTError%);
            else
                RecLogStatus("TrialSoundA", "PlaySound returned unknown value (>0).");
                ChangeStateTo(stateTDTError%);
            endcase
            
            
            
        case iState% = stateSoundAPlaying% then
            
            if recCEDIsPresent% = 1 then  'only check play wave status if the CED is there
                PWA$ := PlayWaveStatus$(recPointsPlayed%);
            endif;
            
            docase
            case recCEDIsPresent% = 0 then
                isPlaying% := 0;  'simulate end of stimulus
            case recPointsPlayed% >= recPlayPoints%  then
                isPlaying% := 0;  'Stimulus is not currently playing if it's in blank space following stimulus
                PlayWaveStop();  'stop playing stimulus while we're at it
            case PWA$ = "" then
                isPlaying% := 0;  'Stimulus is not currently playing if PWA has stopped
            endcase;
            
            docase
            case isPlaying% = 0 then  'use isPlaying rather than PlayWaveStatus because the PWA may be longer than the stimulus
                if isInterrupt% = 1 then
                    isInterrupt% := 0;  'reset variable
                    StimComplete%(0, 0);  'recPreciseTrialTime was determined when interrupt occurred
                    if useTDTforLever% = 1 then  'turn off LED
                        recTDTLEDOff%();
                    else
                        SafeSampleKey("M");
                    endif;
                    ChangeStateTo(stateFAInterrupt%);  'on FA interrupt, reshuffle entire stim sequence in later
                else
                    ChangeStateTo(stateISIDelay%);
                endif
            case recActive% = 0 then
                'Do nothing here if sound is playing but there is no task; simply wait for sound to stop                
            case CheckLever%() <> 1 then  'if the sound is still playing, check for interrupt
                'institute interrupt procedure, will be completed on the next iteration or when stimulus stops
                if isInterrupt% = 0 then  'only do this for "first" interrupt, if stimulus continues  
                    recPreciseTrialTime := recLeverTime;  'time interrupt occurred
                    RecLogStatus("TrialSoundA", "False Positive Interrupt! Lever is up");
                    isInterrupt% := 1;
                    if recContinueSoundOnS1Interrupt% = 0 then
                        if recCEDIsPresent% = 1 then
                            PlayWaveStop();  'stop playing stimulus
                        endif;
                        isPlaying% := 0;
                    endif;
                endif;                
            endcase
            
            
            
        case iState% = stateISIDelay% then
            
            ' Check that lever is still down.
            if recCEDIsPresent% = 1 and recActive% = 1 then
                stmp% := CheckLever%();
                'printlog("Lever status is %d, dammit!\n",stmp%);
            else
                stmp% := 1; 'simulate lever down in testing, and in non-response scenarios
            endif
            
            docase
            case stmp% < 0 then
                RecLogError("WaitLvrUp", "ERROR (" + str$(stmp%) + ")in recLeverDown()");
                Message("Error in recLeverDown()!!!");
                ChangeStateTo(stateTDTError%);
            case stmp% <> 1 then
                RecLogStatus("WaitISI", "False Positive! Lever is up");
                recPreciseTrialTime := recLeverTime;  'time false positive occurred
                StimComplete%(0, 0);
                if useTDTforLever% = 1 then  'turn off LED
                    recTDTLEDOff%();
                else
                    SafeSampleKey("M");
                endif;
                ChangeStateTo(stateFAInterrupt%);  'this is a false alarm, but S2 has not played, so shuffle stimulus sequence back in
            else
                if tNow - tStateStart > recISI then
                    RecLogStatus("WaitISI", "ISI done.");
                    recPreciseTrialTime := tNow;  'time ISI is complete
                    isS2% := StimComplete%(0, 1);
                    docase 
                    case isS2% = 0 then
                        ChangeStateTo(stateStartSoundA%);
                    case isS2% = 1 then
                        isTerminalS1% := 0;
                        ChangeStateTo(stateStartSoundB%);
                    case isS2% = 2 then
                        isTerminalS1% := 1;
                        ChangeStateTo(stateStartSoundC%);  'SoundC is a terminal S1 - a stimulus which will be rewarded for no-go
                    else
                        RecLogStatus("WaitISI", "Unknown return value from StimComplete");
                        Message("Error in StimComplete%()!!!");
                        ChangeStateTo(stateCodingError%);
                    endcase
                endif
            endcase
            
            
            
        case iState% = stateStartSoundB% then
            RecLogStatus("TrialSoundB", "Call expt function");
            if recCEDIsPresent% = 1 then
                stmp% := PlaySound%(isS2%);
            else
                stmp% := 0;  'simulate sound playing if CED is not present
                printlog("No CED, stim would be %s\n",NameThatStimulus$(recStimList%[recPWAList%[recStimCount%][recTrialOrder%[recCurrentTrial%-1]]][recTrialOrder%[recCurrentTrial%-1]]));
            endif;
            docase
            case stmp% = 0 then
                isPlaying% := 1;
                ChangeStateTo(stateSoundBPlaying%);
            case stmp% < 0 then
                RecLogStatus("TrialSoundB", "PlaySound returned negative value.");
                ChangeStateTo(stateTDTError%);
            else
                RecLogStatus("TrialSoundB", "PlaySound returned unknown value (>0).");
                ChangeStateTo(stateTDTError%);
            endcase
            
            
            
        case iState% = stateSoundBPlaying% then
            if recCEDIsPresent% = 1 then
                PWA$ := PlayWaveStatus$(recPointsPlayed%);
            endif;
            docase
            case recCEDIsPresent% = 0 then
                isPlaying% := 0;  'simulate end of stimulus
            case recPointsPlayed% >= recPlayPoints%  then
                isPlaying% := 0;  'Stimulus is not currently playing if it's in blank space following stimulus
                PlayWaveStop();  'stop playing stimulus while we're at it
            case PWA$ = "" then
                isPlaying% := 0;  'Stimulus is not currently playing if PWA has stopped
            endcase;
            
            docase
            case isPlaying% = 0 then  'trying to use isPlaying rather than PlayWaveStatus because the PWA may be longer than the stimulus
                RecLogStatus("WaitTrialSoundB", "Sound done playing.");
                ChangeStateTo(stateTrainingReward%);  'check for training reward no matter what - ask Jackie if we want them to NOT get training reward if S2 is interrupted
            case recActive% = 0 then
                'Do nothing here if sound is playing but there is no task; simply wait for sound to stop
            case CheckLever%() <> 1 then  'if the sound is still playing, check for early hit
                'accept response whether sound should be stopped or not
                if isEarlyHit% = 0 then
                    isEarlyHit% := 1;  'this is a hit before the sound has stopped playing
                    recPreciseTrialTime := recLeverTime;  'time early hit occurred
                    RecLogStatus("WaitTrialSoundB", "Lever is up - HIT interrupting S2");
                    if recContinueSoundOnS2Interrupt% = 0 then
                        if recCEDIsPresent% = 1 then
                            PlayWaveStop();  'stop playing stimulus
                        endif;
                        isPlaying% := 0;
                    endif
                endif
            endcase
            
            
            
        case iState% = stateStartSoundC% then
            'Logic here is actually the same as for sound B
            RecLogStatus("TrialSoundC", "Call expt function");
            if recCEDIsPresent% = 1 then
                stmp% := PlaySound%(isS2%);
            else
                stmp% := 0;  'simulate sound playing if CED is not present
                printlog("No CED, stim would be %s\n",NameThatStimulus$(recStimList%[recPWAList%[recStimCount%][recTrialOrder%[recCurrentTrial%-1]]][recTrialOrder%[recCurrentTrial%-1]]));
            endif;  
            docase
            case stmp% = 0 then
                isPlaying% := 1;
                ChangeStateTo(stateSoundCPlaying%);
            case stmp% < 0 then
                RecLogStatus("TrialSoundC", "PlaySound returned negative value.");
                ChangeStateTo(stateTDTError%);
            else
                RecLogStatus("TrialSoundC", "PlaySound returned unknown value (>0).");
                ChangeStateTo(stateTDTError%);
            endcase            
            
            
            
        case iState% = stateSoundCPlaying% then
            'here there really is no difference between terminal S1 ("nontarget") and target trials, we deal with the difference
            'in stateInResponseWindow% (at least if there's no interrupt of the stimulus
            
            if recCEDIsPresent% = 1 then
                PWA$ := PlayWaveStatus$(recPointsPlayed%);
            endif;
            docase
            case recCEDIsPresent% = 0 then
                isPlaying% := 0;  'simulate end of stimulus
            case recPointsPlayed% >= recPlayPoints%  then
                isPlaying% := 0;  'Stimulus is not currently playing if it's in blank space following stimulus
                PlayWaveStop();  'stop playing stimulus while we're at it
            case PWA$ = "" then
                isPlaying% := 0;  'Stimulus is not currently playing if PWA has stopped
            endcase;
            
            docase
            case isPlaying% = 0 then  'trying to use isPlaying rather than PlayWaveStatus because the PWA may be longer than the stimulus
                RecLogStatus("WaitTrialSoundC", "Sound done playing.");
                if isEarlyFA% = 1 then
                    ChangeStateTo(stateInResponseWindow%);  'this will just shunt to the FA penalty, but it keeps the logic consistent
                else
                    ChangeStateTo(stateTrainingReward%);
                endif;
            case recActive% = 0 then
                'Do nothing here if sound is playing but there is no task; simply wait for sound to stop
            case CheckLever%() <> 1 then 'if the sound is still playing, check for early FA
                'accept response whether sound should be stopped or not
                if isEarlyFA% = 0 then
                    isEarlyFA% := 1;  'this is a hit before the sound has stopped playing
                    recPreciseTrialTime := recLeverTime;  'time early FA occurred
                    RecLogStatus("WaitTrialSoundC", "Lever is up - FA interrupting terminal S1");
                    if recContinueSoundOnS1Interrupt% = 0 then
                        if recCEDIsPresent% = 1 then
                            PlayWaveStop();  'stop playing stimulus
                        endif;
                        isPlaying% := 0;
                    endif
                endif
            endcase            
            
            
            
        case iState% = stateTrainingReward% then
            
            ' Are we giving free (training) rewards? If we are, then do so, otherwise we just pass on through. 
            if recTrainingRewardmL > 0 then
                RecLogStatus("TrainingReward", "Giving training reward, size " + str$(recTrainingRewardmL) + " mLs");
                if recCEDIsPresent% = 1 then
                    recRewardMs% := ConvertmLToSeconds(recTrainingRewardmL)*1000;
                    if (recTDTIsPresent% and useTDTforJuicer% = 1) or (recCEDIsPresent% and useTDTforJuicer% = 0) then
                        stmp% := Reward%();
                    else
                        stmp% := 0;  'simulate success in reward if debugging
                    endif;
                    
                    if stmp% <> 0 then
                        PrintLog("ERROR in recREWARD%()!!! Value of stmp is %d\n",stmp%);
                        Message("Error in recREWARD%()!!!  stmp is" + str$(stmp%));
                        ChangeStateTo(stateTDTError%);  'TDT error is actually apropriate because if CED is called, no error checking is used right now
                    endif;
                endif
            else
                RecLogStatus("TrainingReward", "No training reward.");
            endif
            ChangeStateTo(stateInResponseWindow%);
            
            
            
        case iState% = stateInResponseWindow% then
            
            if recCEDIsPresent% = 1 and recActive% = 1 then
                stmp% := CheckLever%();  'check lever status
            else 
                if isTerminalS1% = 1 then
                    stmp% := 1; 'simulate CR for debugging/passive
                else
                    stmp% := 0;  'simulate hit for debugging/passive
                endif;
            endif
            
            docase
                'Early hit, interrupted final stimulus, this is OK   
            case isEarlyHit% = 1 then  'we don't care about the state of the lever; it was already released early
                isEarlyHit% := 0;  'reset variable
                'time of early hit is recorded above
                StimComplete%(1, 1);
                if useTDTforLever% = 1 then  'turn off LED
                    recTDTLEDOff%();
                else
                    SafeSampleKey("M");
                endif;
                ChangeStateTo(stateHitReward%);
                'Early FA, interrupted final stimulus before actual response window
            case isEarlyFA% = 1 then  'we don't care about the state of the lever; it was already released early
                isEarlyFA% := 0;  'reset variable
                'time of early FA is recorded above
                StimComplete%(2, 0);  'terminal S1
                if useTDTforLever% = 1 then  'turn off LED
                    recTDTLEDOff%();
                else
                    SafeSampleKey("M");
                endif;
                ChangeStateTo(stateFalsePositive%);
                'Error in RecLeverDown%()
            case stmp% < 0 then
                RecLogError("WaitLvrUp", "ERROR (" + str$(stmp%) + ")in recLeverDown()");
                Message("Error in recLeverDown()!!!");
                ChangeStateTo(stateTDTError%);
                'Hit in response window    
            case stmp% = 0 and isTerminalS1% = 0 then
                'SafeSampleKey("R");  'not in Recgen.pls!
                RecLogStatus("WaitLvrUp", "Lever is up - HIT");
                recPreciseTrialTime := recLeverTime;  'time hit occurred
                StimComplete%(1, 1);
                if useTDTforLever% = 1 then  'turn off LED
                    recTDTLEDOff%();
                else
                    SafeSampleKey("M");
                endif;
                ChangeStateTo(stateHitReward%);
                'False alarm in response window    
            case stmp% = 0 and isTerminalS1% = 1 then
                RecLogStatus("WaitLvrUp", "Lever is up - False Alarm on terminal S1");
                recPreciseTrialTime := recLeverTime;  'time FA occurred
                StimComplete%(2, 0);  'terminal S1
                if useTDTforLever% = 1 then  'turn off LED
                    recTDTLEDOff%();
                else
                    SafeSampleKey("M");
                endif;
                ChangeStateTo(stateFalsePositive%);
                'Response window is closed, miss    
            case tNow - tStateStart > recResponseWindow and isTerminalS1% = 0 then
                RecLogStatus("WaitLvrUp", "Lever not up - timed out - MISS");
                recPreciseTrialTime := tNow;  'time response window closed - note we could be more precise (e.g. tStateStart + recResponseWindow) but why?  There's no "event" 
                StimComplete%(1, 0);
                if useTDTforLever% = 1 then  'turn off LED
                    recTDTLEDOff%();
                else
                    SafeSampleKey("M");
                endif;
                ChangeStateTo(stateMissTimeout%);
                'Response window is closed, correct rejection    
            case tNow - tStateStart > recResponseWindow and isTerminalS1% = 1 then 
                RecLogStatus("WaitLvrUp", "Lever not up - Correct Rejection on terminal S1");
                recPreciseTrialTime := tNow;  'time response window closed - note we could be more precise (e.g. tStateStart + recResponseWindow) but why?  There's no "event"
                StimComplete%(2, 1);  'terminal S1
                if useTDTforLever% = 1 then  'turn off LED
                    recTDTLEDOff%();
                else
                    SafeSampleKey("M");
                endif;
                ChangeStateTo(stateCRReward%);  
                'Otherwise, the response window is still open and the lever is still down    
            else
                'Nothing, just a comment                
            endcase
            'We can aggressively wait for the response if the RT is important, just uncomment below (is RT even recorded?)
            nextStateImmed% := 1; 
            
            
            
        case iState% = stateMissTimeout% then
            CheckLever%();  'Flush lever/joystick during timeout
            if tNow - tStateStart > recMissTO then
                RecLogStatus("MissTimeout", "Timeout period done.");
                ChangeStateTo(stateInitializeTrials%);  'move to next trial
                tNextTrial := tNow;  'ready to go
            endif
            
            
            
        case iState% = stateFalsePositive% then 
            'this state is used to give a FA timeout for an incorrect response to a terminal S1 (nontarget) stim 
            'no real need to repeat entire stim sequence as the whole sequence was presented
            CheckLever%();  'Flush lever/joystick during timeout
            if tNow - tStateStart > recFalseAlarmTO then
                RecLogStatus("FalsePositiveTimeout", "Timeout period done.");
                'ChangeStateTo(stateWaitForInitiationMovement%);  'was stateInitializeTrials% but we want to repeat the stimulus
                'ChangeStateTo(stateInitializeTrials%);  'No, actually, I don't think we do want to repeat the stimulus
                'ACTUALLY - we want to shuffle this back in, since there's no diff between a false positive on the final
                'stimulus and one on a prior stimulus.  Note that in the future there may be human experiments where this
                'distinction is valid, so I'm keeping it in.  In that event (only vaguely planned) I think the best way will
                'be to branch inside this logic state.
                
                'Decrement current trial index (which was incremented above in stateInitializeTrials)
                recCurrentTrial% := recCurrentTrial% - 1;
                
                'Send current trial to "middle" of remaining trials
                SendTrialToMiddle%(recNTrials%,recCurrentTrial%,1,recTrialOrder%[]);  'at least one intervening trial
                
                ChangeStateTo(stateInitializeTrials%); 
                tNextTrial := tNow;  'ready to go
            endif
            
            
            
        case iState% = stateFAInterrupt% then
            'this state is used to repeat a FA interrupted stimulus, so that the S2 gets played
            CheckLever%();  'Flush lever/joystick during timeout
            if tNow - tStateStart > recFalseAlarmTO then
                RecLogStatus("FAInterruptTimeout", "Timeout period done. Trial #" + str$(recCurrentTrial%) + " being reshuffled.");
                
                'Decrement current trial index (which was incremented above in stateInitializeTrials)
                recCurrentTrial% := recCurrentTrial% - 1;
                
                'Send current trial to "middle" of remaining trials
                SendTrialToMiddle%(recNTrials%,recCurrentTrial%,1,recTrialOrder%[]);  'at least one intervening trial
                
                ChangeStateTo(stateInitializeTrials%); 
                tNextTrial := tNow;  'ready to go
            endif            
            
            
            
        case iState% = stateHitReward% then
            
            'Increment, if appropriate
            ChangeThresh(doIncUp%,doIncDown%,doIncLeft%,doIncRight%);
            
            if recHitRewardmL > 0 then
                RecLogStatus("HitReward", "Giving Hit Reward, size=" + str$(recHitRewardmL) + " mLs");
                if recCEDIsPresent% = 1 then
                    recRewardMs% := ConvertmLToSeconds(recHitRewardmL)*1000;
                    recRewardMs := recRewardMs%;  'we need a float version for later math
                    s$ := Print$("Reward,%f,%d", tNow, recRewardMs%);
                    SampleText(s$);
                    if (recTDTIsPresent% and useTDTforJuicer% = 1) or (recCEDIsPresent% and useTDTforJuicer% = 0) then
                        stmp% := Reward%();
                    else
                        stmp% := 0;  'simulate success in reward if debugging
                    endif;
                    
                    if stmp% <> 0 then
                        PrintLog("ERROR in recREWARD%()!!! STMP is %d\n",stmp%);
                        Message("Error in recREWARD%()!!!");
                        ChangeStateTo(stateTDTError%);  'TDT error is actually apropriate because if CED is called, no error checking is used right now
                    else
                        ChangeStateTo(stateInitializeTrials%);  'move to next trial after reward is done
                        if useTDTforJuicer% = 0 then
                            tNextTrial := tNow + (recRewardMs/1000);
                        else
                            tNextTrial := tNow; 'the TDT delay is built in, ready to go
                        endif;
                    endif;
                else
                    ChangeStateTo(stateInitializeTrials%);  'move to next trial after reward is done
                    if useTDTforJuicer% = 0 then
                        tNextTrial := tNow + (recRewardMs/1000);
                    else
                        tNextTrial := tNow; 'the TDT delay is built in, ready to go
                    endif;
                endif
            else
                ChangeStateTo(stateInitializeTrials%);  'move to next trial after reward is done
                if useTDTforJuicer% = 0 then
                    tNextTrial := tNow + (recRewardMs/1000);
                else
                    tNextTrial := tNow; 'the TDT delay is built in, ready to go
                endif;
            endif;
            
            
        case iState% = stateCRReward% then
            
            'Increment, if appropriate
            ChangeThresh(doIncUp%,doIncDown%,doIncLeft%,doIncRight%);
            
            if recCRRewardmL > 0 then
                RecLogStatus("CRReward", "Giving CR Reward, size=" + str$(recCRRewardmL) + " mLs");
                if recCEDIsPresent% = 1 then
                    recRewardMs% := ConvertmLToSeconds(recCRRewardmL)*1000;
                    s$ := Print$("Reward,%f,%d", tNow, recRewardMs%);
                    SampleText(s$);
                    if (recTDTIsPresent% and useTDTforJuicer% = 1) or (recCEDIsPresent% and useTDTforJuicer% = 0) then
                        stmp% := Reward%();
                    else
                        stmp% := 0;  'simulate success in reward if debugging
                    endif;
                    
                    if stmp% <> 0 then
                        PrintLog("ERROR in recREWARD%()!!!\n");
                        Message("Error in recREWARD%()!!!");
                        ChangeStateTo(stateTDTError%);  'TDT error is actually apropriate because if CED is called, no error checking is used right now
                    endif;
                endif
            endif
            ChangeStateTo(stateInitializeTrials%);  'move to next trial when reward is done
            if useTDTforJuicer% = 0 then
                tNextTrial := tNow + (recRewardMs/1000);
            else
                tNextTrial := tNow; 'the TDT delay is built in, ready to go
            endif;            
            
            
            
        case iState% = stateDone% then
            
            if useTDTforLever% = 1 then  'turn off LED
                recTDTLEDOff%();
            else
                SafeSampleKey("M");
            endif;
            RecLogStatus("Done", "");
            iStatus% := 0;
            recReadyToQuit% := 0;
            ReturnToExptSelectDialog%();  'If the current expt. is "done" allow another to be run without stopping sampling
            'Stop%();
            
            
            
        case iState% = stateTDTError% then
            
            'find a way to break all the way out
            
            'This is temporary so it does something logical but should be updated eventually
            RecLogStatus("A TDT Error has occurred!", "");
            recReadyToQuit% := 1;  'This will allow the entire thing to quit
            if useTDTforLever% = 1 then  'turn off LED
                recTDTLEDOff%();
            else
                SafeSampleKey("M");
            endif;
            iStatus% := 0;
            Stop%();
            
            
            
        case iState% = stateCodingError% then
            
            'find a way to break all the way out
            
            'This is temporary so it does something logical but should be updated eventually
            RecLogStatus("A coding Error has occurred!", "");
            iStatus% := 0;
            recReadyToQuit% := 1;  'This will allow the entire thing to quit
            if useTDTforLever% = 1 then  'turn off LED
                recTDTLEDOff%();
            else
                SafeSampleKey("M");
            endif;
            Stop%();
            
            
            
        else
            
            RecLogStatus("UNKNOWN STATE", "iState%=" + str$(iState%));
            Message("Unknown state (%d)!", iState%);
            iStatus% := 0;
            recReadyToQuit% := 1;  'This will allow the entire thing to quit
            if useTDTforLever% = 1 then  'turn off LED
                recTDTLEDOff%();
            else
                SafeSampleKey("M");
            endif;
            Stop%();          
        endcase
        
    wend  'close the nextStateImmed% while
    
    
    return iStatus%;  'if iStatus% is 0, the Toolbar() will return
end




'=================================Debounce the Lever Channel=================================
'This function serves as a software debounce for incoming TTL pulses.  It can only parse 1000
'events at one time, but is called every time the idle loop is called (if we are sampling) and at 
'so the 1000 event limit should not really be in danger.
'If there are > 1000 events, I BELIEVE it will simply parse the first 1000, allowing it to 
'continue parsing 1000 events each time it is called until it is caught up.  ...that hasn't been tested.
func DebounceLever%(Now)
    
    var TimesArray[1000];            'array of times of most recent events
    var TimesArrayTemp[999];         'array of times used only the first time through
    var LeverStatusAfter[1000];      'array of lever statuses corresponding to TimesArray[]
    var TimeToPrev[1000];            'array of differences between times in TimesArray[] and previous event
    var TimeToNext[1000];            'array of differences between times in TimesArray[] and next event
    var temp1[999];
    var temp2;
    var RealEventTime[1000];         'Holds times of real (not bouncing) events 
    var RealEventValue[1000];        'Holds lever values resulting from real events
    var EventCount%;                 'Counter for real events
    var ValueCount%;                 'Counter for real lever values
    var DebounceTime := .040;        'Debounce over 40 ms, can be changed manually
    var NumEvents%;                  'Number of potential lever events in the current execution
    var LeverString$;						'A string which details the lever event (for textmark channel)
    var ii%, jj%, BreakVar;
    
    
    view(recDataWindowView%);
    
    if recLeverTime = 0 then 'if it's the first pass or there have not been any events (LeverInitTime and LeverResponseTime are identical for lever scenarios)
        NumEvents% := chandata(recLeverChannel%,TimesArrayTemp[],0,Now);  'put recent times of lever presses in a temporary array
        arrconst(TimesArray[1:999],TimesArrayTemp[]);  'move temporary numbers to regular array, leaving first time blank (indicates "known" event at time = 0)
        NumEvents% := NumEvents% + 1;  'Increment NumEvents% by one to account for asserted event at time = 0
    else
        NumEvents% := chandata(recLeverChannel%,TimesArray[],recLeverTime,Now);  'put times of recent lever presses in regular array, starting with most recent known event
    endif;
    'printlog("Events are at %f and recLeverTime is %f and now is %f\n",TimesArray[],recLeverTime,Now);
    
	'There should always be a "first event" at LeverInitTime.  If there are no more, we haven't actually
	'had anything happen, so don't do anything
    if NumEvents% > 1 then
		'Calculate time to previous, next events
        
		'Fill temp1 with a shifted version of TimesArray, shifted one to the left
		'Note that the fill for a single element must be done differently
        if NumEvents% = 2 then
            temp1[0] := TimesArray[1];
        else
            arrconst(temp1[0:NumEvents%-1],TimesArray[1:NumEvents%-1]);
        endif;
        
		'Subtract, so temp1[x] holds the time difference between TimesArray[x] and TimesArray[x+1]
        arrsub(temp1,TimesArray[]);
        
		'Fill TimeToNext and TimeToPrev, note that temp1[NumEvents%-1] will be negative, and is useless
        if NumEvents% = 2 then
            TimeToPrev[1] := temp1[0];
            TimeToNext[0] := temp1[0];
        else
            arrconst(TimeToPrev[1:NumEvents%-1],temp1[0:NumEvents%-1]);
            arrconst(TimeToNext[0:NumEvents%-1],temp1[0:NumEvents%-1]);
        endif;
        
		'Fill final spot in TimeToNext with time to Now.
        TimeToNext[NumEvents%-1] := Now - TimesArray[NumEvents%-1];
        
		'Get lever status resulting from each lever event
        for ii% := 1 to NumEvents%-1 do 'only consider events starting at second position in array
            nexttime(recLeverChannel%,TimesArray[ii%],temp2);  'temp2 will be 0 if low-to-high and 1 if high-to-low
            LeverStatusAfter[ii%] := 1 - temp2; 'LeverStatusAfter will be 1 if low-to-high and 0 if high-to-low
        next;
        
        
		'Check each event in TimesArray (except [0])
        for ii% := 1 to NumEvents%-1 do 
			'If there was more than DebounceTime between the previous event and this one, the
			'previous state was stable, this should be considered a real event
            if TimeToPrev[ii%] > DebounceTime then
                RealEventTime[EventCount%] := TimesArray[ii%];
                EventCount% := EventCount% + 1;
				'Get the lever status for this event by looking for next stable period
                BreakVar := 0;
                jj% := ii%;
                while jj% <= NumEvents%-1 and BreakVar = 0 do
                    if TimeToNext[jj%] > DebounceTime then 'it has been stable long enough
                        RealEventValue[ValueCount%] := LeverStatusAfter[jj%];
                        ValueCount% := ValueCount% + 1;
                        BreakVar := 1;
                    else
                        jj% := jj% + 1;
                    endif;
                wend;
            endif;
        next;
        
		'Check to see that the number of lever presses and events correspond appropriately
        if ValueCount% <> EventCount% then
            if ValueCount% > EventCount% then
                printlog("Quitting because we have found more real lever presses than real events.  This is a serious bug!\n");
                'view(HiddenLogHandle%).print("Quitting because we have found more real lever presses than real events.  This is a serious bug!\r");
                Stop%();
            endif;
            if ValueCount% < EventCount%-1 then
                printlog("Quitting because we have found more than one event which does not correspond to a stable lever press!\n");
                'view(HiddenLogHandle%).print("Quitting because we have found more than one event which does not correspond to a stable lever press!\r");
                Stop%();
            else
                EventCount% := EventCount%-1;  'decrement, do not consider last event real as we do not have a
                'corresponding lever press
            endif;
        endif;
        
        'Put events in memory channel if they exist and change LeverInitTime/LeverResponseTime/LeverInit%/LeverResponse%
        if EventCount% > 0 then	
            'verbose, just taken out
            'printlog("Debounce: The lever events we considered to be real occurred at times: %f\n",RealEventTime[0:EventCount%]);

            for ii% := 0 to EventCount%-1 do
                recLeverCodes%[0] := RealEventValue[ii%];
                if RealEventValue[ii%] = 1 then
                    LeverString$ := "Lever Pressed";
                else
                    LeverString$ := "Lever Released";
                endif;
                view(recDataWindowView%).MemSetItem(recMemChanLeverDebounce%,0,RealEventTime[ii%],recLeverCodes%[],LeverString$);
            next;
            'return most recent event and value
            recLeverTime := RealEventTime[ii%-1]; 'subtract one because ii% is incremented a final time by the for loop
            recLeverState% := RealEventValue[ii%-1]; 'ditto
            
            'more Sutter stuff, probably not necessary here
			'indicate whether lever is in the origin (meaning not pressed), only if we are responding w/ lever
			'also indicate if lever is in trial initiation position
			'also indicate if lever is in trial response position
            'if RespDevice% = 0 then
            '    InOrigin% := 1 - LeverPos%;
            '    TrialInit% := LeverPos%;
            '    TrialResponse% := InOrigin%;  'for lever, trial response position is same as origin
            '    if TrialResponse% = 1 then
            '        ResponseTime := LeverTime;
            '    endif;
            'endif;
            
        endif;  'end "if there were any events"
        
    endif;  
    
    return 1;
    
end;



'A simple function which points to either recLeverDown%() or DebounceLever%() or ReadJoystick%() as appropriate
func CheckLever%()
    var myret%;  'the return value, 0 if lever is up, 1 if lever is depressed
    docase  'note that in all cases recLeverTime is set within the called function
    case useTDTforLever% = 1 then
        myret% := recLeverDown%();
    case recUseJoystick% = 0 then
        DebounceLever%(tNow);
        myret% := recLeverState%;  'DebounceLever%() is run at the beginning of each idle loop, do it again if necessary before calling
    case recUseJoystick% = 1 then
        ReadJoystick%();  'ReadJoystick needs to call a new function (not AssignJoystickVariables) to get
        'recLeverState%
        myret% := recLeverState%;
    else
        printlog("Unknown value " + Str$(recUseJoystick%) + " for recUseJoystick%, this is probably your problem!");        
    endcase
   
    
    return myret%;
    
end;
