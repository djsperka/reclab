
'This script does not execute any code when the script which includes it is run - it is merely the set of functions
'which define the workings of the presentation engine.  Use RunGoNoGoEngine%() to get things going.


'==========================   Global variables  ============================================


' channel numbers ***and window handles***??
' there are 1-32 max # electrodes on our probe, so reserve these channel numbers for electrodes and don't use them elsewhere
' as far as I can tell, channel numbers are arbitrary (as opposed to Ports#s), so use channel #s 40 and up for non-electrodes
const recLeverChannel% := 33;         ' Channel for behavioral lever recording
const configJoyXChannel% := 34;       ' Channel for JoystickX
const configJoyYChannel% := 35;       ' Channel for JoystickY
const audioOutputCopyChannel% := 36;  ' Audio output should be tee'd and input to ADC port 2 
const recBAK1Channel% := 37;             ' First BAK
const recBAK2Channel% := 38;             ' Second BAK

'electrode channel, port & number variables (because you cant make a const array)
const maxTrodes% := 21; 'Can record 24 ADCs, but three are taken by JoyX/JoyY/AudioCopy
var recTrodePosition%[maxTrodes%];
var recTrodeChannel%[maxTrodes%];
var recTrodePort%[maxTrodes%];
'var maxTrodesThisExpt% := 4;  'if we are stimulating, we need two ports to monitor the stimulation, this reduces the number of ports available for electrodes

' ports
const recLeverPort% := 1;    'Event port
const recBAK1Port% := 0;        'Event port
const recBAK2Port% := 1;        'Event port  --  Note that recLeverPort% and BAK2Port conflict for now.  It is anticipated that there should not be recording+lever until late 2020
const configJoyXPort% := 0;  'A2D port
const configJoyYPort% := 1;  'A2D port

' memory channels
var recMemChanLeverDebounce%;

' For Joystick
var joystickXOffset; 'use registry  
var joystickYOffset;
var joyview%;
var joydatachan%;
var LastPos%;
var JoystickReadOnce%;
var LeverCodes%[4]; 
var XPos%;
var YPos%;
var XTime;
var YTime;
var inOrigin%;
var RespDevice%;
var inTrialInit%;
var inResponse1%;
var inResponse2%;
var TrialResponse%;
var ResponseTime;
var OffAxis%;
var XJoy;
var YJoy;
var doIncUp%;
var doIncDown%;
var doIncLeft%;
var doIncRight%;
var doIncTrialInit%[4];  'indicates which channels to increment on succesful trial init
var doDecTrialInit%[4];  'indicates which channels to decrement on failed trial init
var doIncHit%[4];  'indicates which channels to increment on succesful hit
var doIncCR%[4];  'indicates which channels to increment on succesful CR
var doDecPassiveMiss%[4];  'indicates which channels to decrement on passive miss (no decrement on active miss)
var doDecPassiveFA%[4];  'indicates which channels to decrement on passive FA (no decrement on active FA)

' for anything other than electrodes!
var recXYWindowView%;              ' View variable for XY window
var recDataWindowView%;            ' View variable for data window


'This is all for ExtractSpaceInitialize
var recHBeh%;       ' ecode file
var recHBak%;       ' spikes
var recTLastProcessed := -1;
var recChanWM%;
var recChanTM%;



'Variables for PlaySound 
'const recTTMaxSpeakers% := 100;
const recDAC0Key$        := "A";
'var recTTSpeakers%[recTTMaxSpeakers%];    ' speaker numbers - each is considered a trial type. Can have duplicates. 
'var recTTAtten[recTTMaxSpeakers%];        ' atten to use for each speaker number in g_spcTTSpeakers%[]
var recTone%                := 0;
var recFreq%                := 20000;
var StimOn;                                ' time of stimulus onset
var RewardOn;                              ' time of reward onset
var PrevSequencerTime;                     ' time of previous sequencer time, avoids error if Spike2 code executes faster than sequencer
var StimStopped;
var StimStoppedNotSet%;                    ' Boolean that dictates when StimStopped needs to be set for that stimulus 
var UsPerTime;                             ' number of microseconds per sequencer sample period
var TimePerADC;                            ' 
var SecPerSample;                          ' 
var SequencerPeriodMS;
var dummy% := 0;

'These variables are unused - not sure if I will need them
'var recTTSpikeCounts%[recTTMaxSpeakers%][recMaxTrials%]; ' spike counts for completed trials on each trial type
'var recTTSpikeRate[recTTMaxSpeakers%][recMaxTrials%];    ' spike rates for completed trials on each trial type
'var recTTSpikeRateMean[recTTMaxSpeakers%];' mean spike rate for each trial type
'var recTTSpikeRateStd[recTTMaxSpeakers%]; ' std dev for above. 
'var recTTIndexBackground%;                 ' index into TT arrays which is the background speaker/atten pair. 


' toolbar button numbers
const recStartButton%         := 1;
const recPauseButton%         := 2;
const recResumeButton%        := 3;
const recSelectNewExptButton% := 4;
'const recRewardButton%        := 5; 'REMOVED! use Timing/Reward button instead!
const recStopButton%          := 5;
const recTimingRewardButton%  := 6;
const recJoystickButton%      := 7;
const recCalibrationButton%   := 8;


' States and state control vars 
var isInterrupt%;
var isEarlyHit%;
var isEarlyMiss%;
var isEarlyFA%;
var isEarlyCR%;
var recIsPaused%;
const stateStart%                             := 0;
const stateInitializeTrials%                  := 1;
const stateDetermineRewardType         := 2;
const stateLazyMonkeyTimeout%                 := 3;
const statePreTrialDelay%                     := 4;
const stateStartSoundA%                       := 5;
const stateSoundAPlaying%                     := 6;
const stateISIDelay%                          := 7;
const stateStartSoundB%                       := 8;
const stateSoundBPlaying%                     := 9;
const stateTrialInitReward%                   := 10;
const stateInResponseWindow%                  := 11;
const stateHitReward%                         := 12;
const stateFalsePositive%                     := 13;
const stateMissTimeout%                       := 14;
const stateDone%                              := 20;
const stateTDTError%                          := 21;
const stateCodingError%                       := 22;
const stateFAInterrupt%                       := 23;
const stateStartSoundC%                       := 24;
const stateSoundCPlaying%                     := 25;
const stateCRReward%                          := 26;
const stateStartCEDBlink%                     := 27;
const stateCEDBlinking%                       := 28;
'const stateTDTBlink%                          := 29;
const stateStartSoundD%                       := 30;
const stateSoundDPlaying%                     := 31;
const stateFalseAlarmAudiogram%               := 32;
const stateStartSoundE%                       := 33;
const stateSoundEPlaying%                     := 34;
const stateFRAInitializeTrials%               := 35;
const stateFRAHitReward%                      := 36;
const stateFRAISIDelay%                       := 37;
const stateFRAJuiceBreak%                     := 38;
const statePrepareTone%                       := 39;
const stateFindDigMarkOn%                     := 40;
const stateWaitForEndOfSound%                 := 41;
const stateFindDigMarkOff%                    := 42;
const stateLongToneISI%                       := 43;
const stateStartLongTone%                     := 44;
const stateTrialHoldReward%                   := 45;
'const stateLongNoiseReloadPWA%                := 46;

var recDelayIntervalTime         := 0;
var recDelayIntervalInterrupt%   := 0;  'was there an interrupt in the delay interval?
var recJuiceBreak%:= 3; 'how long to wait after juice reward is given (to avoid recording artifacts from swallowing)
var tNow:=0;		' latest time for which there are values recorded. Used in IdleLoop%
var tStartBlink;    ' used in idle loop
var tLast:=-1;		' last time we checked for a trigger. 
var tLastJoyUpdate; 'last time we updated the joystick
var iState%:=stateStart%;		' present state
var tStateStart:=-1;	' time that present state started. Used to measure wait time, fixation time, etc. 
var tLongToneStart;
var tNextTrial;
var isTerminalS1%:=0;    'if trial has terminal S1, logic of state loop must change, so we need to keep track
var RTESDIsPressed%;  'has ReturnToExperimentSelectionDialog button been pressed?
var recLeverState%;
var recLeverTime;   'this is the time of the most recent lever EVENT - one that we are going to record as a hit, etc.
var recLastLever;   'this is the time of the most recent lever change - whether we plan to record it or not
var recPreciseTrialTime;
var recLeverCodes%[4];
var startingNewExpt%;  'only used with joystick, marks beginning of experiment so that joystick events in the past are "forgotten"
var nextStateImmed% := 1;  'when we are changing to a new state, by default we carry to that state immediately instead of waiting for the next idle loop call
var coinFlipResult%;    'to reward SAME trials for AMDis Hi/Lo *jao
var responseMode%;                  'branched from isS2% (IdleLoop) for Hi/Lo responses, has to be global to work
var isS2%;              'man, this thing's gotta be global, not local in IdleLoop!  It gets reset to zero every time IdleLoop is called!
var recStimOn;
var recFRAPWAIndex% := 0;
var recLongAtten;
var recLoadLongNoise%;
var LongNoiseBlock%;
var LongNoiseCounter%;

'output variables --> for ToolbarText (first step of user feedback)
var numHits% := 0;
var numMisses% := 0;
var numFPs% := 0;
var numFAs% := 0; 'need a CR counter too... (NOT USED NOW)
var numHiResps% := 0; 'reset after each block?
var numLoResps% := 0; 'reset after each block? (kind of redundant, but that's OK)
var percentUPthisBlock;
var percentHITthisBlock;
var amountRewarded := 0;

'var channels%[4];

var expectedOffTime;
var foundDigMarkOnTime;
var foundDigMarkOffTime;
var digCode%[4];

'To remove SampleAutoCommit
var SamplingCommitPeriod := 30;  'This will be more specific, we will auto-commit between trials if it has been at least 30 seconds
var LastSamplingCommitTime := 0;

#include "RecJoystickFuncs.s2s"

'This is the overarching function which is called by the main (template) file
'This function simply creates the sample configuration, initializes the play wave areas,
'initializes the windows, and initializes the toolbar.  Once the toolbar is started, the 
'remainder of the work is done by the idle function once the toolbar is started.  Breaking
'out of the toolbar will then return control to the (template) file.
func RunGoNoGoEngine%()
    
    view(recLog%).print("Begin func RunGoNoGoEngine%.\n");    
    'We do want to start from the start state!
    iState% := stateStart%;
    
    'Set up sampling configuration
    if recCEDIsPresent% = 1 and recCurrentlySampling% = 0 then
        CreateSampleConfiguration();   'CreateSampleConfiguration() is below     TODO: make sure it is OK, fix up .pls file
        view(recLog%).print("Sample configuration created - func RunGoNoGoEngine%.\n");
    endif;
    
    
    ' Initialize PlayWave areas. The call to InitializePlayWaveAreas MUST
    ' come before the call to InitializeWindows -- that's where FileNew() is called. See Spike2
    ' docs for PlayWaveAdd(): PlayWaveAdd must be called before FileNew() for sampling window.
    if recCEDIsPresent% = 1 and recCurrentlySampling% = 0 then 'don't try to initialize a PlayWaveArea if there's no 1401
        docase
        case recExpToRun% = recExpFRAButton% and recFRALoadStim% = 1 then 
            InitializeParallelPlayWaveAreas();
        case recExpToRun% = recExpStereoDisButton% then
            InitializeMultipleParallelPlayWaveAreas();
        'case recExpToRun% = recExpLongToneButton% and recLongToneType% = 1 then
            'Initialize a play wave area for the broadband noise condition
        '    InitializePlayWaveAreaLongBB();
        case recExpToRun% = recExpLongToneButton% and recLongToneType% >= 1 then
            'Initialize a play wave area for the bandpass/broadband noise condition
            InitializePlayWaveAreasLongBP();
        else
            InitializePlayWaveAreas();  'InitializePlayWaveAreas() is below 
        endcase
        view(recLog%).print("PWAs initialized - func RunGoNoGoEngine%.\n");
    endif;
    
    
    'Open XY and data windows
    'Positioned after InitializePlayWaveAreas() because PlayWaveAdd() must be called before FileNew()
    if recCEDIsPresent% = 1 and recCurrentlySampling% = 0 then
        InitializeWindows();           'InitializeWindows() is below, opens one XYwindow and one data sampling window
        view(recLog%).print("Windows initialized - func RunGoNoGoEngine%.\n");
        
        'For now, cutting out ExtractSpaceInitialize as ExtractSpace is being shelved at least temporarily.
        'Since ExtractSpaceInitialize's main function is to set up an online view of the data plotted in 
        'recXYWindowView%, this will almost certainly be re-established, perhaps shortly.
        'ExtractSpaceInitialize(recXYWindowView%,recNSpeakers%);  'TODO: ExtractSpaceInitialize() is in extract_space_functions, may need to be adapted
        'This function basically does prep to plot a polar plot of activity v. speaker location.  Assumes full circular
        'array, evenly spaced, speaker 0 at top and subsequent speakers clockwise.  Could be adapted for more variable arrays.
    endif;
    
    
    ' Initialize toolbar. Once Toolbar is called the experiment is controlled by the toolbar
    ' buttons. Toolbar() does not return until one of the toolbar functions returns 0 - Stop%()
    ' does that if pressed, IdleLoop%() returns an iStatus% of 0 when it reaches the end of all trials. 
    ' What is confusing is that although the Toolbar returns, it's not quite dead.  It's still there in
    ' the background (even visible, but grayed out).  I suppose that's the way it is, an exited,
    ' not-running Toolbar can still be seen because at an early step we made it visible.  OK.
    ' However, a crucial step is that when returning to the experiment selection dialog, the Toolbar's 
    ' idle function must be "turned off", or more technically, directed to no function: ( ToolbarSet(0, ""); )
    ' rather than our state-logic idle loop.  That's because the Toolbar remembers things, and when we
    ' start it up again, if it still thinks the idle function is our state-logic loop, it jumps right into 
    ' it.  If we clear that idle function, then only the Start%() function sets the Toolbar idle function 
    ' to our state-logic loop and gets things going.
    
    InitializeToolbar();
    ToolbarSet(0, "");  'explicitly set the idle function to nothing - for some reason on second/third/etc. expts. the idle function is kicking in early even though I don't think it should be active yet   
    printlog("Toolbar initialized\n");
    view(recLog%).print("Toolbar initialized - func RunGoNoGoEngine%.\n");
    
    JoystickReadOnce% := 0; 'initialize joystick position ~jao 12Aug2014
    
    Toolbar("Hit \"Start\" to begin sampling.", 0x3ff);  'Run the toolbar; the experiment will be here most of the time
    'once we leave the toolbar, return to calling function
    return recReadyToQuit%;
    
end






'==========================  Local functions below ===========================================


''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' SetTrodeChannels (called by CreateSampleConfiguration) sets the electrode channel numbers and 
' port numbers that correspond to electrode position on the linear array probe. In other words, 
' this contains the electrode/port/channel mapping that is crucial to keep track of when running 
' experiments! So, don't fuck with it unless you are sure you know what you're doing!
' ~jao 2014 Aug 21
' -jj fucked with it because he knows what he's doing 2019 Nov 6
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func SetTrodeChannels()
    'make a func so that if you want to make this a dialog function its easier
    var i%;
    var portNum%;
    var trodeNum%;
    
    'TrodePorts will not change! same as TrodeChans, unless TrodeChannels changes/becomes configurable 
    for i% := 0 to maxTrodes%-1 do 'maxTrodes = 21, limited by available ports excluding JoyX/JoyY/AudioCopy
        portNum% := i%+3; 'first electrode is on Port 3
        recTrodePort%[i%] := portNum%;
        recTrodePosition%[i%] := portNum%; 'this way all the numbers are the same! easyPeasy!
        recTrodeChannel%[i%] := portNum%;
    next;
    
end
'======  end SetTrodeChannels() ======================


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' CreateSampleConfiguration()
' jackie's version, 2014 Aug 21
' jackie's version getting rolled by jj's version, 2019 Nov 6
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc CreateSampleConfiguration()
    
	var index;
    var i%;
    var thisTrodeString$;
    var sampleRate%;
    sampleRate% := 50000; 'was 28000
    'call SetTrodeChannels to fill Trode Channels, Ports, and Numbers arrays
    SetTrodeChannels();
    
    PrintLog("Port numbers on CED are......: %d \n", recTrodePort%);
    PrintLog(" >> for Trode Channel numbers: %d \n", recTrodeChannel%);
    PrintLog(" >> for Trode Probe Positions: %d \n", recTrodePosition%);
    
    
    ' Initialize sampling settings
    SampleClear();  'remove any previous sampling settings
    SampleChannels(200); 'Set the max number of channels to be 200! this should solve all my problems
    SampleAutoComment(0);  'no automatic prompt for file comments when sampling ends
	'SampleAutoCommit(30);  'automatically commit sampling every 30 seconds
    SampleAutoCommit(0);  'Auto commit is causing some slow-down issues, trying manual (WON'T WORK ON SPIKE6!!!)...but turning it off anyway!
    SampleAutoFile(0);     'set auto-filing state to "off"
    'SampleAutoName$("reclab000");  'set file name template (or not???)
    
    
    if recUseJoystick% = 0 then
        ' Event channel 1 is for the lever
        SampleEvent(recLeverChannel%, recLeverPort%, 2, 10);  'create a level channel for the lever, 10 Hz max sustained
        SampleTitle$(recLeverChannel%, "Lever");
        SampleComment$(recLeverChannel%, "Lever");
    else
        'create joystick channels
        'X
        SampleWaveform(configJoyXChannel%,configJoyXPort%,5000); 
        SampleComment$(configJoyXChannel%,"JoystikX");
        SampleTitle$(configJoyXChannel%,"JoystikX");
        'Y
        SampleWaveform(configJoyYChannel%,configJoyYPort%,5000); 
        SampleComment$(configJoyYChannel%,"JoystikY");
        SampleTitle$(configJoyYChannel%,"JoystikY");
        'Read joystick offsets
        GetJoystickOffsets(0);  'there is only one joystick type for Recanzone and it is 0
        'Set additional info for joystick channels, notably offset
        SampleCalibrate(configJoyXChannel%,"volt",1,joystickXOffset);
        SampleCalibrate(configJoyYChannel%,"volt",1,joystickYOffset);
        
        'Create XY view for joystick display
        joyview% := FileNew(12);  'open an XY window
        'Create a new channel in the XY view to display the fixation point
        joydatachan% := XYSetChan(0);
        XRange(-2.75,2.75);  'set XRange
        YRange(-2,-2.75,2.75);  'set YRange, all visible channels
        XYDrawMode(0,5,0);  'turns off automatic axis range mode
        WindowVisible(1);  'make window visible
        'Window(75, 55, 100, 100); 'set to lower 16th of screen
        Window(0, 60, 40, 100); 'trying different position
        XYColour(joydatachan%,16);  'set a colo(u)r for joydatachan%
        XYSize(joydatachan%,-1); 'for channel joydatachan%, plot only one point at a time (-1)
    endif
    
    docase
    case recNBAKs% = 1 then
        ' Event channel 0 is for the first BAK
        SampleEvent(recBAK1Channel%, recBAK1Port%, 2, 100);  'create a level channel for the BAK, 100 Hz max sustained
        SampleTitle$(recBAK1Channel%, "BAK1");
        SampleComment$(recBAK1Channel%, "BAK1");
    case recNBAKs% = 2 and recUseJoystick% > 0 then  'If using joystick, there are ports for both BAKs
        ' Event channel 0 is for the first BAK
        SampleEvent(recBAK1Channel%, recBAK1Port%, 2, 100);  'create a level channel for the BAK, 100 Hz max sustained
        SampleTitle$(recBAK1Channel%, "BAK1");
        SampleComment$(recBAK1Channel%, "BAK1");
        ' Event channel 1 is for the second BAK
        SampleEvent(recBAK2Channel%, recBAK2Port%, 2, 100);  'create a level channel for the BAK, 100 Hz max sustained
        SampleTitle$(recBAK2Channel%, "BAK2");
        SampleComment$(recBAK2Channel%, "BAK2");
    case recNBAKs% = 2 and recUseJoystick% = 0 then  'If using lever, only the first BAK can be used, note this
        ' Event channel 0 is for the first BAK
        SampleEvent(recBAK1Channel%, recBAK1Port%, 2, 100);  'create a level channel for the BAK, 100 Hz max sustained
        SampleTitle$(recBAK1Channel%, "BAK1");
        SampleComment$(recBAK1Channel%, "BAK1");
        
        Message("The lever cannot be used with 2 BAKs!  Second BAK will not be used, lever should be in event port 1!");
    endcase
    
    
    ' Text marks
    SampleTextMark(200);  'set channel 30 as TextMark channel, 200 characters, which is max allowed by CED
    recChanTM% := 30;  'That's the TextMark channel --> this isn't used anywhere, it's just to remind us that channel 30 IS textmark (by default)
    '31 is keyboard input also
    
    if recExpToRun% = recExpLongToneButton% then
        ' Digital marker channel
        SampleDigMark(20);  '20 Hz should be plenty high for an expected sustained rate
        SampleTitle$(32,"ToneStartStop");  'Digital marker is by definition channel 32
    endif;
    
    
    ' Record sound output only on debug, it will inflate the file sizes...
    if recSoundRecording% = 1 then
        SampleWaveform(audioOutputCopyChannel%, 2, 100000);   'create a 100 kHz channel to record sound output (on testing only)
        SampleTitle$(audioOutputCopyChannel%, "Audio");
        SampleComment$(audioOutputCopyChannel%, "Audio");
    endif   
    
    ' Set up recording electrodes
    for i% := 0 to recNElectrodes%-1 do  'if recNElectrodes% is 0, this gloriously does nothing with no error!
        'SampleWaveform instead of WaveMark --> will have to filter but then we get LFP data too, which may be pretty cool!
        SampleWaveform(recTrodeChannel%[i%],recTrodePort%[i%], sampleRate%); 'channel#, port#, and "ideal" sampling rate
        thisTrodeString$ := "Trode " + Str$(recTrodePosition%[i%]);
        SampleTitle$(recTrodeChannel%[i%], thisTrodeString$); 'name Channel with actual trode position #
        SampleComment$(recTrodeChannel%[i%], thisTrodeString$); 'and comment Channel with Trode Position #
        '    printlog("thisTrodeString$ = " + thisTrodeString$ + "\n");   
    next;
    
    ' NOTE: wavemark channels must be b/w 1-100    
    'Actual sampling rate may vary! (constrained by hardware)
    
    'This bit hacked out, jj 11/6/2019
    '    ' Record as many electrodes as specified in Experiment Selection Dialog
    '    if recNElectrodes% = 2 then'IF 2 CHANNELS: assume you're Teeing off a single input channel to do wavemark & waveform!
    '        i%:=0; 'do channel 1
    '        SampleWaveMark(recTrodeChannel%[i%],recTrodePort%[i%], 100, 34, 15, sampleRate%); 'channel#, port#,sustained spike rate, points, pre-trigger, sampling rate
    '        thisTrodeString$ := "Trode " + Str$(recTrodePosition%[i%]);
    '        SampleTitle$(recTrodeChannel%[i%], "OnliWaveM"); 'name Channel with actual trode position #
    '        SampleComment$(recTrodeChannel%[i%], "Single trode: online wavemark"); 'and comment Channel with Trode Position #
    '        i%:=1; 'do channel 2
    '        SampleWaveform(recTrodeChannel%[i%],recTrodePort%[i%], sampleRate%); 'channel#, port#, and "ideal" samplig rate
    '        thisTrodeString$ := "Trode " + Str$(recTrodePosition%[i%]);
    '        SampleTitle$(recTrodeChannel%[i%], "Single trode"); 'name Channel with actual trode position #
    '        SampleComment$(recTrodeChannel%[i%], "Single trode: continuous record"); 'and comment Channel with Trode Position #
    '        
    '    else 
    '        if recNElectrodes% = 3 then'IF 3 CHANNELS: assume you're Teeing off a single input channel to do wavemark & waveform & an event channel
    '            '**** YOU'RE GOING TO NEED A MORE SOPHISTICATED WAY TO HANDLE THESE OPTIONS!!****
    '            i%:=0; 'do channel 1
    '            SampleWaveMark(recTrodeChannel%[i%],recTrodePort%[i%], 100, 34, 15, sampleRate%); 'channel#, port#,sustained spike rate, points, pre-trigger, sampling rate
    '            thisTrodeString$ := "Trode " + Str$(recTrodePosition%[i%]);
    '            SampleTitle$(recTrodeChannel%[i%], "OnliWaveM"); 'name Channel with actual trode position #
    '            SampleComment$(recTrodeChannel%[i%], "Single trode: online wavemark"); 'and comment Channel with Trode Position #
    '            i%:=1; 'do channel 2
    '            SampleWaveform(recTrodeChannel%[i%],recTrodePort%[i%], sampleRate%); 'channel#, port#, and "ideal" samplig rate
    '            thisTrodeString$ := "Trode " + Str$(recTrodePosition%[i%]);
    '            SampleTitle$(recTrodeChannel%[i%], "Single trode"); 'name Channel with actual trode position #
    '            SampleComment$(recTrodeChannel%[i%], "Single trode: continuous record"); 'and comment Channel with Trode Position #
    '            i%:=2; 'do channel 3 - event chan (TTL)
    '            SampleEvent(recTrodeChannel%[i%],1,1,1000); 'channel#, EVENT port#, 1=event on rising edge,max sustained event rate (Hz)
    '            thisTrodeString$ := "Trode " + Str$(recTrodePosition%[i%]);
    '            SampleTitle$(recTrodeChannel%[i%], "TTL in"); 'name Channel with actual trode position #
    '            SampleComment$(recTrodeChannel%[i%], "Single trode: TTL input"); 'and comment Channel with Trode Position #        
    '            
    '        else 'all waveform
    '            for i% := 0 to recNElectrodes%-1 do  'if recNElectrodes% is 0, this gloriously does nothing with no error!
    '                'ditch the case statements and loop it
    '                'SampleWaveform instead of WaveMark --> will have to filter but then we get LFP data too, which may be pretty cool!
    '                SampleWaveform(recTrodeChannel%[i%],recTrodePort%[i%], sampleRate%); 'channel#, port#, and "ideal" sampling rate
    '                thisTrodeString$ := "Trode " + Str$(recTrodePosition%[i%]);
    '                SampleTitle$(recTrodeChannel%[i%], thisTrodeString$); 'name Channel with actual trode position #
    '                SampleComment$(recTrodeChannel%[i%], thisTrodeString$); 'and comment Channel with Trode Position #
    '                '    printlog("thisTrodeString$ = " + thisTrodeString$ + "\n");   
    '            next;
    '        endif
    '    endif
    
    
    printlog("PLS file load success is %d\n",SampleSequencer(script$ + "recgen.pls")+1); 'Load sample sequencer script
    
    ' Set optimise mode (do this last). Settings specific to Power1401 625 (that's the "5"). 
    ' The second arg groups channels with same ideal rates together so they all get same 
    ' actual rate. That means multiple electrodes (if used) will all get same actual rate, 
    ' assuming you use same ideal rate (in SampleWavemark()). 
    ' Update: Optimization now done following poll of 1401 to determine what type of 1401 is present
    
	'SampleOptimise(2, 1, 5, 2, 50, -1, 1);  'Optimization settings, don't change unless there's an issue; turn burst mode on!!
    
    this1401Type% := Determine1401Type%();  'this1401Type% is used by Get1401Type%();
    SampleOptimise(2, 1, Get1401Type%(), 2, 50, -1, 1);  'Optimization settings using Get1401Type%; still turn burst mode on
    SampleMode(1);  'Continuous recording
end

' ========== end CreateSampleConfiguration ===============
'
'



'''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' InitializeWindows()
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc InitializeWindows()
    
    ' Since we are opening files here, set the path. 
    'FilePathSet(GetDataPath$(), 1, 1);  'Sets path for new data files
    FilePathSet(GetScratchPath$(), 1, 1);  'Sets path for new data files to scratch folder, alleviates SampleAutoCommit stutter
    'File will still be saved on data path in the end
    
    ' Open xy window for use in online display
    'Currently disabled because ExtractSpaceInitialize etc. are disabled, so it does nothing.  May
    'need to be brought back online earlier than ExtractSpace!
    'recXYWindowView% := FileNew(12);
	'Window(0, 50, 50, 100); 
	'View(recXYWindowView%).WindowVisible(1);
    
	'Open the data sampling window -- only if CED is present!
    if recCEDIsPresent% = 1 then
        recDataWindowView% := FileNew(0,4);
        printlog("Data window pointer is %d\n",recDataWindowView%);  'log the data window pointer
        if recDataWindowView% < 0 then
            printlog("FileNew appear to have broken with error: %s\n",Error$(recDataWindowView%));
        endif;
        Window(0, 0, 100, 50); 
        View(recDataWindowView%).WindowVisible(1);
        
        if recUseJoystick% = 0 then
            ' Create a memory channel for the debounced lever information
            recMemChanLeverDebounce% := MemChan(8,25); 'Create textmark channel for debounced lever with attached lever value, 25 characters
            ChanTitle$(recMemChanLeverDebounce%,"DBLever");  'Give it a title
            chanshow(recMemChanLeverDebounce%);  'Show it
        else
            CreateJoystickChannels%();
        endif;
        
    endif
    
end;




'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' InitializeToolbar - prepare toolbar buttons. Note that the idle processing function 
' (ToolbarSet(0, blah, blah)) is not set here. That's done when the user hits the start 
' button.
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc InitializeToolbar()
    
	View(App(8)).WindowVisible(0);	'Hide the standard sample bar
	ToolbarVisible(1);
	ToolbarSet(recStartButton%, "Start", Start%);
	ToolbarSet(recPauseButton%, "Pause", Pause%);
	ToolbarSet(recResumeButton%, "Resume", Resume%);
    ToolbarSet(recSelectNewExptButton%, "New Expt.", PrepToReturnToExptSelectDialog%);
	'ToolbarSet(recRewardButton%, "Reward", Reward%); 'use Timing/Reward button instead!
    ToolbarSet(recStopButton%, "Stop Sampling", Stop%);
    Toolbarset(recTimingRewardButton%, "Timing/Reward", CallTimingReward%);
    Toolbarset(recJoystickButton%, "Joystick", CallJoystick%);
    ToolbarSet(recCalibrationButton%, "Joystick Calibration", CalibrateJoystick%);  'automatic joystick calibration - make sure power is on to joystick
    
    ' Explicitly set enabled state of things...
    ToolbarEnable(recStartButton%, 1);
    ToolbarEnable(recPauseButton%, 0);
    ToolbarEnable(recResumeButton%, 0);
    ToolbarEnable(recSelectNewExptButton%, 1); 'set to 0 because doesn't work until after "Start" anyway  :( *jao - has to be 1 here to call window
    'ToolbarEnable(recRewardButton%, 1);
    ToolbarEnable(recStopButton%, 0);
    ToolbarEnable(recTimingRewardButton%, 0);
    ToolbarEnable(recJoystickButton%, 0);
    ToolbarEnable(recCalibrationButton%, 1);
    
end;




'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' GetPlayWaveKey$(index%)
' 
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func GetPlayWaveKey$(index%)
    
    return Chr$(Asc(recDAC0Key$)+index%);
    
end




'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' InitializePlayWaveAreas - add play wave areas for sounds. 
' Areas will be allocated in order: "A", "B", .... up to the
' max number of stimuli per trial.  We will reload each
' PlayWaveArea on a trial-by-trial basis, if necessary.
' Currently, the max number of stimuli per trial is hardcoded at 10
' 
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Proc InitializePlayWaveAreas()
    var st;
    var i%;
    
    
    for i% := 0 to recMaxPWA%-1 do
        
        st := PlayWaveAdd(GetPlayWaveKey$(i%), GetPlayWaveKey$(i%), recDAC0%, recPlayRateHz, recMaxPoints%);
        if st < 0 then
            Message("Error in PlayWaveAdd for area " + GetPlayWaveKey$(i%));
            halt;
        else
            PlayWaveTrigger(GetPlayWaveKey$(i%), 1);  'set playwave area to triggered mode
        endif        
        
    next
    
    
    
end


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' InitializePlayWaveAreaLongBB - add play wave area for Long Tone exps (BB noise only). 
' Area "N" only will be allocated.  It will be one second long.  We will set the value
' of PlayWaveCycles() to repeat the PWA until the full duration of the noise stimulus
' is complete.  We will reload the PlayWaveArea multiple times per trial if necessary
' (every second) WHILE IT IS PLAYING so that the noise does not repeat.
' 
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Proc InitializePlayWaveAreaLongBB()
'    var st;
'  
'    st := PlayWaveAdd("N", "N", recDAC0%, recPlayRateHz, recMaxLongNoisePoints%);
'    if st < 0 then
'        Message("Error in PlayWaveAdd for area " + GetPlayWaveKey$(0));
'        halt;
'    else
'        PlayWaveTrigger("N", 1);  'set playwave area to triggered mode
'    endif        
'        
'end


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' InitializePlayWaveAreasLongBP - add play wave areas for Long Tone exps (BP/BB noise only). 
' Areas will be allocated in order: "A", "B", "C", "D", "E" and will be the full duration
' of Long Noise stimuli.  
' 
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Proc InitializePlayWaveAreasLongBP()
    var st;
    var i%;
    var nPoints%;
    
    
    for i% := 0 to nLongTones%-1 do
        
        nPoints% := recPlayRateHz*(LongDurs[i%]+0.020);  'have to add in the ramp
        'Note here that the *PWAs* being initialized are capital letter PWAs, but that the jump points
        'that we assign to them in the sequencer code are lower case equivalents (capital jump points
        'are reserved for traditional model)
        st := PlayWaveAdd(GetPlayWaveKey$(i%), GetPlayWaveKey$(i%), recDAC0%, recPlayRateHz, nPoints%);
        if st < 0 then
            Message("Error in PlayWaveAdd for area " + GetPlayWaveKey$(i%));
            halt;
        else
            PlayWaveTrigger(GetPlayWaveKey$(i%), 1);  'set playwave area to triggered mode
        endif        
        
    next
    
    
    
end




'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' InitializeParallelPlayWaveAreas - add play wave areas for sounds, in order to play 2 sounds simultaneously. 
' Areas will be allocated in order: "A", "B", .... up to the
' max number of stimuli per trial.  We will reload each
' PlayWaveArea on a trial-by-trial basis, if necessary.
' Currently, the max number of stimuli per trial is hardcoded at 10
' 
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Proc InitializeParallelPlayWaveAreas()
    var st;
    var i%;
    var DACchannels%[2];
    
    DACchannels%[0] := RecDAC0%;
    DACchannels%[1] := RecDAC1%;
    
    for i% := 0 to 0 do
        
        st := PlayWaveAdd(GetPlayWaveKey$(i%), GetPlayWaveKey$(i%), DACchannels%, recPlayRateHz, recMaxPoints%);
        if st < 0 then
            Message("Error in PlayWaveAdd for area " + GetPlayWaveKey$(i%));
            halt;
        else
            PlayWaveTrigger(GetPlayWaveKey$(i%), 1); 'set playwave area to triggered mode
        endif
        
    next
    
end


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' InitializeMultipleParallelPlayWaveAreas - add play wave areas for sounds, in order to 
' play 2 sounds simultaneously, with more than one pair of sounds per trial
' Areas will be allocated in order: "A", "B", .... up to the
' max number of stimuli per trial.  We will reload each
' PlayWaveArea on a trial-by-trial basis, if necessary.
' Currently, the max number of stimuli per trial is hardcoded at 10
' 
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Proc InitializeMultipleParallelPlayWaveAreas()
    var st;
    var i%;
    var DACchannels%[2];
    
    DACchannels%[0] := RecDAC0%;
    DACchannels%[1] := RecDAC1%;
    
    for i% := 0 to recMaxPWA%-1 do  'hopefully 10 PWAs like this is not too many...
        
        st := PlayWaveAdd(GetPlayWaveKey$(i%), GetPlayWaveKey$(i%), DACchannels%, recPlayRateHz, recMaxPoints%);
        if st < 0 then
            Message("Error in PlayWaveAdd for area " + GetPlayWaveKey$(i%));
            halt;
        else
            PlayWaveTrigger(GetPlayWaveKey$(i%), 1); 'set playwave area to triggered mode
        endif
        
    next
    
end



'----------------- PlaySound ---------------------------------------------------------------
'
' PlaySound plays the sound for the trial number in recTrialOrder%[recCurrentTrial%].
' It sets the correct speaker and PA4 attenuation and logs a SampleText detailing the stimulus.
'
'-------------------------------------------------------------------------------------------

Func PlaySound%(isS2local%)
    var atten;
    var calatten;
    var trlatten;
    var s$;
    var playChar$;
    var spkr%;
    var playInd%;
    var status%;
    var isS2$;
    var thisStim%;  'this is the index of the physical stimulus (re: stim file list or stim properties list)
    var thisPWAIndex%;  'this is the PWA it will be found in on this trial
    var maxdB;
    var targdB;
    
    'Get index of current trial
    playInd% := recTrialOrder%[recCurrentTrial%-1];  'recCurrentTrial is in human units, convert to index units
    
    'Note that recStimCount% (which steps us through the n S1s and S2, if present, is incremented 
    'in StimComplete% and reset to zero in PrepareNewTrial%.
    
    'Get this PWA index
    thisPWAIndex% := recPWAList%[recStimCount%][playInd%];
    
    'Get this stimulus index
    thisStim% := recStimList%[thisPWAIndex%][playInd%];
    
    'Get play wave area with current stimulus
    'playChar$ := GetPlayWaveKey$(recStimCount%);  
    playChar$ := GetPlayWaveKey$(thisPWAIndex%);
    
    'Get speaker for current stimulus
    spkr% := recSpeakerList%[thisPWAIndex%][playInd%];
    
    
    'Get calibrating attenuation for current stimulus - this is the value to set a stimulus to 65 dB, by definition
    if recMatGenStim% = 0 then
        calatten := recTrialStimCal[thisStim%][spkr%-1];  'I think we have to label speakers 1:N, not 0:N-1, so adjusting that here
        'calatten := recAttenList%[recStimCount%][playInd%];  'value originally read from file
        'calatten := recAttenList%[thisStim%][playInd%];  'value originally read from file
    else
        'calatten := recGeneratedAtten[recStimCount%];  'value created at time of stimulus generation
        calatten := recGeneratedAtten[thisPWAIndex%];  'value created at time of stimulus generation
    endif;
    
    'Get trial-based attenuation for current stimulus
    trlatten := recDeltadBList[recStimCount%][playInd%];  'corresponds to recPWAList%[][], index the same way
    
    'Get total attenuation
    if recExpToRun% = recExpAudiogramButton% then
        printlog("cal atten is %f and current db is %f\n",calatten,recAudiogramCurrentdB);
        atten := 65 + calatten - recAudiogramCurrentdB;
        targdB := recAudiogramCurrentdB;  'convinced myself this is right
    else
        printlog("cal atten is %f and trial atten is %f\n",calatten,trlatten);
        atten := calatten + trlatten;  'for all other cases, attenuation is calibrating attenuation + trial attenuation
        targdB := 65 - trlatten;  'convinced myself this is right
    endif;
    
    'It is possible that due to the maximum intensity of the stimulus that the requested attenuation
    '(particularly in the audiogram) could be negative.  If so, we are screwed.  Set atten to 0 and point
    'this out to the user
    if atten < 0 then
        atten := 0;
        maxdB := 65 + calatten;
        if recExpToRun% = recExpAudiogramButton% then
            recAudiogramCurrentdB := maxdB;  'reset requested dB on audiogram to max allowed
            'Removing message box because it is causing issues with experimentation
            'message("dB requested is above maximum possible for this stim, has been set to %f",maxdB);
            printlog("dB requested is above maximum possible for this stim (%s), has been set to %f",NameThatStimulus$(thisStim%),maxdB);
        else
            'Removing message box because it is causing issues with experimentation
            'message("Requested attenuation was negative, has been reset to 0!");
            printlog("Requested attenuation (%f dB) was negative for this stimulus (%s), has been reset to 0!",calatten + trlatten,NameThatStimulus$(thisStim%));
        endif;
    endif;
    
    
    
    'Set some attenuation (30 db) during testing, just for the sake of our ears.
    'Once reclab_panstim starts returning a value here, we're in business
    'For now, don't set any attenuation if there is trial-based (e.g. intensity tuning) because
    'it would be useful to hear that.  If those are too loud, drop the atten=0 part and just dump
    '30 dB during the debug phase.  Might want to comment this all out once we're up and running
    'if atten = 0 and recDebug% > 0 then
    if recCalibIsPresent% = 0 then
        if recSearchStimType% = 3 then
            atten := 0;  'for clicks, don't attenuate
        else
            'atten := rand(4,30);  'To check that the PA4 is working properly, let's just set a new value every time
            atten := 30;  'temporary, during calibrations
        endif;
    endif;
    
    
    ' Set speaker and atten
    if recTDTIsPresent% = 1  and recCEDIsPresent% = 1 then
        status% := recSpeaker%(spkr%);
        if status% <> 0 then
            return status%;
        endif;
        
        'status% := recAtten%(atten);
        status% := recAttenByID%(atten,arrayPA4ID%);
        if status% <> 0 then
            return status%;
        endif;  
    endif;
    
    
    'This may not be terribly useful, stimulus ID might be helpful as well - but it's just a log and the sampletext is later
    'use trlatten for attenuation because calibrating attenuation isn't informative
    RecLogStatus("PlaySound", "SPK " + str$(spkr%) + " ATT " + str$(trlatten) + "\n");
    
    if recCEDIsPresent% = 1 then
        
        ' Send sample key for the play wave area. Sequencer Variable 3 holds the number of clock ticks at presentation
        SafeSampleKey(playChar$);
        StimOn := GetTimeOfLast1401Event();
        
        'determine S1/S2 status
        docase
        case isS2local% = 0 then
            isS2$ := "S1";   'indicates non-terminal S1, trial continues on CR, trial terminates on FA
        case isS2local% = 1 and (recExpToRun% = recExpAMDiscButton% or recExpToRun% = recExpSpaceDisButton% or recExpToRun% = recExpStereoDisButton%) then
            isS2$ := "S2H";   'Indicates S2-High, trial terminates on H/M, will be rewarded for H    
        case isS2local% = 1 then
            isS2$ := "S2";   'Indicates S2, trial terminates on H/M, will be rewarded for H
        case isS2local% = 2 then
            isS2$ := "S1T";  'indicates terminal S1, trial terminates on CR/FA, will be rewarded for CR
        case isS2local% = 3 then
            isS2$ := "S2L";  'indicates S2-Low, trial terminates on H/M, will be rewarded for H
        endcase
        
        
        
        'write stimulus to sampletext, we need to separate this out based on experiment type
        ' The sample text string contains the following (comma-separated) fields:
        ' 1. playChar: A for first stimulus in a trial, B for second, etc., up to J.
        ' 2. time: time of onset of stimulus
        ' 2. trial number: overall trial counter
        ' 3. speaker number
        ' 4. trial-based attenuation
        ' 5. freq for tone, filename for loaded stims.  (what's most appropriate for generated stims?) 
        '    this is actually a big question.  I think I'll want to have a function that simply determines 
        '    what the best "english" translation of the stimulus is...
        
        docase
        case recMatGenStim% = 0 then 'stimuli are read from a file
            's$ := Print$("\"%s\",%s,%d,%d,%.1f,\"%s\"", playChar$, isS2$, recCurrentTrial%, spkr%, trlatten, recTrialLoadLoc$[recPWAList%[recStimCount%][playInd%]]);
            's$ := Print$("\"%s\",%f,%s,%d,%d,%.1f,\"%s\"", playChar$, StimOn, isS2$, recCurrentTrial%, spkr%, trlatten, recTrialLoadLoc$[thisStim%]);
            s$ := Print$("Sound %s,%s,%d,%d,%.1f,%.1f,%s", playChar$, isS2$, recCurrentTrial%, spkr%, trlatten, targdB, recTrialLoadLoc$[thisStim%]);
            SampleText(s$, StimOn);
        case recMatGenStim% = 1 then 'stimuli are generated
            's$ := Print$("\"%s\",%s,%d,%d,%.1f,\"%s\"", playChar$, isS2$, recCurrentTrial%, spkr%, trlatten, NameThatStimulus$(recPWAList%[recStimCount%][playInd%]));
            's$ := Print$("\"%s\",%f,%s,%d,%d,%.1f,\"%s\"", playChar$, StimOn, isS2$, recCurrentTrial%, spkr%, trlatten, NameThatStimulus$(thisStim%));
            s$ := Print$("Sound %s,%s,%d,%d,%.1f,%.1f,%s", playChar$, isS2$, recCurrentTrial%, spkr%, trlatten, targdB, NameThatStimulus$(thisStim%));
            SampleText(s$, StimOn);
        endcase
        
    endif
    
    'Calculate the duration in points of the stimulus
    'recPlayPoints% := recPlayRateHz*recTrialDur[recPWAList%[recStimCount%][playInd%]]/1000;  'recTrialDur is in ms   
    recPlayPoints% := recPlayRateHz*recTrialDur[thisStim%]/1000;  'recTrialDur is in ms     
    
    return status%;
end

'----------------- PlayTwoSounds ---------------------------------------------------------------
'
' PlaySound plays the sound for the trial number in recTrialOrder%[recCurrentTrial%].
' It sets the correct speaker and PA4 attenuation and logs a SampleText detailing the stimulus.
'
'-------------------------------------------------------------------------------------------

Func PlayTwoSounds%(whichStim%)
    var attenArray;
    var attenArray2;  'not used, at least yet, pointing towards potential two-array usage
    var attenSA;  'standalone speaker, used for some situations
    var calattenArray;
    var calattenSA;
    var trlattenArray;  'necessary to printlog both trial-based attenuations near bottom of function, otherwise we could just reuse trlatten
    var trlattenSA;
    var s$;
    var s2$;
    var playChar$;
    var spkrArray%;
    var spkrArray2%;  'not used, at least yet, pointing towards potential two-array usage
    var playInd%;
    var status%;
    var thisStimArray%;  'this is the index of the physical stimulus (re: stim file list or stim properties list)
    var thisStimArray2%;  'not used, at least yet, pointing towards potential two-array usage
    var thisStimSA%;
    var isS2$;
    var targdBArray;
    var targdBSA;
    'var maxdB;  'This is not being used at all (it IS used in PlaySound), not a priority right now

    'Get index of current trial
    playInd% := recTrialOrder%[recCurrentTrial%-1];  'recCurrentTrial is in human units, convert to index units
    
    'Note that recStimCount% (which steps us through the n S1s and S2, if present, is incremented 
    'in StimComplete% and reset to zero in PrepareNewTrial%.
    
    
    
    docase
    case recExpToRun% = recExpFRAButton% then
        
        isS2$ := "FRA";
        
        'Get this stimulus index
        thisStimArray% := rec2StimList%[playInd%][0];
        
        'Get speaker for current stimulus
        spkrArray% := rec2SpeakerList%[playInd%][0];
        
        'Get calibrating attenuation for current stimulus - this is the value to set a stimulus to 65 dB, by definition
        calattenArray := recTrialStimCal[thisStimArray%][spkrArray%-1];  'I think we have to label speakers 1:N, not 0:N-1, so adjusting that here
        
        'Get trial-based attenuation for current stimulus
        trlattenArray := rec2DeltadBList[playInd%][0];  
        
        'Get total attenuation
        printlog("cal atten is %f and trial atten is %f\n",calattenArray,trlattenArray);
        attenArray := calattenArray + trlattenArray;  'for all other cases, attenuation is calibrating attenuation + trial attenuation
        
        'Get identity of stimulus on standalone as well, even though for now we're not actually playing anything
        thisStimSA% := rec2StimList%[playInd%][1];  
        
        'Get calibrating attenuation for current stimulus - this is the value to set a stimulus to 65 dB, by definition
        calattenSA := recTrialStimCal[thisStimSA%][0];  'There is only one standalone speaker, but the recTrialStimCal variable is a matrix for other code
        
        'Get trial-based attenuation for current stimulus
        trlattenSA := rec2DeltadBList[playInd%][1];
        
        attenSA := calattenSA + trlattenSA;  'for all cases, attenuation is calibrating attenuation + trial attenuation
        targdBSA := 65 - trlattenSA;  'convinced myself this is right
        
        'Get play wave area with current stimulus
        playChar$ := GetPlayWaveKey$(recFRAPWAIndex%);
        'printlog("Retrieved play wave key %s\n",playChar$);
        
    case recExpToRun% = recExpStereoDisButton% then         
        
        '''FOR DISTRACTOR, WHICH IS ON ARRAY
        'Get this stimulus index
        thisStimArray% := recDistractorStimList%[whichStim%][playInd%];
        
        'Get speaker for current stimulus
        spkrArray% := recDistractorSpeakerList%[whichStim%][playInd%];
        
        'Get calibrating attenuation for current stimulus - this is the value to set a stimulus to 65 dB, by definition
        if recMatGenStim% = 1 then
            calattenArray := recStereoDisGeneratedAttenList[whichStim%][0];
        else  'loading stimulus, cal value was in stimcal file
            printlog("CAL ATTEN INDICES ARE:  thisStimArray %d, sprkArray %d\n",thisStimArray%,spkrArray%-1);
            calattenArray := recTrialStimCalDistractor[thisStimArray%][spkrArray%-1];  'I think we have to label speakers 1:N, not 0:N-1, so adjusting that here
        endif
        
        'Get trial-based attenuation for current stimulus
        trlattenArray := recDistractorDeltadBList[whichStim%][playInd%];
        
        'Get total attenuation
        printlog("for distractor, cal atten is %f and trial atten is %f\n",calattenArray,trlattenArray);
        attenArray := calattenArray + trlattenArray;  'for all other cases, attenuation is calibrating attenuation + trial attenuation
        targdBArray := 65 - trlattenArray;  'convinced myself this is right
        
        'Get play wave area with current stimulus
        playChar$ := GetPlayWaveKey$(whichStim%);
        
        '''FOR S1, WHICH IS ON STANDALONE
        'Get this stimulus index
        thisStimSA% := recStimList%[whichStim%][playInd%];
        
        'S1/S2 are on standalone speaker by definition
        
        'Get calibrating attenuation for current stimulus - this is the value to set a stimulus to 65 dB, by definition
        if recMatGenStim% = 1 then
            calattenSA := recStereoDisGeneratedAttenList[whichStim%][1];
        else  'loading stimulus, cal value was in stimcal file
            calattenSA := recTrialStimCal[thisStimSA%][0];  'There is only one standalone speaker, but the recTrialStimCal variable is a matrix for other code
        endif;
        
        'Get trial-based attenuation for current stimulus
        trlattenSA := recDeltadBList[whichStim%][playInd%];
        
        attenSA := calattenSA + trlattenSA;  'for all cases, attenuation is calibrating attenuation + trial attenuation
        targdBSA := 65 - trlattenSA;  'convinced myself this is right
        
        'Get total attenuation
        docase
        case whichStim% = 0 then
            isS2$ := "S1";
            printlog("for S1, cal atten is %f and trial atten is %f\n",calattenSA,trlattenSA);
        case whichStim% = recTrialTerminalIndex%[playInd%] then
            isS2$ := "S2";
            printlog("for S2, cal atten is %f and trial atten is %f\n",calattenSA,trlattenSA);
        else
            isS2$ := "S1." + Str$(whichStim%);
            printlog("for S1.n #%d, cal atten is %f and trial atten is %f\n",whichStim%,calattenSA,trlattenSA);
        endcase;
        
        
        
    endcase
    
    'It is possible that due to the maximum intensity of the stimulus that the requested attenuation
    '(particularly in the audiogram) could be negative.  If so, we are screwed.  Set atten to 0 and point
    'this out to the user
    if attenArray < 0 then
        attenArray := 0;
        'maxdB := 65 + calatten;
        printlog("Requested attenuation (%f dB) was negative for this distractor stimulus (%s), has been reset to 0!",calattenArray + trlattenArray,recTrialLoadLocDistractor$[thisStimArray%]);    
    endif;
    if attenSA < 0 then
        attenSA := 0;
        'maxdB := 65 + calatten;
        printlog("Requested attenuation (%f dB) was negative for this S1/S2 stimulus (%s), has been reset to 0!",calattenSA + trlattenSA,recTrialLoadLoc$[thisStimSA%]);    
    endif;   
    
    'Set some attenuation (30 db) during testing, just for the sake of our ears.
    'Once reclab_panstim starts returning a value here, we're in business
    'For now, don't set any attenuation if there is trial-based (e.g. intensity tuning) because
    'it would be useful to hear that.  If those are too loud, drop the atten=0 part and just dump
    '30 dB during the debug phase.  Might want to comment this all out once we're up and running
    'if atten = 0 and recDebug% > 0 then
    if recCalibIsPresent% = 0 then
        attenArray := 30;  'temporary, during calibrations
        attenSA := 30;  'temporary, during calibrations
    endif;
    
    
    ' Set speaker and atten ---> These functions call to the PM1 and PA4 respectively so hopefully the second playwave area won't be a problem???
    if recCEDIsPresent% = 1 and recTDTIsPresent% = 1 then
        
        docase
        case recExpToRun% = recExpFRAButton% then
            status% := recSpeaker%(spkrArray%);
            if status% <> 0 then
                return status%;
            endif;
            
            status% := recAttenByID%(attenArray,arrayPA4ID%);
            if status% <> 0 then
                return status%;
            endif; 
            
            'Note that we are NOT setting any attenuation for the standalone speaker, so let's do it, even if we're only playing silence for right now
            if standalonePA4ID% > -1 then  'this should always be true...
                status% := recAttenByID%(attenSA,standalonePA4ID%);
                if status% <> 0 then
                    printlog("recAttenByID (Standalone) returned status of %d!! Failing!!\n",status%);
                    return status%;
                endif;
            endif;
            
            'This may not be terribly useful, stimulus ID might be helpful as well - but it's just a log and the sampletext is later
            'use trlatten for attenuation because calibrating attenuation isn't informative
            RecLogStatus("PlayTwoSounds", "SPK " + str$(spkrArray%) + " ATT " + str$(trlattenArray) + "\n");
            
        case recExpToRun% = recExpStereoDisButton% then
            status% := recSpeaker%(spkrArray%);
            if status% <> 0 then
                printlog("recSpeaker returned status of %d!! Failing!!\n",status%);
                return status%;
            endif;
            
            status% := recAttenByID%(attenArray,arrayPA4ID%);
            if status% <> 0 then
                printlog("recAttenByID (Array) returned status of %d!! Failing!!\n",status%);
                return status%;
            endif;
            
            if standalonePA4ID% > -1 then  'this should always be true...
                status% := recAttenByID%(attenSA,standalonePA4ID%);
                if status% <> 0 then
                    printlog("recAttenByID (Standalone) returned status of %d!! Failing!!\n",status%);
                    return status%;
                endif;
            endif;
            
            'This may not be terribly useful, stimulus ID might be helpful as well - but it's just a log and the sampletext is later
            'use trlatten for attenuation because calibrating attenuation isn't informative
            RecLogStatus("PlayTwoSounds", "SPK " + str$(spkrArray%) + " ATT S1/S2 " + str$(trlattenSA) + " ATT DISTRACTOR " + str$(trlattenArray) + "\n");
            
        endcase
        
    endif;
    
    
    
    
    if recCEDIsPresent% = 1 then
        'printlog("Sending SafeSampleKey %s at time %f\n",playChar$,seconds());
        ' Send sample key for the play wave area. Sequencer Variable 3 holds the number of clock ticks at presentation
        SafeSampleKey(playChar$);
        'printlog("SafeSampleKey has finished at time %f\n",seconds());
        
        '        StimOn := SampleSeqVar(3)*UsPerTime/1000000;  'Now, StimOn holds actual presentation time, usually
        '        printlog("Stim on (first try) at %f (SampleSeqVar3) and %f (system time)\n",StimOn,seconds());
        '        while StimOn = PrevSequencerTime do  'This will happen if the above line occurs before the stim starts
        '            yield(.001,1023);  'yield a millisecond until the stimulus starts playing
        '            StimOn := SampleSeqVar(3)*UsPerTime/1000000;  'Keep checking until StimOn is updated
        '            printlog("Stim on (subsequent try) at %f (SampleSeqVar3) and %f (system time)\n",StimOn,seconds());
        '        wend;          
        '        PrevSequencerTime := StimOn;  'keep track of most recent StimOn
        
        StimOn := GetTimeOfLast1401Event();
        
        'write stimulus to sampletext, we need to separate this out based on experiment type
        ' The sample text string contains the following (comma-separated) fields:
        ' 1. playChar: A for first stimulus in a trial, B for second, etc., up to J.
        ' 2. time: time of onset of stimulus
        ' 2. trial number: overall trial counter
        ' 3. speaker number
        ' 4. trial-based attenuation
        ' 5. freq for tone, filename for loaded stims.  (what's most appropriate for generated stims?) 
        '    this is actually a big question.  I think I'll want to have a function that simply determines 
        '    what the best "english" translation of the stimulus is...
        
        
        docase
        case recExpToRun% = recExpFRAButton% then
            s$ := Print$("Sound %s,%s,%d,%d,%.1f,%.1f,%s", playChar$, isS2$, recCurrentTrial%, spkrArray%, trlattenArray, targdBArray, recTrialLoadLoc$[thisStimArray%]);  
            s2$ := Print$("Sound2 %s,silence,%d,standalone,%.1f,%.1f,%s", playChar$, recCurrentTrial%, trlattenSA, targdBSA, recTrialLoadLoc$[thisStimSA%]); 'This is weird to point out "silence" but the placeholder might be useful in the future.        
        case recExpToRun% = recExpStereoDisButton% and recMatGenStim% = 1 then   
            s$ := Print$("Sound %s,%s,%d,standalone,%.1f,%.1f,%s", playChar$, isS2$, recCurrentTrial%, trlattenSA, targdBSA, NameThatStimulusStereoDis$(recStimList%[whichStim%][playInd%],whichStim%,playInd%));  
            s2$ := Print$("Sound2 %s,distractor,%d,%d,%.1f,%.1f,%s", playChar$, recCurrentTrial%, spkrArray%, trlattenArray, targdBArray, NameThatStimulusStereoDis$(recDistractorStimList%[whichStim%][playInd%],whichStim%,playInd%));  
        case recExpToRun% = recExpStereoDisButton% and recMatGenStim% = 0 then
            s$ := Print$("Sound2 %s,%s,%d,standalone,%.1f,%.1f,%s", playChar$, isS2$, recCurrentTrial%, trlattenSA, targdBSA, recTrialLoadLoc$[thisStimSA%]);
            s2$ := Print$("Sound %s,distractor,%d,%d,%.1f,%.1f,%s", playChar$, recCurrentTrial%, spkrArray%, trlattenArray, targdBArray, recTrialLoadLoc$[thisStimArray%]);  
        endcase            
        SampleText(s$, StimOn);
        if whichStim% > 1 then 'only sampletext the distractor stimulus if it is playing
            SampleText(s2$, StimOn+0.001);  'offset second Sampletext by 1 ms
        endif;
        
    endif
    
    'Calculate the duration in points of the stimulus 
    docase
    case recExpToRun% = recExpFRAButton% then
        recPlayPoints% := recPlayRateHz*recTrialDur[thisStimArray%]/1000;  'recTrialDur is in ms 
    case recExpToRun% = recExpStereoDisButton% then  
        recPlayPoints% := recPlayRateHz*recTrialDurDistractor[thisStimArray%]/1000;  'recTrialDur is in ms
    endcase
    
    return status%;
end





'----------- StimComplete%(isS2local%, success%) -------------------------------------
'
' Stimulus (not necessarily trial) has ended. isS2local% tells StimComplete% whether the 
' just-finished stimulus is an S1 (0), S2 (1), or terminal S1 (2). .. or S3 (3) *jao 
' success% tells the function whether the response was successful: 1=good, 0=bad.
' (Success on an S1 is no response, success on an S2 is response)
' Records text marker, does an analysis update using ExtractSpace. 
'
' A return value of -1 means an error has occurred, abort. 
' When isS2local%=0, return value of 0 means continue with S1 stims, return value of 1
' means move on to terminal S2 stim, return value of 2 means move on to terminal S1 stim.
' When isS2local%=1 the return value (unless it is negative) is ignored, but is set to 0, because
' the next stimulus will be an S1.
'
'--------------------------------------------------------------------------------

'Note that on 0,0 input, the current trial counter will be decremented and the interrupted trial will be shuffled in later.

func StimComplete%(isS2local%, success%)
    var status%;
    var strtmp$;
    var stimInd%;
    var termInd%;
    var now;
    var resultCode$;
    
    status% := 0;  'By default, we will assume the next stimulus will be an S1
    
    'Get index of current trial
    stimInd% := recTrialOrder%[recCurrentTrial%-1];  'recCurrentTrial is in human units, convert to index units
    docase
    case isS2local% = 0 then  'stimulus is S1, not terminal
        if success% = 1 then
            ' Record completed stim here, and update online analysis. 
            ' This will print the same output, e.g. "E,234" for each non-terminal S1 in trial 234, so there may be multiple sampletexts with the same entry
            resultCode$ := "E";  'E is for, I dunno, Early Correct Rejection?  (Keeping 'E' from original code)
            
        else 'false alarm on S1
            'trial counter will be decremented in the idle loop
            resultCode$ := "F";
        endif
    case isS2local% = 1 and (recExpToRun% = recExpAMDiscButton% or recExpToRun% = recExpSpaceDisButton%) then  'If it's an S2 (target), AMDis S2-HI *jao
        printlog("AMDis Hi!, current trial is %d\n", recCurrentTrial%); 
        if success% = 1 then
            resultCode$ := "HH";
        else
            resultCode$ := "MH";
        endif;
        
    case isS2local% = 1 and recExpToRun% = recExpStereoDisButton% then  'If this is the final stimulus in the Stereo Distractor experiment, S2 High
        printlog("Stereo Distractor FC Hi!, current trial is %d\n", recCurrentTrial%); 
        if success% = 1 then
            resultCode$ := "HH";
        else
            resultCode$ := "MH";
        endif;
        
    case isS2local% = 1 then  'If it's an S2 (target) - (SAME/DIFF)
        if success% = 1 then
            resultCode$ := "H";
        else
            resultCode$ := "M";
        endif;
        
    case isS2local% = 3 and (recExpToRun% = recExpAMDiscButton% or recExpToRun% = recExpSpaceDisButton%) then  'If it's an S2 (target) 'AMDis S2-LO *jao - case is unique to AMDis and SpaceDis
        printlog("AMDis Lo!, current trial is %d\n", recCurrentTrial%);
        if success% = 1 then
            resultCode$ := "HL";
        else
            resultCode$ := "ML";
        endif;
        
    case isS2local% = 3 and recExpToRun% = recExpStereoDisButton% then  'If this is the final stimulus in the Stereo Distractor experiment, S2 Low
        printlog("Stereo Distractor FC Low!, current trial is %d\n", recCurrentTrial%); 
        if success% = 1 then
            resultCode$ := "HL";
        else
            resultCode$ := "ML";
        endif;
        
    case isS2local% = 2 and (recExpToRun% = recExpAMDiscButton% or recExpToRun% = recExpSpaceDisButton%) then 'If it's a terminal S1 (intended no-response in gonogo) 'AMDis Hi/Lo case *jao
        printlog("AMDis SAME!, current trial is %d\n", recCurrentTrial%); 
        'we want to know if they went up or down!! (and also if rewarded, but need to know behavior too!!
        if success% = 1 then 'for HI/LO, success=1 means this trial was rewarded (coinFlipResult%) *jao
            resultCode$ := "SR";
        else
            resultCode$ := "SN";
        endif;
        
    case isS2local% = 2 and recExpToRun% = recExpStereoDisButton% and recStereoDisExpDoFC% = 1 then  'If this is the final stimulus in the Stereo Distractor FC experiment, S2 Same
        printlog("Stereo Distractor FC Low!, current trial is %d\n", recCurrentTrial%); 
        if success% = 1 then '1 indicates response was S2 High, 0 indicates response was S2 Low
            resultCode$ := "SH";  'Same, response was high
        else
            resultCode$ := "SL";  'Same, response was low
        endif;       
        
    case isS2local% = 2 then 'If it's a terminal S1 (intended no-response)  - (SAME/DIFF)
        if success% = 1 then
            resultCode$ := "C";
        else
            resultCode$ := "F";
        endif;
    else
        RecLogError("StimComplete", "Unknown ttype (" + str$(isS2local%) + ")");
        status% := -1;  'Status update to indicate an error in the arguments to StimComplete%()
    endcase
    
    'Write sample text 
    if isS2local% = 0 then  'trial is not over, just the stimulus is over
        if recExpToRun% = recExpAudiogramButton% then
            strtmp$ := Print$("EndStim %d,%d,%s,%f", recStimCount%,recCurrentTrial%, resultCode$, recAudiogramPreviousdB);  'use previous dB, current dB is already updated
        else
            strtmp$ := Print$("EndStim %d,%d,%s", recStimCount%,recCurrentTrial%, resultCode$);
        endif;
    else 'Trial is over
        if recExpToRun% = recExpAudiogramButton% then
            strtmp$ := Print$("EndTrial %d,%s,%f", recCurrentTrial%, resultCode$, recAudiogramPreviousdB);  'use previous dB, current dB is already updated
        else
            strtmp$ := Print$("EndTrial %d,%s", recCurrentTrial%, resultCode$);
        endif;
    endif;
    SampleText(strtmp$, recPreciseTrialTime);  'This puts the sampletext at the time of the response (or, if no response, at the time we noticed the end of the stimulus)
    
    
    'call BehOutput now, do not increment StimCounter until AFTER call to BehOutput!!!
    if recLogThisResult% = 1 then  'this value will be 1 and not be changed if we are not doing an audiogram - so basically always log, unless audiogram, in which case maybe log
        BehOutput(resultCode$, isS2local%);
    endif;
    
    
    'Update status% 
    if isS2local% = 0 and success% = 1 and status% = 0 then  'stimulus is S1, not terminal, no error in args to StimComplete%()
        'Increment within-trial stimulus counter, if we've played all the S1s, return 1 if playing the S2 or 2 if playing a terminal S1
        recStimCount% += 1;  
        termInd% := recTrialTerminalIndex%[stimInd%];  'terminal index
        if termInd% = recStimCount% then 'if the next stimulus is the terminal stimulus
            docase 'This works for StereoDis as well as AMDis
            case recTrialTerminalIsS2%[stimInd%] = 1 then 'terminal stimulus is a target ; for AMDis is(HI) recTrialS2%[i%] > recTrialS1%[i%] 
                status% := 1;  'return indicates S2 is next (S2-HI if AMDis, StereoDis)
            case recTrialTerminalIsS2%[stimInd%] = 2 then 'terminal stim in a target (LO) recTrialS2%[i%] < recTrialS1%[i%] *jao 
                printlog("AMDis Lo: next stim will be a decrease in AMrate, responseMode:=3 \n"); 
                status% := 3;  'return indicates S2-LO is next
            else
                status% := 2;  'return indicates terminal S1 is next 'For AMDis(now Hi/Lo) this would-be-catch trial will be rewarded 50% *jao
            endcase;
            'otherwise, return is 0 indicating non-terminal S1
        endif;
    endif;
    
    
    return status%;
    
    
    
    
end


'----------- fraStimComplete%() -------------------------------------
'
' Stim has ended. For FRA, the point of this function is to log stimulus via BehOutput. 
'
'--------------------------------------------------------------------------------

func fraStimComplete%()
    var status% := 0;
    var isS2local% := 0;
    var strtmp$;
    var stimInd%;
    var termInd%;
    var now;
    var resultCode$;
    
    'Get index of current trial
    stimInd% := recTrialOrder%[recCurrentTrial%-1];  'recCurrentTrial is in human units, convert to index units
    
    'strtmp$ := Print$("This is a test: trial ,%d", recCurrentTrial%); 
    'strtmp$ := Print$("EndTrial %d,%s", recCurrentTrial%, resultCode$);  'there is no resultCode$!!!
    strtmp$ := Print$("EndTrial %d", recCurrentTrial%);
    
    'SampleText(strtmp$, StimOn);
    SampleText(strtmp$, StimStopped);
    BehOutput(resultCode$, isS2local%);  'this would be empty,0 - that's not useful.  I'll let this stand as current analysis may expect it, but whatever. -jj 12/2019
    
    return status%;
    
    
end



'''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' Start%()
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Start%()
    
    ' Disable start button, enable stop and pause
    view(recLog%).print("In Start%(). About to enable Toolbar.\n");
    ToolbarEnable(recStartButton%, 0);
    ToolbarEnable(recStopButton%, 1);
    ToolbarEnable(recPauseButton%, 1);
    ToolbarEnable(recTimingRewardButton%, 1);
    ToolbarEnable(recJoystickButton%, 1);
    ToolbarEnable(recSelectNewExptButton%, 1); 'enable it here because I disabled it before - :( *jao - button doesn't work after Start!
    view(recLog%).print("Toolbar Enabled.\n");
    
    ' Start the sampling.
    docase    
    case recCEDIsPresent% = 1 and recCurrentlySampling% = 0 then
        view(recLog%).print("CED is present. About to start sampling.\n");
        SampleStart();
        ToolbarText("Sampling started.");  ' Tell the world about it. 
        printlog("Sampling started\n");  ' Tell her about it, tell her everything you feel
        view(recLog%).print("Sampling started.\n");
        recCurrentlySampling% := 1;  'don't start sampling again
        SequencerPeriodMS := SampleSeqClock(1);  'Get the clock period of the sequencer, in MS, must do this after starting sampling
        TimePerADC := SampleTimePerAdc();  'get AD conversion rate
        UsPerTime := SampleUsPerTime();  'get # of microseconds per sample
        SecPerSample := TimePerADC*UsPerTime/1000000; 'get seconds per sample
        SampleText(recExptText$+"Block: "+blockTag$);  'put in the experiment type
        Yield(0.10);
        WriteExpParamsSampleText();  'Write a ton of parameters
        startingNewExpt% := 1;  'should be OK to start here
    case recCEDIsPresent% = 1 and recCurrentlySampling% = 1 then
        'if already sampling still want some of this stuff to happen!
        SampleText(recExptText$+"Block: "+blockTag$);  'put in the experiment type
        Yield(0.10);
        WriteExpParamsSampleText();  'Write a ton of parameters
        startingNewExpt% := 1;  'this allows a reset of joystick event checking
    case recCEDIsPresent% = 0 and recCurrentlySampling% = 0 then
        'virtually start sampling
        recCurrentlySampling% := 1;
        printlog("'Fake Sampling' started\n");  ' Tell her about it, tell her everything you feel
        'SampleText(recExptText$+"_"+blockTag$);  'WTF?  Can't SampleText if you're not sampling and there's no 1401!
        startingNewExpt% := 1;  'this allows a reset of joystick event checking
    endcase
    
    ' Set idle function
    ToolbarSet(0, "", IdleLoop%);
    
    ' Set iState to start
    iState% := stateStart%;    
    
    return 1;
end





'''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' Stop%() - stops sampling
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Stop%()
    PrintLog("Stop called\n");
    PrintLog("#HITS = " + str$(numHits%) + ",   #MISSES = " + str$(numMisses%) + ",   #FPs = " + str$(numFPs%) + ",   LastHitReward(mL) = " + str$(LastHitReward) + ",   TOTAL Juice(mL) = " + str$(amountRewarded) + ".\n");            
    
    recCurrentlySampling% := 0;    
    
    ' Stop sampling....
    if SampleStatus() <> -1 then
        
        if recExpToRun% = recExpLongToneButton% then
            SampleKey("t");  'Stop playing sound (should already be stopped unless we are stopping it in the middle of a tone)
        else
            SafeSampleKey("S");  'Kill blink sequence, if one exists - when does this happens? think about making it not safe ~jao
            SafeSampleKey("K");  'Kill reward, just in case, only relevant if CED is being used
        endif;
        
        
        var retVal2%;
        retVal2% := SampleStop();
        printlog("SampleStop returned %d\n",retVal2%);
        view(recLog%).print("SampleStop returned %d\n",retVal2%);
        if retVal2% < 0 then
            printlog("Samplestop error is %s\n",Error$(retVal2%));
            view(recLog%).print("Samplestop error is %s\n",Error$(retVal2%));
        endif;
        
        View(recDataWindowView%);  'Explicitly set view
        'FileSaveAs(recFileSaveLoc$ + recMonkPrefix$ + ".smr", -1); 'Save data file automagically 
        FileSaveAs(recFileSaveLoc$ + recMonkPrefix$ + "_"+ Date$(2,2,3,3,"-")+ blockTag$ + ".smr", -1); 'NEW FORMAT! add date automagically! 
        
    endif
    
    ' Returning zero from here or any ToolbarSet() functions causes the 
    ' Toolbar() function to return.
    recReadyToQuit% := 1;  'prevent from trying to open another experiment
    return 0;
    
end



'''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' PrepToReturnToExptSelectDialog%() - sets idle loop to return
' to experiment selection dialog when the current trial is complete
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func PrepToReturnToExptSelectDialog%()
    RTESDIsPressed% := 1;
    return 1;  '<-------  This missing line cost me literally like 50 hours to track down.
end;


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' ReturnToExptSelectDialog%() - continues sampling, but opens expt. selection dialog
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func ReturnToExptSelectDialog%()
    PrintLog("Return to Expt. Selection Dialog called\n"); 
    
    'Reset appropriate variables
    recCurrentTrial% := 0;  'start with trial #1
    recSearchLoaded% := 0;  'Need to reset recSearchLoaded, or load will be skipped even for non-search scenarios
    RTESDIsPressed% := 0;
    recExptText$ := "";
    recIsPaused% := 0;      ' djs - if pause, then hit "new expt", this must be set back to zero or the idle loop
    ' will still think you're paused!
    
    'Unset the idle function, so things don't start moving immediately when the Toolbar is next called
    'ToolbarSet(0, "");
    
    ' This causes the Toolbar() to return
    return 0;
    
    
end


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' Pause%()
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Pause%()
    PrintLog("Pause called\n");
    recIsPaused% := 1;
    if iState% = stateCEDBlinking% then  'If we call a pause while CED is blinking, we need to step back a state and restart that blink when we leave the pause
        SampleKey("S");  'Stop flash sequence if we are flashing
        ChangeStateTo(stateStartCEDBlink%);  'Allow restart of flash sequence when we exit Pause if we were flashing
    endif;
    ToolbarEnable(recResumeButton%, 1);
    ToolbarEnable(recPauseButton%, 0);
    return 1;
end






'''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' Resume%()
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Resume%()
    PrintLog("Resume called\n");
    recIsPaused% := 0;
    ToolbarEnable(recResumeButton%, 0);
    ToolbarEnable(recPauseButton%, 1);
    return 1;
end





'''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' CallTimingReward%()
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func CallTimingReward%()
    PrintLog("Pause called to bring up Timing/Reward Dialog\n");
    recIsPaused% := 1;
    if iState% = stateCEDBlinking% then  'If we call a pause while CED is blinking, we need to step back a state and restart that blink when we leave the pause
        SampleKey("S");  'Stop flash sequence if we are flashing
        ChangeStateTo(stateStartCEDBlink%);  'Allow restart of flash sequence when we exit Pause if we were flashing
    endif;
    recRunTimeCall% := 1;
    recWhichDialogCalled% := 1;  '1 is for timing/reward
    'Don't let nobody do nothing! (start and resume are already disabled)
    ToolbarEnable(recPauseButton%, 0);
    ToolbarEnable(recSelectNewExptButton%, 0);
    '    ToolbarEnable(recRewardButton%, 0);
    ToolbarEnable(recStopButton%, 0);
    ToolbarEnable(recTimingRewardButton%, 0);
    ToolbarEnable(recJoystickButton%, 0);
    return 1;
end





'''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' CallJoystick%()
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func CallJoystick%()
    PrintLog("Pause called to bring up Joystick Properties Dialog\n");
    recIsPaused% := 1;
    if iState% = stateCEDBlinking% then  'If we call a pause while CED is blinking, we need to step back a state and restart that blink when we leave the pause
        SampleKey("S");  'Stop flash sequence if we are flashing
        ChangeStateTo(stateStartCEDBlink%);  'Allow restart of flash sequence when we exit Pause if we were flashing
    endif;
    recRunTimeCall% := 1;
    recWhichDialogCalled% := 2;  '2 is for joystick
    'Don't let nobody do nothing! (start and resume are already disabled)
    ToolbarEnable(recPauseButton%, 0);
    ToolbarEnable(recSelectNewExptButton%, 0);
    '   ToolbarEnable(recRewardButton%, 0);
    ToolbarEnable(recStopButton%, 0);
    ToolbarEnable(recTimingRewardButton%, 0);
    ToolbarEnable(recJoystickButton%, 0);
    return 1;
end



'''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' ReturnFromDialogCall%()
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func ReturnFromDialogCall%()
    recRunTimeCall% := 0;  'reset RunTimeCall
    recIsPaused% := 0;  'set it free
    recWhichDialogCalled% := 0;  'no dialog called anymore
    'reenable appropriate buttons
    ToolbarEnable(recPauseButton%, 1);
    ToolbarEnable(recSelectNewExptButton%, 1);
    '    ToolbarEnable(recRewardButton%, 1);
    ToolbarEnable(recStopButton%, 1);
    ToolbarEnable(recTimingRewardButton%, 1);
    ToolbarEnable(recJoystickButton%, 1);
    return 1;
end




'''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' Reward%()
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Reward%()
    ' This function is now used for all reward!
    var stmp%;
    var tStart;
    var tNow;
    var data%[10];  'oversized for readTDTreply%
    var temp%;
    var s;
    
    stmp% := recReward%(recRewardMs%,recJuiceToStimDelay%,recCurrentRewardType%,0);
    
    return stmp%;  'return 0 on success
end





''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' 
' ChangeStateTo
' 
' Call this function on exit from a state. The var stateTo% should be the state to enter
' on the next call to the loop function. 
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc ChangeStateTo(stateTo%)
	iState% := stateTo%;
    nextStateImmed% := 1;  'nothing to wait for
    if recCEDIsPresent% = 1 then
        tStateStart := View(recDataWindowView%).MaxTime();
    else
        tStateStart := tNow;
    endif
end;





''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' 
' RecLogStatus
' 
' Utility to write msg to log window. Will not write if rgDebug is not set. 
' Like 
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc RecLogStatus(stateName$, msg$)
    'if recDebug% > 0 then
    PrintLog("S:    " + stateName$ + "  Tstart: " + str$(tStateStart) + " " + msg$ + "\n");
    'endif
end



''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' 
' RecLogStatusSpecificTime
' 
' Utility to write msg to log window.  Will use specified time rather than tStareStart
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc RecLogStatusSpecificTime(stateName$, msg$, tNow)
    'if recDebug% > 0 then
    PrintLog("S:    " + stateName$ + "  Tstart: " + str$(tNow) + " " + msg$ + "\n");
    'endif
end




''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' 
' RecLogError
' 
' Like RecLogStatus, a utility to write msg to log window. 
' Unlike RecLogStatus, RecLogError will write no matter what - regardless of rgDebug value.
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc RecLogError(stateName$, msg$)
    PrintLog("ERROR===============================================\n");
    if stateName$ = "" then
        PrintLog(msg$ + "\n");
    else
        PrintLog("S:    " + stateName$ + "  Tstart: " + str$(tStateStart) + " " + msg$ + "\n");
    endif
    PrintLog("====================================================\n");
end





''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' 
' RecLogInfo
' 
' Like RecLogStatus, a utility to write msg to log window. 
' Unlike RecLogStatus, RecLogInfo will write no matter what - regardless of rgDebug value.
' Although as of 5/24/2012 it's not ever used.  Oh well.
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc RecLogInfo(msg$)
    PrintLog("INFO " + msg$ + "\n");
end




func PrepareLongTone()
    'This function does nothing but use Matlab to calculate and return the required attenuation for the
    'long tone stimulus.  Since all long tones are the same frequency, we only call it once.
    var atten;
    var matPutOK% := 0;
    var matGetAttenOK%;
    
    if recCalibIsPresent% = 1 then
        'Use speaker calibration to determine attenuation
        matPutOK% := matPutOK% + PutMatlabValueFloat%("fs",recPlayRateHz);  'on any fail, matPutOK% will increment (negative ones)
        matPutOK% := matPutOK% + PutMatlabValueFloat%("dur",500);  'duration doesn't matter, but it is in MILLISECONDS
        matPutOK% := matPutOK% + PutMatlabValueFloat%("lohz",recLongToneFreq);  'Set tone frequency
        matPutOK% := matPutOK% + PutMatlabValueFloat%("hihz",recLongToneFreq);  'Ditto
        matPutOK% := matPutOK% + PutMatlabValueFloat%("issweep",0);
        matPutOK% := matPutOK% + PutMatlabValueFloat%("amfreq",0);
        matPutOK% := matPutOK% + PutMatlabValueFloat%("amdepth",1);
        matPutOK% := matPutOK% + PutMatlabValueFloat%("amphase",0);
        matPutOK% := matPutOK% + PutMatlabValueFloat%("tonephase",0);
        matPutOK% := matPutOK% + PutMatlabValueFloat%("gauss",0);  
        matPutOK% := matPutOK% + PutMatlabValueFloat%("ramp",0);
        matPutOK% := matPutOK% + PutMatlabValueInt%("seed",0);  
        matPutOK% := matPutOK% + PutMatlabValueInt%("pad",recMaxPoints%);
        matPutOK% := matPutOK% + PutMatlabValueInt%("spk",recLongToneSpeaker%);
        
        if matPutOK% < 0 then 'error in at least one matlab put operation - not sure what to do (try again, quit?)
            message("There has been an error in sending data to Matlab!  Quitting!");
            recReadyToQuit% := 1;  'This will allow the entire thing to quit
            SafeSampleKey("M");  'Turn off LED
            Stop%();
            return -1;
        endif;
        
        
        statement$ := "[stimulus atten] = reclab_panstim(dur,fs,lohz,hihz,issweep,amfreq,amdepth,amphase,tonephase,gauss,ramp,seed,pad,AFFT(1,spk));";  'this is for the FFT filtering method
        'statement$ := "[stimulus atten] = reclab_panstim(dur,fs,lohz,hihz,issweep,amfreq,amdepth,amphase,tonephase,gauss,ramp,seed,pad,AFilt(1,spk));";  'this is for the standard filtering method
        EvalMatlabStatement%(statement$);  'Fills atten on matlab side, also creates stimulus but we don't care
        matGetAttenOK% := GetMatlabValueFloat%("atten",atten);  'This is the expected attenuation for 65 dB
        atten := atten + 65 - recLongToneTargetdB;  'Adjust attenuation to produce requested intensity
        if recLongToneTargetdB <> 65 then
            printlog("Calculated attenuation to produce %f dB is %f/n",recLongToneTargetdB,atten);
        endif;
        docase
        case atten < 0 then
            atten := 0;
            message("Requested intensity is louder than max intensity for this tone, setting attenuation to 0!");
        case matGetAttenOK% < 0 then 'error
            message("There has been an error in getting atten data from Matlab, setting to 20 dB arbitrarily!");
            atten := 20;  'set atten to 20 arbitrarily
        endcase;
    else
        atten := 20;  'Guessing!
    endif;
    
    
    return atten;    
end


'This function is part of the "clever" mechanism which would cycle through the PWA multiple times, re-writing
'new noise samples every cycle (at a relatively early but random location in the cycle) and taking advantage of
'the fact that while a PWA is playing, you can overwrite with no ill consequences; the overwrite is faster than
'the play speed, and so when the overwrite passes the point of play the sound just "seamlessly" switches over.
'This worked GREAT for broadband noise, with the caveat that calibration is a bit more variable on Gaussian
'noise than it is on uniform noise, so we had to find an "average" value to set the PA5 to (PA5 setting cannot
'be done on the fly, unlike the PWA overwrite).  Unfortunately, this did NOT work great for bandpass noise. The
'short explanation is that broadband noise is effectively a continuous series of "clicks" as it contains
'frequencies about the Nyquist.  One click is as good as another, or in words of wisdom, "You can't fool me,
'it's clicks all the way down!"  The transition is by definition unnoticeable.  But for our bandpass noise, the
'sound is filtered below the Nyquist, so if you zoom in on it, it is actually smooth.  Switching from one 
'bandpass sound to the next (and restarting the cycle on the PWA, for that matter) introduced a discontinuity,
'and, bam! a click every second.  So much for that.  And as long as we're developing a new method for doing BP
'sounds, we may as well do BB sounds in exactly the same way.
'func PrepareLongNoise(overwritePWA%)
'    var atten;
'    var matPutOK% := 0;
'    var matGetStimOK%;
'    var matGetAttenOK%;
'    var playWaveCopyOK%;
'    var pwChar$;
'    var lndur;
'    var lnpad%;
'    
'    
'    
'    if recCalibIsPresent% = 1 and recMatlabIsPresent% = 1 and recCEDIsPresent% = 1 then  'if there is no calibration/matlab/CED, we can't do this
'        'Get play wave area, hint it's "N"
'        pwChar$ := "N";
'        
'        'Set recStimTransfer%[] to zeros
'        arrconst(recStimTransferLongNoise%[],0);  
'                
'        if recLongToneDuration >= 1 then
'            lndur := 1000;  'We will do 1 second (1000 ms) and repeat
'            lnpad% := 0;  'Do not pad, sound is correct length
'        else
'            lndur := recLongToneDuration*1000;  'Actual duration, expected to be 0.1 seconds, but it's possible the values get changed
'            lnpad% := recMaxLongNoisePoints%;  'pad to correct length
'        endif;
'        
'        
'        'Use speaker calibration to determine attenuation
'        matPutOK% := matPutOK% + PutMatlabValueFloat%("fs",recPlayRateHz);  'on any fail, matPutOK% will increment (negative ones)
'        matPutOK% := matPutOK% + PutMatlabValueFloat%("dur",lndur);  'duration of one second precisely, as this is the size of the PWA (except for 0.1 second sound)
'        matPutOK% := matPutOK% + PutMatlabValueFloat%("lohz",recLongToneBPLow);  'Set BP noise low limit, if broadband, value is already correctly set to -1
'        matPutOK% := matPutOK% + PutMatlabValueFloat%("hihz",recLongToneBPHigh);  'Ditto
'        matPutOK% := matPutOK% + PutMatlabValueFloat%("issweep",0);
'        matPutOK% := matPutOK% + PutMatlabValueFloat%("amfreq",0);
'        matPutOK% := matPutOK% + PutMatlabValueFloat%("amdepth",0);
'        matPutOK% := matPutOK% + PutMatlabValueFloat%("amphase",0);
'        matPutOK% := matPutOK% + PutMatlabValueFloat%("tonephase",0);
'        matPutOK% := matPutOK% + PutMatlabValueFloat%("gauss",99);  'Hardcode Gaussian with 99th percentile cutoff
'        matPutOK% := matPutOK% + PutMatlabValueFloat%("ramp",0);
'        matPutOK% := matPutOK% + PutMatlabValueInt%("seed",0);  
'        matPutOK% := matPutOK% + PutMatlabValueInt%("pad",lnpad%); 
'        matPutOK% := matPutOK% + PutMatlabValueInt%("spk",recLongToneSpeaker%);
'        
'        if matPutOK% < 0 then 'error in at least one matlab put operation - not sure what to do (try again, quit?)
'            message("There has been an error in sending data to Matlab!  Quitting!");
'            recReadyToQuit% := 1;  'This will allow the entire thing to quit
'            SafeSampleKey("M");  'Turn off LED
'            Stop%();
'            return -1;
'        endif;
'        
'        'printlog("fs %f, dur %f, lohz %f, hihz %f, pad %d, spk %d\n",recPlayRateHz,lndur,recLongToneBPLow,recLongToneBPHigh,lnpad%,recLongToneSpeaker%);
'        
'        statement$ := "[stimulus atten] = reclab_panstim(dur,fs,lohz,hihz,issweep,amfreq,amdepth,amphase,tonephase,gauss,ramp,seed,pad,AFFT(1,spk));";  'this is for the FFT filtering method
'        'statement$ := "[stimulus atten] = reclab_panstim(dur,fs,lohz,hihz,issweep,amfreq,amdepth,amphase,tonephase,gauss,ramp,seed,pad,AFilt(1,spk));";  'this is for the standard filtering method
'        EvalMatlabStatement%(statement$);  'Fills atten on matlab side, also creates stimulus but we don't care
'        
'        'Get stim and atten back from Matlab
'        matGetStimOK%:= GetMatlabValueIntArray%("stimulus",recStimTransferLongNoise%[]);
'        matGetAttenOK% := GetMatlabValueFloat%("atten",atten);  'This is the expected attenuation for 65 dB
'        
'        'printlog("atten is %f\n",atten);
'      
'        atten := atten + 65 - recLongToneTargetdB;  'Adjust attenuation to produce requested intensity
'        if recLongToneTargetdB <> 65 then
'            printlog("Calculated attenuation to produce %f dB is %f\n",recLongToneTargetdB,atten);
'        endif;
'        
'        docase
'        case matGetStimOK% < 0 then 'error
'            message("There has been an error in getting stimulus data from Matlab!");
'        case atten < 0 then
'            atten := 0;
'            message("Requested intensity is louder than max intensity for this tone, setting attenuation to 0!");
'        case matGetAttenOK% < 0 then 'error
'            message("There has been an error in getting atten data from Matlab, setting to 20 dB arbitrarily!");
'            atten := 20;  'set atten to 20 arbitrarily
'        endcase;
'        
'        if overwritePWA% <= 1 then  'if 0/1, actually fill PWA.  If 2, we just want the atten value.
'            playWaveCopyOK% := PlayWaveCopy(pwChar$, recStimTransferLongNoise%[]); 
'            if playWaveCopyOK% < 0 then 'error
'                message("There has been an error in PlayWaveCopy!  Check Log File!");
'                printlog("There was an error in PlayWaveCopy!  The error is number %d and the text of the error is '%s'\n",playWaveCopyOK%,Error$(playWaveCopyOK%));
'            endif;
'        endif;
'        
'        if overwritePWA% = 0 then
'            SafeSampleKey("X");  'only put in delay on first load, on subsequent loads we will already be playing
'        endif;
'       
'        
'    else
'        message("Matlab/CED/Calibration values are necessary for Long Noise!  Quitting!");
'        recReadyToQuit% := 1;  'This will allow the entire thing to quit
'        SafeSampleKey("M");  'Turn off LED
'        Stop%();
'        return -1;
'    endif;
'    
'    
'    return atten;    
'end


'This function was a first attempt to fix the problems we were having (noted above before PrepareLongNoise)
'with the bandpass stimuli under that method.  This method here actually worked - I only had to get around a
'memory issue that turned out NOT to be a 1401 memory issue but rather a Matlab limitation when creating very
'long bandpass sounds which was fixed by, of all things, upping the swap space on the PC.  The problem with
'this method is that the stimulus generation and PWA loading are done in real time during the experiment, and
'that takes far too long (order of ten seconds) to allow us a reasonable ISI on each trial.  Obviously we can't
'have a longer ISI for the longer noises because then the animal can anticipate what is coming.  Hopefully, the
'longer portion of that step was the creation of the sounds and not the loading into the PWAs, as the next
'version (yet untested) attempts to create all the noise stimuli up front, and then only dynamically load them
'into the PWAs.  We shall see.
'func PrepareLongNoiseBP()
'    var atten;
'    var matPutOK% := 0;
'    var matGetStimOK%;
'    var matGetAttenOK%;
'    var playWaveCopyOK%;
'    var pwChar$;
'    var lndur;
'    var lnpad%;
'    
'    
'    
'    if recCalibIsPresent% = 1 and recMatlabIsPresent% = 1 and recCEDIsPresent% = 1 then  'if there is no calibration/matlab/CED, we can't do this
'        'Get play wave area
'        pwChar$ := GetPlayWaveKey$(recLongToneDurationIndex%[recCurrentTrial%]);
'        
'        'Set recStimTransferLongNoiseBP%[] to zeros
'        arrconst(recStimTransferLongNoiseBP%[],0);  
'        printlog("current trial is %d\n",recCurrentTrial%);        
'        lndur := recLongToneDurationList[recCurrentTrial%]*1000;  'Actual duration, in ms
'        lnpad% := recPlayRateHz*lndur/1000;  'pad to correct length
'        
'        
'        'Use speaker calibration to determine attenuation
'        matPutOK% := matPutOK% + PutMatlabValueFloat%("fs",recPlayRateHz);  'on any fail, matPutOK% will increment (negative ones)
'        matPutOK% := matPutOK% + PutMatlabValueFloat%("dur",lndur);  'duration of one second precisely, as this is the size of the PWA (except for 0.1 second sound)
'        matPutOK% := matPutOK% + PutMatlabValueFloat%("lohz",recLongToneBPLow);  'Set BP noise low limit, if broadband, value is already correctly set to -1
'        matPutOK% := matPutOK% + PutMatlabValueFloat%("hihz",recLongToneBPHigh);  'Ditto
'        matPutOK% := matPutOK% + PutMatlabValueFloat%("issweep",0);
'        matPutOK% := matPutOK% + PutMatlabValueFloat%("amfreq",0);
'        matPutOK% := matPutOK% + PutMatlabValueFloat%("amdepth",0);
'        matPutOK% := matPutOK% + PutMatlabValueFloat%("amphase",0);
'        matPutOK% := matPutOK% + PutMatlabValueFloat%("tonephase",0);
'        matPutOK% := matPutOK% + PutMatlabValueFloat%("gauss",1);  'Hardcode Gaussian noise
'        matPutOK% := matPutOK% + PutMatlabValueFloat%("ramp",0);
'        matPutOK% := matPutOK% + PutMatlabValueInt%("seed",0);  
'        matPutOK% := matPutOK% + PutMatlabValueInt%("pad",recMaxLongNoiseBPPoints%); 
'        matPutOK% := matPutOK% + PutMatlabValueInt%("spk",recLongToneSpeaker%);
'        
'        if matPutOK% < 0 then 'error in at least one matlab put operation - not sure what to do (try again, quit?)
'            message("There has been an error in sending data to Matlab!  Quitting!");
'            recReadyToQuit% := 1;  'This will allow the entire thing to quit
'            SafeSampleKey("M");  'Turn off LED
'            Stop%();
'            return -1;
'        endif;
'        
'        printlog("fs %f, dur %f, lohz %f, hihz %f, pad %d, spk %d\n",recPlayRateHz,lndur,recLongToneBPLow,recLongToneBPHigh,recMaxLongNoiseBPPoints%,recLongToneSpeaker%);
'        
'        statement$ := "[stimulus atten] = reclab_panstim(dur,fs,lohz,hihz,issweep,amfreq,amdepth,amphase,tonephase,gauss,ramp,seed,pad,AFFT(1,spk));";  'this is for the FFT filtering method
'        'statement$ := "[stimulus atten] = reclab_panstim(dur,fs,lohz,hihz,issweep,amfreq,amdepth,amphase,tonephase,gauss,ramp,seed,pad,AFilt(1,spk));";  'this is for the standard filtering method
'        EvalMatlabStatement%(statement$);  'Fills atten on matlab side, also creates stimulus but we don't care
'        
'        'Get stim and atten back from Matlab
'        matGetStimOK%:= GetMatlabValueIntArray%("stimulus",recStimTransferLongNoiseBP%[]);
'        matGetAttenOK% := GetMatlabValueFloat%("atten",atten);  'This is the expected attenuation for 65 dB
'        
'        'printlog("atten is %f\n",atten);
'      
'        atten := atten + 65 - recLongToneTargetdB;  'Adjust attenuation to produce requested intensity
'        if recLongToneTargetdB <> 65 then
'            printlog("Calculated attenuation to produce %f dB is %f\n",recLongToneTargetdB,atten);
'        endif;
'        
'        docase
'        case matGetStimOK% < 0 then 'error
'            message("There has been an error in getting stimulus data from Matlab!");
'        case atten < 0 then
'            atten := 0;
'            message("Requested intensity is louder than max intensity for this tone, setting attenuation to 0!");
'        case matGetAttenOK% < 0 then 'error
'            message("There has been an error in getting atten data from Matlab, setting to 20 dB arbitrarily!");
'            atten := 20;  'set atten to 20 arbitrarily
'        endcase;
'        printlog("Playwavechar is %s and lnpad is %d\n",pwchar$,lnpad%);
'        playWaveCopyOK% := PlayWaveCopy(pwChar$, recStimTransferLongNoiseBP%[0:lnpad%]); 
'        if playWaveCopyOK% < 0 then 'error
'            message("There has been an error in PlayWaveCopy!  Check Log File!");
'            printlog("There was an error in PlayWaveCopy!  The error is number %d and the text of the error is '%s'\n",playWaveCopyOK%,Error$(playWaveCopyOK%));
'        endif;
'        
'        SafeSampleKey("X"); 'put in load delay (may not be long enough??)
'        
'        
'    else
'        message("Matlab/CED/Calibration values are necessary for Long Noise!  Quitting!");
'        recReadyToQuit% := 1;  'This will allow the entire thing to quit
'        SafeSampleKey("M");  'Turn off LED
'        Stop%();
'        return -1;
'    endif;
'    
'    
'    return atten;    
'end


'This function creates all of the (up-to-100-second) long BB/BP stimuli and holds them in a variable.
'It is called when sampling starts and it takes on the order of two minutes to run, but once it is run
'things go quickly (the load to the PWA is fast enough to get under the ISI, at least).  This allows
'us to present the long noise stimuli without clicking, and with good dB control, and without having
'to worry about giving the animal clues about how long the next one will be.
func PrepareLongNoiseAllAtOnce()
    var atten;
    var seed;
    var matPutOK% := 0;
    var matGetStimOK%;
    var matGetAttenOK%;
    var matGetSeedOK%;
    var lndur;
    var lnpad%;
    var i%;
    var j%;
    
    
    
    if recCalibIsPresent% = 1 and recMatlabIsPresent% = 1 and recCEDIsPresent% = 1 then  'if there is no calibration/matlab/CED, we can't do this
        'for each long noise stimulus
        for i% := 0 to nLongTones%-2 do 'don't create noise on the silent trial
            
            lndur := (LongDurs[i%]+0.020)*1000;  'Calculate actual duration, in ms, have to add in ramp
            lnpad% := recPlayRateHz*lndur/1000;  'pad to correct length
            
            'for each repeat of the tone, we can make an independent noise, not frozen 
            for j% := 0 to recLongToneNRepeats%-1 do
                
                'Set recStimTransferLongNoise2%[] to zeros
                arrconst(recStimTransferLongNoise2%[],0);  
                
                'Create noise, use speaker calibration to determine attenuation
                matPutOK% := matPutOK% + PutMatlabValueFloat%("fs",recPlayRateHz);  'on any fail, matPutOK% will increment (negative ones)
                matPutOK% := matPutOK% + PutMatlabValueFloat%("dur",lndur);  'duration of noise
                matPutOK% := matPutOK% + PutMatlabValueFloat%("lohz",recLongToneBPLow);  'Set BP noise low limit, if broadband, value is already correctly set to -1
                matPutOK% := matPutOK% + PutMatlabValueFloat%("hihz",recLongToneBPHigh);  'Ditto
                matPutOK% := matPutOK% + PutMatlabValueFloat%("issweep",0);
                matPutOK% := matPutOK% + PutMatlabValueFloat%("amfreq",0);
                matPutOK% := matPutOK% + PutMatlabValueFloat%("amdepth",0);
                matPutOK% := matPutOK% + PutMatlabValueFloat%("amphase",0);
                matPutOK% := matPutOK% + PutMatlabValueFloat%("tonephase",0);
                matPutOK% := matPutOK% + PutMatlabValueFloat%("gauss",1);  'Hardcode Gaussian noise
                matPutOK% := matPutOK% + PutMatlabValueFloat%("ramp",10);  'Hardcode 10 ms ramp on/off
                matPutOK% := matPutOK% + PutMatlabValueInt%("seed",0);  
                matPutOK% := matPutOK% + PutMatlabValueInt%("pad",LongPoints3%); 
                matPutOK% := matPutOK% + PutMatlabValueInt%("spk",recLongToneSpeaker%);
                
                if matPutOK% < 0 then 'error in at least one matlab put operation - not sure what to do (try again, quit?)
                    message("There has been an error in sending data to Matlab!  Quitting!");
                    recReadyToQuit% := 1;  'This will allow the entire thing to quit
                    SafeSampleKey("M");  'Turn off LED
                    Stop%();
                    return -1;
                endif;
                
                printlog("fs %f, dur %f, lohz %f, hihz %f, pad %d, spk %d\n",recPlayRateHz,lndur,recLongToneBPLow,recLongToneBPHigh,LongPoints3%,recLongToneSpeaker%);
                
                statement$ := "[stimulus atten seed] = reclab_panstim(dur,fs,lohz,hihz,issweep,amfreq,amdepth,amphase,tonephase,gauss,ramp,seed,pad,AFFT(1,spk));";  'this is for the FFT filtering method
                'statement$ := "[stimulus atten seed] = reclab_panstim(dur,fs,lohz,hihz,issweep,amfreq,amdepth,amphase,tonephase,gauss,ramp,seed,pad,AFilt(1,spk));";  'this is for the standard filtering method
                EvalMatlabStatement%(statement$);  'Fills stimulus/atten/seed on matlab side
                
                'Get stim and atten back from Matlab
                matGetStimOK%:= GetMatlabValueIntArray%("stimulus",recStimTransferLongNoise2%[]);
                matGetAttenOK% := GetMatlabValueFloat%("atten",atten);  'This is the expected attenuation for 65 dB
                matGetSeedOK% := GetMatlabValueFloat%("seed",seed);
                
                'printlog("atten is %f\n",atten);
                
                atten := atten + 65 - recLongToneTargetdB;  'Adjust attenuation to produce requested intensity
                if recLongToneTargetdB <> 65 then
                    printlog("Calculated attenuation to produce %f dB is %f\n",recLongToneTargetdB,atten);
                endif;
                
                if matGetStimOK% < 0 then 'error
                    message("There has been an error in getting stimulus data from Matlab!");
                endif;
                
                if atten < 0 then
                    atten := 0;
                    message("Requested intensity is louder than max intensity for this tone, setting attenuation to 0!");
                endif;
                
                if matGetAttenOK% < 0 then 'error
                    message("There has been an error in getting atten data from Matlab, setting to 20 dB arbitrarily!");
                    atten := 20;  'set atten to 20 arbitrarily
                endif;
                
                if matGetSeedOK% < 0 then 'error
                    message("There has been an error in getting seed data from Matlab!");
                endif;
                
                recLongNoiseAtten[j%][i%] := atten;
                recLongNoiseSeed[j%][i%] := seed;

                docase
                case i% = 0 then
                    ArrConst(recLongNoise0%[j%][0:lnpad%],recStimTransferLongNoise2%[0:lnpad%]);
                case i% = 1 then
                    ArrConst(recLongNoise1%[j%][0:lnpad%],recStimTransferLongNoise2%[0:lnpad%]);
                case i% = 2 then
                    ArrConst(recLongNoise2%[j%][0:lnpad%],recStimTransferLongNoise2%[0:lnpad%]);
                case i% = 3 then
                    ArrConst(recLongNoise3%[j%][0:lnpad%],recStimTransferLongNoise2%[0:lnpad%]);  'should be correct size
                endcase
                
            next
        next
        
    else
        message("Matlab/CED/Calibration values are necessary for Long Noise!  Quitting!");
        recReadyToQuit% := 1;  'This will allow the entire thing to quit
        SafeSampleKey("M");  'Turn off LED
        Stop%();
        return -1;
    endif;
    
    
    return 1;  'no return value right now, assume no failure   
end


'For the newest version of long noise, we are doing stimulus generation and PWA load asynchronously
func LoadLongNoiseToPWA%()
    var pwChar$;
    var playWaveCopyOK%;
    var status%;
    var lndur;
    var lnpad%;
    var wtf%[1000];
    
    'Get play wave area
    pwChar$ := GetPlayWaveKey$(recLongToneDurationIndex%[recCurrentTrial%]);
    
    printlog("current trial is %d\n",recCurrentTrial%); 
    printlog("Playwavechar is %s\n",pwchar$);
    
    lndur := (LongDurs[recLongToneDurationIndex%[recCurrentTrial%]]+0.020)*1000;  'Calculate actual duration, in ms, have to add in ramp
    lnpad% := recPlayRateHz*lndur/1000;  'pad to correct length
         
    'Mark it zero, dude
    arrconst(recStimTransferLongNoise2%[],0);
    
    docase
    case recLongToneDurationIndex%[recCurrentTrial%] = 0 then
        ArrConst(recStimTransferLongNoise2%[0:lnpad%],recLongNoise0%[LongNoiseBlock%][0:lnpad%]);
    case recLongToneDurationIndex%[recCurrentTrial%] = 1 then
        ArrConst(recStimTransferLongNoise2%[0:lnpad%],recLongNoise1%[LongNoiseBlock%][0:lnpad%]);
    case recLongToneDurationIndex%[recCurrentTrial%] = 2 then
        ArrConst(recStimTransferLongNoise2%[0:lnpad%],recLongNoise2%[LongNoiseBlock%][0:lnpad%]);
    case recLongToneDurationIndex%[recCurrentTrial%] = 3 then
        ArrConst(recStimTransferLongNoise2%[0:lnpad%],recLongNoise3%[LongNoiseBlock%][0:lnpad%]);
    'In the case of index = 5, we want silence anyways, so leave it marked zero, dude.
    endcase
    
    'Copy noise to PWA and set PA5 (or copy zeros to PWA if it's the first time through, just in case the "silent" PWA isn't zeros)
    'Note that for the time being I've actually repented of this decision 15 seconds after I made it seeing as the
    'delay for loading the PWA might be significant enough that *not* loading zeros changes the timing.  I reserve
    'the right to un-repent of this decision at any point.
    'if recLongToneDurationIndex%[recCurrentTrial%] < nLongTones% or LongNoiseBlock% = 0 then    
    playWaveCopyOK% := PlayWaveCopy(pwChar$,recStimTransferLongNoise2%[0:lnpad%]); 
    if playWaveCopyOK% < 0 then 'error
        message("There has been an error in PlayWaveCopy!  Check Log File!");
        printlog("There was an error in PlayWaveCopy!  The error is number %d and the text of the error is '%s'\n",playWaveCopyOK%,Error$(playWaveCopyOK%));
    endif;
    
    SafeSampleKey("X"); 'put in load delay (may not be long enough??)
    
    'Set attenuation per stimulus when we load the PWA
    status% := recAttenByID%(recLongNoiseAtten[LongNoiseBlock%][recLongToneDurationIndex%[recCurrentTrial%]],arrayPA4ID%);
    if status% <> 0 then
        printlog("Problem setting attenuation for long noise!\n");
        return 0;
    endif; 
    'endif
    
    
    
    return 1;  'Any useful return value??
end




'------- PrepareNextTrial% --------------------------------------------------------
' 
' Called prior to initiating a set of S1/S2 stimuli. 
' Return 1 if all is well, 0 if all trials are done, negative for error. 
'
' This is the place to get a list of stimuli to run and load Play Wave areas as needed. 
' All stuff (like loading stimuli) which will be too costly time-wise to do while a 
' trial is running should be done here.
'
' Finally inverted "dontLoadPWAs" logic to "loadPWAs" because, man, it makes it easier to think about it.


func PrepareNextTrial%(loadPWAs%)
    var i%;
    var ind%;
    var thisSpkr%;
    var thisTrial%;
    var thisPWA%;
    var nread%:= 0;  'looks unused but won't hurt
    var file$;
    var fh%;
    var statement$;
    var pwChar$;
    var matPutOK% := 0;
    var matGetStimOK%;
    var matGetAttenOK%;
    var matGetSeedOK%;
    var playWaveCopyOK%;
    var ok% := 1;  'by default, return 1 (success)
    
    
    ' Check to see if we are done
    if recCurrentTrial% >= recNTrials% then
        return 0;  'end the sequence
    endif;
    
    'Printlog current trial
    printlog("Current trial is %d\n",recCurrentTrial%);
    
    ' Get index of current trial
    thisTrial% :=  recTrialOrder%[recCurrentTrial%];  'recCurrentTrial is an index, BUT it hasn't been incremented yet, so don't subtract 1
    
    
    
    ' Put current trial sequence into log file
    if recDebug% > 0 then
        printlog("recCurrentTrial is %d\n",recCurrentTrial%);
        printlog("thisTrial is %d\n",thisTrial%);
        PrintLog("Trial #%d, TrialList ",recCurrentTrial%+1);
        printlog("Terminal index is %d\n",recTrialTerminalIndex%[thisTrial%]);
        PrintLog("Stims: ");
        for i% := 0 to recTrialTerminalIndex%[thisTrial%] do
            ' Get current PWA
            thisPWA% := recPWAList%[i%][thisTrial%];
            ' Print stmulus number
            PrintLog(str$(recStimList%[thisPWA%][thisTrial%]) + " ");
        next
        PrintLog("\nPWAs: ");
        for i% := 0 to recTrialTerminalIndex%[thisTrial%] do
            ' Get current PWA
            thisPWA% := recPWAList%[i%][thisTrial%];
            ' Print PWA number
            PrintLog(str$(thisPWA%) + " ");
        next
        PrintLog("\n");
    endif
    
    
    if loadPWAs% = 1 then
        ' Generate/Load stimuli and put them into PlayWaveAreas
        'for i% := 0 to recTrialTerminalIndex%[thisTrial%] do
        for i% := 0 to recNUniqueStims%[thisTrial%]-1 do
            'Get play wave area for current stimulus
            pwChar$ := GetPlayWaveKey$(i%); 
            
            'get index of trial
            ind% := recStimList%[i%][thisTrial%];
            
            'get speaker of trial
            thisSpkr% := recSpeakerList%[i%][thisTrial%];
            
            'Set recStimTransfer%[] to zeros
            arrconst(recStimTransfer%[],0);  
            
            docase
            case recMatGenStim% = 1 and recMatlabIsPresent% = 0 and recCEDIsPresent% = 0 then  'this is testing
                'don't do anything, just pretend all is OK
            case recMatGenStim% = 1 and recMatlabIsPresent% = 0 and recCEDIsPresent% = 1 then  'this is a boo-boo
                message("Holy crap, I can't generate the stimulus because you said there's no Matlab!");
                recReadyToQuit% := 1;  'This will allow the entire thing to quit
                SafeSampleKey("M");  'Turn off LED
                Stop%();
                return -1;
            case recMatGenStim% = 1 and recSearchStimType% <> 3 then  'Generate stimuli using Matlab - even something CED can do like tones.  Just easier to be consistent.
                'opening a figure is slow, but everything else looks fast.  I can't quite ID exactly how long these things take
                'because things look like they happen in about 15-ms increments as far as CED's "Seconds()" command is concerned.
                'Needless to say, you can operate several commands (put, get, eval) without any time elapsing, then 15 ms for a
                'similar command.  Whether that's OS time or just clock precision I don't know.  What I do know is that under optimal
                'conditions you can put and get a 100000-element float in essentially 0 time, and maximally 15 ms.  So in principle as
                'long as the Matlab commands to eval are quick, we shouldn't worry about the time to do up to 10 "gets".  If we can
                'cleverly have all of them come simultaneously (i.e. a 2-d array of stimuli), that's cool too.  May not be necessary.
                
                matPutOK% := matPutOK% + PutMatlabValueFloat%("fs",recPlayRateHz);  'on any fail, matPutOK% will increment (negative ones)
                matPutOK% := matPutOK% + PutMatlabValueFloat%("dur",recTrialDur[ind%]);  'size of trial is variable, that's OK
                matPutOK% := matPutOK% + PutMatlabValueFloat%("lohz",recTrialGenLowpassHz[ind%]);  'Value of lowpass Hz or tone freq will be correctly interpreted by Matlab
                matPutOK% := matPutOK% + PutMatlabValueFloat%("hihz",recTrialGenHighpassHz[ind%]);  'Ditto
                matPutOK% := matPutOK% + PutMatlabValueFloat%("issweep",recTrialGenIsSweep%[ind%]);
                matPutOK% := matPutOK% + PutMatlabValueFloat%("amfreq",recTrialGenAMFreqHz[ind%]);
                matPutOK% := matPutOK% + PutMatlabValueFloat%("amdepth",recTrialGenAMDepthPct[ind%]);
                matPutOK% := matPutOK% + PutMatlabValueFloat%("amphase",recTrialGenAMPhaseDeg[ind%]);
                matPutOK% := matPutOK% + PutMatlabValueFloat%("tonephase",recTrialGenTonePhaseDeg[ind%]);
                matPutOK% := matPutOK% + PutMatlabValueFloat%("gauss",recTrialGenGauss%[ind%]);  
                matPutOK% := matPutOK% + PutMatlabValueFloat%("ramp",recTrialGenRampMS[ind%]);
                matPutOK% := matPutOK% + PutMatlabValueInt%("seed",recTrialGenSeed%[ind%]);  
                matPutOK% := matPutOK% + PutMatlabValueInt%("pad",recMaxPoints%);
                matPutOK% := matPutOK% + PutMatlabValueInt%("spk",thisSpkr%);
                
                if matPutOK% < 0 then 'error in at least one matlab put operation - not sure what to do (try again, quit?)
                    message("There has been an error in sending data to Matlab!  Quitting!");
                    recReadyToQuit% := 1;  'This will allow the entire thing to quit
                    SafeSampleKey("M");  'Turn off LED
                    Stop%();
                    return -1;
                endif;
                
                'Ask Matlab to create the stimulus - reclab_panstim can make just about anything
                'NOTE THAT WITHOUT THE CALIB VARIABLE, THE FULL STATEMENT DOES NOT WORK PROPERLY
                'USE THE TRUNCATED STATEMENT WITH NO CALIB UNTIL CALIBRATION IS IMPLEMENTED
                if recCalibIsPresent% = 1 then
                    statement$ := "[stimulus atten65 seed] = reclab_panstim(dur,fs,lohz,hihz,issweep,amfreq,amdepth,amphase,tonephase,gauss,ramp,seed,pad,AFFT(1,spk));";  'this is for the FFT filtering method
                    'statement$ := "[stimulus atten65 seed] = reclab_panstim(dur,fs,lohz,hihz,issweep,amfreq,amdepth,amphase,tonephase,gauss,ramp,seed,pad,AFilt(1,spk));";  'this is for the standard filtering method
                else
                    statement$ := "[stimulus atten65 seed] = reclab_panstim(dur,fs,lohz,hihz,issweep,amfreq,amdepth,amphase,tonephase,gauss,ramp,seed,pad);";
                endif;
                EvalMatlabStatement%(statement$);
                'printlog("%s\n",statement$);
                'printlog("Values are %d %d %d %d ",recTrialDur[ind%],recPlayRateHz,recTrialGenLowpassHz[ind%],recTrialGenHighpassHz[ind%]);
                'printlog("%d %d %d %d %d ",recTrialGenIsSweep%[ind%],recTrialGenAMFreqHz[ind%],recTrialGenAMDepthPct[ind%],recTrialGenAMPhaseDeg[ind%],recTrialGenTonePhaseDeg[ind%]);
                'printlog("%d %d %d %d %d \n",recTrialGenGauss%[ind%],recTrialGenRampMS[ind%],recTrialGenSeed%[ind%],recMaxPoints%,thisSpkr%);
                
                
                'Get the stimulus and the seed back from Matlab
                matGetStimOK%:= GetMatlabValueIntArray%("stimulus",recStimTransfer%[]);
                matGetAttenOK% := GetMatlabValueFloat%("atten65",recGeneratedAtten[i%]);
                matGetSeedOK% := GetMatlabValueInt%("seed",recCurrRandomSeed%[i%]);  'put current random seed into variable for NameThatStimulus
                
                docase
                case matGetStimOK% < 0 then 'error
                    message("There has been an error in getting stimulus data from Matlab!");
                    'recReadyToQuit% := 1;  'This will allow the entire thing to quit
                    'SafeSampleKey("M");  'Turn off LED
                    'Stop%();
                    'return -1;
                case matGetAttenOK% < 0 then 'error
                    message("There has been an error in getting atten data from Matlab!");
                    'recReadyToQuit% := 1;  'This will allow the entire thing to quit
                    'SafeSampleKey("M");  'Turn off LED
                    'Stop%();
                    'return -1;
                case matGetSeedOK% < 0 then 'error
                    message("There has been an error in getting seed data from Matlab!");
                    'recReadyToQuit% := 1;  'This will allow the entire thing to quit
                    'SafeSampleKey("M");  'Turn off LED
                    'Stop%();
                    'return -1;
                endcase;
                
                'printlog("gen values are %d\n",recStimTransfer%[4000:50]);   
                
                'Note that loading the filter coefficients for each speaker on each call would be a time-waster.
                'Instead, we will load up CALIB into the Matlab workspace as the experiment begins, and the call
                'to RECLAB_PANSTIM above will use that CALIB variable (indexed by the speaker).
                
            case recMatGenStim% = 1 and recSearchStimType% = 3 then  'Clicks - matlab is not set up to generate these
                
                recStimTransfer%[1] := 32767;  'make the second element (2^15)-1, then everything else 0 - that's a click
                'arrconst(recStimTransfer%[3:500],30000);
                'printlog("click values are %d\n",recStimTransfer%[0:20]); 
                
            else  'Load stimuli from file
                
                'get filename
                file$ := recTrialLoadLoc$[ind%];
                
                'open current stimulus
                fh%:=fileopen(file$,9,0);
                if fh%<0 then
                    message("Warning Message | failed to load the stimulus waveform!");
                    printlog("Quitting because the Stim waveform %s failed to load!\n",file$);
                    Stop%();
                    return -1;
                endif;
                
                'reads fh% two bytes at a time, puts in recStimTransfer%[]
                nread%:=breadsize(2,recStimTransfer%[]); 
                if nread% < 0 then
                    printlog("There was an error in reading the binary file!  The error is number %d and the text of the error is '%s'\n",nread%,Error$(nread%));
                endif;
                
                
                'close current stimulus
                fileclose();  'close fh%
                
            endcase;
            
            'Finally, place the stimulus into the appropriate Play Wave Area
            if recCEDIsPresent% = 1 then
                playWaveCopyOK% := PlayWaveCopy(pwChar$, recStimTransfer%[]);  'recStimTransfer% is an integer array and as such should be signed 16 bit integers
                if playWaveCopyOK% < 0 then 'error
                    message("There has been an error in PlayWaveCopy!  Check Log File!");
                    printlog("There was an error in PlayWaveCopy!  The error is number %d and the text of the error is '%s'\n",playWaveCopyOK%,Error$(playWaveCopyOK%));
                    'recReadyToQuit% := 1;  'This will allow the entire thing to quit
                    'SafeSampleKey("M");  'Turn off LED
                    'Stop%();
                    'return -1;
                endif;
                SafeSampleKey("X");  'PlayWaveCopy() does not appear to be a "blocking" function.  It's a bit strange to me
                                     'because it returns a success value, but this is evidently before the PWC operation is
                                     'complete.  If we ask to play the stimulus too quickly, we can get crashes.  This puts
                                     'in a delay (timed on the sequencer) to prevent 'too fast' calls to play the stim after loading
                                     'Note that for multi-PWA loads, it is not clear whether it is necessary to do this on
                                     'every load, or just once at the end.  Right now, "every load" is what we're doing but
                                     'this may be overkill.  If we load 10 PWAs that's half a second, which might be a lot.
            endif;
            
        next;
    endif;
    
    
    recStimCount% := 0;  'Reset stim count
    return ok%;
    
end



'------- PrepareNextTrial2PWAs --------------------------------------------------------
' 
' Called prior to initiating a set of S1/S2 stimuli, for scenarios like Stereo Distractor that
' have double-barreled PWAs.
' Return 1 if all is well, 0 if all trials are done, negative for error. 
'
' This is the place to get a list of stimuli to run and load Play Wave areas as needed. 
' All stuff (like loading stimuli) which will be too costly time-wise to do while a 
' trial is running should be done here. 
'
'Right now this is ONLY used by the StereoDis experiment (this experiment may well be renamed soon)
'For this experiment, there is a convention that a true S1 (the first S1, we may use this later
'for stimuli we may call S1.n stimuli) there is no distractor, so we will leave the value in the
'distractor position as zeroes.


func PrepareNextTrial2PWAs(loadPWAs%)
    var i%;
    var ind%;
    var indD%;
    var thisSpkr%;
    var thisTrial%;
    var thisPWA%;
    var nread%:= 0;  'looks unused but won't hurt
    var file$;
    var fh%;
    var statement$;
    var pwChar$;
    var matPutOK% := 0;
    var matGetStimOK%;
    var matGetAttenOK%;
    var matGetSeedOK%;
    var playWaveCopyOK%;
    var ok% := 1;  'by default, return 1 (success)
    
    
    ' Check to see if we are done
    if recCurrentTrial% >= recNTrials% then
        return 0;  'end the sequence
    endif;
    
    'Printlog current trial
    printlog("Current trial is %d\n",recCurrentTrial%);
    
    ' Get index of current trial
    thisTrial% :=  recTrialOrder%[recCurrentTrial%];  'recCurrentTrial is an index, BUT it hasn't been incremented yet, so don't subtract 1
    
    
    
    ' Put current trial sequence into log file (this may not be an ideal log, but it's basically unused so it's a low priority)
    if recDebug% > 0 then
        printlog("recCurrentTrial is %d\n",recCurrentTrial%);
        printlog("thisTrial is %d\n",thisTrial%);
        PrintLog("Trial #%d, TrialList ",recCurrentTrial%+1);
        printlog("Terminal index is %d\n",recTrialTerminalIndex%[thisTrial%]);
        PrintLog("Stims: ");
        for i% := 0 to recTrialTerminalIndex%[thisTrial%] do
            ' Get current PWA
            thisPWA% := recPWAList%[i%][thisTrial%];
            ' Print stimulus number
            PrintLog(str$(recStimList%[thisPWA%][thisTrial%]) + " ");
        next
        PrintLog("\nPWAs: ");
        for i% := 0 to recTrialTerminalIndex%[thisTrial%] do
            ' Get current PWA
            thisPWA% := recPWAList%[i%][thisTrial%];
            ' Print PWA number
            PrintLog(str$(thisPWA%) + " ");
        next
        PrintLog("\n");
    endif
    
    
    if loadPWAs% = 1 then
        ' Generate/Load stimuli and put them into PlayWaveAreas
        for i% := 0 to recTrialTerminalIndex%[thisTrial%] do  'go through S1, S2
            'Note that this actually SHOULD work for scenarios where there are more than one S1 stimulus,
            'well except that the recDistractorStimList%[] would need to be 2-D, I think.
            
            'Get play wave area for current stimulus
            pwChar$ := GetPlayWaveKey$(i%); 
            
            'get index of trial to index into stim file
            ind% := recStimList%[i%][thisTrial%];
            indD% := recDistractorStimList%[i%][thisTrial%];
            
            'Set rec2StimTransfer%[] to zeros
            arrconst(rec2StimTransfer%[][],0);  
            
            docase
            case recMatGenStim% = 1 and recMatlabIsPresent% = 0 and recCEDIsPresent% = 0 then  'this enables testing, currently no double-barreled PWA experiments allow generated stimuli
                'don't do anything, just pretend all is OK
            case recMatGenStim% = 1 and recMatlabIsPresent% = 0 and recCEDIsPresent% = 1 then  'this is a boo-boo
                'Really, this isn't a boo-boo we should expect, but I'm leaving it in in case it's useful down the road
                message("Holy crap, I can't generate the stimulus because Matlab has not been initialized!");
                recReadyToQuit% := 1;  'This will allow the entire thing to quit
                SafeSampleKey("M");  'Turn off LED
                Stop%();
                return -1;
            case recMatGenStim% = 1 then  'Generate stimuli if Matlab is present (even if CED isn't!)
                
                'get speaker of trial, used to calculate attenuation 
                thisSpkr% := recSpeakerList%[i%][thisTrial%];  'Only the distractor changes speaker
                
                'Generate the stimulus, for stereo dis this will be an AM
                'printlog("ind is %d and recTrialDur is %f\n",ind%,recTrialDur[ind%]);
                matPutOK% := matPutOK% + PutMatlabValueFloat%("fs",recPlayRateHz);  'on any fail, matPutOK% will increment (negative ones)
                matPutOK% := matPutOK% + PutMatlabValueFloat%("dur",recTrialDur[ind%]*1000);  'size of trial is variable, that's OK
                matPutOK% := matPutOK% + PutMatlabValueFloat%("lohz",recTrialGenLowpassHz[ind%]);  'Value of lowpass Hz or tone freq will be correctly interpreted by Matlab
                matPutOK% := matPutOK% + PutMatlabValueFloat%("hihz",recTrialGenHighpassHz[ind%]);  'Ditto
                matPutOK% := matPutOK% + PutMatlabValueFloat%("issweep",recTrialGenIsSweep%[ind%]);
                matPutOK% := matPutOK% + PutMatlabValueFloat%("amfreq",recTrialGenAMFreqHz[ind%]);
                matPutOK% := matPutOK% + PutMatlabValueFloat%("amdepth",recTrialGenAMDepthPct[ind%]);
                matPutOK% := matPutOK% + PutMatlabValueFloat%("amphase",recTrialGenAMPhaseDeg[ind%]);
                matPutOK% := matPutOK% + PutMatlabValueFloat%("tonephase",recTrialGenTonePhaseDeg[ind%]);
                matPutOK% := matPutOK% + PutMatlabValueFloat%("gauss",recTrialGenGauss%[ind%]);  
                matPutOK% := matPutOK% + PutMatlabValueFloat%("ramp",recTrialGenRampMS[ind%]);
                matPutOK% := matPutOK% + PutMatlabValueInt%("seed",recTrialGenSeed%[ind%]);  
                matPutOK% := matPutOK% + PutMatlabValueInt%("pad",recMaxPoints%);
                matPutOK% := matPutOK% + PutMatlabValueInt%("spk",thisSpkr%);
                
                if matPutOK% < 0 then 'error in at least one matlab put operation - not sure what to do (try again, quit?)
                    message("There has been an error in sending data to Matlab!  Quitting!");
                    recReadyToQuit% := 1;  'This will allow the entire thing to quit
                    SafeSampleKey("M");  'Turn off LED
                    Stop%();
                    return -1;
                endif;
                
                'Ask Matlab to create the stimulus - reclab_panstim can make just about anything
                if recCalibIsPresent% = 1 then
                    statement$ := "[stimulus atten65 seed] = reclab_panstim(dur,fs,lohz,hihz,issweep,amfreq,amdepth,amphase,tonephase,gauss,ramp,seed,pad,stAFFT(1,spk));";  'this is for the FFT filtering method, for the standalone
                    'statement$ := "[stimulus atten65 seed] = reclab_panstim(dur,fs,lohz,hihz,issweep,amfreq,amdepth,amphase,tonephase,gauss,ramp,seed,pad,AFilt(1,spk));";  'this is for the standard filtering method
                else
                    statement$ := "[stimulus atten65 seed] = reclab_panstim(dur,fs,lohz,hihz,issweep,amfreq,amdepth,amphase,tonephase,gauss,ramp,seed,pad);";
                endif;
                EvalMatlabStatement%(statement$);
                'printlog("%s\n",statement$);
                'printlog("Values are %d %d %d %d ",recTrialDur[ind%]*1000,recPlayRateHz,recTrialGenLowpassHz[ind%],recTrialGenHighpassHz[ind%]);
                'printlog("%d %d %d %d %d ",recTrialGenIsSweep%[ind%],recTrialGenAMFreqHz[ind%],recTrialGenAMDepthPct[ind%],recTrialGenAMPhaseDeg[ind%],recTrialGenTonePhaseDeg[ind%]);
                'printlog("%d %d %d %d %d \n",recTrialGenGauss%[ind%],recTrialGenRampMS[ind%],recTrialGenSeed%[ind%],recMaxPoints%,thisSpkr%);
                
                
                'Get the stimulus and the seed back from Matlab
                matGetStimOK%:= GetMatlabValueIntArray%("stimulus",rec2StimTransfer%[][1]);  '<----- NOTE THAT STIMULUS GOES TO DAC1, BECAUSE DAC1 IS CONNECTED TO THE STANDALONE
                matGetAttenOK% := GetMatlabValueFloat%("atten65",recStereoDisGeneratedAttenList[i%][1]);  'put current random seed into variable for setting PA4
                matGetSeedOK% := GetMatlabValueInt%("seed",recStereoDisSeedList%[i%][1]);  'put current random seed into variable for NameThatStimulus
                
                docase
                case matGetStimOK% < 0 then 'error
                    message("There has been an error in getting stimulus data from Matlab!");
                case matGetAttenOK% < 0 then 'error
                    message("There has been an error in getting atten data from Matlab!");
                case matGetSeedOK% < 0 then 'error
                    message("There has been an error in getting seed data from Matlab!");
                endcase;
                
                
                
                'Generate the distractor, but only during the S2 (or subsequent S1s, which is something Dominique talked about briefly, dunno if those will be implemented ever)
                if i% > 0 then  'do not generate a distractor for the first S1, rec2StimTransfer%[][0] will remain zeroes
                    
                    'get speaker of trial, used to calculate attenuation 
                    thisSpkr% := recDistractorSpeakerList%[i%][thisTrial%];  'Only the distractor changes speaker
                    'printlog("ind is %d and recTrialDur is %f\n",indD%,recTrialDur[indD%]);
                    matPutOK% := matPutOK% + PutMatlabValueFloat%("fs",recPlayRateHz);  'on any fail, matPutOK% will increment (negative ones)
                    matPutOK% := matPutOK% + PutMatlabValueFloat%("dur",recTrialDur[indD%]*1000);  'size of trial is variable, that's OK
                    matPutOK% := matPutOK% + PutMatlabValueFloat%("lohz",recTrialGenLowpassHz[indD%]);  'Value of lowpass Hz or tone freq will be correctly interpreted by Matlab
                    matPutOK% := matPutOK% + PutMatlabValueFloat%("hihz",recTrialGenHighpassHz[indD%]);  'Ditto
                    matPutOK% := matPutOK% + PutMatlabValueFloat%("issweep",recTrialGenIsSweep%[indD%]);
                    matPutOK% := matPutOK% + PutMatlabValueFloat%("amfreq",recTrialGenAMFreqHz[indD%]);
                    matPutOK% := matPutOK% + PutMatlabValueFloat%("amdepth",recTrialGenAMDepthPct[indD%]);
                    matPutOK% := matPutOK% + PutMatlabValueFloat%("amphase",recTrialGenAMPhaseDeg[indD%]);
                    matPutOK% := matPutOK% + PutMatlabValueFloat%("tonephase",recTrialGenTonePhaseDeg[indD%]);
                    matPutOK% := matPutOK% + PutMatlabValueFloat%("gauss",recTrialGenGauss%[indD%]);  
                    matPutOK% := matPutOK% + PutMatlabValueFloat%("ramp",recTrialGenRampMS[indD%]);
                    matPutOK% := matPutOK% + PutMatlabValueInt%("seed",recTrialGenSeed%[indD%]);  
                    matPutOK% := matPutOK% + PutMatlabValueInt%("pad",recMaxPoints%);
                    matPutOK% := matPutOK% + PutMatlabValueInt%("spk",thisSpkr%);
                    
                    if matPutOK% < 0 then 'error in at least one matlab put operation - not sure what to do (try again, quit?)
                        message("There has been an error in sending data to Matlab!  Quitting!");
                        recReadyToQuit% := 1;  'This will allow the entire thing to quit
                        SafeSampleKey("M");  'Turn off LED
                        Stop%();
                        return -1;
                    endif;
                    
                    'Ask Matlab to create the stimulus - reclab_panstim can make just about anything
                    if recCalibIsPresent% = 1 then
                        statement$ := "[stimulus atten65 seed] = reclab_panstim(dur,fs,lohz,hihz,issweep,amfreq,amdepth,amphase,tonephase,gauss,ramp,seed,pad,AFFT(1,spk));";  'this is for the FFT filtering method, for the current Array
                        'statement$ := "[stimulus atten65 seed] = reclab_panstim(dur,fs,lohz,hihz,issweep,amfreq,amdepth,amphase,tonephase,gauss,ramp,seed,pad,AFilt(1,spk));";  'this is for the standard filtering method
                    else
                        statement$ := "[stimulus atten65 seed] = reclab_panstim(dur,fs,lohz,hihz,issweep,amfreq,amdepth,amphase,tonephase,gauss,ramp,seed,pad);";
                    endif;
                    EvalMatlabStatement%(statement$);
                    'printlog("%s\n",statement$);
                    'printlog("Values are %d %d %d %d ",recTrialDur[ind%],recPlayRateHz,recTrialGenLowpassHz[ind%],recTrialGenHighpassHz[ind%]);
                    'printlog("%d %d %d %d %d ",recTrialGenIsSweep%[ind%],recTrialGenAMFreqHz[ind%],recTrialGenAMDepthPct[ind%],recTrialGenAMPhaseDeg[ind%],recTrialGenTonePhaseDeg[ind%]);
                    'printlog("%d %d %d %d %d \n",recTrialGenGauss%[ind%],recTrialGenRampMS[ind%],recTrialGenSeed%[ind%],recMaxPoints%,thisSpkr%);
                    
                    
                    'Get the stimulus and the seed back from Matlab
                    matGetStimOK%:= GetMatlabValueIntArray%("stimulus",rec2StimTransfer%[][0]);  '<----- NOTE THAT DISTRACTOR GOES TO DAC0, BECAUSE DAC0 IS CONNECTED TO THE PM1
                    matGetAttenOK% := GetMatlabValueFloat%("atten65",recStereoDisGeneratedAttenList[i%][0]);
                    matGetSeedOK% := GetMatlabValueInt%("seed",recStereoDisSeedList%[i%][0]);  'put current random seed into variable for NameThatStimulus
                    
                    docase
                    case matGetStimOK% < 0 then 'error
                        message("There has been an error in getting stimulus data from Matlab!");
                    case matGetAttenOK% < 0 then 'error
                        message("There has been an error in getting atten data from Matlab!");
                    case matGetSeedOK% < 0 then 'error
                        message("There has been an error in getting seed data from Matlab!");
                    endcase;
                    
                    
                    
                endif;
                
                
                
                
                
            else  'Load stimuli from file (which is the ONLY thing we can legally do right now for this double-wide PWA thingy)
                
                if i% > 0 then  'do not load a distractor for the first S1, rec2StimTransfer%[][0] will remain zeroes
                    'get filename
                    file$ := recTrialLoadLocDistractor$[indD%];  'this is the distractor
                    if recDebug% > 0 then
                        printlog("Trying to open stim file %s\n",file$);
                    endif;
                    'open current stimulus
                    fh%:=fileopen(file$,9,0);
                    if fh%<0 then
                        message("Warning Message | failed to load the stimulus waveform!");
                        printlog("Quitting because the Stim waveform %s failed to load!\n",file$);
                        Stop%();
                        return -1;
                    endif;
                    
                    'reads fh% two bytes at a time, puts in recStimTransfer%[]
                    nread%:=breadsize(2,rec2StimTransfer%[][0]); '<----- NOTE THAT DISTRACTOR GOES TO DAC0, BECAUSE DAC0 IS CONNECTED TO THE PM1
                    
                    'close current stimulus
                    fileclose();  'close fh%
                endif;
                
                
                
                'get filename of S1/S2
                file$ := recTrialLoadLoc$[ind%];  'this is the S1/S2
                if recDebug% > 0 then
                    printlog("Trying to open stim file %s\n",file$);
                endif
                'open current stimulus
                fh%:=fileopen(file$,9,0);
                if fh%<0 then
                    message("Warning Message | failed to load the stimulus waveform!");
                    printlog("Quitting because the Stim waveform %s failed to load!\n",file$);
                    Stop%();
                    return -1;
                endif;
                
                'reads fh% two bytes at a time, puts in recStimTransfer%[]
                nread%:=breadsize(2,rec2StimTransfer%[][1]); '<----- NOTE THAT S1/S2 GOES TO DAC1, BECAUSE DAC1 IS NOT CONNECTED TO THE PM1
                
                'close current stimulus
                fileclose();  'close fh%
                
            endcase;
            
            'Finally, place the stimulus into the appropriate Play Wave Area
            if recCEDIsPresent% = 1 then
                playWaveCopyOK% := PlayWaveCopy(pwChar$, rec2StimTransfer%[][]);  'rec2StimTransfer% is an integer array and as such should be signed 16 bit integers
                if playWaveCopyOK% < 0 then 'error
                    message("There has been an error in PlayWaveCopy!  Check Log File!");
                    printlog("There was an error in PlayWaveCopy!  The error is number %d and the text of the error is '%s'\n",playWaveCopyOK%,Error$(playWaveCopyOK%));
                    'recReadyToQuit% := 1;  'This will allow the entire thing to quit
                    'SafeSampleKey("M");  'Turn off LED
                    'Stop%();
                    'return -1;
                endif;
                if i% = recTrialTerminalIndex%[thisTrial%] then
                    SafeSampleKey("X");  'This puts in a delay (timed on the sequencer) to prevent 'too fast' calls to play the stim after loading, only do for last PWA
                endif;
            endif;
            
        next;
    endif;
    
    
    recStimCount% := 0;  'Reset stim count
    return ok%;
    
end





'------- FRAPrepareNextTrial% --------------------------------------------------------
' 
' Called prior to initiating a set of S1/S2 stimuli. 
' Return 1 if all is well, 0 if all trials are done, negative for error. 
'
' This is the place to get a list of stimuli to run and load Play Wave areas as needed. 
' All stuff (like loading stimuli) which will be too costly time-wise to do while a 
' trial is running should be done here. 


func FRAPrepareNextTrial%(loadPWAs%)
    var ind%;
    var i%;
    var thisSpkr%;
    var thisTrial%;
    var thisPWA%;
    var nread%:= 0;  'looks unused but won't hurt
    var file$;
    var fh%;
    var statement$;
    var pwChar$;
    var matPutOK% := 0;
    var matGetStimOK%;
    var matGetAttenOK%;
    var matGetSeedOK%;
    var playWaveCopyOK%;
    var ok% := 1;  'by default, return 1 (success)
    
    ' Set pwChar$ array to DAC0 and DAC1
    pwChar$ := GetPlayWaveKey$(recFRAPWAIndex%);
    printlog("PWA index is %d\n", recFRAPWAIndex%);
    
    ' Check to see if we are done
    if recCurrentTrial% >= recNTrials% then
        return 0;  'end the sequence
    endif;
    
    'Printlog current trial
    printlog("Current trial is %d\n",recCurrentTrial%);
    
    'get stim number by calling tria`numth entry
    recCurrentTrial% := recCurrentTrial%;
    printlog("Stim number is %d\n",recCurrentTrial%);
    
    recDur := recTrialDur[rec2StimList%[recTrialOrder%[recCurrentTrial%]][0]];  
    
    ' Put current trial sequence into log file
    if recDebug% > 0 then
        printlog("recCurrentTrial is %d\n",recCurrentTrial%);
        PrintLog("Stimuli: ");
        PrintLog("\n");
        ' Print stimulus number
        PrintLog("16 array: " + str$(rec2StimList%[recTrialOrder%[recCurrentTrial%]][0]) + ", Standalone: " + str$(rec2StimList%[recTrialOrder%[recCurrentTrial%]][1]));
        PrintLog("\n");
        printLog("stimulus duration is %f\n",recDur);
    endif
    
    
    if loadPWAs% = 1 then
        ' Generate/Load stimuli and put them into PlayWaveAreas
        
        'get speaker on array for this trial (second stimulus plays on stand-alone)
        thisSpkr% := rec2SpeakerList%[recTrialOrder%[recCurrentTrial%]][0];
        printlog("Array speaker: " + str$(thisSpkr%));
        printlog("\n");
        
        'Set rec2StimTransfer%[] to zeros
        arrconst(rec2StimTransfer%[][],0); 
        
        seconds(0);  'set "seconds" time to zero, for testing
        'seconds(0,1);  'set resolution to hi-res, not legal in Spike6
        
        for i% := 0 to 1 do
            
            printlog("Loading file for DAC" + str$(i%));
            printlog("\n"); 
            
            'Load stimuli from file
            
            'get filename
            file$ := recTrialLoadLoc$[rec2StimList%[recTrialOrder%[recCurrentTrial%]][i%]];
            printlog("Current file loading: " + file$);
            printlog("\n");
            
            'open current stimulus
            fh%:=fileopen(file$,9,0);
            
            if fh%<0 then
                message("Warning Message | failed to load the stimulus waveform!");
                printlog("Quitting because the Stim waveform %s failed to load!\n",file$);
                Stop%();
                return -1;
            endif;
            
            'reads fh% two bytes at a time, puts in recStimTransfer%[]
            'printlog("Time before BReadSize is %f\n",seconds());
            nread%:=breadsize(2,rec2StimTransfer%[][i%]); 
            'printlog("BReadSize returned at %f\n",seconds());
            if nread% < 0 then
                printlog("There was an error in reading the binary file!  The error is number %d and the text of the error is '%s'\n",nread%,Error$(nread%));
            else
                printlog("Number of bytes read = %d\n",nread%);
            endif;
            
            
            'close current stimulus
            fileclose();  'close fh%
        next
        
        
        
        'Finally, place the stimulus into the appropriate Play Wave Area
        if recCEDIsPresent% = 1 then
            'printlog("Time before PlayWaveCopy is %f\n",seconds());
            playWaveCopyOK% := PlayWaveCopy(pwChar$, rec2StimTransfer%[][]);  'recStimTransfer% is an integer array and as such should be signed 16 bit integers
            'printlog("PlayWaveCopy returned at %f\n",seconds());
            if playWaveCopyOK% < 0 then 'error
                message("There has been an error in PlayWaveCopy!  Check Log File!");
                printlog("There was an error in PlayWaveCopy!  The error is number %d and the text of the error is '%s'\n",playWaveCopyOK%,Error$(playWaveCopyOK%));
                'recReadyToQuit% := 1;  'This will allow the entire thing to quit
                'SafeSampleKey("M");  'Turn off LED
                'Stop%();
                'return -1;
            else
                printlog("PlayWaveCopy success for PWA %s!\n",pwChar$);
                SafeSampleKey("X");  'This puts in a delay (timed on the sequencer) to prevent 'too fast' calls to play the stim after loading
            endif;
        endif;
        
    endif;
    
    
    recStimCount% := 0;  'Reset stim count
    return ok%;
    
end



'''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' IdleLoop%()
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func IdleLoop%()
	var iStatus% := 1;	' this is return value. value of 1 (0) continues (stops) processing
    var stmp%;
    var strtmp$;
    var PWA$;
    var s$;
    var temprnd;  'a temporary variable to hold a Rand, used for changing reward type
    
    
    nextStateImmed% := 1;  'obviously we run the damn thing the FIRST time through each idle loop
                           'Note that ChangeStateTo() sets nextStateImmed% to 1, so we will ALWAYS
                           'try the next state immediately, and only return control to the OS when
                           'the current state is not ready to move on yet.
    
    while nextStateImmed% = 1 do  'Allows repeat of internal loop; otherwise we have to wait until the idle function is called again, OS may grab time
        
        'Get the current time
        if recCEDIsPresent% = 1 then
            tNow :=  View(recDataWindowView%).MaxTime();
        else
            tNow += .05;  'simulate 50 ms between loops
        endif
        
        'Don't repeat this (internal) loop unless there is a state change (ChangeStateTo() will set to 1)
        'or specifically asked to below for timing purposes
        nextStateImmed% := 0; 
        
        
        
        'Update the joystick plot every 5 ms
        'printlog("recUseJoystick% is %d and tNow is %f and tLastJoyUpdate is %f\n",recUseJoystick%,tNow,tLastJoyUpdate);
        if recUseJoystick% <> 0 and tNow-tLastJoyUpdate > .005 and recCEDIsPresent% = 1 and tNow > .002 then
            XJoy := View(recDataWindowView%).ChanMeasure(configJoyXChannel%,2,tNow-.001,tNow-.006);
            YJoy := View(recDataWindowView%).ChanMeasure(configJoyYChannel%,2,tNow-.001,tNow-.006);
            View(joyview%).XYAddData(joydatachan%,XJoy,YJoy);  'do not need to flip axis values
            tLastJoyUpdate := tNow;
            'printlog("Updated joystick voltage with x voltage %f and y voltage %f\n",XJoy,YJoy);
        endif;
        
        
        
        ' ============= State Logic - determine which state we are in 
        docase
        case iState% = stateStart% then
            'This state is only entered once per "experiment" - once per each time the template file passes control
            RecLogStatus("Start", "Starting state logic loop.");
            docase
            case recExpToRun% = recExpFRAButton% and recFRALoadStim% = 1 then
                ChangeStateTo(stateFRAInitializeTrials%);
            case recExpToRun% = recExpLongToneButton% then
                ChangeStateTo(statePrepareTone%);
            else
                ChangeStateTo(stateInitializeTrials%);
            endcase;
            
            
        case iState% = stateInitializeTrials% then
            
            ToolbarText("#HITS = " + str$(numHits%) + ",   #MISSES = " + str$(numMisses%) + ",   #FPs = " + str$(numFPs%) + ";   LastHit(mL) = " + str$(LastHitReward) + 
            ",   TOTAL(mL) = " + str$(amountRewarded) + ";   On Trial # " + str$(recCurrentTrial%) + " of " + str$(recNTrials%) + ".");                       
            
            ' prepare stimuli for the next trial.
            ' this is the point where the expt can be paused. Operator can hit the pause
            ' button anytime, but the actual pause will happen here. --> added a few pause checks, will check in each state up until statePreTrialDelay
            
            if RTESDIsPressed% = 1 then  'if the ReturnToExperimentSelectionDialog button has been pressed, this is where we return
                ReturnToExptSelectDialog%();  'this doesn't actually get us out...but it changes some variables
                iStatus% := 0;  'this is how we get out
                nextStateImmed% := 0;  'this keeps the rest of everything from executing
            endif;
            
            
            CheckLever%("inOrigin%",1);  'flush joystick/lever data, default to inOrigin
            
            'Replace indiscriminate SampleAutoCommit period with pre-trial commit that won't interfere with trials
            'Will not work with Spike6
            '            if tNow > LastSamplingCommitTime + SamplingCommitPeriod then
            '                View(recDataWindowView%).Modified(0,0);  'Not sure if 0,0 (faster, to OS buffer but no disk write) or 0,1 (slower, full write to disk)
            '                LastSamplingCommitTime := tNow;
            '            endif;
            
            
            'only original check for pause location....
            if recIsPaused% = 0 and iStatus% = 1 then  'if not paused and we actually keep going, do trial initialization
                
                docase
                case recExpToRun% = recExpStereoDisButton% then
                    stmp% := PrepareNextTrial2PWAs(1);
                case recExpToRun% = recExpAudiogramButton% and recAudiogramStartNewTrial% = 1 then
                    stmp% := PrepareNextTrial%(1); 'load PWAs, should gracefully pass through in debug mode as well
                case recExpToRun% = recExpAudiogramButton% and recAudiogramStartNewTrial% = 0 then    
                    recCurrentTrial% -= 1;  'if current trial (in human units) is same as last trial, PrepareNextTrial will exit.  Decrement, will reincrement upon return. -jj 8/21/17
                    stmp% := PrepareNextTrial%(0);  'don't load PWAs for repeated audiogram stimuli
                case recExpToRun% = recExpSearchButton% and recSearchLoaded% = 1 then
                    stmp% := PrepareNextTrial%(0);  'don't load PWAs for search trials after #1
                else
                    stmp% := PrepareNextTrial%(1); 'load PWAs, should gracefully pass through in debug mode as well
                    recSearchLoaded% := 1;  'only allow loading PWAs once for search                  
                endcase;
                
                docase
                case stmp% = 0 then
                    RecLogStatus("PrepareNextTrial", "All trials are done!");
                    ChangeStateTo(stateDone%);
                    'Note that we can't actually get here from Search, the user simply hits the NewExpt. button to end search and move on
                case stmp% < 0 then
                    RecLogStatus("PrepareNextTrial", "Error return value from PrepareNextTrial%");
                    ChangeStateTo(stateCodingError%);
                else
                    recCurrentTrial% += 1;  'recCurrentTrial% only incremented here, upon successful PWA load of new trial.
                    docase
                    case recExpToRun% = recExpAudiogramButton% and recAudiogramStartNewTrial% = 1 then 
                        recAudiogramStartNewTrial% := 0;  'the increment above has been accepted, don't let it increment again until new frequency is needed
                    case recExpToRun% = recExpAudiogramButton% and recAudiogramStartNewTrial% = 0 then
                        'recCurrentTrial% -= 1;  'if we are not starting a new trial on audiogram, undo increment of trial counter (now more correctly done earlier -jj 8/21/17)
                    endcase;
                    RecLogStatus("PrepareNextTrial", "Trial #" + str$(recCurrentTrial%) + " ready.");
                    RecLogStatus("Passive task", "True: " + str$(recAMSPPassiveTask%));  'seems pretty unnecessary, not dealing with it now just in case (jj 2/13/2020)
                    ChangeStateTo(stateDetermineRewardType);  'We are no longer DeterminingRewardType as microstim is dead, just sampletexting at this point
                endcase
            else  'but if paused, check to see if we have a call out to a dialog box to change values
                if recRunTimeCall% = 1 then
                    docase
                    case recWhichDialogCalled% = 1 then
                        RecExpTimingRewardDialog%();
                        ReturnFromDialogCall%();
                    case recWhichDialogCalled% = 2 then
                        RecExpLeverJoystickDialog%();  
                        ReturnFromDialogCall%();
                    endcase
                endif
            endif
            
            
        case iState% = stateFRAInitializeTrials% then
            
            ToolbarText("#HITS = " + str$(numHits%) + ",   #MISSES = " + str$(numMisses%) + ",   #FPs = " + str$(numFPs%) + ";   LastHit(mL) = " + str$(LastHitReward) + 
            ",   TOTAL(mL) = " + str$(amountRewarded) + ";   On Trial # " + str$(recCurrentTrial%) + " of " + str$(recNTrials%) + ".");                       
            
            ' prepare stimuli for the next trial.
            ' this is the point where the expt can be paused. Operator can hit the pause
            ' button anytime, but the actual pause will happen here. --> added a few pause checks, will check in each state up until statePreTrialDelay
            
            if RTESDIsPressed% = 1 then  'if the ReturnToExperimentSelectionDialog button has been pressed, this is where we return
                ReturnToExptSelectDialog%();  'this doesn't actually get us out...but it changes some variables
                iStatus% := 0;  'this is how we get out
                nextStateImmed% := 0;  'this keeps the rest of everything from executing
            endif;
            
            'Replace indiscriminate SampleAutoCommit period with pre-trial commit that won't interfere with trials
            'Will not work with Spike6
            '            if tNow > LastSamplingCommitTime + SamplingCommitPeriod then
            '                View(recDataWindowView%).Modified(0,0);  'Not sure if 0,0 (faster, to OS buffer but no disk write) or 0,1 (slower, full write to disk)
            '                LastSamplingCommitTime := tNow;
            '            endif;
            
            
            'only original check for pause location....
            if recIsPaused% = 0 and iStatus% = 1 then  'if not paused and we actually keep going, do trial initialization
                
                stmp% := FRAPrepareNextTrial%(1);
                
                docase
                case stmp% = 0 then
                    RecLogStatus("FRA PrepareNextTrial", "All trials are done!");
                    ChangeStateTo(stateDone%);
                    'Note that we can't actually get here from Search, the user simply hits the NewExpt. button to end search and move on
                case stmp% < 0 then
                    RecLogStatus("FRA PrepareNextTrial", "Error return value from PrepareNextTrial%");
                    ChangeStateTo(stateCodingError%);
                else
                    recCurrentTrial% += 1;  'recCurrentTrial% only incremented here, upon successful load of new trial.
                    RecLogStatus("FRA PrepareNextTrial", "Trial #" + str$(recCurrentTrial%) + " ready.");
                    if recCurrentTrial% = 1 then ' if this is the first trial go right to playing
                        ChangeStateTo(stateStartSoundE%);
                    else
                        ChangeStateTo(stateFRAISIDelay%);
                    endif;
                endcase
            else  'but if paused, check to see if we have a call out to a dialog box to change values
                if recRunTimeCall% = 1 then
                    docase
                    case recWhichDialogCalled% = 1 then
                        RecExpTimingRewardDialog%();
                        ReturnFromDialogCall%();
                    case recWhichDialogCalled% = 2 then
                        RecExpLeverJoystickDialog%();  
                        ReturnFromDialogCall%();
                    endcase
                endif
            endif
            
        case iState% = stateDetermineRewardType then  'Not actually determining reward type anymore, just sampletexting the trial start.  
            'CHECK FOR PAUSE HERE TOO:
            if recIsPaused% = 0 and iStatus% = 1 then  'if not paused and we actually keep going, determine reward type
                
                'I have commented out ALL the code here that presumes that we might have stimulation reward, as that
                'is dead.  Hopefully it never comes back, but if it does...we're ready to go...
                
                'If necessary, change the reward type on this trial (recRewardType 0/1 does not change)
                'Note that this step is done here rather than stateInitializeTrials because all relevant results
                'go through this state (miss, various FA, lazy monkey), but lazy monkey does NOT go through stateInitializeTrials
'                docase  
'                case recRewardType% = 3 and recChangeRewardType% = 1 then 'cycle through reward types
'                    recChangeRewardType% := 0;  'Reset, don't change again until necessary
'                    recCurrentRewardType% += 1;  'increment current reward type
'                    if recCurrentRewardType% = 3 then 'legal values are [0 1 2], if 3, cycle to 0
'                        recCurrentRewardType% := 0;
'                    endif;
'                case recRewardType% = 4 then 'and recChangeRewardType% = 1 then 'select random reward type based on values set in dialog
'                    'recChangeRewardType% := 0;  'Reset, don't change again until necessary
'                    temprnd := Rand(100,0);  'get rand, values in dialog are in terms of percentage
'                    docase
'                    case temprnd < recPctJuice% then
'                        recCurrentRewardType% := 0;  'set juice
'                    case temprnd > recPctJuice% and temprnd < (recPctJuice%+recPctStimulation%) then
'                        recCurrentRewardType% := 1;  'set stimulation
'                    else
'                        recCurrentRewardType% := 2;  'set juice + stimulation
'                    endcase   
'                case recRewardType% = 5 then
'                    temprnd := Rand(100,0);  'get rand, values in dialog are in terms of percentage
'                    docase
'                    case temprnd < recPctStimulation% then
'                        recCurrentRewardType% := 2;  'set juice + stimulation
'                    else
'                        recCurrentRewardType% := 0;  'set juice only
'                    endcase
'                endcase
'                
'                
'                docase
'                case recCurrentRewardType% = 0 then
'                    SampleText("Trial #" + str$(recCurrentTrial%) + ", Juice reward", tNow);
'                case recCurrentRewardType% = 1 then
'                    SampleText("Trial #" + str$(recCurrentTrial%) + ", Stim reward", tNow);
'                case recCurrentRewardType% = 2 then
'                    SampleText("Trial #" + str$(recCurrentTrial%) + ", Juice+Stim reward", tNow);
'                endcase
                
                'Indicate the start of the trial, loosely
                SampleText("Trial #" + str$(recCurrentTrial%), tNow);
                
                'do state stuff here...
                ChangeStateTo(stateStartCEDBlink%);
                
            else  'but if paused, check to see if we have a call out to a dialog box to change values
                if recRunTimeCall% = 1 then
                    docase
                    case recWhichDialogCalled% = 1 then
                        RecExpTimingRewardDialog%();
                        ReturnFromDialogCall%();
                    case recWhichDialogCalled% = 2 then
                        RecExpLeverJoystickDialog%();  
                        ReturnFromDialogCall%();
                    endcase
                endif
            endif
            
            
            
        case iState% = stateStartCEDBlink% then
            'CHECK FOR PAUSE HERE TOO:
            if recIsPaused% = 0 and iStatus% = 1 then  'if not paused and we actually keep going, do trial initialization
                'do state stuff here
                CheckLever%("inOrigin%",1);
                if inOrigin% = 1 or recAMSPPassiveTask% = 1 then  'lever must be in origin to start blink
                    if tNow > tNextTrial then
                        RecLogStatusSpecificTime("WaitTrlInit", "Blink/Wait.",tNow);
                        if recCEDIsPresent% = 1 and recActive% = 1 then
                            SampleSeqVar(4,1);  'set the flash sequence to on
                            Sampleseqvar(6,500/SampleSeqClock(1));  'Flashing at 500 ms, divide by sequencer period in ms to get number of sequencer clock ticks
                            sampleseqvar(5,ceil((recTrialInitWindow*1000)/(500*2)));  'Set sequencer variable 5 to number of flashes, 500 ms flash duration, put recTrialInitWindow in ms
                            sampleseqvar(8,1);  'Set Flash-Allow variable to 1, this allows flashing
                            SafeSampleKey("L");  'Start the flash
                            tStartBlink :=  View(recDataWindowView%).MaxTime(); 
                            RecLogStatusSpecificTime("Testing", "Trial initiation window should end at " + str$(tStartBlink + recTrialInitWindow),tNow);
                        else
                            tStartBlink := tNow;
                        endif;
                        ChangeStateTo(stateCEDBlinking%);
                    endif;
                else
                    if tNow > recTrialInitWindow + tNextTrial then  'Use trial init window both for getting into origin and starting trial
                        '''Lazy monkey timeout excised!  Uncomment to reinstate!
                        '                        RecLogStatus("PreBlinkPeriod", "Timeout waiting for lever/joystick into origin.");
                        '                        ChangeStateTo(stateLazyMonkeyTimeout%);                        
                        RecLogStatusSpecificTime("PreBlinkPeriod", "Waiting for joystick in origin, still waiting, NOT going to timeout",tNow);
                        tNextTrial := tNow;  'reset tNextTrial so this does not repeat EVERY loop
                        
                    endif;
                endif;
            else  'but if paused, check to see if we have a call out to a dialog box to change values
                if recRunTimeCall% = 1 then
                    docase
                    case recWhichDialogCalled% = 1 then
                        RecExpTimingRewardDialog%();
                        ReturnFromDialogCall%();
                    case recWhichDialogCalled% = 2 then
                        RecExpLeverJoystickDialog%();  
                        ReturnFromDialogCall%();
                    endcase
                endif
            endif
            
        case iState% = stateCEDBlinking% then
            'CHECK FOR PAUSE HERE TOO:
            if recIsPaused% = 0 and iStatus% = 1 then  'if not paused and we actually keep going, do trial initialization
                'do state stuff here
                if tNow < tStartBlink + recTrialInitWindow then
                    CheckLever%("inTrialInit%",1);
                    'printlog("InTrialInit value is %d and time is %f\n",inTrialInit%,tNow);
                    'printlog("recAMSPPassiveTask value is %d and time is %f\n",recAMSPPassiveTask%,tNow);
                    'if we are starting the trial
                    if inTrialInit% = 1 or recAMSPPassiveTask% = 1 then
                        'if there is a blink sequence, stop it
                        if recCEDIsPresent% = 1 and recActive% = 1 then
                            SampleKey("S"); 'stop blink sequence *immediately* - therefore, do not use SafeSampleKey
                        endif;
                        
                        if recFixLED% = 1 then
                            SafeSampleKey("L"); 'turn on LED for fixpt
                        endif;
                        'Increment, if appropriate
                        ChangeThresh2(doIncTrialInit%[]);
                        'Calculate new delay interval time, unless there was an interrupt in the last one, in that case keep it
                        if recDelayIntervalInterrupt% = 0 then
                            recDelayIntervalTime := recMinOnsetDelay + Rand(recVarOnsetDelay, 0);
                        endif;
                        RecLogStatus("WaitTrlInit", "Delay interval=" + str$(recDelayIntervalTime) + " s.");
                        ChangeStateTo(statePreTrialDelay%);
                    endif;
                else  'this is timeout
                    SafeSampleKey("S"); 'stop blink sequence immediately, though it should already be stopped - this might need to be unSafe'd as well
                    '''Lazy monkey timeout excised!  Uncomment to reinstate!
                    '                    RecLogStatus("WaitTrlInit", "Timeout waiting for trial initiation.");
                    RecLogStatus("WaitTrlInit", "Still waiting for trial initiation, restarting blink.");
                    
                    'Decrement, if appropriate
                    'ChangeThresh(-doIncUp%,-doIncDown%,-doIncLeft%,-doIncRight%); 'old version
                    ChangeThresh2(doDecTrialInit%[]);
                    
                    '''Lazy monkey timeout excised!  Uncomment to reinstate!
                    '                    ChangeStateTo(stateLazyMonkeyTimeout%);
                    ChangeStateTo(stateDetermineRewardType);
                endif;
                
            else  'but if paused, check to see if we have a call out to a dialog box to change values
                if recRunTimeCall% = 1 then
                    docase
                    case recWhichDialogCalled% = 1 then
                        RecExpTimingRewardDialog%();
                        ReturnFromDialogCall%();
                    case recWhichDialogCalled% = 2 then
                        RecExpLeverJoystickDialog%();  
                        ReturnFromDialogCall%();
                    endcase
                endif
            endif
            
            '        case iState% = stateTDTBlink% then
            '
            '           'CHECK FOR PAUSE HERE TOO:
            '            if recIsPaused% = 0 and iStatus% = 1 then  'if not paused and we actually keep going, do trial initialization
            '                'do state stuff here
            '                CheckLever%("inOrigin%",1);
            '                if inOrigin% = 1 then  'lever must be up to start blink
            '                    if tNow > tNextTrial then
            '                        
            '                        RecLogStatus("WaitTrlInit", "Blink/Wait.");
            '                        
            '                        'leave this the same...recBlinkUntilLeverDown%() is special, and I DON'T want to recode it
            '                        if recCEDIsPresent% = 1 and recActive% = 1 then
            '                            stmp% := recBlinkUntilLeverDown%(.5, recTrialInitWindow);  
            '                            'Will leave LED on once lever is down
            '                            if recFixLED% = 0 then
            '                                SafeSampleKey("M"); 'turn LED off if we are not using it for fixation
            '                            endif;
            '                        else
            '                            stmp% := 1;  'simulate success in lever press
            '                        endif
            '                        
            '                        docase
            '                        case stmp% = 1 then
            '                            recDelayIntervalTime := recMinOnsetDelay + Rand(recVarOnsetDelay, 0);
            '                            'SafeSampleKey("P");  'TODO: What is this?  Still don't know.  Not in Recgen.pls!
            '                            RecLogStatus("WaitTrlInit", "Delay interval=" + str$(recDelayIntervalTime) + " s.");
            '                            'Increment, if appropriate
            '                            ChangeThresh2(doIncTrialInit%[]);
            '                            ChangeStateTo(statePreTrialDelay%);
            '                        case stmp% = 0 then
            '                            RecLogStatus("WaitTrlInit", "Timeout waiting for lever down.");
            '                            'Decrement, if appropriate
            '                            'ChangeThresh(-doIncUp%,-doIncDown%,-doIncLeft%,-doIncRight%);
            '                            ChangeThresh2(doDecTrialInit%[]);
            '                            ChangeStateTo(stateLazyMonkeyTimeout%);
            '                        else
            '                            PrintLog("ERROR in recBlinkUntilLeverDown%()!!!\n");
            '                            Message("Error in recBlinkUntilLeverDown!");
            '                            ChangeStateTo(stateTDTError%);
            '                        endcase
            '                    endif;
            '                else
            '                    RecLogStatus("PreBlinkPeriod", "Timeout waiting for lever up.");
            '                    ChangeStateTo(stateLazyMonkeyTimeout%);
            '                endif;
            '            
            '            else  'but if paused, check to see if we have a call out to a dialog box to change values
            '                if recRunTimeCall% = 1 then
            '                    docase
            '                    case recWhichDialogCalled% = 1 then
            '                        RecExpTimingRewardDialog%();
            '                        ReturnFromDialogCall%();
            '                    case recWhichDialogCalled% = 2 then
            '                        RecExpLeverJoystickDialog%();  
            '                        ReturnFromDialogCall%();
            '                    endcase
            '                endif
            '            endif
            '            
        case iState% = stateLazyMonkeyTimeout% then
            '''Lazy monkey timeout excised!  Uncomment to reinstate!
            '            CheckLever%("inOrigin%",1);  'Flush lever/joystick during timeout, default assign to in origin
            '            if tNow - tStateStart > recLazyMonkeyTO then
            '                RecLogStatus("LazyMonkeyTimeout", "Timeout period done. Trial #" + str$(recCurrentTrial%) + " ready.");
            '                recChangeRewardType% := 1;  'will change reward type after lazy timeout, if other conditions are met 
            '                ChangeStateTo(stateDetermineRewardType);  'restart as if we had just finished loading
            '                tNextTrial := tNow;
            '            endif
            ChangeStateTo(stateDetermineRewardType);  'we should not enter this state
            RecLogStatus("LazyMonkeyTimeout","Entered Lazy Monkey Timeout!  This should currently be disabled, so WTF?!?"); 'log status that cannot be reached put in for...reasons, I guess
            
            
            
        case iState% = statePreTrialDelay% then
            'printlog("tnow is %f and tstatestart is %f and diff is %f\n",tNow,tStateStart, tNow-tStateStart);
            CheckLever%("inTrialInit%",1);
            if recAMSPPassiveTask% = 1 then
                inTrialInit% := 1;
            endif
            
            docase  
            case inTrialInit% <> 1 and recCEDIsPresent% = 1  and recActive% = 1 and recExpToRun% = recExpAudiogramButton% then 
                'for the Audiogram experiment, we need to treat this NOT as a slip
                RecLogStatus("DelayInterval", "False Alarm during delay.");
                ChangeStateTo(stateFalseAlarmAudiogram%); 
                SafeSampleKey("M");  'turn off LED
                recDelayIntervalInterrupt% := 1;
            case inTrialInit% <> 1 and recCEDIsPresent% = 1  and recActive% = 1 then
                'for all other experiments we are generous and treat this as a slip
                RecLogStatus("DelayInterval", "Interrupt during delay.");
                SafeSampleKey("M");  'turn off LED
                ChangeStateTo(stateDetermineRewardType);  'no interrupt penalty, it's probably a slip, just start over, trial already loaded
                tNextTrial := tNow;
                recDelayIntervalInterrupt% := 1;
            case tNow - tStateStart >= recDelayIntervalTime then
                RecLogStatus("DelayInterval", "Delay done.");
                recDelayIntervalInterrupt% := 0;
                docase
                case recDoJoyTrain% = 1 then '*jao
                    SafeSampleKey("M");  'turn off LED
                    ChangeStateTo(stateHitReward%); 
                case recTrialInitReward% <> 0 then 'if not zero (might be -1 from last trial)
                    recTrialInitReward% :=1; 'set it back to 1
                    ChangeStateTo(stateTrialInitReward%);
                case recExpToRun% = recExpAudiogramButton% then
                    isS2% := 1;  'all audiogram stimuli deserve a response
                    ChangeStateTo(stateStartSoundB%);  'for audiogram, there is only one sound, we want a response, so let's just call it sound B
                else
                    isS2% := 0;  'by definition sound A is an S1
                    ChangeStateTo(stateStartSoundA%);
                endcase '*jao
            endcase
            
            
            
        case iState% = stateStartSoundA% then  'SoundA is a non-terminal S1
            
            RecLogStatus("TrialSoundA", "Call expt function");
            if recCEDIsPresent% = 1 then
                if recExpToRun% = recExpStereoDisButton% then
                    stmp% := PlayTwoSounds%(recStimCount%);
                else
                    stmp% := PlaySound%(isS2%);
                endif;
                
                recStimOn := StimOn;   
                
                RecLogStatus("stmp", "stmp%=" + str$(stmp%));
            else
                stmp% := 0;  'simulate playing sound if no CED
                'stmp% := PlayTwoSounds%(recStimCount%);  'Hmm.  Other "simulate" periods do not call PlaySound.  Why we would
                                                          'call PlayTWOSounds without regard to the experiment is not clear.
                                                          'Either way, PlayTwoSounds (and PlaySound) are set up to do things
                                                          'like atten calculations without a CED present, so we could put it
                                                          'back in if we want, don't know if it's useful though -jj
                printlog("No CED, stim would be %s\n",NameThatStimulus$(recStimList%[recPWAList%[recStimCount%][recTrialOrder%[recCurrentTrial%-1]]][recTrialOrder%[recCurrentTrial%-1]]));
            endif;
            
            docase
            case stmp% = 0 then
                ChangeStateTo(stateSoundAPlaying%);
            case stmp% < 0 then
                RecLogStatus("TrialSoundA", "PlaySound returned negative value.");
                ChangeStateTo(stateTDTError%);
            else
                RecLogStatus("TrialSoundA", "PlaySound returned unknown value (>0).");
                ChangeStateTo(stateTDTError%);
            endcase
            
            
            
        case iState% = stateSoundAPlaying% then
            
            'Note that we are now checking the PlayWaveStatus instead of relying on the variable isPlaying%, which
            'has been removed.  In principle the isPlaying% method should work, but there are some strange issues 
            'that suggest tomfoolery with the PlayWaveAreas that *might* be caused by a PlayWaveStop() command, which
            'is simply assumed to work, instead failing.  The solution as designed is, while any sound is playing, to
            'first check the PlayWaveStatus in order to get the number of points played.  If the number of points
            'played is greater than the number of points in the stimulus, we are presumed to be in a blank space at
            'the end of a long PWA, and we call a PlayWaveStop.  Then, regardless of the number of points returned, 
            'we check the PlayWaveStatus again.  If the stimulus is in fact no longer playing, we move forward,
            'otherwise we wait for the stimulus to be stopped as reported by PlayWaveStatus.  Previously, after a 
            'PlayWaveStop was called, isPlaying% was set to zero, but no explicit check that the stimulus had stopped
            'playing was in fact done.  That check is now explicit, and all commented calls to isPlaying% have been excised.
            
            'See if sound is still playing, get number of points played
            if recCEDIsPresent% = 1 then  'only check play wave status if the CED is there
                PWA$ := PlayWaveStatus$(recPointsPlayed%);
            else
                PWA$ := "";  'if CED is absent simulate end of stimulus
            endif;
            
            'If sound is still playing, see if it should be over, stop it if so
            if recPointsPlayed% >= recPlayPoints%  then
                PlayWaveStopWithErrorCheck();  'stop playing stimulus while we're at it
            endif;
            
            'Check again to see if sound is playing
            if recCEDIsPresent% = 1 then  'only check play wave status if the CED is there
                PWA$ := PlayWaveStatus$(recPointsPlayed%);
            else
                PWA$ := "";  'if CED is absent simulate end of stimulus
            endif;
            
            CheckLever%("inTrialInit%",1);
            
            docase
            case PWA$ = "" then
                docase
                case recAMSPPassiveTask% = 0 and isInterrupt% = 1 then
                    isInterrupt% := 0;  'reset variable
                    StimComplete%(0, 0);  'recPreciseTrialTime was determined when interrupt occurred
                    SafeSampleKey("M");  'Turn off LED
                    ChangeStateTo(stateFAInterrupt%);  'on FA interrupt, reshuffle entire stim sequence in later
                else
                    ChangeStateTo(stateISIDelay%);
                endcase
            case recActive% = 0 then
                'Do nothing here if sound is playing but there is no task; simply wait for sound to stop 
            case recAMSPPassiveTask% = 0 and inTrialInit% <> 1 then  'if the sound is still playing, check for interrupt
                'institute interrupt procedure, will be completed on the next iteration or when stimulus stops
                if isInterrupt% = 0 then  'only do this for "first" interrupt, if stimulus continues  
                    recPreciseTrialTime := recLeverTime;  'time interrupt occurred
                    RecLogStatus("TrialSoundA", "False Positive Interrupt! Lever is up");
                    numFPs% += 1;  'increment FP counter
                    isInterrupt% := 1;  'don't institute interrupt procedure twice if stimulus continues to end
                    if recContinueSoundOnS1Interrupt% = 0 then
                        if recCEDIsPresent% = 1 then
                            PlayWaveStopWithErrorCheck();  'stop playing stimulus
                        endif;
                    endif;
                endif;
            endcase
            
            
            
            
            
        case iState% = stateISIDelay% then
            CheckLever%("inTrialInit%",1);
            if recAMSPPassiveTask% = 1 then
                inTrialInit% := 1;
            endif;
            
            docase
            case recAMSPPassiveTask% = 0 and inTrialInit% <> 1 then
                RecLogStatus("WaitISI", "False Positive! Lever is up");
                numFPs% += 1;  'increment FP counter
                recPreciseTrialTime := recLeverTime;  'time false positive occurred
                StimComplete%(0, 0);
                SafeSampleKey("M");  'Turn off LED
                ChangeStateTo(stateFAInterrupt%);  'this is a false alarm, but S2 has not played, so shuffle stimulus sequence back in
            else
                if tNow - tStateStart > recISI then
                    RecLogStatus("WaitISI", "ISI done.");
                    recPreciseTrialTime := tNow;  'time ISI is complete
                    responseMode% := -1; 'reset for debugging
                    isS2% := StimComplete%(0, 1);  'update isS2% to tell us what the next stimulus is
                    responseMode% := isS2%; 'branched from isS2% for Hi/Lo responses
                    
                    docase 
                    case isS2% = 0 then
                        ChangeStateTo(stateStartSoundA%);  'SoundA is a non-terminal S1
                    case isS2% = 1 then
                        isTerminalS1% := 0;
                        ChangeStateTo(stateStartSoundB%);  'for AMdis/StereoDis: Hi (S2>S1)
                    case isS2% = 2 then
                        isTerminalS1% := 1;
                        ChangeStateTo(stateStartSoundC%);  'SoundC is a terminal S1 - a stimulus which will be rewarded for no-go; for Hi/Lo (forced choice) case, will be rewarded 50%
                        if recExpToRun% = recExpAMDiscButton% or recExpToRun% = recExpSpaceDisButton% or recExpToRun% = recExpStereoDisButton% then  'StereoDis not rewarded right now, but still run through this...may be useful in future
                            coinFlipResult% := round(rand()); 'simple 50/50 way. might want to create a variable "sameRewardRate" or something.
                            printlog("coinFlipResult% = /d%", coinFlipResult%); '*jao
                        endif;
                    case isS2% = 3 then
                        isTerminalS1% := 0;
                        ChangeStateTo(stateStartSoundD%);  'for AMDis/StereoDis: Lo (S2<S1) 
                    else
                        RecLogStatus("WaitISI", "Unknown return value from StimComplete");
                        Message("Error in StimComplete%()!!!");
                        ChangeStateTo(stateCodingError%);
                    endcase
                endif
            endcase
            
            
        case iState% = stateFRAISIDelay% then
            if tNow - StimStopped > recISI then
                RecLogStatus("FRA WaitISI", "ISI done.");
                recPreciseTrialTime := tNow;  'time ISI is complete
                if recFRAreward%[recCurrentTrial%] then 'if this trial is rewarded
                    ChangeStateTo(stateFRAHitReward%);
                else 'if not keep going
                    ChangeStateTo(stateStartSoundE%);
                endif;
            endif
            
            
        case iState% = stateFRAJuiceBreak% then
            if tNow - tStateStart > recJuiceBreak% then
                RecLogStatus("Juice break.", "Break done.");
                recPreciseTrialTime := tNow;  'time ISI is complete
                ChangeStateTo(stateStartSoundE%); 
            endif        
            
            
        case iState% = stateStartSoundB% then
            RecLogStatus("TrialSoundB", "Call expt function");
            if recCEDIsPresent% = 1 then
                if recExpToRun% = recExpStereoDisButton% then
                    stmp% := PlayTwoSounds%(recStimCount%);
                else
                    stmp% := PlaySound%(isS2%);
                endif;
                recStimOn := StimOn;
            else
                stmp% := 0;  'simulate sound playing if CED is not present
                printlog("No CED, stim would be %s\n",NameThatStimulus$(recStimList%[recPWAList%[recStimCount%][recTrialOrder%[recCurrentTrial%-1]]][recTrialOrder%[recCurrentTrial%-1]]));
            endif;
            docase
            case stmp% = 0 then
                ChangeStateTo(stateSoundBPlaying%);
            case stmp% < 0 then
                RecLogStatus("TrialSoundB", "PlaySound returned negative value.");
                ChangeStateTo(stateTDTError%);
            else
                RecLogStatus("TrialSoundB", "PlaySound returned unknown value (>0).");
                ChangeStateTo(stateTDTError%);
            endcase
            
            
            
        case iState% = stateSoundBPlaying% then
            
            'See if sound is still playing, get number of points played
            if recCEDIsPresent% = 1 then  'only check play wave status if the CED is there
                PWA$ := PlayWaveStatus$(recPointsPlayed%);
            else
                PWA$ := "";  'if CED is absent simulate end of stimulus
            endif;
            
            'If sound is still playing, see if it should be over, stop it if so
            if recPointsPlayed% >= recPlayPoints%  then
                PlayWaveStopWithErrorCheck();  'stop playing stimulus while we're at it
            endif;
            
            'Check again to see if sound is playing
            if recCEDIsPresent% = 1 then  'only check play wave status if the CED is there
                PWA$ := PlayWaveStatus$(recPointsPlayed%);
            else
                PWA$ := "";  'if CED is absent simulate end of stimulus
            endif;
            
            CheckLever%("inResponse1%",0);  'default is no early hit
            docase
            case PWA$ = "" then 'if sound is not playing
                RecLogStatus("WaitTrialSoundB", "Sound done playing.");
                ChangeStateTo(stateTrialHoldReward%);  'check for trial hold reward no matter what, will then move to response window
            case recActive% = 0 then
                'Do nothing here if sound is playing but there is no task; simply wait for sound to stop
            case recIsGoNoGo% = 1 and inResponse1% = 1 then  'if the sound is still playing, check for early hit (go/no-go)
                'accept response whether sound should be stopped or not
                if isEarlyHit% = 0 then
                    isEarlyHit% := 1;  'this is a hit before the sound has stopped playing
                    recPreciseTrialTime := recLeverTime;  'time early hit occurred
                    RecLogStatus("WaitTrialSoundB", "Lever is in response 1 - HIT interrupting S2");
                    if recContinueSoundOnS2Interrupt% = 0 then
                        if recCEDIsPresent% = 1 then
                            PlayWaveStopWithErrorCheck();  'stop playing stimulus
                        endif;
                    endif;
                endif;
            case recIsGoNoGo% = 0 and inResponse2% = 1 then 'if the sound is still playing, check for early "miss" (FC)
                'accept response whether sound should be stopped or not
                if isEarlyMiss% = 0 then
                    isEarlyMiss% := 1;  'this is a miss before the sound has stopped playing
                    recPreciseTrialTime := recLeverTime;  'time early hit occurred
                    RecLogStatus("WaitTrialSoundB", "Lever is in response 2 - MISS interrupting S2");
                    if recContinueSoundOnS2Interrupt% = 0 then
                        if recCEDIsPresent% = 1 then
                            PlayWaveStopWithErrorCheck();  'stop playing stimulus
                        endif;
                    endif;
                endif;
            case recIsGoNoGo% = 0 and inResponse1% = 1 then  'if the sound is still playing, check for early hit (FC)
                'accept response whether sound should be stopped or not
                if isEarlyHit% = 0 then
                    isEarlyHit% := 1;  'this is a hit before the sound has stopped playing
                    recPreciseTrialTime := recLeverTime;  'time early hit occurred
                    RecLogStatus("WaitTrialSoundB", "Lever is in response 1 - HIT interrupting S2");
                    if recContinueSoundOnS2Interrupt% = 0 then
                        if recCEDIsPresent% = 1 then
                            PlayWaveStopWithErrorCheck();  'stop playing stimulus
                        endif;
                    endif;
                endif;
            endcase;
            
            
            
        case iState% = stateStartSoundC% then  'sound C is a terminal S1
            'Logic here is actually the same as for sound B
            RecLogStatus("TrialSoundC", "Call expt function");
            if recCEDIsPresent% = 1 then
                if recExpToRun% = recExpStereoDisButton% then
                    stmp% := PlayTwoSounds%(recStimCount%);
                else
                    stmp% := PlaySound%(isS2%);
                endif;
                recStimOn := StimOn;  
            else
                stmp% := 0;  'simulate sound playing if CED is not present
                printlog("No CED, stim would be %s\n",NameThatStimulus$(recStimList%[recPWAList%[recStimCount%][recTrialOrder%[recCurrentTrial%-1]]][recTrialOrder%[recCurrentTrial%-1]]));
            endif;  
            docase
            case stmp% = 0 then
                ChangeStateTo(stateSoundCPlaying%);
            case stmp% < 0 then
                RecLogStatus("TrialSoundC", "PlaySound returned negative value.");
                ChangeStateTo(stateTDTError%);
            else
                RecLogStatus("TrialSoundC", "PlaySound returned unknown value (>0).");
                ChangeStateTo(stateTDTError%);
            endcase            
            
            
            
        case iState% = stateSoundCPlaying% then
            'here there really is no difference between terminal S1 ("nontarget") and target trials, we deal with the difference
            'in stateInResponseWindow% (at least if there's no interrupt of the stimulus
            
            'See if sound is still playing, get number of points played
            if recCEDIsPresent% = 1 then  'only check play wave status if the CED is there
                PWA$ := PlayWaveStatus$(recPointsPlayed%);
            else
                PWA$ := "";  'if CED is absent simulate end of stimulus
            endif;
            
            'If sound is still playing, see if it should be over, stop it if so
            if recPointsPlayed% >= recPlayPoints%  then
                PlayWaveStopWithErrorCheck();  'stop playing stimulus while we're at it
            endif;
            
            'Check again to see if sound is playing
            if recCEDIsPresent% = 1 then  'only check play wave status if the CED is there
                PWA$ := PlayWaveStatus$(recPointsPlayed%);
            else
                PWA$ := "";  'if CED is absent simulate end of stimulus
            endif;
            
            CheckLever%("inResponse1%",0);  'default no false alarm
            docase
            case PWA$ = "" then    
                RecLogStatus("WaitTrialSoundC", "Sound done playing.");
                if isEarlyFA% = 1 then
                    ChangeStateTo(stateInResponseWindow%);  'this will just shunt to the FA penalty, but it keeps the logic consistent
                else
                    ChangeStateTo(stateTrialHoldReward%);
                endif;
            case recActive% = 0 then
                'Do nothing here if sound is playing but there is no task; simply wait for sound to stop
            case recIsGoNoGo% = 1 and inResponse1% = 1 then 'if the sound is still playing, check for early FA (go/no-go)
                'accept response whether sound should be stopped or not
                if isEarlyFA% = 0 then
                    isEarlyFA% := 1;  'this is a hit before the sound has stopped playing
                    recPreciseTrialTime := recLeverTime;  'time early FA occurred
                    RecLogStatus("WaitTrialSoundC", "Lever is up - FA interrupting terminal S1");
                    if recContinueSoundOnS1Interrupt% = 0 then
                        if recCEDIsPresent% = 1 then
                            PlayWaveStopWithErrorCheck();  'stop playing stimulus
                        endif;
                    endif
                endif
            case recIsGoNoGo% = 0 and inResponse2% = 1 then 'if the sound is still playing, check for early CR (FC)
                'accept response whether sound should be stopped or not
                if isEarlyCR% = 0 then
                    isEarlyCR% := 1;  'this is a hit before the sound has stopped playing
                    recPreciseTrialTime := recLeverTime;  'time early CR occurred
                    RecLogStatus("WaitTrialSoundC", "Lever is up - FA interrupting terminal S1");
                    if recContinueSoundOnS1Interrupt% = 0 then
                        if recCEDIsPresent% = 1 then
                            PlayWaveStopWithErrorCheck();  'stop playing stimulus
                        endif;
                    endif
                endif
            case recIsGoNoGo% = 0 and inResponse1% = 1 then 'if the sound is still playing, check for early FA (FC)
                'accept response whether sound should be stopped or not
                if isEarlyFA% = 0 then
                    isEarlyFA% := 1;  'this is a hit before the sound has stopped playing
                    recPreciseTrialTime := recLeverTime;  'time early FA occurred
                    RecLogStatus("WaitTrialSoundC", "Lever is up - FA interrupting terminal S1");
                    if recContinueSoundOnS1Interrupt% = 0 then
                        if recCEDIsPresent% = 1 then
                            PlayWaveStopWithErrorCheck();  'stop playing stimulus
                        endif;
                    endif
                endif                
            endcase            
            
            
            
            'Keep this space open for Sound D - a terminal S3 stimulus! --> here it is! *jao
        case iState% = stateStartSoundD% then
            RecLogStatus("TrialSoundD", "Call expt function");
            if recCEDIsPresent% = 1 then
                if recExpToRun% = recExpStereoDisButton% then
                    stmp% := PlayTwoSounds%(recStimCount%);
                else
                    stmp% := PlaySound%(isS2%);
                endif;
                recStimOn := StimOn;  
            else
                stmp% := 0;  'simulate sound playing if CED is not present
                printlog("No CED, stim would be %s\n",NameThatStimulus$(recStimList%[recPWAList%[recStimCount%][recTrialOrder%[recCurrentTrial%-1]]][recTrialOrder%[recCurrentTrial%-1]]));
            endif;
            docase
            case stmp% = 0 then
                ChangeStateTo(stateSoundDPlaying%);
            case stmp% < 0 then
                RecLogStatus("TrialSoundD", "PlaySound returned negative value.");
                ChangeStateTo(stateTDTError%);
            else
                RecLogStatus("TrialSoundD", "PlaySound returned unknown value (>0).");
                ChangeStateTo(stateTDTError%);
            endcase     'exactly the same as stateStartSoundB *jao
            
            
        case iState% = stateSoundDPlaying% then
            
            'See if sound is still playing, get number of points played
            if recCEDIsPresent% = 1 then  'only check play wave status if the CED is there
                PWA$ := PlayWaveStatus$(recPointsPlayed%);
            else
                PWA$ := "";  'if CED is absent simulate end of stimulus
            endif;            
            
            'If sound is still playing, see if it should be over, stop it if so
            if recPointsPlayed% >= recPlayPoints%  then
                PlayWaveStopWithErrorCheck();  'stop playing stimulus while we're at it
            endif;
            
            'Check again to see if sound is playing
            if recCEDIsPresent% = 1 then  'only check play wave status if the CED is there
                PWA$ := PlayWaveStatus$(recPointsPlayed%);
            else
                PWA$ := "";  'if CED is absent simulate end of stimulus
            endif;
            
            CheckLever%("inResponse2%",0);  'default is no early hit 'switched to Response2 for S3 *jao
            docase
            case PWA$ = "" then    
                RecLogStatus("WaitTrialSoundD", "Sound done playing.");
                ChangeStateTo(stateTrialHoldReward%);  'check for training reward no matter what
            case recActive% = 0 then
                'Do nothing here if sound is playing but there is no task; simply wait for sound to stop
            case recIsGoNoGo% = 1 and inResponse2% = 1 then  'if the sound is still playing, check for early hit (go/no-go) 'Response2=Hit, though this case should never really happen *jao
                'accept response whether sound should be stopped or not
                if isEarlyHit% = 0 then
                    isEarlyHit% := 1;  'this is a hit before the sound has stopped playing
                    recPreciseTrialTime := recLeverTime;  'time early hit occurred
                    RecLogStatus("WaitTrialSoundD", "Lever is in response 1 - HIT interrupting S2 ... WAIT! HOW DID WE GET HERE?!");
                    if recContinueSoundOnS2Interrupt% = 0 then
                        if recCEDIsPresent% = 1 then
                            PlayWaveStopWithErrorCheck();  'stop playing stimulus
                        endif;
                    endif;
                endif;
            case recIsGoNoGo% = 0 and inResponse1% = 1 then 'if the sound is still playing, check for early "miss" (FC) 'Response1=Miss, *jao
                'accept response whether sound should be stopped or not
                if isEarlyMiss% = 0 then
                    isEarlyMiss% := 1;  'this is a miss before the sound has stopped playing
                    recPreciseTrialTime := recLeverTime;  'time early hit occurred
                    RecLogStatus("WaitTrialSoundD", "Lever is in response 2 - MISS interrupting S2");
                    if recContinueSoundOnS2Interrupt% = 0 then
                        if recCEDIsPresent% = 1 then
                            PlayWaveStopWithErrorCheck();  'stop playing stimulus
                        endif;
                    endif;
                endif;
            case recIsGoNoGo% = 0 and inResponse2% = 1 then  'if the sound is still playing, check for early hit (FC) 'Response2=Hit, *jao
                'accept response whether sound should be stopped or not
                if isEarlyHit% = 0 then
                    isEarlyHit% := 1;  'this is a hit before the sound has stopped playing
                    recPreciseTrialTime := recLeverTime;  'time early hit occurred
                    RecLogStatus("WaitTrialSoundD", "Lever is in response 1 - HIT interrupting S2");
                    if recContinueSoundOnS2Interrupt% = 0 then
                        if recCEDIsPresent% = 1 then
                            PlayWaveStopWithErrorCheck();  'stop playing stimulus
                        endif;
                    endif;
                endif;
            endcase;
            
        case iState% = stateStartSoundE% then
            RecLogStatus("TrialSoundE", "Call expt function");
            if recCEDIsPresent% = 1 then
                stmp% := PlayTwoSounds%(recStimCount%);  'For FRA, we need to pass a value, but it will be ignored
                StimStoppedNotSet% := 1; ' now that we played a sound we need to set the time of that sound stopping again (for ISI)
                recStimOn := StimOn;  
                'dummy% := fraStimComplete%();  'This was not the right time to run this function
            else
                stmp% := 0;  'simulate sound playing if CED is not present
                printlog("No CED, stim would be [this code is incomplete and I'm not fixing it now]");
            endif;
            docase
            case stmp% = 0 then
                ChangeStateTo(stateSoundEPlaying%);
            case stmp% < 0 then
                RecLogStatus("TrialSoundE", "PlayTwoSounds returned negative value.");
                ChangeStateTo(stateTDTError%);
            else
                RecLogStatus("TrialSoundE", "PlayTwoSounds returned unknown value (>0).");
                ChangeStateTo(stateTDTError%);
            endcase    
            
        case iState% = stateSoundEPlaying% then
            
            'This particular IF statement seems not terribly useful, but as designed it is the only way to get out
            'of this idle loop state.  
            if tNow - (stimOn + (recDur/1000) + 0.01) > 0 then
                RecLogStatus("WaitTrialSoundE", "Calling playwave stop.");
                PlayWaveStop();  'I would guess that this often gets called with the PWA already stopped
                
                if StimStoppedNotSet% then
                    StimStopped :=  View(recDataWindowView%).MaxTime();
                    StimStoppedNotSet% := 0;
                endif;
                
                'if recFRAPWAIndex% > 8 then
                '    recFRAPWAIndex% := 0;
                'else
                '    recFRAPWAIndex% += 1;
                'endif;
                
                dummy% := fraStimComplete%();  'This is a better time to run this function
                
                ChangeStateTo(stateFRAInitializeTrials%);

            endif;
            
            'See if sound is still playing, get number of points played
            if recCEDIsPresent% = 1 then  'only check play wave status if the CED is there
                PWA$ := PlayWaveStatus$(recPointsPlayed%);
            else
                PWA$ := "";  'if CED is absent simulate end of stimulus
            endif;
            
            'If sound is still playing, see if it should be over, stop it if so
            if recPointsPlayed% >= recPlayPoints%  then
                PlayWaveStopWithErrorCheck();  'stop playing stimulus while we're at it
            endif;
            
            'Check again to see if sound is playing
            if recCEDIsPresent% = 1 then  'only check play wave status if the CED is there
                PWA$ := PlayWaveStatus$(recPointsPlayed%);
            else
                PWA$ := "";  'if CED is absent simulate end of stimulus
            endif;
            
            if PWA$ = "" then    
                RecLogStatus("WaitTrialSoundE", "Sound done playing.");
                'ChangeStateTo(stateTrialHoldReward%);  'Not doing a trial hold reward in FRA for now -jj
            endif;
            
            
            
        case iState% = stateTrialInitReward% then
            
            ' Are we giving trial init rewards? If we are, then do so, otherwise we just pass on through. 
            if recTrialInitReward% = 1 and recTrainingRewardmL > 0 and recTurnOffReward% = 0 then
                RecLogStatus("TrialInitReward", "Giving trial init reward, size " + str$(recTrainingRewardmL) + " mLs");
                amountRewarded += recTrainingRewardmL;  'add reward to juice counter
                if recCEDIsPresent% = 1 then
                    recRewardMs% := ConvertmLToSeconds(recTrainingRewardmL)*1000;
                    recRewardMs := recRewardMs%;  'we need a float version for later math
                    
                    stmp% := Reward%();
                    'Yield(recRewardMs/1000);  'This really is an undesirable thing to do, but suspect 1401 is doing crazy stuff and I think SafeSampleKey is being violated
                    if stmp% <> 0 then
                        PrintLog("ERROR in recREWARD%()!!! Value of stmp is %d\n",stmp%);
                        Message("Error in recREWARD%()!!!  stmp is" + str$(stmp%));
                        ChangeStateTo(stateTDTError%);  'TDT error is actually apropriate because if CED is called, no error checking is used right now
                    endif;
                    
                    RewardOn := GetTimeOfLast1401Event();
                    s$ := Print$("InitReward %d", recRewardMs%);
                    SampleText(s$, RewardOn);
                    
                    
                endif
            else
                RecLogStatus("TrialInitReward", "No trial init reward.");
            endif
            if recTrialInitReward% = 1 then
                recTrialInitReward% := -1; 'so that after soundA we can pass by this and move forward!! *jao (i feel smart!)
                printlog("INIT REWARD? recTrainingRewardmL= %f and recTrialInitReward= %d\n", recTrainingRewardmL,recTrialInitReward%);
                ChangeStateTo(stateStartSoundA%);
            else
                ChangeStateTo(stateInResponseWindow%);
            endif;
            
            
        case iState% = stateTrialHoldReward% then
            
            ' Are we giving trial hold rewards? Was stimulus held all the way through? If yes, then give reward, otherwise we just pass on through. 
            if recTrialHoldReward% = 1 and isEarlyHit% = 0 and isEarlyMiss% = 0 and isEarlyCR% = 0 and recTrainingRewardmL > 0 and recTurnOffReward% = 0 then
                RecLogStatus("TrialHoldReward", "Giving trial hold reward, size " + str$(recTrainingRewardmL) + " mLs");
                amountRewarded += recTrainingRewardmL;  'add reward to juice counter
                if recCEDIsPresent% = 1 then
                    recRewardMs% := ConvertmLToSeconds(recTrainingRewardmL)*1000;
                    recRewardMs := recRewardMs%;  'we need a float version for later math
                    
                    stmp% := Reward%();
                    'Yield(recRewardMs/1000);  'This really is an undesirable thing to do, but suspect 1401 is doing crazy stuff and I think SafeSampleKey is being violated
                    if stmp% <> 0 then
                        PrintLog("ERROR in recREWARD%()!!! Value of stmp is %d\n",stmp%);
                        Message("Error in recREWARD%()!!!  stmp is" + str$(stmp%));
                        ChangeStateTo(stateTDTError%);  'TDT error is actually apropriate because if CED is called, no error checking is used right now
                    endif;
                    
                    RewardOn := GetTimeOfLast1401Event();
                    s$ := Print$("HoldReward %d", recRewardMs%);
                    SampleText(s$, RewardOn);
                    
                    
                endif
            else
                RecLogStatus("TrialHoldReward", "No trial hold reward.");
            endif

            ChangeStateTo(stateInResponseWindow%);    
            
            
        case iState% = stateInResponseWindow% then
            
            if recActive% = 1 then
                if isTerminalS1% = 1 then
                    CheckLever%("inResponse2%",1);  'check lever status, simulate CR for debugging
                else
                    CheckLever%("inResponse1%",1);  'check lever status, simulate hit for debugging
                endif;
            else 
                if isTerminalS1% = 1 then
                    inResponse2% := 1; 'simulate CR for passive
                else
                    inResponse1% := 1;  'simulate hit for passive
                endif;
            endif
            
            
            'Case through all possible early responses then check through response window
            docase
                'Early hit, interrupted final stimulus, this is OK   
            case isEarlyHit% = 1 then  'we don't care about the state of the lever; it was already released early
                isEarlyHit% := 0;  'reset variable
                'time of early hit is recorded above
                SafeSampleKey("M");  'Turn off LED
                if recExpToRun% = recExpAudiogramButton% then
                    UpdateAudiogram(1);  'hit, make audiogram stimulus quieter, etc.
                endif;
                docase
                case responseMode% = 1 and (recExpToRun% = recExpAMDiscButton% or recExpToRun% = recExpSpaceDisButton% or recExpToRun% = recExpStereoDisButton%) then 'HI, HIT
                    StimComplete%(1, 1);
                case responseMode% = 3 and (recExpToRun% = recExpAMDiscButton% or recExpToRun% = recExpSpaceDisButton% or recExpToRun% = recExpStereoDisButton%) then 'LOW, HIT
                    StimComplete%(3, 1);
                else
                    StimComplete%(1, 1);  'must come after UpdateAudiogram()
                endcase
                
                numHits% += 1; 'increment HIT counter
                recPreciseTrialTime := tNow;
                ChangeStateTo(stateHitReward%);
                
                'Early Miss, interrupted final stimulus before actual response window
            case isEarlyMiss% = 1 then  'we don't care about the state of the lever; it was already released early
                isEarlyMiss% := 0;  'reset variable
                'time of early FA is recorded above
                docase
                case responseMode% = 1 and (recExpToRun% = recExpAMDiscButton% or recExpToRun% = recExpSpaceDisButton% or recExpToRun% = recExpStereoDisButton%) then 'HI, MISS
                    StimComplete%(1, 0);
                case responseMode% = 3 and (recExpToRun% = recExpAMDiscButton% or recExpToRun% = recExpSpaceDisButton% or recExpToRun% = recExpStereoDisButton%) then 'LOW, MISS
                    StimComplete%(3, 0);
                else
                    StimComplete%(1, 0);  'must come after UpdateAudiogram()
                endcase
                SafeSampleKey("M");  'Turn off LED
                numMisses% += 1;  'increment MISS counter
                ChangeStateTo(stateFalsePositive%);
                
                'AMDis Hi/Lo or StereoDis --> SAME trials early response
            case (isEarlyFA% = 1 or isEarlyCR% = 1) and (recExpToRun% = recExpAMDiscButton% or recExpToRun% = recExpSpaceDisButton% or recExpToRun% = recExpStereoDisButton%) then  'AMDis Hi/Lo --> SAME trial, inResponse1% OR 2                 
                docase
                case isEarlyCR% = 1 then 'inResponse2%
                    isEarlyCR% := 0;  'reset variable
                    RecLogStatus("InResponseWindow", "In response position 2 , SAME trial - went Lo (early)");
                    'want to keep track of which response happened in output...
                case isEarlyFA% = 1 then 'inResponse1%
                    isEarlyFA% := 0;  'reset variable
                    RecLogStatus("InResponseWindow", "In response position 1 , SAME trial - went Hi (early)");
                    'want to keep track of which response happened in output...
                else
                    printlog("how the hell did we get here?");
                endcase;
                
                'time of early "FA" or "CR" (response) is recorded above ; for either response do:
                StimComplete%(2, coinFlipResult%);   'terminal S1
                SafeSampleKey("M");  'Turn off LED
                'NOTE: do not increment hit or miss counter for SAME trials in HI/LO experiment
                if coinFlipResult% = 1 then
                    ChangeStateTo(stateHitReward%);
                else
                    ChangeStateTo(stateMissTimeout%);
                endif;
                
                'Early FA, interrupted final stimulus before actual response window
            case isEarlyFA% = 1 then  'we don't care about the state of the lever; it was already released early
                isEarlyFA% := 0;  'reset variable
                'time of early FA is recorded above
                StimComplete%(2, 0);  'terminal S1
                SafeSampleKey("M");  'Turn off LED
                numFAs% += 1;  'increment FA counter
                ChangeStateTo(stateFalsePositive%);
                'Early CR, interrupted final stimulus, this is OK   
            case isEarlyCR% = 1 then  'we don't care about the state of the lever; it was already released early
                isEarlyCR% := 0;  'reset variable
                'time of early hit is recorded above
                StimComplete%(2, 1);   'terminal S1
                SafeSampleKey("M");  'Turn off LED
                'CR counter?
                ChangeStateTo(stateHitReward%);   
                
                
                'Done with early responses, now in response window 
                
                'PASSIVE AMDis/SpaceDis HI, wait for response window to close and call it a hit
            case tNow - tStateStart > recResponseWindow and recAMSPPassiveTask% = 1 and responseMode% = 1 and (recExpToRun% = recExpAMDiscButton% or recExpToRun% = recExpSpaceDisButton%) then
                RecLogStatus("InResponseWindow", "Passive task - HIT HI"); 
                StimComplete%(1, 1);
                SafeSampleKey("M");  'Turn off LED
                numHits% += 1; 'increment HIT counter
                recPreciseTrialTime := recLeverTime; 'time hit occurred
                ChangeStateTo(stateHitReward%);
                'PASSIVE AMDis/SpaceDis LO, wait for response window to close and call it a hit
            case tNow - tStateStart > recResponseWindow and recAMSPPassiveTask% = 1 and responseMode% = 3 then 'LO, HIT -implied: and (recExpToRun% = recExpAMDiscButton% or recExpToRun% = recExpSpaceDisButton%) 
                RecLogStatus("InResponseWindow", "Passive task - HIT Lo");
                StimComplete%(3, 1);
                SafeSampleKey("M");  'Turn off LED
                numHits% += 1; 'increment HIT counter
                recPreciseTrialTime := recLeverTime; 'time hit occurred
                ChangeStateTo(stateHitReward%);
                'ACTIVE AMDis/SpaceDis/StereoDis HI Hit, either FC or GNG, InResponse% is same for both
            case inResponse1% = 1 and responseMode% = 1 and (recExpToRun% = recExpAMDiscButton% or recExpToRun% = recExpSpaceDisButton% or recExpToRun% = recExpStereoDisButton%) then 'HI, HIT 
                RecLogStatus("InResponseWindow", "In response position 1 - HIT HI"); 
                StimComplete%(1, 1);
                SafeSampleKey("M");  'Turn off LED
                numHits% += 1; 'increment HIT counter
                recPreciseTrialTime := recLeverTime; 'time hit occurred
                ChangeStateTo(stateHitReward%);
                'ACTIVE StereoDis LO Hit, GNG only
            case inResponse1% = 1 and responseMode% = 3 and recExpToRun% = recExpStereoDisButton% and recIsGoNoGo% = 1 then 'LO, HIT 
                RecLogStatus("InResponseWindow", "In response position 1 - HIT LO"); 
                StimComplete%(3, 1);
                SafeSampleKey("M");  'Turn off LED
                numHits% += 1; 'increment HIT counter
                recPreciseTrialTime := recLeverTime; 'time hit occurred
                ChangeStateTo(stateHitReward%);
                'ACTIVE AMDis/SpaceDis/StereoDis LO Hit, FC only (cannot get inResponse2% = 1 in GNG)
            case inResponse2% = 1 and responseMode% = 3 then 'LO, HIT -implied: and (recExpToRun% = recExpAMDiscButton% or recExpToRun% = recExpSpaceDisButton% or recExpToRun% = recExpStereoDisButton%)
                RecLogStatus("InResponseWindow", "In response position 2 - HIT Lo");
                StimComplete%(3, 1);
                SafeSampleKey("M");  'Turn off LED
                numHits% += 1; 'increment HIT counter
                recPreciseTrialTime := recLeverTime; 'time hit occurred
                ChangeStateTo(stateHitReward%);
                'ACTIVE AMDis/SpaceDis/StereoDis HI Miss, FC only (cannot get inResponse2% = 1 in GNG)    
            case inResponse2% = 1 and responseMode% = 1 and (recExpToRun% = recExpAMDiscButton% or recExpToRun% = recExpSpaceDisButton% or recExpToRun% = recExpStereoDisButton%) then 'HI, MISS  
                RecLogStatus("InResponseWindow", "In response position 2 - MISS, HI");
                recPreciseTrialTime := recLeverTime;  'time FA occurred
                StimComplete%(1, 0);  
                SafeSampleKey("M");  'Turn off LED
                if recMissRepeats% = 1 and recMissRepeatsCounter% <= recMissRepeatsMax% then 'might need a -1 here
                    'Decrement current trial index (which was incremented above in stateInitializeTrials)
                    recCurrentTrial% := recCurrentTrial% - 1; 'this should do it!?
                    '**increment recMissRepeatsCounter HERE and reset to 0 in StateHitReward**
                    printlog("MissRepeatsCounter = %d this trial; keeps track of consecutive Misses \n", recMissRepeatsCounter%);
                    recMissRepeatsCounter% += 1; 'increment MissRepeatsCounter, keep track of consecutive Misses
                    printlog("MissRepeatsCounter incremented! is now = %d \n", recMissRepeatsCounter%);
                else
                    printlog("not repeating missed trials \n");
                endif
                numMisses% += 1;  'increment MISS counter
                ChangeStateTo(stateMissTimeout%);
                'ACTIVE AMDis/SpaceDis/StereoDis LO Miss, FC only, GNG case must be dealt with earlier in CASE statement   
            case inResponse1% = 1 and responseMode% = 3 and (recExpToRun% = recExpAMDiscButton% or recExpToRun% = recExpSpaceDisButton% or recExpToRun% = recExpStereoDisButton%) then 'LO, MISS 
                RecLogStatus("InResponseWindow", "In response position 1 - MISS, Lo");
                recPreciseTrialTime := recLeverTime;  'time hit occurred
                StimComplete%(3, 0);   'gotcha bitch!
                SafeSampleKey("M");  'Turn off LED
                if recMissRepeats% = 1 and recMissRepeatsCounter% <= recMissRepeatsMax% then 'might need a -1 here
                    'Decrement current trial index (which was incremented above in stateInitializeTrials)
                    recCurrentTrial% := recCurrentTrial% - 1; 'this should do it!?
                    '**increment recMissRepeatsCounter HERE and reset to 0 in StateHitReward**
                    printlog("MissRepeatsCounter = %d this trial; keeps track of consecutive Misses \n", recMissRepeatsCounter%);
                    recMissRepeatsCounter% += 1; 'increment MissRepeatsCounter, keep track of consecutive Misses
                    printlog("MissRepeatsCounter incremented! is now = %d \n", recMissRepeatsCounter%);
                    
                else
                    printlog("not repeating missed trials \n");
                endif
                numMisses% += 1;  'increment MISS counter
                ChangeStateTo(stateMissTimeout%);
                
                'SAME trial, in either response window    
            case responseMode% = 2 and (recExpToRun% = recExpAMDiscButton% or recExpToRun% = recExpSpaceDisButton% or recExpToRun% = recExpStereoDisButton%) and (inResponse1% = 1 or inResponse2% = 1) and recIsGoNoGo% = 0 then 'SAME, either response
                if inResponse1% = 1 then
                    RecLogStatus("InResponseWindow", "In response position 1 , SAME trial - went Hi");
                    'want to keep track of which response happened in output...
                else 'inResponse2% = 1 
                    RecLogStatus("InResponseWindow", "In response position 2 , SAME trial - went Lo");
                    'want to keep track of which response happened in output...
                endif;
                recPreciseTrialTime := recLeverTime;  'time response occurred
                if recExpToRun% = recExpStereoDisButton% then
                    'Cheating here, and passing a value OTHER THAN actual success, so that we can know which direction the human actually responded, as that seems important
                    StimComplete%(2, inResponse1%);  '1 indicates response was S2 High, 0 indicates response was S2 Low
                else
                    StimComplete%(2, coinFlipResult%);  '**this variable needs to be declared and established somewhere** *jao 
                endif;
                SafeSampleKey("M");  'Turn off LED
                'NOTE: do not increment hit or miss counter for SAME trials in HI/LO experiment
                if coinFlipResult% = 1 then
                    ChangeStateTo(stateHitReward%);
                else
                    ChangeStateTo(stateMissTimeout%);
                endif;
                
                'the original code for SAME/DIFF:
            case (tNow - tStateStart > recResponseWindow and recAMSPPassiveTask% = 1) or (inResponse1% = 1 and isTerminalS1% = 0) then  'forced choice OR go/no-go
                RecLogStatus("InResponseWindow", "In response position 1 - HIT");
                recPreciseTrialTime := recLeverTime;  'time hit occurred
                SafeSampleKey("M");  'Turn off LED
                if recExpToRun% = recExpAudiogramButton% then
                    UpdateAudiogram(1);  'hit, make audiogram stimulus quieter, etc.
                endif;
                StimComplete%(1, 1);  'must come after UpdateAudiogram()
                numHits% += 1; 'increment HIT counter
                ChangeStateTo(stateHitReward%);
                'False alarm in response window    
            case inResponse1% = 1 and isTerminalS1% = 1 then  'forced choice OR go/no-go
                RecLogStatus("InResponseWindow", "In response position 1 - False Alarm on terminal S1");
                recPreciseTrialTime := recLeverTime;  'time FA occurred
                StimComplete%(2, 0);  'terminal S1
                SafeSampleKey("M");  'Turn off LED
                numFAs% += 1;  'increment FA counter
                ChangeStateTo(stateFalsePositive%);
                'CR in response window    
            case inResponse2% = 1 and isTerminalS1% = 1 then  'forced choice only
                'SafeSampleKey("R");  'not in Recgen.pls!
                RecLogStatus("InResponseWindow", "In response position 2 - Correct Rejection");
                recPreciseTrialTime := recLeverTime;  'time hit occurred
                StimComplete%(2, 1);    'terminal S1
                SafeSampleKey("M");  'Turn off LED
                'CR counter?
                ChangeStateTo(stateHitReward%);
                'Miss in response window    
            case inResponse2% = 1 and isTerminalS1% = 0 then  'forced choice only
                RecLogStatus("InResponseWindow", "In response position 2 - Miss on terminal S2");
                recPreciseTrialTime := recLeverTime;  'time FA occurred
                StimComplete%(1, 0);
                SafeSampleKey("M");  'Turn off LED
                numMisses% += 1;  'increment MISS counter
                ChangeStateTo(stateFalsePositive%); 'should this be MissTimeout?? - reshuffle trial?
                
                'Response window is closed, failure to respond on forced choice
            case tNow - tStateStart > recResponseWindow and recIsGoNoGo% = 0 then
                RecLogStatus("InResponseWindow", "Lever not up - timed out - NO RESPONSE ON FORCED CHOICE");
                recPreciseTrialTime := tNow;  'time response window closed - note we could be more precise (e.g. tStateStart + recResponseWindow) but why?  There's no "event" 
                docase
                case (recExpToRun% = recExpAMDiscButton% or recExpToRun% = recExpSpaceDisButton% or recExpToRun% = recExpStereoDisButton%) then 
                    StimComplete%(responseMode%, 0);
                else
                    StimComplete%(isTerminalS1%+1, 0);  'this covers whether it is terminal S1 or not
                endcase
                
                SafeSampleKey("M");  'Turn off LED
                'Decrement joystick thresholds if appropriate
                docase  'doing a case statement here because I think there might be "isTerminalS1% == 2" down the road
                case isTerminalS1% = 1 then
                    ChangeThresh2(doDecPassiveMiss%[]);
                case isTerminalS1% = 0 then
                    ChangeThresh2(doDecPassiveFA%[]);
                endcase;
                if recDoNotShuffle% = 0 then  'if we are specifically ordering the trials, do not send current trial to a random location!
                    'Decrement current trial index (which was incremented above in stateInitializeTrials)
                    recCurrentTrial% := recCurrentTrial% - 1;
                    'Send current trial to "middle" of remaining trials
                    SendTrialToMiddle%(recNTrials%,recCurrentTrial%,1,recTrialOrder%[]);  'at least one intervening trial 'reshuffle trial if no response!
                endif;
                RecLogStatus("InResponseWindow", "NO RESPONSE ON FORCED CHOICE - trial reshuffled");
                'numFPs% += 1;  'increment FP counter   'NOTE: NOT SURE WHETHER TO INCREMENT FA COUNTER HERE OR NOT
                ChangeStateTo(stateMissTimeout%);  'go to miss timeout for no response --> OR, delete reshuffling above and do FA timeout
                
                'ACTIVE StereoDis HI Miss, GNG only
            case tNow - tStateStart > recResponseWindow and recIsGoNoGo% = 1 and responseMode% = 1 and recExpToRun% = recExpStereoDisButton% then 'HI, Miss 
                RecLogStatus("InResponseWindow", "Lever not up - timed out - MISS (HI)"); 
                StimComplete%(1, 0);
                SafeSampleKey("M");  'Turn off LED
                numMisses% += 1;  'increment MISS counter
                recPreciseTrialTime := tNow;  'time response window closed - note we could be more precise (e.g. tStateStart + recResponseWindow) but why?  There's no "event"
                ChangeStateTo(stateMissTimeout%);
                'ACTIVE StereoDis LO Miss, GNG only
            case tNow - tStateStart > recResponseWindow and recIsGoNoGo% = 1 and responseMode% = 3 and recExpToRun% = recExpStereoDisButton% then 'HI, Miss 
                RecLogStatus("InResponseWindow", "Lever not up - timed out - MISS (LO)"); 
                StimComplete%(3, 0);
                SafeSampleKey("M");  'Turn off LED
                numMisses% += 1;  'increment MISS counter
                recPreciseTrialTime := tNow;  'time response window closed - note we could be more precise (e.g. tStateStart + recResponseWindow) but why?  There's no "event"
                ChangeStateTo(stateMissTimeout%);
                'Response window is closed, miss on go/no-go   
            case tNow - tStateStart > recResponseWindow and recIsGoNoGo% = 1 and isTerminalS1% = 0 then  'go/no-go miss
                RecLogStatus("InResponseWindow", "Lever not up - timed out - MISS");
                recPreciseTrialTime := tNow;  'time response window closed - note we could be more precise (e.g. tStateStart + recResponseWindow) but why?  There's no "event" 
                numMisses% += 1;  'increment MISS counter
                if recExpToRun% = recExpAudiogramButton% then
                    UpdateAudiogram(-1);  'miss, make audiogram stimulus louder, etc.
                    'Calculate new delay interval time
                    recDelayIntervalTime := recMinOnsetDelay + Rand(recVarOnsetDelay, 0);
                    ChangeStateTo(statePreTrialDelay%);  'for the audiogram, misses are expected, just change state to pre-trial delay and do not turn off LED
                else
                    SafeSampleKey("M");  'Turn off LED
                    ChangeStateTo(stateMissTimeout%);
                endif;
                StimComplete%(1, 0);  'must come after UpdateAudiogram()
                'Response window is closed, correct rejection on go/no-go  
            case tNow - tStateStart > recResponseWindow and recIsGoNoGo% = 1 and isTerminalS1% = 1 then  'go/no-go CR
                RecLogStatus("InResponseWindow", "Lever not up - Correct Rejection on terminal S1");
                recPreciseTrialTime := tNow;  'time response window closed - note we could be more precise (e.g. tStateStart + recResponseWindow) but why?  There's no "event"
                StimComplete%(2, 1);  'terminal S1
                SafeSampleKey("M");  'Turn off LED
                'CR counter?
                ChangeStateTo(stateCRReward%);  
                'Otherwise, the response window is still open and the lever is still down    
            else
                'Nothing, just a comment                
            endcase
            'We can aggressively wait for the response if the RT is important, just uncomment below (is RT even recorded?)
            nextStateImmed% := 0;   'or don't, testing
            
            
            
        case iState% = stateMissTimeout% then
            CheckLever%("inOrigin%",1);  'Flush lever/joystick during timeout, just simulate inorigin for debug
            'if Miss or FA, reset to thisHitReward so that it will go to base reward next time:
            thisHitReward := 0; 'reset thisreward
            if tNow - tStateStart > recMissTO then
                RecLogStatus("MissTimeout", "Timeout period done.");
                recChangeRewardType% := 1;  'will change reward type after miss, if other conditions are met 
                ChangeStateTo(stateInitializeTrials%);  'move to next trial
                tNextTrial := tNow;  'ready to go
            endif
            
            
            
        case iState% = stateFalsePositive% then 
            'this state is used to give a FA timeout for an incorrect response to a terminal S1 (nontarget) stim 
            'no real need to repeat entire stim sequence as the whole sequence was presented
            CheckLever%("inOrigin%",1);  'Flush lever/joystick during timeout, just simulate inorigin for debug
            'if Miss or FA, reset to thisHitReward so that it will go to base reward next time:
            thisHitReward := 0; 'reset thisreward
            if tNow - tStateStart > recFalseAlarmTO then
                RecLogStatus("FalsePositiveTimeout", "Timeout period done.");
                recChangeRewardType% := 1;  'will change reward type after FA, if other conditions are met 
                'ChangeStateTo(stateDetermineRewardType);  'was stateInitializeTrials% but we want to repeat the stimulus
                'ChangeStateTo(stateInitializeTrials%);  'No, actually, I don't think we do want to repeat the stimulus
                'ACTUALLY - we want to shuffle this back in, since there's no diff between a false positive on the final
                'stimulus and one on a prior stimulus.  Note that in the future there may be human experiments where this
                'distinction is valid, so I'm keeping it in.  In that event (only vaguely planned) I think the best way will
                'be to branch inside this logic state.
                
                if recDoNotShuffle% = 0 then  'if we are specifically ordering the trials, do not send current trial to a random location!
                    'Decrement current trial index (which was incremented above in stateInitializeTrials)
                    recCurrentTrial% := recCurrentTrial% - 1;
                    'Send current trial to "middle" of remaining trials
                    SendTrialToMiddle%(recNTrials%,recCurrentTrial%,1,recTrialOrder%[]);  'at least one intervening trial
                endif;
                
                ChangeStateTo(stateInitializeTrials%); 
                tNextTrial := tNow;  'ready to go
            endif
            
            
        case iState% = stateFalseAlarmAudiogram% then 
            'this state is used to give a FA timeout for a response not corresponding to a stimulus
            'we do not want to reset any of the audiogram values here, just restart on the same stimulus at
            'the same intensity and same staircase state as before
            CheckLever%("inOrigin%",1);  'Flush lever/joystick during timeout, just simulate inorigin for debug
            if tNow - tStateStart > recFalseAlarmTO then
                RecLogStatus("FalsePositiveTimeout", "Timeout period done.");
                recChangeRewardType% := 1;  'will change reward type after FA, if other conditions are met 
                
                'Do not decrement current trial index.  
                'recCurrentTrial% := recCurrentTrial% - 1;
                
                ChangeStateTo(stateInitializeTrials%); 
                tNextTrial := tNow;  'ready to go
            endif            
            
            
        case iState% = stateFAInterrupt% then
            'this state is used to repeat a FA interrupted stimulus, so that the S2 gets played
            CheckLever%("inOrigin%",1);  'Flush lever/joystick during timeout, just simulate inorigin for debug
            if tNow - tStateStart > recFalseAlarmTO then
                RecLogStatus("FAInterruptTimeout", "Timeout period done. Trial #" + str$(recCurrentTrial%) + " being reshuffled.");
                recChangeRewardType% := 1;  'will change reward type after FA, if other conditions are met 
                
                if recDoNotShuffle% = 0 then  'if we are specifically ordering the trials, do not send current trial to a random location!
                    'Decrement current trial index (which was incremented above in stateInitializeTrials)
                    recCurrentTrial% := recCurrentTrial% - 1;
                    'Send current trial to "middle" of remaining trials
                    SendTrialToMiddle%(recNTrials%,recCurrentTrial%,1,recTrialOrder%[]);  'at least one intervening trial
                endif;
                
                ChangeStateTo(stateInitializeTrials%); 
                tNextTrial := tNow;  'ready to go
            endif            
            
            
            
        case iState% = stateHitReward% then
            
            'Increment, if appropriate
            ChangeThresh2(doIncHit%[]);
            'ChangeThresh(doIncUp%,doIncDown%,doIncLeft%,doIncRight%);
            recMissRepeatsCounter% := 0; 'reset MissRepeatsCounter to 0, keep track of consecutive Misses
            
            if recHitRewardmL > 0 and recTurnOffReward% = 0 then
                'do reward increment stuff (note: if no increment then adding 0 every time will do nothing)
                if thisHitReward = 0 then 'it was reset! (or this is the first trial)
                    thisHitReward := recHitRewardmL; 'this reward will be the base reward level
                    'lastHitReward not needed in this case, will be initialized below after first Hit is given
                else
                    thisHitReward := lastHitReward + recHitRewardIncmL;
                    if thisHitReward > recMaxHitRewardmL then 'check if this exceeds Max
                        thisHitReward := recMaxHitRewardmL;
                    endif    
                endif
                RecLogStatus("HitReward", "Giving Hit Reward, size=" + str$(thisHitReward) + " mLs"); 'replaced recHitRewardmL with thisHitReward
                amountRewarded += thisHitReward;  'add this reward to juice counter
                lastHitReward := thisHitReward; 'save this hit reward value for next time (does this need to be lower down?)
                if recCEDIsPresent% = 1 then
                    recRewardMs% := ConvertmLToSeconds(thisHitReward)*1000; 'replaced recHitRewardmL with thisHitReward
                    recRewardMs := recRewardMs%;  'we need a float version for later math
                    
                    stmp% := Reward%();
                    'Yield(recRewardMs/1000);  'This really is an undesirable thing to do, but suspect 1401 is doing crazy stuff and I think SafeSampleKey is being violated
                    RewardOn := GetTimeOfLast1401Event();
                    s$ := Print$("Reward %d", recRewardMs%);
                    SampleText(s$, RewardOn);
                    
                    if stmp% <> 0 then
                        PrintLog("ERROR in recREWARD%()!!! STMP is %d\n",stmp%);
                        Message("Error in recREWARD%()!!!");
                        ChangeStateTo(stateTDTError%);  'TDT error is actually apropriate because if CED is called, no error checking is used right now
                    else
                        ChangeStateTo(stateInitializeTrials%);  'move to next trial after reward is done
                        tNextTrial := tNow + (recRewardMs/1000);
                    endif;
                else
                    ChangeStateTo(stateInitializeTrials%);  'move to next trial after reward is done
                    tNextTrial := tNow; 'the TDT delay is built in, ready to go
                endif
            else
                ChangeStateTo(stateInitializeTrials%);  'move to next trial after reward is done
                tNextTrial := tNow; 'the TDT delay is built in, ready to go
            endif;
            
        case iState% = stateFRAHitReward% then
            
            if recHitRewardmL > 0 then
                'do reward increment stuff (note: if no increment then adding 0 every time will do nothing)
                if thisHitReward = 0 then 'it was reset! (or this is the first trial)
                    thisHitReward := recHitRewardmL; 'this reward will be the base reward level
                    'lastHitReward not needed in this case, will be initialized below after first Hit is given
                else
                    thisHitReward := lastHitReward + recHitRewardIncmL;
                    if thisHitReward > recMaxHitRewardmL then 'check if this exceeds Max
                        thisHitReward := recMaxHitRewardmL;
                    endif    
                endif
                RecLogStatus("HitReward", "Giving Hit Reward, size=" + str$(thisHitReward) + " mLs"); 'replaced recHitRewardmL with thisHitReward
                amountRewarded += thisHitReward;  'add this reward to juice counter
                lastHitReward := thisHitReward; 'save this hit reward value for next time (does this need to be lower down?)
                if recCEDIsPresent% = 1 then
                    recRewardMs% := ConvertmLToSeconds(thisHitReward)*1000; 'replaced recHitRewardmL with thisHitReward
                    recRewardMs := recRewardMs%;  'we need a float version for later math

                    stmp% := Reward%();
                    'Yield(recRewardMs/1000);  'This really is an undesirable thing to do, but suspect 1401 is doing crazy stuff and I think SafeSampleKey is being violated
                    RewardOn := GetTimeOfLast1401Event();
                    s$ := Print$("Reward %d", recRewardMs%);
                    SampleText(s$, RewardOn);

                    if stmp% <> 0 then
                        PrintLog("ERROR in recREWARD%()!!! STMP is %d\n",stmp%);
                        Message("Error in recREWARD%()!!!");
                        ChangeStateTo(stateTDTError%);  'TDT error is actually apropriate because if CED is called, no error checking is used right now
                    else
                        ChangeStateTo(stateFRAJuiceBreak%);  'move to next trial after reward is done
                        tNextTrial := tNow + (recRewardMs/1000);
                    endif;
                else
                    ChangeStateTo(stateFRAJuiceBreak%);  'move to next trial after reward is done
                    tNextTrial := tNow; 'the TDT delay is built in, ready to go
                endif
            else
                ChangeStateTo(stateFRAJuiceBreak%);  'move to next trial after reward is done
                tNextTrial := tNow; 'the TDT delay is built in, ready to go
            endif;
            
            
        case iState% = stateCRReward% then
            
            'Increment, if appropriate
            ChangeThresh2(doIncCR%[]);
            'ChangeThresh(doIncUp%,doIncDown%,doIncLeft%,doIncRight%);
            
            if recCRRewardmL > 0 then
                RecLogStatus("CRReward", "Giving CR Reward, size=" + str$(recCRRewardmL) + " mLs");
                amountRewarded += recCRRewardmL;  'add reward to juice counter
                if recCEDIsPresent% = 1 then
                    recRewardMs% := ConvertmLToSeconds(recCRRewardmL)*1000;
                    recRewardMs := recRewardMs%;  'we need a float version for later math

                    stmp% := Reward%();
                    'Yield(recRewardMs/1000);  'This really is an undesirable thing to do, but suspect 1401 is doing crazy stuff and I think SafeSampleKey is being violated
                    s$ := Print$("Reward %d", recRewardMs%);
                    RewardOn := GetTimeOfLast1401Event();
                    SampleText(s$, RewardOn);
 
                    if stmp% <> 0 then
                        PrintLog("ERROR in recREWARD%()!!!\n");
                        Message("Error in recREWARD%()!!!");
                        ChangeStateTo(stateTDTError%);  'TDT error is actually apropriate because if CED is called, no error checking is used right now
                    endif;
                endif
            endif
            ChangeStateTo(stateInitializeTrials%);  'move to next trial when reward is done
            tNextTrial := tNow + (recRewardMs/1000);
            
        case iState% = stateDone% then
            PrintLog("#HITS = " + str$(numHits%) + ",   #MISSES = " + str$(numMisses%) + ",   #FPs = " + str$(numFPs%) + ",   LastHitReward(mL) = " + str$(LastHitReward) + ",   TOTAL Juice(mL) = " + str$(amountRewarded) + ".\n");            
            SafeSampleKey("M");  'Turn off LED
            RecLogStatus("Done", "");
            iStatus% := 0;
            recReadyToQuit% := 0;
            ReturnToExptSelectDialog%();  'If the current expt. is "done" allow another to be run without stopping sampling
            'Stop%();
            
            
        case iState% = statePrepareTone% then
            var attenmat[10];
            var doRepeat%;
            var status%;
            
            docase
            case recLongToneType% = 0 then  'If we are doing a tone, set up the tone
                'Set values that can be assigned for the entire set of stimuli
                SampleSeqVar(11,SequencerToneAmplitude%(1));  'set amplitude of pulse
                SampleSeqVar(12,SequencerToneFrequency%(recLongToneFreq));  'set frequency of pulse
                recLongAtten := PrepareLongTone();
                'Set attenuation once for tone, for noise we will set per stimulus when we load the PWA
                status% := recAttenByID%(recLongAtten,arrayPA4ID%);
                if status% <> 0 then
                    printlog("Problem setting attenuation for long tone!\n");
                    return 0;
                endif; 
            else 
                PrepareLongNoiseAllAtOnce();  'Fill all noise, atten, seed variables before doing anything else - will be slow
                recLoadLongNoise% := 1;  'Make sure long noise loads to PWA
'            case recLongToneType% = 1 then 'if we are doing broadbandnoise, which requires a different setup
'                recLongToneDuration := recLongToneDurationList[recCurrentTrial%];  'assign duration, can't run initial PrepareLongNoise witout it!
'                for doRepeat% := 0 to 9 do
'                    attenmat[doRepeat%] := PrepareLongNoise(2);  'pass 2, do not do 50-ms delay, do not fill PWA, this is only to get an attenuation value
'                next
'                ArrSum(attenmat[],recLongAtten);  'get mean attenuation of 10 tries, should reduce randomness
'                'note that we are only setting the attenuation ONCE.  There is going to be some variability.
'            else 'recLongToneType% = 2
'                recLongToneDuration := recLongToneDurationList[recCurrentTrial%];  'assign duration
'                recLongAtten := PrepareLongNoiseBP();  'This might be slow for the 100 second stimulus
            endcase;
            
            
            ' Set speaker one time, same for both tone/noise
            if recTDTIsPresent% = 1 then
                status% := recSpeaker%(recLongToneSpeaker%);
                if status% <> 0 then
                    printlog("Problem setting speaker for long tone!\n");
                    return 0;
                endif;
                
            endif;
            
            ChangeStateTo(stateLongToneISI%);  'Go to an ISI before the first tone to get a full pre-stimulus period           
            
        case iState% = stateLongToneISI% then
            
            'Load PWA first, only do it once
            if recLongToneType% >= 1 and recLoadLongNoise% = 1 then
                LoadLongNoiseToPWA%();  'correct PWA is calculated inside this function, attenuation set inside this function
                recLoadLongNoise% := 0;  'Don't load twice!
            endif; 
            
            'Wait through ISI
            if tNow > tStateStart + recLongToneISI then
                
                if rand() < recLongToneRewardProb and recTurnOffReward% = 0 then
                    recRewardMs% := ConvertmLToSeconds(recHitRewardmL)*1000;
                    stmp% := Reward%();
                    'Yield(recRewardMs/1000);  'This really is an undesirable thing to do, but suspect 1401 is doing crazy stuff and I think SafeSampleKey is being violated
                    RewardOn := GetTimeOfLast1401Event();
                    s$ := Print$("Reward %d", recRewardMs%);
                    SampleText(s$, RewardOn);
                    
                    if stmp% <> 0 then
                        PrintLog("ERROR in recREWARD%()!!! Value of stmp is %d\n",stmp%);
                        Message("Error in recREWARD%()!!!  stmp is" + str$(stmp%));
                        ChangeStateTo(stateTDTError%);  'TDT error is actually apropriate because if CED is called, no error checking is used right now
                    endif;
                    
                    Yield(1.0);  'wait for lick
                    
                endif
                
                ChangeStateTo(stateStartLongTone%);
                
            endif
            
        case iState% = stateStartLongTone% then
            var pwchar$;
            
            recLongToneDuration := recLongToneDurationList[recCurrentTrial%];  'assign duration, variable will be used about 3x below
            
            
            'Do this early, so that tStateStart will be prior to the DigMark from the start of the tone
            foundDigMarkOnTime := -1;
            foundDigMarkOffTime := -1;
            
            'Prepare to change to next state
            ChangeStateTo(stateFindDigMarkOn%);
            
            yield(0.025);  'wait 25 ms before starting tone, should prevent NextTime problems in next state
            
            docase
            case recLongToneType% = 0 and recLongToneDurationIndex%[recCurrentTrial%] < 4 then  'this is a tone
                
                SampleSeqVar(13,SequencerToneDuration%(recLongToneDuration));  'set duration of tone on sequencer
                
                printlog("Starting tone \n");
                SampleKey("T");  'Start tone
                StimOn := GetTimeOfLast1401Event();
            
                s$ := Print$("Sound T,LongTone,%d,%d,%.1f,%.1f,%s,%s", recCurrentTrial%, recLongToneSpeaker%, recLongAtten, recLongToneTargetdB, Str$(recLongToneDuration) + "s", Str$(recLongToneFreq) + "Hz");
                SampleText(s$,StimOn);
                
                tLongToneStart :=  View(recDataWindowView%).MaxTime();
                
            case recLongToneType% = 0 and recLongToneDurationIndex%[recCurrentTrial%] = 4 then  'this is a silent period
                
                SampleSeqVar(13,SequencerToneDuration%(recLongToneDuration));  'set duration of silence on sequencer
                
                printlog("Starting silent trial \n");
                SampleKey("U");  'Start silent period
                StimOn := GetTimeOfLast1401Event();
                
                'For this Sampletext, only the duration is variable
                s$ := Print$("Sound U,SilentTrial,%d,0,0,0,%s,0Hz", recCurrentTrial%, Str$(recLongToneDuration) + "s");
                SampleText(s$,StimOn);
                
                tLongToneStart :=  View(recDataWindowView%).MaxTime();    
                
            'case recLongToneType% = 1 then
            '    PrepareLongNoise(0);  'pass 0, this will trigger SSK("X") to add 50-ms delay
            '    'Set the number of times to cycle through the PWA
            '    if recLongToneDuration >= 1 then
            '        recLongToneCyclesRemaining% := recLongToneDuration;  'Same # of cycles as we have seconds
            '    else
            '        recLongToneCyclesRemaining% := 1;  '1 cycle for the 0.10 second stimulus, we need this for PlayWaveCycles but not for anything else
            '    endif;
            '    printlog("Number of cycles is %d\n",recLongToneCyclesRemaining%);
            '    PlayWaveCycles("N",recLongToneCyclesRemaining%);
            '    SampleSeqVar(16,recLongToneCyclesRemaining%);  'put number of cycles expected into sequencer variable
            '    
            '    printlog("Starting BB noise \n");
            '    SampleKey("N");  'Start noise
            '    StimOn := GetTimeOfLast1401Event();
            '    recLongToneCycleStartTime := StimOn;
            '    
            '    s$ := Print$("Sound N,LongNoiseBB,%d,%d,%.1f,%.1f,%s,%s,%s", recCurrentTrial%, recLongToneSpeaker%, recLongAtten, recLongToneTargetdB, Str$(recLongToneDuration) + "s", Str$(recLongToneBPLow) + "Hz", Str$(recLongToneBPHigh) + "Hz");
            '    SampleText(s$,StimOn);
            '    
            '    tLongToneStart :=  View(recDataWindowView%).MaxTime();
                
            case recLongToneType% = 1 then 'only difference is in sampletexting
                pwChar$ := GetPlayWaveKey$(recLongToneDurationIndex%[recCurrentTrial%]);
                printlog("Starting BB noise \n");
                SampleKey(LCase$(pwChar$));  'Start bb noise, use LOWER to activate correct portion of sequencer code
                StimOn := GetTimeOfLast1401Event();
            
                s$ := Print$("Sound %s,LongNoiseBB,%d,%d,%.1f,%.1f,%s,BB,seed=%d", pwChar$, recCurrentTrial%, recLongToneSpeaker%, recLongNoiseAtten[LongNoiseBlock%][recLongToneDurationIndex%[recCurrentTrial%]], 
                recLongToneTargetdB, Str$(recLongToneDuration) + "s",recLongNoiseSeed[LongNoiseBlock%][recLongToneDurationIndex%[recCurrentTrial%]]);
                SampleText(s$,StimOn);
                
                tLongToneStart :=  View(recDataWindowView%).MaxTime();
                
            case recLongToneType% = 2 then
                pwChar$ := GetPlayWaveKey$(recLongToneDurationIndex%[recCurrentTrial%]);
                printlog("Starting BP noise \n");
                SampleKey(LCase$(pwChar$));  'Start bb noise, use LOWER to activate correct portion of sequencer code
                StimOn := GetTimeOfLast1401Event();
                
                s$ := Print$("Sound %s,LongNoiseBP,%d,%d,%.1f,%.1f,%s,%s,%s,seed=%d", pwChar$, recCurrentTrial%, recLongToneSpeaker%, recLongNoiseAtten[LongNoiseBlock%][recLongToneDurationIndex%[recCurrentTrial%]], 
                recLongToneTargetdB, Str$(recLongToneDuration) + "s", Str$(recLongToneBPLow) + "Hz", Str$(recLongToneBPHigh) + "Hz",recLongNoiseSeed[LongNoiseBlock%][recLongToneDurationIndex%[recCurrentTrial%]]);
                SampleText(s$,StimOn);
                
                tLongToneStart :=  View(recDataWindowView%).MaxTime();
                
            endcase;
            

            
        case iState% = stateFindDigMarkOn% then
            while foundDigMarkOnTime < tStateStart and tNow < tLongToneStart+1 do  'don't wait more than 1 second to read digmark, in case this doesn't work (seems to work)
                foundDigMarkOnTime := NextTime(32,tStateStart,digCode%[]);
                tNow := View(recDataWindowView%).MaxTime();
            wend
            if foundDigMarkOnTime >= tStateStart then
                expectedOffTime := foundDigMarkOnTime + recLongToneDuration;
                printlog("Found code %d at %f for stimulus on, expected off time is %f\n",digCode%[0],foundDigMarkOnTime,expectedOffTime);
            else
                printlog("We didn't find the digMark to start the stimulus!\n");
                expectedOffTime := tNow + recLongToneDuration -1;  'We've already waited through a second of this
            endif;
            'if recLongToneType% = 1 and recLongToneDuration > 1 then  'if it's a BB, and we expect multiple cycles
            '    ChangeStateTo(stateLongNoiseReloadPWA%);
            'else
                ChangeStateTo(stateWaitForEndOfSound%); ' if we expect only one cycle, just wait for the end
            'endif;
            
            
        'case iState% = stateLongNoiseReloadPWA% then
        '    
        '    if tNow > recLongToneCycleStartTime then  'if the next cycle has started playing
        '        PrepareLongNoise(1);  'reload PWA with new random noise WHILE PLAYING (this is OK!!), don't use SSK("X")
        '        printlog("Changing stim\n");
        '        recLongToneCycleStartTime += 1;  'Get new cycle start time
        '        recLongToneCyclesRemaining% -= 1; 'decrement number of cycles remaining
        '        'if we are on the last cycle, go to waiting for end of sound, otherwise just stay here
        '        if recLongToneCyclesRemaining% <= 0 then  'use less than just in case something wacky happens in testing
        '            ChangeStateTo(stateWaitForEndOfSound%);
        '        endif;
        '    endif
            
            
            
        case iState% = stateWaitForEndOfSound% then
            if tNow > expectedOffTime then
                printlog("Looking for digMark at end of stimulus because tNow is %f and expected off time is %f\n",tNow,expectedOffTime);
                ChangeStateTo(stateFindDigMarkOff%);
            endif;
            
        case iState% = stateFindDigMarkOff% then  
            while foundDigMarkOffTime < foundDigMarkOnTime+0.05 and tNow < expectedOffTime+10 do
                foundDigMarkOffTime := NextTime(32,foundDigMarkOnTime+0.05,digCode%[]);
                Yield(0.1);  'This allows the display to update
                tNow := View(recDataWindowView%).MaxTime();
            wend
            if foundDigMarkOffTime > foundDigMarkOnTime+0.05 then
                printlog("Found code %d at %f for stimulus off\n",digCode%[0],foundDigMarkOffTime);
            else
                printlog("We didn't find the digMark to end the stimulus!\n");
            endif;
            
            'Either way, move to next trial, or go back to experiment selection dialog
            recCurrentTrial% += 1;
            if recCurrentTrial% >= recNTrials% then
                printlog("All long tone trials complete!\n");
                iStatus% := 0;
                recReadyToQuit% := 0;
                ReturnToExptSelectDialog%();  'If the current expt. is "done" allow another to be run without stopping sampling
            else
                printlog("Waiting for next stimulus start time\n");
                'if recLongToneType% = 2 then
                '    ChangeStateTo(statePrepareTone%);
                'else
                recLoadLongNoise% := 1;  'All code now goes straight to the ISI, reset long noise to load PWA
                LongNoiseCounter% += 1;  'Increment count...
                if LongNoiseCounter% = nLongTones% then  'And if we reach the end of the block...
                    LongNoiseBlock% += 1;   'increment block counter...
                    LongNoiseCounter% := 0;  'reset trial counter
                endif;
                ChangeStateTo(stateLongToneISI%);
                'endif;
            endif;
            
            
            
            
            
        case iState% = stateTDTError% then
            
            'find a way to break all the way out
            
            'This is temporary so it does something logical but should be updated eventually
            RecLogStatus("A TDT Error has occurred!", "");
            recReadyToQuit% := 1;  'This will allow the entire thing to quit
            SafeSampleKey("M");  'Turn off LED
            iStatus% := 0;
            Stop%();
            
            
            
        case iState% = stateCodingError% then
            
            'find a way to break all the way out
            
            'This is temporary so it does something logical but should be updated eventually
            RecLogStatus("A coding Error has occurred!", "");
            iStatus% := 0;
            recReadyToQuit% := 1;  'This will allow the entire thing to quit
            SafeSampleKey("M");  'Turn off LED
            Stop%();
            
            
            
        else
            
            RecLogStatus("UNKNOWN STATE", "iState%=" + str$(iState%));
            Message("Unknown state (%d)!", iState%);
            iStatus% := 0;
            recReadyToQuit% := 1;  'This will allow the entire thing to quit
            SafeSampleKey("M");  'Turn off LED
            Stop%();          
        endcase
        
    wend  'close the nextStateImmed% while
    
    return iStatus%;  'if iStatus% is 0, the Toolbar() will return
end




'=================================Debounce the Lever Channel=================================
'This function serves as a software debounce for incoming TTL pulses.  It can only parse 1000
'events at one time, but is called every time the idle loop is called (if we are sampling) and at 
'so the 1000 event limit should not really be in danger.
'If there are > 1000 events, I BELIEVE it will simply parse the first 1000, allowing it to 
'continue parsing 1000 events each time it is called until it is caught up.  ...that hasn't been tested.
func DebounceLever%(Now)
    
    var TimesArray[1000];            'array of times of most recent events
    var TimesArrayTemp[999];         'array of times used only the first time through
    var LeverStatusAfter[1000];      'array of lever statuses corresponding to TimesArray[]
    var TimeToPrev[1000];            'array of differences between times in TimesArray[] and previous event
    var TimeToNext[1000];            'array of differences between times in TimesArray[] and next event
    var temp1[999];
    var temp2;
    var RealEventTime[1000];         'Holds times of real (not bouncing) events 
    var RealEventValue[1000];        'Holds lever values resulting from real events
    var EventCount%;                 'Counter for real events
    var ValueCount%;                 'Counter for real lever values
    var DebounceTime := .040;        'Debounce over 40 ms, can be changed manually
    var NumEvents%;                  'Number of potential lever events in the current execution
    var LeverString$;						'A string which details the lever event (for textmark channel)
    var ii%, jj%, BreakVar;
    
    
    view(recDataWindowView%);
    
    if recLeverTime = 0 then 'if it's the first pass or there have not been any events (LeverInitTime and LeverResponseTime are identical for lever scenarios)
        NumEvents% := chandata(recLeverChannel%,TimesArrayTemp[],0,Now);  'put recent times of lever presses in a temporary array
        arrconst(TimesArray[1:999],TimesArrayTemp[]);  'move temporary numbers to regular array, leaving first time blank (indicates "known" event at time = 0)
        NumEvents% := NumEvents% + 1;  'Increment NumEvents% by one to account for asserted event at time = 0
    else
        NumEvents% := chandata(recLeverChannel%,TimesArray[],recLeverTime,Now);  'put times of recent lever presses in regular array, starting with most recent known event
    endif;
    'printlog("Events are at %f and recLeverTime is %f and now is %f\n",TimesArray[],recLeverTime,Now);
    
	'There should always be a "first event" at LeverInitTime.  If there are no more, we haven't actually
	'had anything happen, so don't do anything
    if NumEvents% > 1 then
		'Calculate time to previous, next events
        
		'Fill temp1 with a shifted version of TimesArray, shifted one to the left
		'Note that the fill for a single element must be done differently
        if NumEvents% = 2 then
            temp1[0] := TimesArray[1];
        else
            arrconst(temp1[0:NumEvents%-1],TimesArray[1:NumEvents%-1]);
        endif;
        
		'Subtract, so temp1[x] holds the time difference between TimesArray[x] and TimesArray[x+1]
        arrsub(temp1,TimesArray[]);
        
		'Fill TimeToNext and TimeToPrev, note that temp1[NumEvents%-1] will be negative, and is useless
        if NumEvents% = 2 then
            TimeToPrev[1] := temp1[0];
            TimeToNext[0] := temp1[0];
        else
            arrconst(TimeToPrev[1:NumEvents%-1],temp1[0:NumEvents%-1]);
            arrconst(TimeToNext[0:NumEvents%-1],temp1[0:NumEvents%-1]);
        endif;
        
		'Fill final spot in TimeToNext with time to Now.
        TimeToNext[NumEvents%-1] := Now - TimesArray[NumEvents%-1];
        
		'Get lever status resulting from each lever event
        for ii% := 1 to NumEvents%-1 do 'only consider events starting at second position in array
            nexttime(recLeverChannel%,TimesArray[ii%],temp2);  'temp2 will be 0 if low-to-high and 1 if high-to-low
            LeverStatusAfter[ii%] := 1 - temp2; 'LeverStatusAfter will be 1 if low-to-high and 0 if high-to-low
        next;
        
        
		'Check each event in TimesArray (except [0])
        for ii% := 1 to NumEvents%-1 do 
			'If there was more than DebounceTime between the previous event and this one, the
			'previous state was stable, this should be considered a real event
            if TimeToPrev[ii%] > DebounceTime then
                RealEventTime[EventCount%] := TimesArray[ii%];
                EventCount% := EventCount% + 1;
				'Get the lever status for this event by looking for next stable period
                BreakVar := 0;
                jj% := ii%;
                while jj% <= NumEvents%-1 and BreakVar = 0 do
                    if TimeToNext[jj%] > DebounceTime then 'it has been stable long enough
                        RealEventValue[ValueCount%] := LeverStatusAfter[jj%];
                        ValueCount% := ValueCount% + 1;
                        BreakVar := 1;
                    else
                        jj% := jj% + 1;
                    endif;
                wend;
            endif;
        next;
        
		'Check to see that the number of lever presses and events correspond appropriately
        if ValueCount% <> EventCount% then
            if ValueCount% > EventCount% then
                printlog("Quitting because we have found more real lever presses than real events.  This is a serious bug!\n");
                'view(HiddenLogHandle%).print("Quitting because we have found more real lever presses than real events.  This is a serious bug!\r");
                Stop%();
            endif;
            if ValueCount% < EventCount%-1 then
                printlog("Quitting because we have found more than one event which does not correspond to a stable lever press!\n");
                'view(HiddenLogHandle%).print("Quitting because we have found more than one event which does not correspond to a stable lever press!\r");
                Stop%();
            else
                EventCount% := EventCount%-1;  'decrement, do not consider last event real as we do not have a
                'corresponding lever press
            endif;
        endif;
        
        'Put events in memory channel if they exist and change LeverInitTime/LeverResponseTime/LeverInit%/LeverResponse%
        if EventCount% > 0 then	
            'verbose, just taken out
            'printlog("Debounce: The lever events we considered to be real occurred at times: %f\n",RealEventTime[0:EventCount%]);
            
            for ii% := 0 to EventCount%-1 do
                recLeverCodes%[0] := RealEventValue[ii%];
                if RealEventValue[ii%] = 1 then
                    LeverString$ := "Lever Pressed";
                else
                    LeverString$ := "Lever Released";
                endif;
                view(recDataWindowView%).MemSetItem(recMemChanLeverDebounce%,0,RealEventTime[ii%],recLeverCodes%[],LeverString$);
            next;
            'return most recent event and value
            recLeverTime := RealEventTime[ii%-1]; 'subtract one because ii% is incremented a final time by the for loop
            recLeverState% := RealEventValue[ii%-1]; 'ditto
            
            'more Sutter stuff, probably not necessary here
			'indicate whether lever is in the origin (meaning not pressed), only if we are responding w/ lever
			'also indicate if lever is in trial initiation position
			'also indicate if lever is in trial response position
            'if RespDevice% = 0 then
            '    InOrigin% := 1 - LeverPos%;
            '    TrialInit% := LeverPos%;
            '    TrialResponse% := InOrigin%;  'for lever, trial response position is same as origin
            '    if TrialResponse% = 1 then
            '        ResponseTime := LeverTime;
            '    endif;
            'endif;
            
        endif;  'end "if there were any events"
        
    endif;  
    
    return 1;
    
end;



'A simple function which points to either recLeverDown%() or DebounceLever%() or ReadJoystick%() as appropriate
func CheckLever%(varName$,varState%)
    'printlog("CHECKLEVER: varName$ is %s, varState% is %d\n",varName$,varState%);
    'This function no longer returns a value, it merely changes inOrigin%, inTrialInit%, inResponse1%, inResponse2%
    'Major update to CheckLever% - the problem is that there was really no way to move the "experiment" forward
    'in testing mode.  Now CheckLever% REQUIRES two inputs in the form of a variable name (inOrigin%, etc.) and a
    'state to set that variable to which will allow the state logic to step forward.  This will only happen if BOTH
    'the CED and TDT are not present, otherwise, the program assumes you're actually trying to run it.
    if recActive% = 1 and recCEDIsPresent% = 1 then
        docase  'note that in all cases recLeverTime is set within the called function
        case recUseJoystick% = 0 then
            DebounceLever%(tNow);  'DebounceLever%() is run at the beginning of each idle loop, do it again if necessary before calling 
            inOrigin% := 1-recLeverState%;
            inTrialInit% := recLeverState%;
            inResponse1% := inOrigin%;  'for a lever, response 1 position is the origin (not pressed)
            inResponse2% := 0;  'there is no response 2 with a lever
            'If recLeverState% is -1 (TDT error), the other values will be recognizably illegal
        case recUseJoystick% = 1 then
            ReadJoystick%();  'ReadJoystick calls another function (AssignJoystickVariables) to get
            'joystick position variables, not done here.
        else
            printlog("Unknown value " + Str$(recUseJoystick%) + " for recUseJoystick%, this is probably your problem!\n");        
        endcase
    else
        docase
        case varName$ = "inOrigin%" then
            inOrigin% := varState%;
        case varName$ = "inTrialInit%" then
            inTrialInit% := varState%;
        case varName$ = "inResponse1%" then
            inResponse1% := varState%;
        case varName$ = "inResponse2%" then
            inResponse2% := varState%;
        else
            printlog("Unknown value " + varName$ + " in debug level of CheckLever% call!\n");
        endcase        
    endif
    
    '   printlog("inOrigin is %d, inTrialInit is %d, inResponse1 is %d, inResponse2 is %d, and reclevertime is %f\n",inOrigin%,inTrialInit%,inResponse1%,inResponse2%,recLeverTime);
    '   these values were all 0 for recGoNoGo =1!
    
    return 0
    
end;

'-----------  BehOutput(result$, isS2local%) -------------------------------------
' creates and writes to text file output with relevant behavioral variables
' for each experiment (Space and AMDis so far)
' probably could be a proc, not a function, but i'll leave it in case I want to add a return value??
func BehOutput(resultCode$, isS2local%)
    'called from StimComplete%
    'resultCode$ is determined in StimComplete% from success% and isS2local% is passed forward from IdleLoop%
    'see NameThatStimulus$ (RecRoom) for how to extract stimulus variables!
    
    var fh%; 'file handle
    var exptext$;
    'var playInd% := recTrialOrder%[recCurrentTrial%-1];  'recCurrentTrial is in human units, convert to index units
    var thisStim%;
    var spkr%;
    var thisStimD%;  'Distractor in StereoDis
    var spkrD%;
    var joyResponse%;
    var missReps%;
    var dB1;
    var dB2;
    
    'NameThatStimulus$(recStimList%[recPWAList%[recStimCount%][recTrialOrder%[recCurrentTrial%-1]]][recTrialOrder%[recCurrentTrial%-1]]));
    'other vars to include?
    'Get trial-based attenuation for current stimulus
    '   trlatten := recDeltadBList[recStimCount%][playInd%];  'corresponds to recPWAList%[][], index the same way
    'carrier% := recTrialGenGauss%[n%]; '1 if Gaussian, 0 if uniform noise
    
    'determing expt specific strings... etc..
    'this docase also ensures a new file will be created for each experiment or for which vars to add for which expt
    'I have moved this up to allow StereoDis case to do some additional work
    docase
    case recExpToRun% = recExpAMDiscButton% then
        exptext$ := "AMDis";
    case recExpToRun% = recExpSpaceDisButton% then    
        exptext$ := "SpaceDis";
    case recExpToRun% = recExpSearchButton% then
        exptext$ := "Search";
    case recExpToRun% = recExpFRAButton% then
        exptext$ := "FRA";
    case recExpToRun% = recExpJoyTrnButton% then 
        exptext$ := "JoyTrain";
    case recExpToRun% = recExpCueingButton% then
        exptext$ := "Cueing";
    case recExpToRun% = recExpAudiogramButton% then
        exptext$ := "Audiogram"; 
    case recExpToRun% = recExpStereoDisButton% then
        exptext$ := "StereoDis";
        thisStimD% := recDistractorStimList%[recStimCount%][recTrialOrder%[recCurrentTrial%-1]];  
        spkrD% := recDistractorSpeakerList%[recStimCount%][recTrialOrder%[recCurrentTrial%-1]];
        PrintLog("***thisStimDistractor = %d and thisSpeakerDistractor = %d\n",thisStimD%,spkrD%);
    endcase
    
    
    thisStim% := recStimList%[recPWAList%[recStimCount%][recTrialOrder%[recCurrentTrial%-1]]][recTrialOrder%[recCurrentTrial%-1]];
    spkr% := recSpeakerList%[recPWAList%[recStimCount%][recTrialOrder%[recCurrentTrial%-1]]][recTrialOrder%[recCurrentTrial%-1]];
    
    PrintLog("***thisStim = %d and thisSpeaker = %d\n",thisStim%,spkr%);
    'This won't work for loaded stims but it's there anyway...
    printlog("**Stim should be %s\n",NameThatStimulus$(recStimList%[recPWAList%[recStimCount%][recTrialOrder%[recCurrentTrial%-1]]][recTrialOrder%[recCurrentTrial%-1]]));
    
    
    joyResponse% :=0;
    docase
    case inResponse1% = 1 then
        joyResponse% :=1;
    case inResponse2% = 1 then
        joyResponse% :=2;
    else
        joyResponse% :=0;
    endcase
    
    if recMissRepeats% = 1 then
        missReps% := recMissRepeatsMax%;
    else 
        missReps% := 0;
    endif
    
    'just use first 3 chars of monk name/prefix and then append date so format is consistent
    'blockTag$ ensures a new file complete with header file is created for each block - these will be concatenated later during analysis (easiest way to keep track of blocks)
    
    'Open existing file, use "Kershaw" location (now "Seager", but directory is the same) in lobby, RecLab location in RecLab
    if recDebug% = 2 then
        fh%:=FileOpen(recFileSaveLocKershaw$ + recMonkPrefix$ +"_"+ Date$(2,2,3,3,"-")+ blockTag$ +"_"+ exptext$ + ".txt",8,2); 'or 3 to create if DNE
    else
        fh%:=FileOpen(recFileSaveLoc$ + recMonkPrefix$ +"_"+ Date$(2,2,3,3,"-")+ blockTag$ +"_"+ exptext$ + ".txt",8,2); 'or 3 to create if DNE
    endif;
    
    
    'PrintLog("BehOutput: Filename is " + recFileSaveLoc$ + recMonkPrefix$ +"_"+ Date$(2,2,3,3,"-")+ blockTag$ +"_"+ exptext$ + ".txt\n");
    'PrintLog("BehOutput: File handle = %d\n", fh%);
    
    if fh%<0 then 'if file does not exist... create it! and stuff
        'OR check for a firstTime or newBlock variable to figure out what to do...
        'Open new file, use "Kershaw" location (now "Seager", but directory is the same) in lobby, RecLab location in RecLab
        if recDebug% = 2 then
            fh%:=FileOpen(recFileSaveLocKershaw$+ recMonkPrefix$ +"_"+ Date$(2,2,3,3,"-")+ blockTag$ +"_"+ exptext$ + ".txt",8,3); '3 to create file        
        else    
            fh%:=FileOpen(recFileSaveLoc$ + recMonkPrefix$ +"_"+ Date$(2,2,3,3,"-")+ blockTag$ +"_"+ exptext$ + ".txt",8,3); '3 to create file   
        endif;        
        
        'file header chunk: expt, monk, date, time info:
        PrintLog("\nBehOutput: File handle = %d\n", fh%);
        PrintLog("%s\n", "Stimulus file is " + recSelectedStimFile$);
        PrintLog("Trials file is %s\n\n",recSelectedTrialsFile$);
        
        view(fh%).print(recMonkPrefix$+"\t"+Date$(20,1,3,3," ")+" "+Time$(1,3)+"\t"+exptext$+"Block "+blockTag$+"\n");
        'FORMAT 1  'file header chunk cont..: trials file & stim file if AMDis or Space (or Cueing) and Speaker Array used
        view(fh%).print("Stimulus file: %s\n",recSelectedStimFile$);
        view(fh%).print("Trials file: %s\n",recSelectedTrialsFile$);
        view(fh%).print("Joy Init = %d\nResponse1 = %d\nResponse2 = %d\n", recTrialInitPosition%,recTrialResponsePosition1%,recTrialResponsePosition2%);
        'header cont... miss repeats and training reward (i.e., is this a training file or real behavior)
        view(fh%).print("Miss repeats max = %d\ntraining reward = %.2f\n", missReps%, recTrainingRewardmL);
        'header for trial by trial info
        view(fh%).print("Speaker array = %d\n",recNSpeakers%); 
        'for AMDis and SpaceDis... (case this bitch to add experiment formats)
        view(fh%).print("Response window = %f\n", recResponseWindow);
        
        'FORMAT 2?  'file header chunk cont..: trials file & stim file if AMDis or Space (or Cueing) and Speaker Array used
        '    view(fh%).print("Stimulus file \tTrials file \t Joy Init \tResponse1 \tResponse2 \tMiss repeats max \ttraining reward \tSpeaker array \n");
        '    view(fh%).print("%s\t%s\t%d\t%d\t%d\t%d\t%f\t%d\n",recSelectedStimFile$,recSelectedTrialsFile$, recTrialInitPosition%,recTrialResponsePosition1%,recTrialResponsePosition2%,recMissRepeatsMax%,recTrainingRewardmL,recNSpeakers%);
        '
        
        'For now, there is only one format of log file, but we will need at least one more for Audiogram -jj
        docase
        case recExpToRun% = recExpAudiogramButton% then
            view(fh%).print("\n%s\t%s\t%s\t%s\t%s\n","Spkr","Freq","dB","Result","StimOnset","LeverTime"); 'header for trial vars
        case recExpToRun% = recExpFRAButton% then
            view(fh%).print("\n%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n","Stim1","Spkr1","Stim2","Spkr2","dB1","dB2","StimOnset","Reward");
        case recExpToRun% = recExpStereoDisButton% then
            'hmm
            view(fh%).print("\n%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n","Trial","Stype","StimMF","StimCarrier","StimAtten","DistStimMF",
            "DistStimCarrier","DistSpkr","DistAtten","Result","Resp","StimOnset","LeverTime"); 'header for Stereo Distractor vars
        else 'in all other cases, this is what Jackie has right now - case statement can be easily updated in the future
            view(fh%).print("\n%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n","Trial","Stype","AMrate","Spkr","Atten","Result","Resp","StimOnset","LeverTime"); 'header for trial vars
            'or split S1 and S2 into two lines - call after each StimComplete --> yes. this will be called after each stimulus from StimComplete
        endcase
    endif
    '**TODO: fix the monkprefix problem and then create a new file for each block..
    'solution: add a block number/tag variable?? (the letter that goes at the end of the file name)
    
    'now fill in the data for this trial
    'for AMDis and SpaceDis... (case this bitch to add experiment formats)(casing this bitch -jj)
    docase
    case recExpToRun% = recExpAudiogramButton% then
        view(fh%).print("%d\t%d\t%f\t%s\t%f\t%f\n",spkr%,recTrialGenLowpassHz[thisStim%],recAudiogramPreviousdB,resultCode$,recStimOn,recLeverTime);
    case recExpToRun% = recExpFRAButton% then
        'calc dB for each one
        dB1 := 65-rec2DeltadBList[recCurrentTrial%][0];
        dB2 := 70; 'no PA4 for the standalone, so we just set the amplifier so the sounds would come out at ~70dB unattenuated.
        
        view(fh%).print("%d\t%d\t",rec2StimList%[recCurrentTrial%][0],rec2SpeakerList%[recCurrentTrial%][0]);
        view(fh%).print("%d\t%d\t",rec2StimList%[recCurrentTrial%][1],rec2SpeakerList%[recCurrentTrial%][1]);
        view(fh%).print("%f\t%f\t",dB1,dB2);
        view(fh%).print("%f\t%d\n",StimOn,recFRAreward%[recCurrentTrial%]);
    case recExpToRun% = recExpStereoDisButton% then
        'This line is apparently not too long, but man, it's gotta be close.
        view(fh%).print("%d\t%d\t%f\t%s\t%f\t %f\t%s\t %d\t%f\t%s\t%d\t%f\t%f\n",recCurrentTrial%,isS2local%+1,recTrialMF[thisStim%],recTrialCarrier$[thisStim%],
        recDeltadBList[recStimCount%][recTrialOrder%[recCurrentTrial%-1]],recTrialMFDistractor[thisStimD%],recTrialCarrierDistractor$[thisStimD%],spkrD%,
        recDistractorDeltadBList[recStimCount%][recTrialOrder%[recCurrentTrial%-1]],resultCode$,joyResponse%,StimOn,recLeverTime);
        'NOTE: output key for "Stype" for Stereo Distractor
        'isS2local%+1 = 1 for S1, 2 for S2 High, 3 for terminal S1 (same), and 4 for S2 Low
    else
        view(fh%).print("%d\t%d\t%d\t%d\t%d\t%s\t%d\t%f\t%f\n",recCurrentTrial%,isS2local%+1,recTrialGenAMFreqHz[thisStim%],spkr%,recDeltadBList[recStimCount%][recTrialOrder%[recCurrentTrial%-1]],resultCode$,joyResponse%,StimOn,recLeverTime); 'data!
    endcase
    'NOTE: output key for "Stype"
    'isS2local%+1 = 1 for S1, 2 for S2 (change), 3 for terminal S1 (same - NoGo trial), and 4 for terminal S1 for forced choice
    'for Stype = 4, see resultCode for reward status
    
    'don't forget to close the file!
    fileclose(fh%);
    
end
'-----------  end of BehOutput(result$, isS2local%) -------------------------------------



'A function to update the logic variables for the audiogram
proc UpdateAudiogram(AGresult%)
    'AGresult% will be 1 following a hit and -1 following a miss
    
    recAudiogramPreviousdB := recAudiogramCurrentdB; 'hold value of most recent dB, will be used for logging
    
    docase
    case AGresult% = 1 and recAudiogramCurrentDirection% = 1 then
        'This is a hit while getting louder
        'This is a reversal (countable, loggable)
        recAudiogramCurrentDirection% := 0;  'reverse the direction
        recAudiogramCurrentdB := recAudiogramCurrentdB - recAudiogramQuieterdBStep;  'update atten, make stim quieter (note: due to reversal cannot be on initial direction)
        recAudiogramCurrentReversals% += 1;  'increment number of reversals
        recLogThisResult% := 1;  'always log this result
        recAudiogramIsInitialDirection% := 0;  'there has been a reversal, we are not in the initial direction
    case AGresult% = 1 and recAudiogramCurrentDirection% = 0 then
        'This is a hit while getting quieter
        'This is not a reversal
        if recAudiogramIsInitialDirection% = 1 then
            recAudiogramCurrentdB := recAudiogramCurrentdB - recAudiogramInitialdBStep;  'update atten, make stim quieter using large value
        else
            recAudiogramCurrentdB := recAudiogramCurrentdB - recAudiogramQuieterdBStep;  'update atten, make stim quieter using normal value
        endif;
        if recAudiogramOnlyLogReversals% = 0 then
            recLogThisResult% := 1;  'log this result
        else
            recLogThisResult% := 0;  'do not log this result
        endif;
    case AGresult% = -1 and recAudiogramCurrentDirection% = 1 then
        'This is a miss while getting louder
        'This is not a reversal
        if recAudiogramIsInitialDirection% = 1 then
            recAudiogramCurrentdB := recAudiogramCurrentdB + recAudiogramInitialdBStep;  'update atten, make stim louder using large value
        else
            recAudiogramCurrentdB := recAudiogramCurrentdB + recAudiogramLouderdBStep;  'update atten, make stim louder using normal value
        endif;
        if recAudiogramOnlyLogReversals% = 0 then
            recLogThisResult% := 1;  'log this result
        else
            recLogThisResult% := 0;  'do not log this result
        endif;
    case AGresult% = -1 and recAudiogramCurrentDirection% = 0 then
        'This is a miss while getting quieter
        'This is a reversal (loggable, but not countable - does not count towards total number of reversals)  
        recAudiogramCurrentDirection% := 1;  'reverse the direction 
        recAudiogramCurrentdB := recAudiogramCurrentdB + recAudiogramLouderdBStep;  'update atten, make stim louder (note: due to reversal cannot be on initial direction)
        recLogThisResult% := 1;  'always log this result
        recAudiogramIsInitialDirection% := 0;  'there has been a reversal, we are not in the initial direction
    endcase
    
    'If we have reached the correct number of reversals, reset for next frequency of audiogram
    if recAudiogramCurrentReversals% = recAudiogramNReversals% then
        recAudiogramCurrentDirection% := recAudiogramInitialDirection%;  'reset to original direction
        recAudiogramIsInitialDirection% := 1;  'reset this as well
        recAudiogramCurrentReversals% := 0; 
        recAudiogramStartNewTrial% := 1;
        recAudiogramCurrentdB := recAudiogramStartdB; 'reset initial dB value
    else
        'recAudiogramStartNewTrial% := 0;  'this would be redundant, this is properly zeroed right after the increment in stateinitializetrials
    endif
    
    
    
end



proc PlayWaveStopWithErrorCheck()
    'This proc will call PlayWaveStop and check the return, informing the user of any error therein
    'A simple function, but since I want to call it a bunch of times...
    var PWSErr%;
    var ErrTxt$;
    
    PWSErr% := PlayWaveStop();
    
    docase
    case PWSErr% = 0 then
        ErrTxt$ := "PlayWaveStop was called but CED believes the stimulus is not playing";
        sampleText(ErrTxt$,tNow);
        printlog("Error: %s at time %f\n",ErrTxt$,tNow);
    case PWSErr% < 0 then
        ErrTxt$ := "PlayWaveStop has returned the following error: " + Error$(PWSErr%);
        sampleText(ErrTxt$,tNow);
        printlog("Error: %s at time %f\n",ErrTxt$,tNow);
    endcase
    
end





'This function takes a value from 0 to 1, which is an amplitude scale value intended for use
'with the sampling sequencer when creating tones on the 1401, where 1 corresponds to the full
'amplitude range allowed.  Returns an integer value to be placed into a sample sequencer variable.
func SequencerToneAmplitude%(in)
    var out%;
    out% := 32768*in;
    return out%;
end


'This function takes a value in seconds and converts it to 1401 clock ticks.  Requires SequencerPeriodMS
'to have been calculated.  Returns an integer value to be placed into a sample sequencer variable 
func SequencerToneDuration%(sec)
    var temp;
    var out%;
    temp := sec*1000/SequencerPeriodMS;  'do math in float
    out% := temp-2;  'now convert to integer, subtract two ticks for sequencer instructions
    return out%;
end


'This function takes a value in Hz and converts it to a value that the 1401 can convert to degrees/step.
func SequencerToneFrequency%(Hz)
    var out%;
    var OneDeg% := 11930465;  'when placed in a sample sequencer variable, this integer is one degree
    var PeriodDurSec;
    var StepsPerCycle;
    var DegPerCycle;
    PeriodDurSec := 1/Hz;  'How many seconds in one tone cycle
    StepsPerCycle := PeriodDurSec*1000/SequencerPeriodMS;  'How many clock steps in one tone cycle
    DegPerCycle := 360/StepsPerCycle;  'How many degrees do we advance in one clock cycle
    out% := DegPerCycle*OneDeg%;
    return out%;
end


'This function grabs the most recent time the sequencer on the 1401 has logged into SampleSeqVar(3)
'We don't HAVE to call this function any time we run a SampleKey that updates SSV3, but if we don't
'we are liable to get the wrong time.
func GetTimeOfLast1401Event()
    var seqtime;
    
    seqtime := SampleSeqVar(3)*UsPerTime/1000000;  'Now, seqtime holds actual most recent time, usually
    
    'if recAMSPPassiveTask% = 0 then  'It's not clear why this excludes the Passive task
    while seqtime = PrevSequencerTime do  'This will happen if the above line occurs before the stim starts
        yield(.001,1023);  'yield a millisecond until the stimulus starts playing
        seqtime := SampleSeqVar(3)*UsPerTime/1000000;  'Keep checking until StimOn is updated
    wend; 
    'endif;
    
    PrevSequencerTime := seqtime;  'keep track of most recent StimOn
    
    return seqtime;
end




'Since we are trying to include all of the info in the .smr file, dump it in a series of sampletexts we will never read
proc WriteExpParamsSampleText()
    var s$;
    s$ := Print$("Date %s, Time %s\n",date$(2,2,3,1,"/"),time$(2,15,1,":"));
    SampleText(s$);
    yield(0.01);
    
    s$ := Print$("Param1 MonkeyName=%s,FileSuffix=%s,NTrodes=%d,NBAKs=%d,SpkrArray1=%d,SpkrArray2=%d,DoNotShuffle=%d,TurnOffReward=%d",
    recMonkPrefix$,blockTag$,recNElectrodes%,recNBAKs%,recSpeakerArrayIndex%,recSpeakerArrayIndex2%,recDoNotShuffle%,recTurnOffReward%);    
    SampleText(s$);
    yield(0.01);
    
    s$ := Print$("Param2 MinOnsetDelay=%.2f,VarOnsetDelay=%.2f,ISI=%.2f,TrialInitWindow=%.2f,ResponseWindow=%.2f",
    recMinOnsetDelay,recVarOnsetDelay,recISI,recTrialInitWindow,recResponseWindow);
    SampleText(s$);
    yield(0.01);
    
    s$ := Print$("Param3 MissTO=%.2f,FalseAlarmTO=%.2f,DoMissRepeats=%d,MaxMissRepeats=%d,OnS1Interrupt=%d,OnS2Interrupt=%d",
    recMissTO,recFalseAlarmTO,recMissRepeats%,recMissRepeatsMax%,recContinueSoundOnS1Interrupt%,recContinueSoundOnS2Interrupt%);
    SampleText(s$);
    yield(0.01);
    
    s$ := Print$("Param4 RewardType%=%d,PctJuice=%d,PctStimRew=%d,JuiceToStimDelay",
    recRewardType%,recPctJuice%,recPctStimulation%,recJuiceToStimDelay%);
    SampleText(s$);
    yield(0.01);
    
    s$ := Print$("Param5 TrainingRewardML=%.2f,HitRewardML=%.2f,CRRewardML=%.2f,MaxHitRewardML=%.2f,MaxCRRewardML=%.2f,HitRewardIncML=%.2f,S1RewardIncML=%.2f",
    recTrainingRewardmL,recHitRewardmL,recCRRewardmL,recMaxHitRewardmL,recMaxCRRewardmL,recHitRewardIncmL,recS1RewardIncmL);
    SampleText(s$);
    yield(0.01);
    
    s$ := Print$("Param6 UseJoystick=%d,TrialInitPos=%d,TrialResponsePos=%d,TrialResponsePos2=%d,DoIncrements=%d,isGNG=%d",
    recUseJoystick%,recTrialInitPosition%,recTrialResponsePosition1%,recTrialResponsePosition2%,recDoIncrements%,recIsGoNoGo%);
    SampleText(s$);
    yield(0.01);
    
    s$ := Print$("Param7 UpThreshInner=%.2f,UpThreshOuter=%.2f,DownThreshInner=%.2f,DownThreshOuter=%.2f,LeftThreshInner=%.2f,LeftThreshOuter=%.2f,RightThreshInner=%.2f,RightThreshOuter=%.2f",
    UpThreshInner,UpThreshOuter,DownThreshInner,DownThreshOuter,LeftThreshInner,LeftThreshOuter,RightThreshInner,RightThreshOuter);
    SampleText(s$);
    yield(0.01);
    
    s$ := Print$("Param8 UpThreshOuterDec=%.2f,UpThreshOuterInc=%.2f,UpThreshInnerDec=%.2f,UpThreshInnerInc=%.2f",
    UpThreshOuterDec,UpThreshOuterInc,UpThreshInnerDec,UpThreshInnerInc);
    SampleText(s$);
    yield(0.01);
    
    s$ := Print$("Param9 DownThreshInnerDec=%.2f,DownThreshInnerInc=%.2f,DownThreshOuterDec=%.2f,DownThreshOuterInc=%.2f",
    DownThreshInnerDec,DownThreshInnerInc,DownThreshOuterDec,DownThreshOuterInc);
    SampleText(s$);
    yield(0.01);
    
    s$ := Print$("Param10 LeftThreshOuterInc=%.2f,LeftThreshOuterDec=%.2f,LeftThreshInnerInc=%.2f,LeftThreshInnerDec=%.2f",
    LeftThreshOuterInc,LeftThreshOuterDec,LeftThreshInnerInc,LeftThreshInnerDec);
    SampleText(s$);
    yield(0.01);
    
    s$ := Print$("Param11 RightThreshInnerInc=%.2f,RightThreshInnerDec=%.2f,RightThreshOuterInc=%.2f,RightThreshOuterDec=%.2f",
    RightThreshInnerInc,RightThreshInnerDec,RightThreshOuterInc,RightThreshOuterDec);
    SampleText(s$);
    yield(0.01);
    
    
    s$ := Print$("Param12 UpThreshOuterMin=%.2f,UpThreshOuterMax=%.2f,UpThreshInnerMin=%.2f,UpThreshInnerMax=%.2f",
    UpThreshOuterMin,UpThreshOuterMax,UpThreshInnerMin,UpThreshInnerMax);
    SampleText(s$);
    yield(0.01);
    
    s$ := Print$("Param13 DownThreshInnerMin=%.2f,DownThreshInnerMax=%.2f,DownThreshOuterMin=%.2f,DownThreshOuterMax=%.2f",
    DownThreshInnerMin,DownThreshInnerMax,DownThreshOuterMin,DownThreshOuterMax);
    SampleText(s$);
    yield(0.01);
    
    s$ := Print$("Param14 LeftThreshOuterMax=%.2f,LeftThreshOuterMin=%.2f,LeftThreshInnerMax=%.2f,LeftThreshInnerMin=%.2f",
    LeftThreshOuterMax,LeftThreshOuterMin,LeftThreshInnerMax,LeftThreshInnerMin);
    SampleText(s$);
    yield(0.01);
    
    s$ := Print$("Param15 RightThreshInnerMax=%.2f,RightThreshInnerMin=%.2f,RightThreshOuterMax=%.2f,RightThreshOuterMin=%.2f",
    RightThreshInnerMax,RightThreshInnerMin,RightThreshOuterMax,RightThreshOuterMin); 
    SampleText(s$);
    yield(0.01);    
    
    
    docase
    case recExpToRun% = recExpLongToneButton% then 
        docase
        case recLongToneType% = 0 then
            s$ := Print$("ParamLT1 ToneFreq=%.2f,Spkr=%d,NRepeats=%d,ISI=%.2f,TargetdB=%.2f,pReward=%.2f",
            recLongToneFreq,recLongToneSpeaker%,recLongToneNRepeats%,recLongToneISI,recLongToneTargetdB,recLongToneRewardProb); 
            SampleText(s$);
            yield(0.01); 
        case recLongToneType% = 1 then
            s$ := Print$("ParamLN1 Broadband,Spkr=%d,NRepeats=%d,ISI=%.2f,TargetdB=%.2f,pReward=%.2f",
            recLongToneSpeaker%,recLongToneNRepeats%,recLongToneISI,recLongToneTargetdB,recLongToneRewardProb); 
            SampleText(s$);
            yield(0.01); 
        case recLongToneType% = 2 then
            s$ := Print$("ParamLN2 NoiseBPLow=%.2f,NoiseBPHigh=%.2f,Spkr=%d,NRepeats=%d,ISI=%.2f,TargetdB=%.2f,pReward=%.2f",
            recLongToneBPLow,recLongToneBPHigh,recLongToneSpeaker%,recLongToneNRepeats%,recLongToneISI,recLongToneTargetdB,recLongToneRewardProb); 
            SampleText(s$);
            yield(0.01);
        endcase
        
    case recExpToRun% = recExpSearchButton% then  'For Search, all stimuli are generated
        s$ := Print$("ParamS1 StimType=%d,ToneFreq=%.2f,BPLow=%.2f,BPHigh=%.2f,TSweepNRepeats=%d",
        recSearchStimType%,recSearchToneFreq,recSearchBPLowerLim,recSearchBPUpperLim,recSearchToneSweepRepeats%); 
        SampleText(s$);
        yield(0.01); 
        
        s$ := Print$("ParamS2 TSweepLow=%.2f,TSweepHigh=%.2f,TSweepNSteps=%d,S1Spkr=%d,s2Spkr=%d,MinS1=%d,VarS1=%d",
        recSearchToneSweepLowLim,recSearchToneSweepUpperLim,recSearchToneSweepNSteps%,recSearchS1Speaker%,
        recSearchS2Speaker%,recSearchMinS1%,recSearchVarS1%); 
        SampleText(s$);
        yield(0.01); 
        
        s$ := Print$("ParamS3 pCatch=%.2f,dbLevel=%.2f,Active=%d,FixationLED=%d,SpkrSweepNRepeats=%d",
        recSearchPropCatch,recSearchdBLevel,recSearchActive%,recSearchFixLED%,recSearchSpeakerSweepRepeats%); 
        SampleText(s$);
        yield(0.01); 
        
    case recExpToRun% = recExpFRAButton% then  'FRA
        s$ := Print$("ParamFRA1 LoadStim=%d,StimFileName=%s,TrialFileName=%s,S1Spkr=%d,MinS1=%d,VarS1=%d",
        recFRALoadStim%,recSelectedStimFile$,recSelectedTrialsFile$,recFRAS1Speaker%,recFRAMinS1%,recFRAVarS1%); 
        SampleText(s$);
        yield(0.01); 
        
        s$ := Print$("ParamFRA2 RateLevelNRepeats=%d,RateLeveldBLow=%.2f,RateLeveldBHigh=%.2f,S1AMNoiseRepeats=%d,BandpassNoiseRepeats=%d",
        recRateLevelNRepeats%,recRateLeveldBLow,recRateLeveldBHigh,recS1AMnoiseReps%,recBPnoiseReps%); 
        SampleText(s$);
        yield(0.01);
        
        s$ := Print$("ParamFRA3 ToneNRepeats=%d,TonedBLow=%.2f,TonedBHigh=%.2f,ToneFreqLow=%.2f,ToneFreqHigh=%.2f",
        recFRANRepeats%,recFRATonedBLow,recFRATonedBHigh,recFRAToneFreqLow,recFRAToneFreqHigh); 
        SampleText(s$);
        yield(0.01);
        
        s$ := Print$("ParamFRA4 FMSweepRepeats=%d,FMSweepStart=%d,FMSweepEnd=%d,FMSweepDur1=%d,FMSweepDur2=%d,FMSweepDur3=%d,FMSweepDur4=%d,FMSweepDur5=%d",
        recFRAFMSweepRepeats%,recFRAFMSweepStart%,recFRAFMSweepEnd%,recFRAFMSweepDur1%,recFRAFMSweepDur2%,recFRAFMSweepDur3%,recFRAFMSweepDur4%,recFRAFMSweepDur5%); 
        SampleText(s$);
        yield(0.01);
        
        s$ := Print$("ParamFRA5 S2dBLevel=%.2f,SpaceNRepeats=%d,Active=%d",
        recFRAS2dBLevel, recSpaceNRepeats%, recFRAActive%); 
        SampleText(s$);
        yield(0.01);
        
        
    case recExpToRun% = recExpJoyTrnButton% then 
        s$ := Print$("ParamJT HitRewardmL=%.2f,HitRewardIncmL=.2f,MinOnsetDelay=%.2f,TrialInitPosition=%d,DoIncrements=%d",
        recHitRewardmL, recHitRewardIncmL, recMinOnsetDelay, recTrialInitPosition%, recDoIncrements%); 
        SampleText(s$);
        yield(0.01); 
        

    case recExpToRun% = recExpAMDiscButton% then 
        s$ := Print$("ParamAMD1 GenerateStim=%d,StimFileName=%s,TrialsFileName=%s",
        recAMDiscMatGenStim%,recSelectedStimFile$,recSelectedTrialsFile$); 
        SampleText(s$);
        yield(0.01); 
        
        s$ := Print$("ParamAMD2 MinS1=%d,VarS1=%d,pCatch=%,2f,dBLevel=%.2f,RepeatsPerStim=%d,TrialInitReward=%d,TrialHoldReward=%d,Passive=%d",
        recAMDiscMinS1%,recAMDiscVarS1%,recAMDiscPropCatch,recAMDiscdBLevel,recAMDiscRepeatsPerStim%, recAMDiscTrialInitReward%, recAMDiscTrialHoldReward%, recAMSPPassiveTask%); 
        SampleText(s$);
        yield(0.01);        
        
    case recExpToRun% = recExpSpaceDisButton% then 
        s$ := Print$("ParamSpD1 GenerateStim=%d,StimFileName=%s,TrialsFileName=%s",
        recSpaceDisMatGenStim%,recSelectedStimFile$,recSelectedTrialsFile$); 
        SampleText(s$);
        yield(0.01); 
        
        s$ := Print$("ParamSpD2 MinS1=%d,VarS1=%d,pCatch=%,2f,dBLevel=%.2f,RepeatsPerStim=%d,TrialInitReward=%d,TrialHoldReward=%d,Passive=%d",
        recSpaceDisMinS1%,recSpaceDisVarS1%,recSpaceDisPropCatch,recSpaceDisdBLevel,recSpaceDisRepeatsPerStim%, recSpaceDisTrialInitReward%, recSpaceDisTrialHoldReward%, recAMSPPassiveTask%); 
        SampleText(s$);
        yield(0.01); 
        
  
    case recExpToRun% = recExpCueingButton% then  
        'Not Yet Implemented
        
        's$ := Print$("ParamXXX =%.2f,=%d,=%d,=%.2f,=%.2f,=%.2f",
        '); 
        'SampleText(s$);
        'yield(0.01); 
        
    case recExpToRun% = recExpAudiogramButton% then
        s$ := Print$("ParamAG1 S1Spkr=%d,HitRewardmL=%.2f,MinOnsetDelay=%.2f,VarOnsetDelay=%.2f,ResponseWindow=%.2f,FalseAlarmTO=%.2f",
        recAudiogramS1Speaker%,recHitRewardmL,recMinOnsetDelay,recVarOnsetDelay,recResponseWindow,recTrialInitWindow,recFalseAlarmTO); 
        SampleText(s$);
        yield(0.01);     
        
        s$ := Print$("ParamAG2 NFreqs=%d,ToneFreqLow=%.2f,ToneFreqHigh=%.2f,NReversals=%d,OnlyLogReversals=%d",
        recAudiogramNFreqs%,recAudiogramToneFreqLow,recAudiogramToneFreqHigh,recAudiogramNReversals%,recAudiogramOnlyLogReversals%); 
        SampleText(s$);
        yield(0.01); 
        
        s$ := Print$("ParamAG3 StartdB=%.2f,InitDirection=%d,InitdBStep=%.2f,LouderdBStep=%.2f,QuieterdBStep=%.2f",
        recAudiogramStartdB,recAudiogramInitialDirection%,recAudiogramInitialdBStep,recAudiogramLouderdBStep,recAudiogramQuieterdBStep); 
        SampleText(s$);
        yield(0.01); 
        
                  
        
    case recExpToRun% = recExpStereoDisButton% then 
        s$ := Print$("ParamStD1 DoForcedChoice=%d,DoGoNoGo=%d,RepeatsPerStim=%d",
        recStereoDisExpDoFC%,recStereoDisExpDoGNG%,recStereoDisRepeatsPerStim%); 
        SampleText(s$);
        yield(0.01); 
        
        s$ := Print$("ParamStD2 =%s,=%s,=%s",
        recSelectedStimFile$,recSelectedStimDistractorFile$,recSelectedTrialsFile$); 
        SampleText(s$);
        yield(0.01); 
        
        
        
            
            
        
        
    endcase;
    
    
end
