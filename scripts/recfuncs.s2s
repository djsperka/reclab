' $Id$

' Recfuncs are convenience functions to hide the calls to the TDT server behind calls that 
' are more practical for experimental needs. 


#include "tdt.s2s"

'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' recAtten
'
' Set attenuation to the value supplied. Returns 0 on success, nonzero on error (see tdtPA4Atten%). 
'
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

func recAtten%(atten)
    
    return tdtPA4Atten%(1, atten);
    
end


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' recSpeaker
'
' Set the speaker output on the PM1 to the speaker given. 
' Returns 0 on success, nonzero otherwise (see tdtPM1SpkOn)
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

func recSpeaker%(spk%)
    
    return tdtPM1Spkon%(1, spk%);
    
end



'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' recReward
'
' Gives reward using Crist juicer 
' Can be changed to use either a TDT (PI2) or CED output
' Returns 0 on success, 1 or -1 otherwise, -1 means failure to communicate, 1 means unexpected value
' returned from TDT server.
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

func recReward%(ms%,useTDT%)
    
    if useTDT% = 1 then
        return tdtREWARD%(ms%); 'return 0 on success
    else
        DeliverRewardCED(ms%);
        return 0;  'there's not really a success check here, so return success
    endif;
    
end


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' DeliverRewardCED
'
' Sends TTL pulse of desired duration to Crist juider from CED 
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc DeliverRewardCED(iMS%)
    PrintLog("Reward %d\n", iMS%);
    SampleSeqVar(1, iMS%);
    SafeSampleKey("R");
    Yield(); YieldSystem(iMS%/1000.0);
    return;
end


''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' 
' SafeSampleKey
' 
' Calls SampleKey, but makes sure that there is no current action occurring on the sequencer
' Waits up to 5 seconds before giving up and forcing the issue
' Requires sequencer file to set and unset sequencer variable V2
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Proc SafeSampleKey(s$)
    var count% := 0;
    yield(.001);  'It takes the sequencer up to a full step to change the value of variable V2, this step is obligatory
    while SampleSeqVar(2) <> 0 and count% < 5000 do
        count% += 1;
        Yield();
    wend
    SampleKey(s$);    
    return;
end


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' recLeverDown%()
'
' Returns 1 (0) if lever is held down (not held down). Returns -1 if an error occurred
' reading the TDT PI2. Assumes that the PI2 bit 5 is always set (0x10 = 16), and that bit 6
' is also set (0x30 = 48) when the lever circuit is closed (lever down). 
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

func recLeverDown%()
    var pii% := 0;
    var status% := 0;
    var down% := 0;
    
    ' read PI2
    status% := tdtPI2Read%(1, pii%);
    if status% = 0 then
        if pii% = 48 then status% := 1; endif;
    else
        status% := -1;
    endif
    PrintLog("recLeverDown: tdtPI2Read status %d pii %d\n", status%, pii%);
    return status%;
end


'recTDTLEDOn%() - because it's easier to remember than the correct setting for the setbit function
func recTDTLEDOn%()
    
    return tdtPI2Setbit%(1, 2);
    
end


'recTDTLEDOff%() - because it's easier to remember than the correct setting for the clrbit function
func recTDTLEDOff%()
    
    return tdtPI2Clrbit%(1, 2);
    
end


' recBlinkUntilLeverDown%(yieldTime, maxTime)
'
' Causes LED (PI2 bit 2 = 0x2) to blink until the lever is down. LED is held on/off 
' for approximately the time (in seconds) in yieldTime (subject to the spike2 function 
' Yield() and Windows clock). Seems to work well with yieldTime=0.5, though I doubt that
' the blinking is very uniform. 
' 
' if maxBlinkTime <= 0, this will go on forever until the lever is pressed. If maxTime is 
' greater than 0, however, we quit if the lever has not been pressed in (approximately)
' that amount of time. The time is not measured, we merely increment a counter by 
' yieldTime every time there is a Yield(). Since Yield() is not that accurate, the actual
' time measurement is only approximate. 
'
' Updated to change the total duration to be based on MaxTime().  Keeping Yield for the blink
' duration as for quick blinks it may be preferable to waiting for the OS to get control and
' then give it back.
' 
' Returns 1 when lever is down. Returns -1 if an error occurred. Returns 0 if maxTime>0 
' and the lever is not pressed in that time. Sets LED ON upon exiting if lever is down, 
' sets LED OFF upon exiting if lever is up. 
'TODO: I think we can do this better.  Consult PresEngine for blinking stuff
'Certainly if we want to use the CED for the LED control, we'd have to update this.

func recBlinkUntilLeverDown%(yieldTime, maxBlinkTime)
    var status%:= 0;
    var s%;
    var idone% := 0;
    var t% := 1;
    'var approxTime := 0;
    
    if yieldTime < 0 then yieldTime := 0; endif
    
    'while idone% = 0 and (maxBlinkTime <= 0 or (maxBlinkTime > 0 and approxTime < maxBlinkTime)) do  'not sure why we don't just look at the actual time
    while idone% = 0 and (maxBlinkTime <= 0 or (MaxTime() < maxBlinkTime)) do  'the MaxTime() version will only work if we are sampling, but when would we NOT be?
        
        if t% = 1 then
            's% := tdtPI2Setbit%(1, 2);
            s% := recTDTLEDOn%();
            if s% <> 0 then
                PrintLog("recBlinkUntilLeverDown%(): Error in tdtPI2Setbit%()\n");
                return -1;
            endif
        else
            's% := tdtPI2Clrbit%(1, 2);
            s% := recTDTLEDOff%();
            if s% < 0 then
                PrintLog("recBlinkUntilLeverDown%(): Error in tdtPI2ClrBit%()\n");
                return -1;
            endif
        endif
        t% := 1 - t%;   ' toggles t% between 1 and 0. 
        
        ' Check the lever
        s% := recLeverDown%();
        if s% < 0 then
            PrintLog("recBlinkUntilLeverDown%(): Error in recLeverDown%()\n");
            return -1;
        else
            if s% = 1 then 
                idone% := 1; 
            else
                Yield(yieldTime);
            endif
        endif
        'approxTime := approxTime + yieldTime;
    wend
    
    if idone% = 1 then
        's% := tdtPI2Setbit%(1, 2);
        s% := recTDTLEDOn%();
        if s% <> 0 then
            PrintLog("recBlinkUntilLeverDown%(): Error in tdtPI2Setbit%()\n");
            return -1;
        endif
    else  'if period times out, turn LED off
        s% := recTDTLEDOff%();
        if s% <> 0 then
            PrintLog("recBlinkUntilLeverDown%(): Error in tdtPI2Clrbit%()\n");
            return -1;
        endif
    endif
    
    return idone%;
end


''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' recInitTDT%()
'
' Initialization of TDT rig and communications (serial line). Returns 0 on success, 
' -1 on error.
'
' The serial port must be connected to the TDT machine, and the TDT server 'tdtserv' 
' must be up and ready to receive commands when this is called. 
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

func recInitTDT%()
    var status%:=0;
    var i%;
    
    if tdtSerial(1, 0) < 0 then
        Message("Error in tdtSerial. Check serial line.");
        return -1;
    else
        printLog("Serial open OK\n");
    endif
    
    status% := tdtPING%();
    printLog("ping status " + str$(status%) + "\n");
    if status% <> 0 then
        Message("Cannot ping TDT server. Check that TDTSERV is running.");
        return -1;
    endif
    
    ' Initialize tdt stuff
    
    tdtPI2Clear%(1);
    tdtPI2Outs%(1, 207);
    tdtPI2Logic%(1, 0x00, 0x20);
    tdtPI2OutsX%(1, 1);
    tdtPI2OutsX%(1, 2);
    tdtPI2writeX%(1, 1, 0);
    tdtPI2WriteX%(1, 2, 0);
    tdtPM1Clear%(1);
    tdtPM1Config%(1, 1);
    tdtPM1Mode%(1, 1);
    tdtPA4Atten%(1, 30);
    
    return 0;
end
